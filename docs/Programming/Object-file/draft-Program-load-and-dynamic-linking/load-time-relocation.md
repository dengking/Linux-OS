# [动态共享对象的装载时重定位](https://blog.csdn.net/parallelyk/article/details/42747239)

最近读程序员的自我修养--链接 装载与库，其中有句话：**动态链接模块**被装载映射到**虚拟空间**后，**指令部分**是在多个**进程**之间**共享**的，由于**装载时重定位**的方法需要**修改**指令，所以没有办法做到同一份指令被多个进程共享，因为指令被**重定位**后对于每个进程来讲是不同的。一直没搞懂，花了不少时间查阅资料，了解原理。觉得自己一直理解的东西都太浅了。 以下是对这块内容的总结，作为记录。

其中的关键点在于掌握**内存映射**，重定位的实现以及共享对象的装载。搞清楚**虚拟内存空间**和**物理内存空间**。

共享对象在被装载时，是如何确定它在进程虚拟地址空间中的位置？

一种方法是固定装载，这种方法弊端明显：地址冲突；共享库升级困难；空间受限等等。（基本不用）

那么只能采用另一种思路，即**共享对象**能在任意地址装载。这种情况叫做**装载时重定位**。当程序被装载时，系统的**动态链接器**会将程序所需的所有**动态链接库**（例如最基本的libc.so）装载到进程的地址空间，且将程序中所有**未决议的符号**绑定到相应的**动态链接库**中，并进行**重定位工作**（术语叫**装载时重定位**-load time relocation，在windows中，又叫基址重置-rebasing，区别于静态链接的**链接时重定位**-link time relocation）。也即，动态链接是把**可执行elf**的形成过程从本来的程序链接前**推迟**到装载时。共享对象的最终装载地址在**编译时**是不确定的，而是在**装载时**，**装载器**根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。

**装载时重定位**的原理来自**链接时重定位**，但是对于共享对象，单纯的装载时重定位显然会引发问题，也就是文章开头说到的那句话。动态链接模块被装载映射到虚拟空间后，指令部分是在多个进程之间共享的，由于**装载时重定位**的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来讲是不同的。

在网上看到有不少人问了这个问题，答案看得我也是迷迷糊糊。折腾了一下午，发现其实是自己对基本的原理都没搞清楚才会看不懂这句话。关键在于共享对象也就是动态链接库在被装载到物理内存后，始终是只有一份的，不管有多少个进程使用它。但是对于每一个进程，**共享对象**会映射一次到**虚拟地址空间**，也就是每个进程空间都有一份共享对象的**映射**，此时，对于不同的进程，映射的地址（**基址**）是不一样的（大部分情况下）。紧接着，进行**装载时重定位**。**装载时重定位**由**动态链接器**完成，**动态链接器**会被一起映射到**进程空间**中。它根据**共享对象**在**虚拟内存空间中**的地址修改在**物理内存**中的**共享对象**中的指令，为什么会修改指令，原因在于**绝对地址访问**（如模块内的变量访问）是直接用`mov`指令完成的，也就是直接将地址打入寄存器，所以，此时的重定位会直接修改指令。进一步，共享对象中修改的指令是**根据共享对象被映射到虚拟空间中的地址（基址）决定的**，而每个进程对共享对象的映射不可能都是在相同地址。所以也就无法完成这一部分代码的共享。

那么如何解决这个问题，就要用到**位置无关代码（PIC）**，也有叫**地址无关代码**的。基本思路是把**指令**中那些需要被修改的部分分离出来，跟**数据部分**放到一起，这样，剩下的指令就可以保持不变，而数据部分在每个进程中拥有一个副本。ELF针对各种可能的访问类型（模块内部指令调用、模块内部数据访问、模块间指令调用、模块间数据访问），实现了对应地址引用方式，从而实现了PIC。具体的细节不在这里赘述。



# Q&A

## 每个进程会有一份共享对象的映射

这段话中的映射是什么意思？

参考资料：http://www.360doc.com/content/14/0902/09/19184777_406438267.shtml

http://blog.chinaunix.net/uid-26983585-id-3364514.html

http://blog.163.com/shi_shun/blog/static/2370784920122875910467/