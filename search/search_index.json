{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u5173\u4e8e\u672c\u9879\u76ee \u672c\u9879\u76ee\u4ece\u591a\u4e2a\u65b9\u9762\u5bf9Linux operating system\u8fdb\u884c\u63cf\u8ff0\u4e0e\u603b\u7ed3\uff0c\u4e0b\u9762\u5bf9\u672c\u9879\u76ee\u7684\u4e3b\u8981\u5185\u5bb9\u8fdb\u884c\u6982\u62ec: \u7406\u8bba\u90e8\u5206 \u8fd9\u90e8\u5206\u7684\u5185\u5bb9\u5927\u591a\u6570: philosophy\u3001design\u3001structure\uff1b \u4e3b\u8981\u5305\u542b\u5982\u4e0b\u51e0\u5927\u90e8\u5206: 1) Architecture of computing system \u9996\u5148\u63cf\u8ff0Computing system\u7684architecture\uff0c\u5efa\u7acb\u8d77\u4e00\u4e2a\u9ad8\u5c4b\u5efa\u74f4\u7684\u89c6\u89d2\uff0c\u8fd9\u662f\u91c7\u7528\u7684\u7ed3\u6784\u5316\u601d\u7ef4\u3002\u4ece\u4e2d\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e00\u4e2aComputing system\u7684\u7ec4\u6210\uff0c\u5176\u4e2d\u6d89\u53ca\u5230hardware\u7684\u5730\u65b9\u53ef\u4ee5\u53c2\u52a0\u5de5\u7a0bHardware\uff08TODO: \u9700\u8981\u7ed9Hardware\u6dfb\u52a0\u94fe\u63a5\uff09; 2) Operating system \u4e3b\u8981\u63cf\u8ff0operating system\u7684\u6982\u5ff5\u3002 3) Kernel \u4e3b\u8981\u5305\u542b: kernel \u7684\u57fa\u7840\u77e5\u8bc6 linux kernel \u7684\u5b9e\u73b0\uff0c\u4e3b\u8981\u53c2\u8003\u4e66\u7c4d\u300a Understanding.The.Linux.kernel.3 rd .Edition \u300b NOTE: \u4ece\u7ed3\u6784\u4e0a\u6765\u8bf4\uff0c\u4e0a\u8ff0\u4e09\u90e8\u5206\u5b58\u5728\u7740\u5305\u542b\u5173\u7cfb: Architecture of computing system \u5305\u542b Operating system \u5305\u542b Kernel \u5b9e\u8df5\u90e8\u5206 \u4e3b\u8981\u63cf\u8ff0\u8fd0\u7528Linux OS\u65f6\u7684\u4e00\u4e9btechnique\u3001tips\u3001tricks \u4e3b\u8981\u5305\u542b\u5982\u4e0b\u51e0\u5927\u90e8\u5206: 1) Programming \u5305\u542bLinux operating system\u4e2d\u8fdb\u884cprogramming\u65f6\u9700\u8981\u638c\u63e1\u7684\u6240\u6709\u77e5\u8bc6\uff0c\u5305\u62ec\uff1a system call interface philosophy \u4e3b\u8981\u53c2\u8003\uff1a Advanced Programming in the UNIX\u00ae Environment, Third Edition The Linux Programming Interface man7.org Linux man pages die.net Linux man pages 2) Network network\u662f\u4e00\u4e2a\u548coperating system\u5bc6\u5207\u76f8\u5173\u7684\u5185\u5bb9\uff0c\u548cnetwork\u76f8\u5173\u7684\u5185\u5bb9\u5c06\u5728\u8fd9\u4e00\u7ae0\u8282\u8fdb\u884c\u63cf\u8ff0\u3002 3) Shell and tools Linux operating system\u4e2d\u7684\u5e38\u89c1\u547d\u4ee4 \u4e3b\u8981\u53c2\u8003\uff1a Linux Documentation man7.org Linux man pages die.net Linux man pages","title":"Home"},{"location":"#_1","text":"\u672c\u9879\u76ee\u4ece\u591a\u4e2a\u65b9\u9762\u5bf9Linux operating system\u8fdb\u884c\u63cf\u8ff0\u4e0e\u603b\u7ed3\uff0c\u4e0b\u9762\u5bf9\u672c\u9879\u76ee\u7684\u4e3b\u8981\u5185\u5bb9\u8fdb\u884c\u6982\u62ec:","title":"\u5173\u4e8e\u672c\u9879\u76ee"},{"location":"#_2","text":"\u8fd9\u90e8\u5206\u7684\u5185\u5bb9\u5927\u591a\u6570: philosophy\u3001design\u3001structure\uff1b \u4e3b\u8981\u5305\u542b\u5982\u4e0b\u51e0\u5927\u90e8\u5206:","title":"\u7406\u8bba\u90e8\u5206"},{"location":"#1#architecture#of#computing#system","text":"\u9996\u5148\u63cf\u8ff0Computing system\u7684architecture\uff0c\u5efa\u7acb\u8d77\u4e00\u4e2a\u9ad8\u5c4b\u5efa\u74f4\u7684\u89c6\u89d2\uff0c\u8fd9\u662f\u91c7\u7528\u7684\u7ed3\u6784\u5316\u601d\u7ef4\u3002\u4ece\u4e2d\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e00\u4e2aComputing system\u7684\u7ec4\u6210\uff0c\u5176\u4e2d\u6d89\u53ca\u5230hardware\u7684\u5730\u65b9\u53ef\u4ee5\u53c2\u52a0\u5de5\u7a0bHardware\uff08TODO: \u9700\u8981\u7ed9Hardware\u6dfb\u52a0\u94fe\u63a5\uff09;","title":"1) Architecture of computing system"},{"location":"#2#operating#system","text":"\u4e3b\u8981\u63cf\u8ff0operating system\u7684\u6982\u5ff5\u3002","title":"2) Operating system"},{"location":"#3#kernel","text":"\u4e3b\u8981\u5305\u542b: kernel \u7684\u57fa\u7840\u77e5\u8bc6 linux kernel \u7684\u5b9e\u73b0\uff0c\u4e3b\u8981\u53c2\u8003\u4e66\u7c4d\u300a Understanding.The.Linux.kernel.3 rd .Edition \u300b NOTE: \u4ece\u7ed3\u6784\u4e0a\u6765\u8bf4\uff0c\u4e0a\u8ff0\u4e09\u90e8\u5206\u5b58\u5728\u7740\u5305\u542b\u5173\u7cfb: Architecture of computing system \u5305\u542b Operating system \u5305\u542b Kernel","title":"3) Kernel"},{"location":"#_3","text":"\u4e3b\u8981\u63cf\u8ff0\u8fd0\u7528Linux OS\u65f6\u7684\u4e00\u4e9btechnique\u3001tips\u3001tricks \u4e3b\u8981\u5305\u542b\u5982\u4e0b\u51e0\u5927\u90e8\u5206:","title":"\u5b9e\u8df5\u90e8\u5206"},{"location":"#1#programming","text":"\u5305\u542bLinux operating system\u4e2d\u8fdb\u884cprogramming\u65f6\u9700\u8981\u638c\u63e1\u7684\u6240\u6709\u77e5\u8bc6\uff0c\u5305\u62ec\uff1a system call interface philosophy \u4e3b\u8981\u53c2\u8003\uff1a Advanced Programming in the UNIX\u00ae Environment, Third Edition The Linux Programming Interface man7.org Linux man pages die.net Linux man pages","title":"1) Programming"},{"location":"#2#network","text":"network\u662f\u4e00\u4e2a\u548coperating system\u5bc6\u5207\u76f8\u5173\u7684\u5185\u5bb9\uff0c\u548cnetwork\u76f8\u5173\u7684\u5185\u5bb9\u5c06\u5728\u8fd9\u4e00\u7ae0\u8282\u8fdb\u884c\u63cf\u8ff0\u3002","title":"2) Network"},{"location":"#3#shell#and#tools","text":"Linux operating system\u4e2d\u7684\u5e38\u89c1\u547d\u4ee4 \u4e3b\u8981\u53c2\u8003\uff1a Linux Documentation man7.org Linux man pages die.net Linux man pages","title":"3) Shell and tools"},{"location":"Architecture-of-computing-system/","text":"Architecture of computing system \u672c\u7ae0\u6240\u8981\u63a2\u8ba8\u7684\u662farchitecture of computing system \uff0c\u800c\u4e0d\u662f\u5bfb\u5e38\u6240\u8bf4\u7684 computer architecture \uff0c\u4e00\u822c computer architecture \u6240\u6307\u7684\u662f\u8bf8\u5982 Von Neumann architecture \u3001 Harvard architecture \u7b49\u63cf\u8ff0computer\u786c\u4ef6\u7684\u67b6\u6784\u3002\u672c\u8282\u6240\u8981\u63cf\u8ff0\u7684\u5185\u5bb9\u662f\u4ece\u4e00\u4e2a\u66f4\u52a0\u9ad8\u7684\u89d2\u5ea6\u6765\u770b\u5f85 computing system \uff0c\u5305\u62ec\u6700\u5e95\u5c42\u7684hardware\uff0coperating system\uff0capplication software\u3002 \u6b63\u5982 Computer hardware \u4e2d\u6240\u63cf\u8ff0\u7684\uff1a The progression from levels of \"hardness\" to \"softness\" in computer systems parallels a progression of layers of abstraction in computing. A combination of hardware and software forms a usable computing system. \u73b0\u4ee3 computing system \u7684\u6574\u4f53\u67b6\u6784\u7684\u53d1\u5c55\u662f\u53d7\u5230\u8ba1\u7b97\u673a\u79d1\u5b66\u9886\u57df\u7684 layers of abstraction \u601d\u60f3\uff08\u5206\u5c42\u601d\u60f3\uff09\u7684\u5f71\u54cd\u7684\uff0c\u4e00\u4e2a computing system \u53ef\u4ee5\u8ba4\u4e3a\u7531\u4e24\u5c42\u6784\u6210\uff1a software hardware Instruction set \u662fsoftware\u548chardware\u4e4b\u95f4\u7684\u63a5\u53e3\u3002 \u73b0\u4ee3 computing system \u7684\u8fd0\u884c\u662f\u79bb\u4e0d\u5f00operating system\u7684\uff0coperating system\u6240\u5c5e\u7684\u662fsoftware\u8fd9\u4e00\u5c42\uff0c\u4e0b\u9762\u5bf9operating system\u6765\u8fdb\u884c\u66f4\u52a0\u7cbe\u7ec6\u7684\u5206\u5c42\u3002 Architecture of operating system \u5728 Operating system \u4e2d\u7ed9\u51fa\u4e86\u4e00\u4e2a\u5178\u578b\u7684operating system\u7684architecture\u5982\u4e0b\uff1a Operating systems \u4e0a\u56fe\u4e2dUser\u8868\u793a\u7684\u662f\u7528\u6237\uff0c\u4e0d\u5c5e\u4e8eOS\u4e2d\uff0c\u540e\u9762\u7684\u8ba8\u8bba\u4f1a\u5c06\u5176\u5ffd\u89c6\u3002 \u5728 Advanced Programming in the UNIX\u00ae Environment, Third Edition \u76841.2 UNIX Architecture\u8282\u4e2d\u7ed9\u51fa\u4e86Architecture of the UNIX operating system\uff0c\u5982\u4e0b\uff1a \u4e0a\u8ff0\u4e24\u4e2a\u67b6\u6784\u56fe\u90fd\u5927\u4f53\u5c55\u793aOS\u7684architecture\uff0c\u4e24\u8005\u90fd\u5404\u6709\u5229\u5f0a\uff0c\u56fe\u4e00\u5305\u542b\u4e86hardware\uff0c\u4f46\u662f\u5ffd\u89c6\u4e86\u5404\u5c42\u4e4b\u95f4\u7684interface\u3002\u56fe\u4e8c\u5219\u6b63\u597d\u76f8\u53cd\u3002\u6240\u4ee5\u5c06\u4e24\u8005\u7ed3\u5408\u8d77\u6765\u5219\u6b63\u597d\uff0c\u540e\u9762\u4f1a\u6309\u7167\u56fe\u4e8c\u4e2d\u7684\u8868\u793a\u65b9\u5f0f\uff0c\u5c06interface\u4e5f\u770b\u505a\u662f\u4e00\u5c42\u3002\u5145\u5f53interface\u7684layer\u4f5c\u4e3a\u5b83\u7684\u4e0a\u4e0b\u4e24\u5c42\u4e4b\u95f4\u7684interface\u3002 upper layer layer role software application system calls &library routines interface kernel Instruction set interface hardware hardware \u4e0a\u8ff0\u8868\u683c\uff0c\u5728\u540e\u9762\u4f1a\u8fdb\u884c\u4e0d\u65ad\u5730\u4e30\u5bcc\u548c\u6269\u5145\uff0c\u5728\u4e0b\u9762\u7ae0\u8282\u4e2d\u4f1a\u5305\u542b\u5bf9\u5b83\u7684\u6269\u5145\u548c\u5bf9\u5e94\u7684\u56fe\u5f62\u5c55\u793a: Kernel\\Kernel.md#Monolithic kernel \u7ae0\u8282 Kernel\\Architecture.md#Kernel space and user space \u7ae0\u8282 Operating-system\\index.md#Concrete OS structure \u7ae0\u8282 \u901a\u8fc7architecture\u6765\u5206\u6790OS\u7684\u4f5c\u7528 \u901a\u8fc7\u4e0a\u8ff0\u7684OS\u7684architecture\uff0c\u6211\u4eec\u80fd\u591f\u66f4\u52a0\u6df1\u523b\u5730\u4e86\u89e3OS\u7684\u4f5c\u7528\u4e86\uff0c\u4e0b\u9762\u662f\u6458\u6284\u81ea Understanding.The.Linux.kernel.3 rd .Edition \u7684Chapter 1.4. Basic Operating System Concepts\u4e2d\u5173\u4e8eOS\u7684\u4f5c\u7528\u7684\u63cf\u8ff0\uff1a The operating system must fulfill two main objectives: 1) Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform. 2) Provide an execution environment to the applications that run on the computer system (the so-called user programs). \u8fd9\u4e24\u4e2aobjective\uff08\u5176\u5b9e\u5c31\u662fOS\u7684\u4f5c\u7528\u3001\u4f7f\u547d\uff09\u76f8\u5f53\u4e8e\u4e24\u6761\u7ebf\uff0c\u540e\u9762\u6211\u4eec\u5c06\u6cbf\u7740\u8fd9\u4e24\u6761\u7ebf\u6df1\u5165\u5bf9linux OS\u7684\u5b66\u4e60\u3002 \u6211\u4eec\u53ef\u4ee5\u8fdb\u4e00\u6b65\u7b80\u5316\uff1aOS\u7ba1\u7406\u7740hardware\u548cprocess\uff0c\u5b83\u4f5c\u4e3a\u4e24\u8005\u4e4b\u95f4\u7684\u6865\u6881\u3002 \u603b\u7ed3 \u4e0a\u9762\u6211\u4f7f\u7528\u4e86**\u5c42\u6b21\u5316\u7684\u7ed3\u6784**\u6765\u63cf\u8ff0 computing system \u7684\u67b6\u6784\uff0c\u81f3\u6b64\uff0c\u5df2\u7ecf\u5efa\u7acb\u4e86operating system\u7684\u6574\u4f53architecture\uff08model\uff09\u3002","title":"Introduction"},{"location":"Architecture-of-computing-system/#architecture#of#computing#system","text":"\u672c\u7ae0\u6240\u8981\u63a2\u8ba8\u7684\u662farchitecture of computing system \uff0c\u800c\u4e0d\u662f\u5bfb\u5e38\u6240\u8bf4\u7684 computer architecture \uff0c\u4e00\u822c computer architecture \u6240\u6307\u7684\u662f\u8bf8\u5982 Von Neumann architecture \u3001 Harvard architecture \u7b49\u63cf\u8ff0computer\u786c\u4ef6\u7684\u67b6\u6784\u3002\u672c\u8282\u6240\u8981\u63cf\u8ff0\u7684\u5185\u5bb9\u662f\u4ece\u4e00\u4e2a\u66f4\u52a0\u9ad8\u7684\u89d2\u5ea6\u6765\u770b\u5f85 computing system \uff0c\u5305\u62ec\u6700\u5e95\u5c42\u7684hardware\uff0coperating system\uff0capplication software\u3002 \u6b63\u5982 Computer hardware \u4e2d\u6240\u63cf\u8ff0\u7684\uff1a The progression from levels of \"hardness\" to \"softness\" in computer systems parallels a progression of layers of abstraction in computing. A combination of hardware and software forms a usable computing system. \u73b0\u4ee3 computing system \u7684\u6574\u4f53\u67b6\u6784\u7684\u53d1\u5c55\u662f\u53d7\u5230\u8ba1\u7b97\u673a\u79d1\u5b66\u9886\u57df\u7684 layers of abstraction \u601d\u60f3\uff08\u5206\u5c42\u601d\u60f3\uff09\u7684\u5f71\u54cd\u7684\uff0c\u4e00\u4e2a computing system \u53ef\u4ee5\u8ba4\u4e3a\u7531\u4e24\u5c42\u6784\u6210\uff1a software hardware Instruction set \u662fsoftware\u548chardware\u4e4b\u95f4\u7684\u63a5\u53e3\u3002 \u73b0\u4ee3 computing system \u7684\u8fd0\u884c\u662f\u79bb\u4e0d\u5f00operating system\u7684\uff0coperating system\u6240\u5c5e\u7684\u662fsoftware\u8fd9\u4e00\u5c42\uff0c\u4e0b\u9762\u5bf9operating system\u6765\u8fdb\u884c\u66f4\u52a0\u7cbe\u7ec6\u7684\u5206\u5c42\u3002","title":"Architecture of computing system"},{"location":"Architecture-of-computing-system/#architecture#of#operating#system","text":"\u5728 Operating system \u4e2d\u7ed9\u51fa\u4e86\u4e00\u4e2a\u5178\u578b\u7684operating system\u7684architecture\u5982\u4e0b\uff1a Operating systems \u4e0a\u56fe\u4e2dUser\u8868\u793a\u7684\u662f\u7528\u6237\uff0c\u4e0d\u5c5e\u4e8eOS\u4e2d\uff0c\u540e\u9762\u7684\u8ba8\u8bba\u4f1a\u5c06\u5176\u5ffd\u89c6\u3002 \u5728 Advanced Programming in the UNIX\u00ae Environment, Third Edition \u76841.2 UNIX Architecture\u8282\u4e2d\u7ed9\u51fa\u4e86Architecture of the UNIX operating system\uff0c\u5982\u4e0b\uff1a \u4e0a\u8ff0\u4e24\u4e2a\u67b6\u6784\u56fe\u90fd\u5927\u4f53\u5c55\u793aOS\u7684architecture\uff0c\u4e24\u8005\u90fd\u5404\u6709\u5229\u5f0a\uff0c\u56fe\u4e00\u5305\u542b\u4e86hardware\uff0c\u4f46\u662f\u5ffd\u89c6\u4e86\u5404\u5c42\u4e4b\u95f4\u7684interface\u3002\u56fe\u4e8c\u5219\u6b63\u597d\u76f8\u53cd\u3002\u6240\u4ee5\u5c06\u4e24\u8005\u7ed3\u5408\u8d77\u6765\u5219\u6b63\u597d\uff0c\u540e\u9762\u4f1a\u6309\u7167\u56fe\u4e8c\u4e2d\u7684\u8868\u793a\u65b9\u5f0f\uff0c\u5c06interface\u4e5f\u770b\u505a\u662f\u4e00\u5c42\u3002\u5145\u5f53interface\u7684layer\u4f5c\u4e3a\u5b83\u7684\u4e0a\u4e0b\u4e24\u5c42\u4e4b\u95f4\u7684interface\u3002 upper layer layer role software application system calls &library routines interface kernel Instruction set interface hardware hardware \u4e0a\u8ff0\u8868\u683c\uff0c\u5728\u540e\u9762\u4f1a\u8fdb\u884c\u4e0d\u65ad\u5730\u4e30\u5bcc\u548c\u6269\u5145\uff0c\u5728\u4e0b\u9762\u7ae0\u8282\u4e2d\u4f1a\u5305\u542b\u5bf9\u5b83\u7684\u6269\u5145\u548c\u5bf9\u5e94\u7684\u56fe\u5f62\u5c55\u793a: Kernel\\Kernel.md#Monolithic kernel \u7ae0\u8282 Kernel\\Architecture.md#Kernel space and user space \u7ae0\u8282 Operating-system\\index.md#Concrete OS structure \u7ae0\u8282","title":"Architecture of operating system"},{"location":"Architecture-of-computing-system/#architectureos","text":"\u901a\u8fc7\u4e0a\u8ff0\u7684OS\u7684architecture\uff0c\u6211\u4eec\u80fd\u591f\u66f4\u52a0\u6df1\u523b\u5730\u4e86\u89e3OS\u7684\u4f5c\u7528\u4e86\uff0c\u4e0b\u9762\u662f\u6458\u6284\u81ea Understanding.The.Linux.kernel.3 rd .Edition \u7684Chapter 1.4. Basic Operating System Concepts\u4e2d\u5173\u4e8eOS\u7684\u4f5c\u7528\u7684\u63cf\u8ff0\uff1a The operating system must fulfill two main objectives: 1) Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform. 2) Provide an execution environment to the applications that run on the computer system (the so-called user programs). \u8fd9\u4e24\u4e2aobjective\uff08\u5176\u5b9e\u5c31\u662fOS\u7684\u4f5c\u7528\u3001\u4f7f\u547d\uff09\u76f8\u5f53\u4e8e\u4e24\u6761\u7ebf\uff0c\u540e\u9762\u6211\u4eec\u5c06\u6cbf\u7740\u8fd9\u4e24\u6761\u7ebf\u6df1\u5165\u5bf9linux OS\u7684\u5b66\u4e60\u3002 \u6211\u4eec\u53ef\u4ee5\u8fdb\u4e00\u6b65\u7b80\u5316\uff1aOS\u7ba1\u7406\u7740hardware\u548cprocess\uff0c\u5b83\u4f5c\u4e3a\u4e24\u8005\u4e4b\u95f4\u7684\u6865\u6881\u3002","title":"\u901a\u8fc7architecture\u6765\u5206\u6790OS\u7684\u4f5c\u7528"},{"location":"Architecture-of-computing-system/#_1","text":"\u4e0a\u9762\u6211\u4f7f\u7528\u4e86**\u5c42\u6b21\u5316\u7684\u7ed3\u6784**\u6765\u63cf\u8ff0 computing system \u7684\u67b6\u6784\uff0c\u81f3\u6b64\uff0c\u5df2\u7ecf\u5efa\u7acb\u4e86operating system\u7684\u6574\u4f53architecture\uff08model\uff09\u3002","title":"\u603b\u7ed3"},{"location":"Kernel/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u4e3b\u8981\u5185\u5bb9\u5982\u4e0b\uff1a Kernel(operating-system)\uff1a\u8ba8\u8bbaOS kernel\u7684\u57fa\u7840\u77e5\u8bc6 Guide\uff1a\u57fa\u4e8eBook-Understanding-the-Linux-Kernel\u505a\u7684\u4e00\u4e9b\u603b\u7ed3\uff0c\u53ef\u4f5c\u4e3a\u9605\u8bfb\u672c\u4e66\u7684\u6307\u5bfc\u3002 Book-Understanding-the-Linux-Kernel\uff1a\u8ba8\u8bba linux kernel \u7684\u5b9e\u73b0\uff0c\u4ee5 Understanding.The.Linux.kernel.3 rd .Edition \u4e3a\u4e3b\u8981\u53c2\u8003\u3002","title":"Introduction"},{"location":"Kernel/#_1","text":"\u672c\u7ae0\u4e3b\u8981\u5185\u5bb9\u5982\u4e0b\uff1a Kernel(operating-system)\uff1a\u8ba8\u8bbaOS kernel\u7684\u57fa\u7840\u77e5\u8bc6 Guide\uff1a\u57fa\u4e8eBook-Understanding-the-Linux-Kernel\u505a\u7684\u4e00\u4e9b\u603b\u7ed3\uff0c\u53ef\u4f5c\u4e3a\u9605\u8bfb\u672c\u4e66\u7684\u6307\u5bfc\u3002 Book-Understanding-the-Linux-Kernel\uff1a\u8ba8\u8bba linux kernel \u7684\u5b9e\u73b0\uff0c\u4ee5 Understanding.The.Linux.kernel.3 rd .Edition \u4e3a\u4e3b\u8981\u53c2\u8003\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Kernel/Architecture/","text":"Architecture \u672c\u7ae0\u4ee5\u201c\u7ed3\u6784\u5316\u601d\u7ef4\u201d\u5bf9Linux OS\u8fdb\u884c\u603b\u7ed3\u3002 The Process/Kernel Model \u5728 Understanding.The.Linux.kernel.3 rd .Edition \u7684chapter 1.6.1. The Process/Kernel Model\u4e2d\u6240\u63cf\u8ff0Process/Kernel Model\u4e0e\u4e0a\u9762\u6240\u63cf\u8ff0\u7684architecture\u76f8\u540c\uff0c\u8fd9\u4e2a\u540d\u79f0\u66f4\u52a0\u7cbe\u7b80\uff0c\u4fbf\u4e8e\u8868\u8fbe\u3002\u5bf9\u4e8e\u4e00\u4e2alinux OS programmer\uff0c\u5fc3\u4e2d\u5e94\u8be5\u7262\u8bb0\u8fd9\u4e2amodel\u3002 Interface: system call \u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662f: system call\u662fprocess\u548ckernel\u4e4b\u95f4\u7684interface\u3002 Linux\u91c7\u7528\u7684\u662fmonolithic kernel\uff0c\u8fd9\u5c31\u4f7f\u5f97Linux OS\u7684\u201dProcess/Kernel Model\u201c\u66f4\u52a0\u5730\u7b80\u5316: process\u7684\u6240\u6709\u8bf7\u6c42\u90fd\u662f\u901a\u8fc7system call\u6765\u5411kernel\u53d1\u8d77\u7684 Control \u4ece**\u63a7\u5236\u8bba**\u7684\u89d2\u5ea6\u6765\u770b\uff0cprocess\u7684\u6267\u884c\u6536scheduler\uff08\u4f4d\u4e8ekernel\u4e2d\uff09\u7684\u63a7\u5236\uff0c\u5373process\u53d7\u63a7\u4e8ekernel\u3002 \u5173\u4e8e\u63a7\u5236\u8bba\uff0c\u53c2\u89c1\u5de5\u7a0bsoftware-engineering\u7684 Software-design\\Control-theory \u7ae0\u8282\u3002 Kernel space and user space Kernel space \u548c user space \u80fd\u591f\u5c06Linux OS\u8fdb\u4e00\u6b65\u8fdb\u884c\u5212\u5206\u3002\u4e0b\u9762\u8fd9\u7bc7\u6587\u7ae0\u8fd8\u63cf\u8ff0\u4e86\u8fd9\u79cd\u5212\u5206\u7684\u610f\u4e49\u3002 wikipedia User space A modern computer operating system usually segregates virtual memory into kernel space and user space .[ a] Primarily, this separation serves to provide memory protection and hardware protection from malicious or errant software behaviour. Kernel space is strictly reserved for running a privileged operating system kernel , kernel extensions, and most device drivers . In contrast, user space is the memory area where application software and some drivers execute. Overview The term userland (or user space) refers to all code that runs outside the operating system's kernel .[ 1] Userland usually refers to the various programs and libraries that the operating system uses to interact with the kernel : software that performs input/output , manipulates file system objects, application software , etc. NOTE: \u4e0b\u9762\u5bf9user space process\u7684\u603b\u7ed3\u975e\u5e38\u597d\uff0c\u53ef\u4ee5\u770b\u5230Linux OS\u7684\u5f88\u591a\u7279\u6027\u90fd\u662f\u5728\u6b64\u57fa\u7840\u4e0a\u5efa\u7acb\u8d77\u6765\u7684\u3002 Each user space process normally runs in its own virtual memory space, and, unless explicitly allowed, cannot access the memory of other processes. This is the basis for memory protection in today's mainstream operating systems, and a building block for privilege separation . NOTE: separation A separate user mode can also be used to build efficient virtual machines \u2013 see Popek and Goldberg virtualization requirements . NOTE: virtual machine With enough privileges, processes can request the kernel to map part of another process's memory space to its own, as is the case for debuggers . NOTE: debugger Programs can also request shared memory regions with other processes, although other techniques are also available to allow inter-process communication . NOTE: shared memory NOTE: \u539f\u6587\u7684\u8fd9\u5f20\u56fe\u603b\u7ed3\u7684\u975e\u5e38\u597d\uff1b\u5b83\u662f\u5bf9 Architecture-of-computing-system \u4e2d\u7684\u56fe\u7684\u6269\u5145\u3002 NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0csystemd\u662f\u8fd0\u884c\u5728user mode\uff0c\u800c\u4e0d\u662fkernel mode\uff1b Implementation The most common way of implementing a user mode separate from kernel mode involves operating system protection rings . NOTE: \u540e\u9762\u4f1a\u8bb2\u89e3Linux kernel\u7684\u5b9e\u73b0","title":"Architecture"},{"location":"Kernel/Architecture/#architecture","text":"\u672c\u7ae0\u4ee5\u201c\u7ed3\u6784\u5316\u601d\u7ef4\u201d\u5bf9Linux OS\u8fdb\u884c\u603b\u7ed3\u3002","title":"Architecture"},{"location":"Kernel/Architecture/#the#processkernel#model","text":"\u5728 Understanding.The.Linux.kernel.3 rd .Edition \u7684chapter 1.6.1. The Process/Kernel Model\u4e2d\u6240\u63cf\u8ff0Process/Kernel Model\u4e0e\u4e0a\u9762\u6240\u63cf\u8ff0\u7684architecture\u76f8\u540c\uff0c\u8fd9\u4e2a\u540d\u79f0\u66f4\u52a0\u7cbe\u7b80\uff0c\u4fbf\u4e8e\u8868\u8fbe\u3002\u5bf9\u4e8e\u4e00\u4e2alinux OS programmer\uff0c\u5fc3\u4e2d\u5e94\u8be5\u7262\u8bb0\u8fd9\u4e2amodel\u3002","title":"The Process/Kernel Model"},{"location":"Kernel/Architecture/#interface#system#call","text":"\u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662f: system call\u662fprocess\u548ckernel\u4e4b\u95f4\u7684interface\u3002 Linux\u91c7\u7528\u7684\u662fmonolithic kernel\uff0c\u8fd9\u5c31\u4f7f\u5f97Linux OS\u7684\u201dProcess/Kernel Model\u201c\u66f4\u52a0\u5730\u7b80\u5316: process\u7684\u6240\u6709\u8bf7\u6c42\u90fd\u662f\u901a\u8fc7system call\u6765\u5411kernel\u53d1\u8d77\u7684","title":"Interface: system call"},{"location":"Kernel/Architecture/#control","text":"\u4ece**\u63a7\u5236\u8bba**\u7684\u89d2\u5ea6\u6765\u770b\uff0cprocess\u7684\u6267\u884c\u6536scheduler\uff08\u4f4d\u4e8ekernel\u4e2d\uff09\u7684\u63a7\u5236\uff0c\u5373process\u53d7\u63a7\u4e8ekernel\u3002 \u5173\u4e8e\u63a7\u5236\u8bba\uff0c\u53c2\u89c1\u5de5\u7a0bsoftware-engineering\u7684 Software-design\\Control-theory \u7ae0\u8282\u3002","title":"Control"},{"location":"Kernel/Architecture/#kernel#space#and#user#space","text":"Kernel space \u548c user space \u80fd\u591f\u5c06Linux OS\u8fdb\u4e00\u6b65\u8fdb\u884c\u5212\u5206\u3002\u4e0b\u9762\u8fd9\u7bc7\u6587\u7ae0\u8fd8\u63cf\u8ff0\u4e86\u8fd9\u79cd\u5212\u5206\u7684\u610f\u4e49\u3002","title":"Kernel space and user space"},{"location":"Kernel/Architecture/#wikipedia#user#space","text":"A modern computer operating system usually segregates virtual memory into kernel space and user space .[ a] Primarily, this separation serves to provide memory protection and hardware protection from malicious or errant software behaviour. Kernel space is strictly reserved for running a privileged operating system kernel , kernel extensions, and most device drivers . In contrast, user space is the memory area where application software and some drivers execute.","title":"wikipedia User space"},{"location":"Kernel/Architecture/#overview","text":"The term userland (or user space) refers to all code that runs outside the operating system's kernel .[ 1] Userland usually refers to the various programs and libraries that the operating system uses to interact with the kernel : software that performs input/output , manipulates file system objects, application software , etc. NOTE: \u4e0b\u9762\u5bf9user space process\u7684\u603b\u7ed3\u975e\u5e38\u597d\uff0c\u53ef\u4ee5\u770b\u5230Linux OS\u7684\u5f88\u591a\u7279\u6027\u90fd\u662f\u5728\u6b64\u57fa\u7840\u4e0a\u5efa\u7acb\u8d77\u6765\u7684\u3002 Each user space process normally runs in its own virtual memory space, and, unless explicitly allowed, cannot access the memory of other processes. This is the basis for memory protection in today's mainstream operating systems, and a building block for privilege separation . NOTE: separation A separate user mode can also be used to build efficient virtual machines \u2013 see Popek and Goldberg virtualization requirements . NOTE: virtual machine With enough privileges, processes can request the kernel to map part of another process's memory space to its own, as is the case for debuggers . NOTE: debugger Programs can also request shared memory regions with other processes, although other techniques are also available to allow inter-process communication . NOTE: shared memory NOTE: \u539f\u6587\u7684\u8fd9\u5f20\u56fe\u603b\u7ed3\u7684\u975e\u5e38\u597d\uff1b\u5b83\u662f\u5bf9 Architecture-of-computing-system \u4e2d\u7684\u56fe\u7684\u6269\u5145\u3002 NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0csystemd\u662f\u8fd0\u884c\u5728user mode\uff0c\u800c\u4e0d\u662fkernel mode\uff1b","title":"Overview"},{"location":"Kernel/Architecture/#implementation","text":"The most common way of implementing a user mode separate from kernel mode involves operating system protection rings . NOTE: \u540e\u9762\u4f1a\u8bb2\u89e3Linux kernel\u7684\u5b9e\u73b0","title":"Implementation"},{"location":"Kernel/Kernel/","text":"Kernel (operating system) \u672c\u8282\u8ba8\u8bbaOS\u7684kernel\uff0c\u672c\u8282\u662f\u5bf9Kernel\u7684\u6982\u8ff0\uff0c\u53c2\u8003\u7684\u662f wikipedia Kernel (operating system) The kernel is a computer program that is the core of a computer's operating system , with complete control over everything in the system. On most systems, it is one of the first programs loaded on start-up (after the bootloader ). It handles the rest of start-up as well as input/output requests from software , translating them into data-processing instructions for the central processing unit . It handles memory and peripherals (\u5916\u8bbe) like keyboards, monitors, printers, and speakers. The critical code of the kernel is usually loaded into a separate area of memory, which is protected from access by application programs or other, less critical parts of the operating system. The kernel performs its tasks, such as running processes, managing hardware devices such as the hard disk , and handling interrupts, in this protected kernel space . In contrast, everything a user does is in user space : writing text in a text editor, running programs in a GUI , etc. This separation prevents user data and kernel data from interfering with each other and causing instability and slowness, as well as preventing malfunctioning application programs from crashing the entire operating system. NOTE:\u9694\u79bb\u5e26\u6765\u5b89\u5168 The kernel's interface is a low-level abstraction layer . When a process makes requests of the kernel, it is called a system call . Kernel designs differ in how they manage these system calls and resources . A monolithic kernel runs all the operating system instructions in the same address space for speed. A microkernel runs most processes in user space, for modularity . A kernel connects the application software to the hardware of a computer. Function of Kernel NOTE: \u5173\u4e8e\u5185\u6838\u7684\u529f\u80fd\uff0c\u5728\u672c\u7bc7\u6587\u7ae0\u4e2d\u6ca1\u6709\u8fdb\u884c\u8be6\u7ec6\u7684\u5206\u7c7b\u4ecb\u7ecd\uff0c\u6240\u4ee5\u6b64\u5904\u8fdb\u884c\u7701\u7565\uff1b\u5728 Operating system \u7684 Kernel \u7ae0\u8282\u8fdb\u884c\u4e86\u975e\u5e38\u597d\u7684\u4ecb\u7ecd\uff0c\u63a8\u8350\u53bb\u9605\u8bfb\u3002 Kernel design decisions \u539f\u6587\u672c\u8282\u6240\u63cf\u8ff0\u7684\u662f\u5728\u8bbe\u8ba1\u4e00\u4e2akernel\u7684\u65f6\u5019\u9700\u8981\u8003\u8651\u54ea\u4e9b\u95ee\u9898\uff0c\u8bfb\u8005\u5e94\u8be5\u5bf9\u8fd9\u4e9b\u95ee\u9898\u6709\u4e9b\u4e86\u89e3\uff0c\u8fd9\u4e9b\u95ee\u9898\u76f4\u63a5\u5f71\u54cd\u4e86kernel\u7684\u5b9e\u73b0\u3002 Kernel-wide design approaches \u539f\u6587\u672c\u8282\u6240\u63cf\u8ff0\u7684\u662f\u5b9e\u73b0kernel\uff08\u672c\u8d28\u4e0akernel\u662f\u4e00\u4e2asoftware\uff09\u65f6\uff0c\u91c7\u53d6\u600e\u6837\u7684\u8f6f\u4ef6\u67b6\u6784\u3002\u76ee\u524d\u4e3b\u6d41\u7684\u7684\u67b6\u6784\u6709\u4e24\u79cd\u3002\u539f\u6587\u4e2d\u8fd8\u5bf9\u8fd9\u4e24\u79cd\u8f6f\u4ef6\u67b6\u6784\u80cc\u540e\u7684philosophy\u5373 separation of mechanism and policy \u8fdb\u884c\u4e86\u5206\u6790\uff0c\u6211\u8bfb\u5b8c\u4ecd\u7136\u4e00\u5934\u96fe\u6c34\u3002 While monolithic kernels execute all of their code in the same address space ( kernel space ), microkernels try to run most of their services in user space, aiming to improve maintainability and modularity of the codebase. Most kernels do not fit exactly into one of these categories, but are rather found in between these two designs. These are called hybrid kernels . More exotic designs such as nanokernels and exokernels are available, but are seldom used for production systems. The Xen hypervisor, for example, is an exokernel. Monolithic kernels Main article: Monolithic kernel NOTE: \u7531\u4e8eLinux \u91c7\u7528\u7684\u662f monolithic kernel\uff0c\u6240\u4ee5\u9700\u8981\u5bf9\u5b83\u8fdb\u884c\u8be6\u7ec6\u5206\u6790\uff0c\u540e\u9762\u8865\u5145\u4e86\u201cMonolithic kernel\u201d\u7ae0\u8282\u3002 Diagram of a monolithic kernel In a monolithic kernel, all OS services run along with the main kernel thread, thus also residing in the same memory area. This approach provides rich and powerful hardware access. Some developers, such as UNIX developer Ken Thompson , maintain that it is \"easier to implement a monolithic kernel\" than microkernels. The main disadvantages of monolithic kernels are the dependencies between system components \u2013 a bug in a device driver might crash the entire system \u2013 and the fact that large kernels can become very difficult to maintain. NOTE: Linux\u5c31\u662f\u5178\u578b\u7684monolithic kernel Microkernels Main article: Microkernel Microkernel (also abbreviated \u03bcK or uK) is the term describing an approach to operating system design by which the functionality of the system is moved out of the traditional \"kernel\", into a set of \"servers\" that communicate through a \"minimal\" kernel, leaving as little as possible in \"system space\" and as much as possible in \"user space\". A microkernel that is designed for a specific platform or device is only ever going to have what it needs to operate. The microkernel approach consists of defining a simple abstraction over the hardware, with a set of primitives or system calls to implement minimal OS services such as memory management , multitasking , and inter-process communication . Other services, including those normally provided by the kernel, such as networking , are implemented in user-space programs, referred to as servers . Microkernels are easier to maintain than monolithic kernels, but the large number of system calls and context switches might slow down the system because they typically generate more overhead than plain function calls. Monolithic kernel \u201cmonolithic\u201d\u7684\u610f\u601d\u662f \u96c6\u6210\u7684\u3001\u4e00\u4f53\u5316\u7684\uff0cmonolithic kernel\u7684\u610f\u601d\u662f\u201c\u96c6\u6210\u6838\u201d\u3001\u201c\u4e00\u4f53\u5316\u6838\u201d\uff0cLinux\u91c7\u7528\u7684\u5c31\u662f\u8fd9\u79cd\u7ed3\u6784\u3002 wikipedia Monolithic kernel A monolithic kernel is an operating system architecture where the entire operating system is working in kernel space . The monolithic model differs from other operating system architectures (such as the microkernel architecture)[ 1] [ 2] in that it alone defines a high-level virtual interface over computer hardware. A set of primitives or system calls implement all operating system services such as process management, concurrency , and memory management . Device drivers can be added to the kernel as modules . Structure of monolithic kernel,microkernel and hybrid kernel-based operating systems Loadable modules NOTE: \u8fd9\u662f\u4e00\u79cdPlugin architecture\u3002 Modular operating systems such as OS-9 and most modern monolithic operating systems such as OpenVMS , Linux , BSD , SunOS , AIX , and MULTICS can dynamically load (and unload) executable modules at runtime. This modularity of the operating system is at the binary (image) level and not at the architecture level. Modular monolithic operating systems are not to be confused with the architectural level of modularity inherent in server-client operating systems (and its derivatives sometimes marketed as hybrid kernel ) which use microkernels and servers (not to be mistaken for modules or daemons). Practically speaking, dynamically loading modules is simply a more flexible way of handling the operating system image at runtime\u2014as opposed to rebooting with a different operating system image. The modules allow easy extension of the operating systems' capabilities as required.[ 3] Dynamically loadable modules incur a small overhead when compared to building the module into the operating system image. However, in some cases, loading modules dynamically (as-needed) helps to keep the amount of code running in kernel space to a minimum; for example, to minimize operating system footprint for embedded devices or those with limited hardware resources. Namely, an unloaded module need not be stored in scarce random access memory .","title":"Kernel"},{"location":"Kernel/Kernel/#kernel#operating#system","text":"\u672c\u8282\u8ba8\u8bbaOS\u7684kernel\uff0c\u672c\u8282\u662f\u5bf9Kernel\u7684\u6982\u8ff0\uff0c\u53c2\u8003\u7684\u662f","title":"Kernel (operating system)"},{"location":"Kernel/Kernel/#wikipedia#kernel#operating#system","text":"The kernel is a computer program that is the core of a computer's operating system , with complete control over everything in the system. On most systems, it is one of the first programs loaded on start-up (after the bootloader ). It handles the rest of start-up as well as input/output requests from software , translating them into data-processing instructions for the central processing unit . It handles memory and peripherals (\u5916\u8bbe) like keyboards, monitors, printers, and speakers. The critical code of the kernel is usually loaded into a separate area of memory, which is protected from access by application programs or other, less critical parts of the operating system. The kernel performs its tasks, such as running processes, managing hardware devices such as the hard disk , and handling interrupts, in this protected kernel space . In contrast, everything a user does is in user space : writing text in a text editor, running programs in a GUI , etc. This separation prevents user data and kernel data from interfering with each other and causing instability and slowness, as well as preventing malfunctioning application programs from crashing the entire operating system. NOTE:\u9694\u79bb\u5e26\u6765\u5b89\u5168 The kernel's interface is a low-level abstraction layer . When a process makes requests of the kernel, it is called a system call . Kernel designs differ in how they manage these system calls and resources . A monolithic kernel runs all the operating system instructions in the same address space for speed. A microkernel runs most processes in user space, for modularity . A kernel connects the application software to the hardware of a computer.","title":"wikipedia Kernel (operating system)"},{"location":"Kernel/Kernel/#function#of#kernel","text":"NOTE: \u5173\u4e8e\u5185\u6838\u7684\u529f\u80fd\uff0c\u5728\u672c\u7bc7\u6587\u7ae0\u4e2d\u6ca1\u6709\u8fdb\u884c\u8be6\u7ec6\u7684\u5206\u7c7b\u4ecb\u7ecd\uff0c\u6240\u4ee5\u6b64\u5904\u8fdb\u884c\u7701\u7565\uff1b\u5728 Operating system \u7684 Kernel \u7ae0\u8282\u8fdb\u884c\u4e86\u975e\u5e38\u597d\u7684\u4ecb\u7ecd\uff0c\u63a8\u8350\u53bb\u9605\u8bfb\u3002","title":"Function of Kernel"},{"location":"Kernel/Kernel/#kernel#design#decisions","text":"\u539f\u6587\u672c\u8282\u6240\u63cf\u8ff0\u7684\u662f\u5728\u8bbe\u8ba1\u4e00\u4e2akernel\u7684\u65f6\u5019\u9700\u8981\u8003\u8651\u54ea\u4e9b\u95ee\u9898\uff0c\u8bfb\u8005\u5e94\u8be5\u5bf9\u8fd9\u4e9b\u95ee\u9898\u6709\u4e9b\u4e86\u89e3\uff0c\u8fd9\u4e9b\u95ee\u9898\u76f4\u63a5\u5f71\u54cd\u4e86kernel\u7684\u5b9e\u73b0\u3002","title":"Kernel design decisions"},{"location":"Kernel/Kernel/#kernel-wide#design#approaches","text":"\u539f\u6587\u672c\u8282\u6240\u63cf\u8ff0\u7684\u662f\u5b9e\u73b0kernel\uff08\u672c\u8d28\u4e0akernel\u662f\u4e00\u4e2asoftware\uff09\u65f6\uff0c\u91c7\u53d6\u600e\u6837\u7684\u8f6f\u4ef6\u67b6\u6784\u3002\u76ee\u524d\u4e3b\u6d41\u7684\u7684\u67b6\u6784\u6709\u4e24\u79cd\u3002\u539f\u6587\u4e2d\u8fd8\u5bf9\u8fd9\u4e24\u79cd\u8f6f\u4ef6\u67b6\u6784\u80cc\u540e\u7684philosophy\u5373 separation of mechanism and policy \u8fdb\u884c\u4e86\u5206\u6790\uff0c\u6211\u8bfb\u5b8c\u4ecd\u7136\u4e00\u5934\u96fe\u6c34\u3002 While monolithic kernels execute all of their code in the same address space ( kernel space ), microkernels try to run most of their services in user space, aiming to improve maintainability and modularity of the codebase. Most kernels do not fit exactly into one of these categories, but are rather found in between these two designs. These are called hybrid kernels . More exotic designs such as nanokernels and exokernels are available, but are seldom used for production systems. The Xen hypervisor, for example, is an exokernel.","title":"Kernel-wide design approaches"},{"location":"Kernel/Kernel/#monolithic#kernels","text":"Main article: Monolithic kernel NOTE: \u7531\u4e8eLinux \u91c7\u7528\u7684\u662f monolithic kernel\uff0c\u6240\u4ee5\u9700\u8981\u5bf9\u5b83\u8fdb\u884c\u8be6\u7ec6\u5206\u6790\uff0c\u540e\u9762\u8865\u5145\u4e86\u201cMonolithic kernel\u201d\u7ae0\u8282\u3002 Diagram of a monolithic kernel In a monolithic kernel, all OS services run along with the main kernel thread, thus also residing in the same memory area. This approach provides rich and powerful hardware access. Some developers, such as UNIX developer Ken Thompson , maintain that it is \"easier to implement a monolithic kernel\" than microkernels. The main disadvantages of monolithic kernels are the dependencies between system components \u2013 a bug in a device driver might crash the entire system \u2013 and the fact that large kernels can become very difficult to maintain. NOTE: Linux\u5c31\u662f\u5178\u578b\u7684monolithic kernel","title":"Monolithic kernels"},{"location":"Kernel/Kernel/#microkernels","text":"Main article: Microkernel Microkernel (also abbreviated \u03bcK or uK) is the term describing an approach to operating system design by which the functionality of the system is moved out of the traditional \"kernel\", into a set of \"servers\" that communicate through a \"minimal\" kernel, leaving as little as possible in \"system space\" and as much as possible in \"user space\". A microkernel that is designed for a specific platform or device is only ever going to have what it needs to operate. The microkernel approach consists of defining a simple abstraction over the hardware, with a set of primitives or system calls to implement minimal OS services such as memory management , multitasking , and inter-process communication . Other services, including those normally provided by the kernel, such as networking , are implemented in user-space programs, referred to as servers . Microkernels are easier to maintain than monolithic kernels, but the large number of system calls and context switches might slow down the system because they typically generate more overhead than plain function calls.","title":"Microkernels"},{"location":"Kernel/Kernel/#monolithic#kernel","text":"\u201cmonolithic\u201d\u7684\u610f\u601d\u662f \u96c6\u6210\u7684\u3001\u4e00\u4f53\u5316\u7684\uff0cmonolithic kernel\u7684\u610f\u601d\u662f\u201c\u96c6\u6210\u6838\u201d\u3001\u201c\u4e00\u4f53\u5316\u6838\u201d\uff0cLinux\u91c7\u7528\u7684\u5c31\u662f\u8fd9\u79cd\u7ed3\u6784\u3002","title":"Monolithic kernel"},{"location":"Kernel/Kernel/#wikipedia#monolithic#kernel","text":"A monolithic kernel is an operating system architecture where the entire operating system is working in kernel space . The monolithic model differs from other operating system architectures (such as the microkernel architecture)[ 1] [ 2] in that it alone defines a high-level virtual interface over computer hardware. A set of primitives or system calls implement all operating system services such as process management, concurrency , and memory management . Device drivers can be added to the kernel as modules . Structure of monolithic kernel,microkernel and hybrid kernel-based operating systems","title":"wikipedia Monolithic kernel"},{"location":"Kernel/Kernel/#loadable#modules","text":"NOTE: \u8fd9\u662f\u4e00\u79cdPlugin architecture\u3002 Modular operating systems such as OS-9 and most modern monolithic operating systems such as OpenVMS , Linux , BSD , SunOS , AIX , and MULTICS can dynamically load (and unload) executable modules at runtime. This modularity of the operating system is at the binary (image) level and not at the architecture level. Modular monolithic operating systems are not to be confused with the architectural level of modularity inherent in server-client operating systems (and its derivatives sometimes marketed as hybrid kernel ) which use microkernels and servers (not to be mistaken for modules or daemons). Practically speaking, dynamically loading modules is simply a more flexible way of handling the operating system image at runtime\u2014as opposed to rebooting with a different operating system image. The modules allow easy extension of the operating systems' capabilities as required.[ 3] Dynamically loadable modules incur a small overhead when compared to building the module into the operating system image. However, in some cases, loading modules dynamically (as-needed) helps to keep the amount of code running in kernel space to a minimum; for example, to minimize operating system footprint for embedded devices or those with limited hardware resources. Namely, an unloaded module need not be stored in scarce random access memory .","title":"Loadable modules"},{"location":"Kernel/TODO/","text":"20190126linux\u5185\u6838\u662f\u5982\u4f55\u6765\u7ec4\u7ec7process\u7684 \u4eca\u5929\u5728\u9605\u8bfb Separation Anxiety: A Tutorial for Isolating Your System with Linux Namespaces \u8fd9\u7bc7\u6587\u7ae0\u7684\u65f6\u5019\uff0c\u5176\u4e2d\u4e00\u6bb5\u8bdd\uff1a Historically, the Linux kernel has maintained a single process tree. The tree contains a reference to every process currently running in a parent-child hierarchy. A process, given it has sufficient privileges and satisfies certain conditions, can inspect another process by attaching a tracer to it or may even be able to kill it. \u8fd9\u6bb5\u8bdd\u5f15\u8d77\u4e86\u6211\u7684\u601d\u8003\uff1a\u5728linux\u7684\u5185\u6838\u4e2d\uff0c\u662f\u4f7f\u7528tree\u6765\u6309\u7167parent-child\u5173\u7cfb\u6765\u7ec4\u7ec7process\u7684\u5417\uff1f \u521a\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u6211\u89c9\u5f97\u5e94\u8be5\u662f\u8fd9\u6837\u7684\uff0c\u56e0\u4e3a ptree \uff0c\u663e\u7136\u6309\u7167parent-child\u5173\u7cfb\u662f\u53ef\u4ee5\u6309\u7167tree\u7ed3\u6784\u6765\u7ec4\u7ec7process\u7684\uff0c\u4f46\u662f\u5b9e\u9645\u7684\u5b9e\u73b0\u8981\u8fdc\u6bd4\u8fd9\u590d\u6742\uff0c\u56e0\u4e3a\u9664\u6b64\u4e4b\u5916\uff0c\u8fd8\u9700\u8981\u8003\u8651\u7684\u95ee\u9898\u6709\uff1a schedule\uff0c\u5373\u8c03\u5ea6\u95ee\u9898\uff0c\u5185\u6838\u9700\u8981\u8fdb\u884c\u9ad8\u6548\u5730\u8c03\u5ea6\uff0c\u6240\u4ee5\u5bf9process\u7684\u7ec4\u7ec7\u5c31\u975e\u5e38\u91cd\u8981 \u4e0b\u9762\u662f\u4e00\u4e9b\u53c2\u8003\u5185\u5bb9\uff1a The Linux Kernel/Processing Traverse the Process Tree Process management Scheduling (computing) Completely Fair Scheduler The Linux process tree","title":"20190126linux\u5185\u6838\u662f\u5982\u4f55\u6765\u7ec4\u7ec7process\u7684"},{"location":"Kernel/TODO/#20190126linuxprocess","text":"\u4eca\u5929\u5728\u9605\u8bfb Separation Anxiety: A Tutorial for Isolating Your System with Linux Namespaces \u8fd9\u7bc7\u6587\u7ae0\u7684\u65f6\u5019\uff0c\u5176\u4e2d\u4e00\u6bb5\u8bdd\uff1a Historically, the Linux kernel has maintained a single process tree. The tree contains a reference to every process currently running in a parent-child hierarchy. A process, given it has sufficient privileges and satisfies certain conditions, can inspect another process by attaching a tracer to it or may even be able to kill it. \u8fd9\u6bb5\u8bdd\u5f15\u8d77\u4e86\u6211\u7684\u601d\u8003\uff1a\u5728linux\u7684\u5185\u6838\u4e2d\uff0c\u662f\u4f7f\u7528tree\u6765\u6309\u7167parent-child\u5173\u7cfb\u6765\u7ec4\u7ec7process\u7684\u5417\uff1f \u521a\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u6211\u89c9\u5f97\u5e94\u8be5\u662f\u8fd9\u6837\u7684\uff0c\u56e0\u4e3a ptree \uff0c\u663e\u7136\u6309\u7167parent-child\u5173\u7cfb\u662f\u53ef\u4ee5\u6309\u7167tree\u7ed3\u6784\u6765\u7ec4\u7ec7process\u7684\uff0c\u4f46\u662f\u5b9e\u9645\u7684\u5b9e\u73b0\u8981\u8fdc\u6bd4\u8fd9\u590d\u6742\uff0c\u56e0\u4e3a\u9664\u6b64\u4e4b\u5916\uff0c\u8fd8\u9700\u8981\u8003\u8651\u7684\u95ee\u9898\u6709\uff1a schedule\uff0c\u5373\u8c03\u5ea6\u95ee\u9898\uff0c\u5185\u6838\u9700\u8981\u8fdb\u884c\u9ad8\u6548\u5730\u8c03\u5ea6\uff0c\u6240\u4ee5\u5bf9process\u7684\u7ec4\u7ec7\u5c31\u975e\u5e38\u91cd\u8981 \u4e0b\u9762\u662f\u4e00\u4e9b\u53c2\u8003\u5185\u5bb9\uff1a The Linux Kernel/Processing Traverse the Process Tree Process management Scheduling (computing) Completely Fair Scheduler The Linux process tree","title":"20190126linux\u5185\u6838\u662f\u5982\u4f55\u6765\u7ec4\u7ec7process\u7684"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/","text":"\u5173\u4e8e\u672c\u4e66 Understanding.The.Linux.kernel.3 rd .Edition Understanding the Linux Kernel \u5728Architecture\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u5efa\u7acb\u8d77\u6765linux OS\u7684\u6574\u4f53architecture\u548c\u5b83\u7684\u4f7f\u547d\u4e86\uff08\u5373\u5b83\u8981\u505a\u54ea\u4e9b\u4e8b\u60c5\uff09\uff0c\u672c\u4e66\u6240\u8981\u505a\u7684\u5c31\u662f\u544a\u8bc9\u8bfb\u8005linux OS\u5982\u4f55\u6765\u5b9e\u73b0\u5b83\u7684\u4f7f\u547d\u7684\u3002","title":"Introduction"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/#_1","text":"Understanding.The.Linux.kernel.3 rd .Edition Understanding the Linux Kernel \u5728Architecture\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u5efa\u7acb\u8d77\u6765linux OS\u7684\u6574\u4f53architecture\u548c\u5b83\u7684\u4f7f\u547d\u4e86\uff08\u5373\u5b83\u8981\u505a\u54ea\u4e9b\u4e8b\u60c5\uff09\uff0c\u672c\u4e66\u6240\u8981\u505a\u7684\u5c31\u662f\u544a\u8bc9\u8bfb\u8005linux OS\u5982\u4f55\u6765\u5b9e\u73b0\u5b83\u7684\u4f7f\u547d\u7684\u3002","title":"\u5173\u4e8e\u672c\u4e66"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.1-Linux-Versus-Other-Unix-Like-Kernels/","text":"1.1. Linux Versus Other Unix-Like Kernels The various Unix-like systems on the market, some of which have a long history and show signs of archaic\uff08\u53e4\u8001\u7684\uff0c\u9648\u65e7\u7684\uff09 practices, differ in many important respects. All commercial variants were derived from either SVR4 or 4.4BSD, and all tend to agree on some common standards like IEEE's Portable Operating Systems based on Unix (POSIX) and X/Open's Common Applications Environment (CAE). The current standards specify only an application programming interface (API)that is, a well-defined environment in which user programs should run. Therefore, the standards do not impose any restriction on internal design choices of a compliant kernel . [*] [*] As a matter of fact, several non-Unix operating systems, such as Windows NT and its descendents, are POSIX-compliant. NOTE: \u5173\u4e8eUnix-like system\u7684standard\uff0c\u6f14\u8fdb\u5386\u7a0b\uff0c\u53c2\u89c1\u300a Unix-standardization-and-implementation.md \u300b To define a common user interface, Unix-like kernels often share fundamental design ideas and features . In this respect, Linux is comparable with the other Unix-like operating systems. Reading this book and studying the Linux kernel, therefore, may help you understand the other Unix variants, too. The 2.6 version of the Linux kernel aims to be compliant with the IEEE POSIX standard. This, of course, means that most existing Unix programs can be compiled and executed on a Linux system with very little effort or even without the need for patches to the source code. Moreover, Linux includes all the features of a modern Unix operating system, such as virtual memory , a virtual filesystem , lightweight processes , Unix signals , SVR4 interprocess communications , support for Symmetric Multiprocessor (SMP) systems , and so on. When Linus Torvalds wrote the first kernel, he referred to some classical books on Unix internals, like Maurice Bach's The Design of the Unix Operating System (Prentice Hall, 1986). Actually, Linux still has some bias toward the Unix baseline described in Bach's book (i.e., SVR2). However, Linux doesn't stick to any particular variant. Instead, it tries to adopt the best features and design choices of several different Unix kernels. The following list describes how Linux competes against some well-known commercial Unix kernels: Monolithic kernel It is a large, complex do-it-yourself program, composed of several logically different components. In this, it is quite conventional; most commercial Unix variants are monolithic. (Notable exceptions are the Apple Mac OS X and the GNU Hurd operating systems, both derived from the Carnegie-Mellon's Mach, which follow a microkernel approach.) NOTE: See also Monolithic kernel Compiled and statically linked traditional Unix kernels Most modern kernels can dynamically load and unload some portions of the kernel code (typically, device drivers ), which are usually called modules . Linux's support for modules is very good, because it is able to automatically load and unload modules on demand. Among the main commercial Unix variants, only the SVR4.2 and Solaris kernels have a similar feature. NOTE: \u672c\u4e66\u4e2d\uff0c\u8ba8\u8bbamodule\u7684\u7ae0\u8282\uff1a 1.4.4. Kernel Architecture \u672c\u4e66\u4e2d\uff0c\u8ba8\u8bbadevice driver\u7684\u7ae0\u8282\uff1a 1.6.9. Device Drivers See also Loadable kernel module Kernel threading Some Unix kernels, such as Solaris and SVR4.2/MP, are organized as a set of kernel threads .A kernel thread is an execution context that can be independently scheduled; it may be associated with a user program, or it may run only some kernel functions. Context switches between kernel threads are usually much less expensive than context switches between ordinary processes, because the former usually operate on a common address space. Linux uses kernel threads in a very limited way to execute a few kernel functions periodically; however, they do not represent the basic execution context abstraction. (That's the topic of the next item.) NOTE: \u672c\u4e66\u8ba8\u8bbakernel thread\u7684\u7ae0\u8282\uff1a 3.4.2. Kernel Threads Multithreaded application support Most modern operating systems have some kind of support for multithreaded applications that is, user programs that are designed in terms of many relatively independent execution flows that share a large portion of the application data structures. A multithreaded user application could be composed of many lightweight processes (LWP), which are processes that can operate on a common address space, common physical memory pages, common opened files, and so on. Linux defines its own version of lightweight processes, which is different from the types used on other systems such as SVR4 and Solaris. While all the commercial Unix variants of LWP are based on kernel threads , Linux regards lightweight processes as the basic execution context and handles them via the nonstandard clone( ) system call. NOTE: See also Light-weight process \u9605\u8bfb\u4ee5\u4e0b clone( ) system call\u7684\u6587\u6863\u6709\u52a9\u4e8e\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u7684\u542b\u4e49\u3002 NOTE: LWP VS kernel thread? \u4e0a\u4e00\u6bb5\u4e2d\u6240\u63cf\u8ff0\u7684\uff1aLinux kernel threads do not represent the basic execution context abstraction. \u672c\u6bb5\u4e2d\u6240\u63cf\u8ff0\u7684\uff1aLinux regards lightweight processes as the basic execution context and handles them via the nonstandard clone( ) system call. \u663e\u7136\uff0ckernel thread\u4e0d\u662flinux\u7684lightweight process\u3002 \u663e\u7136linux\u7684lightweight process\u662f\u9700\u8981\u7531linux\u7684scheduler\u6765\u8fdb\u884c\u8c03\u5ea6\u7684\uff0c\u90a3kernel thread\u662f\u7531\u8c01\u6765\u8fdb\u884c\u8c03\u5ea6\u5462\uff1f\u4e0b\u9762\u662f\u4e00\u4e9b\u6709\u4ef7\u503c\u7684\u5185\u5bb9\uff1a Are kernel threads processes and daemons? Difference between user-level and kernel-supported threads? Kernel threads made easy Preemptive kernel When compiled with the \"Preemptible Kernel\" option, Linux 2.6 can arbitrarily interleave execution flows while they are in privileged mode . Besides Linux 2.6, a few other conventional, general-purpose Unix systems, such as Solaris and Mach 3.0 , are fully preemptive kernels . SVR4.2/MP introduces some fixed preemption points as a method to get limited preemption capability. NOTE: See also Preemption (computing) Kernel preemption Multiprocessor support Several Unix kernel variants take advantage of multiprocessor systems. Linux 2.6 supports symmetric multiprocessing (SMP ) for different memory models, including NUMA: the system can use multiple processors and each processor can handle any task there is no discrimination among them. Although a few parts of the kernel code are still serialized by means of a single \" big kernel lock ,\" it is fair to say that Linux 2.6 makes a near optimal use of SMP. NOTE: Giant-lock Filesystem Linux's standard filesystems come in many flavors. You can use the plain old Ext2 filesystem if you don't have specific needs. You might switch to Ext3 if you want to avoid lengthy filesystem checks after a system crash. If you'll have to deal with many small files, the ReiserFS filesystem is likely to be the best choice. Besides Ext3 and ReiserFS, several other journaling filesystems can be used in Linux; they include IBM AIX's Journaling File System (JFS ) and Silicon Graphics IRIX 's XFS filesystem. Thanks to a powerful object-oriented Virtual File System technology (inspired by Solaris and SVR4), porting a foreign filesystem to Linux is generally easier than porting to other kernels. STREAMS Linux has no analog to the STREAMS I/O subsystem introduced in SVR4, although it is included now in most Unix kernels and has become the preferred interface for writing device drivers, terminal drivers, and network protocols.","title":"1.1-Linux-Versus-Other-Unix-Like-Kernels"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.1-Linux-Versus-Other-Unix-Like-Kernels/#11#linux#versus#other#unix-like#kernels","text":"The various Unix-like systems on the market, some of which have a long history and show signs of archaic\uff08\u53e4\u8001\u7684\uff0c\u9648\u65e7\u7684\uff09 practices, differ in many important respects. All commercial variants were derived from either SVR4 or 4.4BSD, and all tend to agree on some common standards like IEEE's Portable Operating Systems based on Unix (POSIX) and X/Open's Common Applications Environment (CAE). The current standards specify only an application programming interface (API)that is, a well-defined environment in which user programs should run. Therefore, the standards do not impose any restriction on internal design choices of a compliant kernel . [*] [*] As a matter of fact, several non-Unix operating systems, such as Windows NT and its descendents, are POSIX-compliant. NOTE: \u5173\u4e8eUnix-like system\u7684standard\uff0c\u6f14\u8fdb\u5386\u7a0b\uff0c\u53c2\u89c1\u300a Unix-standardization-and-implementation.md \u300b To define a common user interface, Unix-like kernels often share fundamental design ideas and features . In this respect, Linux is comparable with the other Unix-like operating systems. Reading this book and studying the Linux kernel, therefore, may help you understand the other Unix variants, too. The 2.6 version of the Linux kernel aims to be compliant with the IEEE POSIX standard. This, of course, means that most existing Unix programs can be compiled and executed on a Linux system with very little effort or even without the need for patches to the source code. Moreover, Linux includes all the features of a modern Unix operating system, such as virtual memory , a virtual filesystem , lightweight processes , Unix signals , SVR4 interprocess communications , support for Symmetric Multiprocessor (SMP) systems , and so on. When Linus Torvalds wrote the first kernel, he referred to some classical books on Unix internals, like Maurice Bach's The Design of the Unix Operating System (Prentice Hall, 1986). Actually, Linux still has some bias toward the Unix baseline described in Bach's book (i.e., SVR2). However, Linux doesn't stick to any particular variant. Instead, it tries to adopt the best features and design choices of several different Unix kernels. The following list describes how Linux competes against some well-known commercial Unix kernels:","title":"1.1. Linux Versus Other Unix-Like Kernels"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.1-Linux-Versus-Other-Unix-Like-Kernels/#monolithic#kernel","text":"It is a large, complex do-it-yourself program, composed of several logically different components. In this, it is quite conventional; most commercial Unix variants are monolithic. (Notable exceptions are the Apple Mac OS X and the GNU Hurd operating systems, both derived from the Carnegie-Mellon's Mach, which follow a microkernel approach.) NOTE: See also Monolithic kernel","title":"Monolithic kernel"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.1-Linux-Versus-Other-Unix-Like-Kernels/#compiled#and#statically#linked#traditional#unix#kernels","text":"Most modern kernels can dynamically load and unload some portions of the kernel code (typically, device drivers ), which are usually called modules . Linux's support for modules is very good, because it is able to automatically load and unload modules on demand. Among the main commercial Unix variants, only the SVR4.2 and Solaris kernels have a similar feature. NOTE: \u672c\u4e66\u4e2d\uff0c\u8ba8\u8bbamodule\u7684\u7ae0\u8282\uff1a 1.4.4. Kernel Architecture \u672c\u4e66\u4e2d\uff0c\u8ba8\u8bbadevice driver\u7684\u7ae0\u8282\uff1a 1.6.9. Device Drivers See also Loadable kernel module","title":"Compiled and statically linked traditional Unix kernels"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.1-Linux-Versus-Other-Unix-Like-Kernels/#kernel#threading","text":"Some Unix kernels, such as Solaris and SVR4.2/MP, are organized as a set of kernel threads .A kernel thread is an execution context that can be independently scheduled; it may be associated with a user program, or it may run only some kernel functions. Context switches between kernel threads are usually much less expensive than context switches between ordinary processes, because the former usually operate on a common address space. Linux uses kernel threads in a very limited way to execute a few kernel functions periodically; however, they do not represent the basic execution context abstraction. (That's the topic of the next item.) NOTE: \u672c\u4e66\u8ba8\u8bbakernel thread\u7684\u7ae0\u8282\uff1a 3.4.2. Kernel Threads","title":"Kernel threading"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.1-Linux-Versus-Other-Unix-Like-Kernels/#multithreaded#application#support","text":"Most modern operating systems have some kind of support for multithreaded applications that is, user programs that are designed in terms of many relatively independent execution flows that share a large portion of the application data structures. A multithreaded user application could be composed of many lightweight processes (LWP), which are processes that can operate on a common address space, common physical memory pages, common opened files, and so on. Linux defines its own version of lightweight processes, which is different from the types used on other systems such as SVR4 and Solaris. While all the commercial Unix variants of LWP are based on kernel threads , Linux regards lightweight processes as the basic execution context and handles them via the nonstandard clone( ) system call. NOTE: See also Light-weight process \u9605\u8bfb\u4ee5\u4e0b clone( ) system call\u7684\u6587\u6863\u6709\u52a9\u4e8e\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u7684\u542b\u4e49\u3002 NOTE: LWP VS kernel thread? \u4e0a\u4e00\u6bb5\u4e2d\u6240\u63cf\u8ff0\u7684\uff1aLinux kernel threads do not represent the basic execution context abstraction. \u672c\u6bb5\u4e2d\u6240\u63cf\u8ff0\u7684\uff1aLinux regards lightweight processes as the basic execution context and handles them via the nonstandard clone( ) system call. \u663e\u7136\uff0ckernel thread\u4e0d\u662flinux\u7684lightweight process\u3002 \u663e\u7136linux\u7684lightweight process\u662f\u9700\u8981\u7531linux\u7684scheduler\u6765\u8fdb\u884c\u8c03\u5ea6\u7684\uff0c\u90a3kernel thread\u662f\u7531\u8c01\u6765\u8fdb\u884c\u8c03\u5ea6\u5462\uff1f\u4e0b\u9762\u662f\u4e00\u4e9b\u6709\u4ef7\u503c\u7684\u5185\u5bb9\uff1a Are kernel threads processes and daemons? Difference between user-level and kernel-supported threads? Kernel threads made easy","title":"Multithreaded application support"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.1-Linux-Versus-Other-Unix-Like-Kernels/#preemptive#kernel","text":"When compiled with the \"Preemptible Kernel\" option, Linux 2.6 can arbitrarily interleave execution flows while they are in privileged mode . Besides Linux 2.6, a few other conventional, general-purpose Unix systems, such as Solaris and Mach 3.0 , are fully preemptive kernels . SVR4.2/MP introduces some fixed preemption points as a method to get limited preemption capability. NOTE: See also Preemption (computing) Kernel preemption","title":"Preemptive kernel"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.1-Linux-Versus-Other-Unix-Like-Kernels/#multiprocessor#support","text":"Several Unix kernel variants take advantage of multiprocessor systems. Linux 2.6 supports symmetric multiprocessing (SMP ) for different memory models, including NUMA: the system can use multiple processors and each processor can handle any task there is no discrimination among them. Although a few parts of the kernel code are still serialized by means of a single \" big kernel lock ,\" it is fair to say that Linux 2.6 makes a near optimal use of SMP. NOTE: Giant-lock","title":"Multiprocessor support"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.1-Linux-Versus-Other-Unix-Like-Kernels/#filesystem","text":"Linux's standard filesystems come in many flavors. You can use the plain old Ext2 filesystem if you don't have specific needs. You might switch to Ext3 if you want to avoid lengthy filesystem checks after a system crash. If you'll have to deal with many small files, the ReiserFS filesystem is likely to be the best choice. Besides Ext3 and ReiserFS, several other journaling filesystems can be used in Linux; they include IBM AIX's Journaling File System (JFS ) and Silicon Graphics IRIX 's XFS filesystem. Thanks to a powerful object-oriented Virtual File System technology (inspired by Solaris and SVR4), porting a foreign filesystem to Linux is generally easier than porting to other kernels.","title":"Filesystem"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.1-Linux-Versus-Other-Unix-Like-Kernels/#streams","text":"Linux has no analog to the STREAMS I/O subsystem introduced in SVR4, although it is included now in most Unix kernels and has become the preferred interface for writing device drivers, terminal drivers, and network protocols.","title":"STREAMS"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.2-Hardware-Dependency/","text":"1.2. Hardware Dependency Linux tries to maintain a neat distinction between hardware-dependent and hardware-independent source code. To that end, both the arch and the include directories include 23 subdirectories that correspond to the different types of hardware platforms supported. The standard names of the platforms are: arm, arm26 ARM processor-based computers such as PDAs and embedded devices i386 IBM-compatible personal computers based on 80x86 microprocessors ia64 Workstations based on the Intel 64-bit Itanium microprocessor mips Workstations based on MIPS microprocessors, such as those marketed by Silicon Graphics x86_64 Workstations based on the AMD's 64-bit microprocessorssuch Athlon and Opteron and Intel's ia32e/EM64T 64-bit microprocessors","title":"1.2-Hardware-Dependency"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.2-Hardware-Dependency/#12#hardware#dependency","text":"Linux tries to maintain a neat distinction between hardware-dependent and hardware-independent source code. To that end, both the arch and the include directories include 23 subdirectories that correspond to the different types of hardware platforms supported. The standard names of the platforms are: arm, arm26 ARM processor-based computers such as PDAs and embedded devices i386 IBM-compatible personal computers based on 80x86 microprocessors ia64 Workstations based on the Intel 64-bit Itanium microprocessor mips Workstations based on MIPS microprocessors, such as those marketed by Silicon Graphics x86_64 Workstations based on the AMD's 64-bit microprocessorssuch Athlon and Opteron and Intel's ia32e/EM64T 64-bit microprocessors","title":"1.2. Hardware Dependency"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.4-Basic-Operating-System-Concepts/","text":"1.4. Basic Operating System Concepts Each computer system includes a basic set of programs called the operating system . The most important program in the set is called the kernel . It is loaded into RAM when the system boots and contains many critical procedures that are needed for the system to operate. The other programs are less crucial utilities; they can provide a wide variety of interactive experiences for the user as well as doing all the jobs the user bought the computer for but the essential shape and capabilities of the system are determined by the kernel . The kernel provides key facilities to everything else on the system and determines many of the characteristics of higher software. Hence, we often use the term \"operating system\" as a synonym for \"kernel.\" NOTE: See also Operating system Kernel (operating system) The operating system must fulfill two main objectives: Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform. Provide an execution environment to the applications that run on the computer system (the so-called user programs). Some operating systems allow all user programs to directly play with the hardware components (a typical example is MS-DOS ). In contrast, a Unix-like operating system hides all low-level details concerning the physical organization of the computer from applications run by the user. When a program wants to use a hardware resource, it must issue a request to the operating system. The kernel evaluates the request and, if it chooses to grant the resource, interacts with the proper hardware components on behalf of the user program. To enforce this mechanism, modern operating systems rely on the availability of specific hardware features that forbid user programs to directly interact with low-level hardware components or to access arbitrary memory locations. In particular, the hardware introduces at least two different execution modes for the CPU: a nonprivileged mode for user programs and a privileged mode for the kernel. Unix calls these User Mode and Kernel Mode , respectively. NOTE: See also User space CPU modes Protection ring In the rest of this chapter, we introduce the basic concepts that have motivated the design of Unix over the past two decades, as well as Linux and other operating systems. While the concepts are probably familiar to you as a Linux user, these sections try to delve into them a bit more deeply than usual to explain the requirements they place on an operating system kernel. These broad considerations refer to virtually all Unix-like systems. The other chapters of this book will hopefully help you understand the Linux kernel internals. 1.4.1. Multiuser Systems A multiuser system is a computer that is able to concurrently and independently execute several applications belonging to two or more users . Concurrently means that applications can be active at the same time and contend for the various resources such as CPU, memory, hard disks, and so on. Independently means that each application can perform its task with no concern for what the applications of the other users are doing. Switching from one application to another, of course, slows down each of them and affects the response time seen by the users. Many of the complexities of modern operating system kernels, which we will examine in this book, are present to minimize the delays enforced on each program and to provide the user with responses that are as fast as possible. Multiuser operating systems must include several features: An authentication mechanism for verifying the user's identity A protection mechanism against buggy user programs that could block other applications running in the system A protection mechanism against malicious user programs that could interfere with or spy on the activity of other users An accounting mechanism that limits the amount of resource units assigned to each user To ensure safe protection mechanisms , operating systems must use the hardware protection associated with the CPU privileged mode . Otherwise, a user program would be able to directly access the system circuitry and overcome the imposed bounds. Unix is a multiuser system that enforces the hardware protection of system resources . 1.4.2. Users and Groups In a multiuser system , each user has a private space on the machine; typically, he owns some quota of the disk space to store files, receives private mail messages, and so on. The operating system must ensure that the private portion of a user space is visible only to its owner. In particular, it must ensure that no user can exploit a system application for the purpose of violating the private space of another user. All users are identified by a unique number called the User ID , or UID . Usually only a restricted number of persons are allowed to make use of a computer system. When one of these users starts a working session, the system asks for a login name and a password. If the user does not input a valid pair, the system denies access. Because the password is assumed to be secret, the user's privacy is ensured. To selectively share material with other users, each user is a member of one or more user groups , which are identified by a unique number called a user group ID . Each file is associated with exactly one group. For example, access can be set so the user owning the file has read and write privileges, the group has read-only privileges, and other users on the system are denied access to the file. Any Unix-like operating system has a special user called root or superuser . The system administrator must log in as root to handle user accounts, perform maintenance tasks such as system backups and program upgrades, and so on. The root user can do almost everything, because the operating system does not apply the usual protection mechanisms to her. In particular, the root user can access every file on the system and can manipulate every running user program. 1.4.3. Processes NOTE: \u672c\u8282\u4e2d\u7684process\u6307\u7684\u662f\u6807\u51c6 Process All operating systems use one fundamental abstraction: the process . A process can be defined either as \"an instance of a program in execution\" or as the \"execution context\" of a running program. In traditional operating systems, a process executes a single sequence of instructions in an address space ; the address space is the set of memory addresses that the process is allowed to reference. Modern operating systems allow processes with multiple execution flows that is, multiple sequences of instructions executed in the same address space . NOTE: \u6bcf\u4e2aexecution flow\u5bf9\u5e94\u7684\u662f\u4e00\u4e2athread Multiuser systems must enforce an execution environment in which several processes can be active concurrently and contend for system resources, mainly the CPU. Systems that allow concurrent active processes are said to be multiprogramming or multiprocessing . [*] It is important to distinguish programs from processes; several processes can execute the same program concurrently, while the same process can execute several programs sequentially. [*] Some multiprocessing operating systems are not multiuser; an example is Microsoft Windows 98. On uniprocessor systems, just one process can hold the CPU, and hence just one execution flow can progress at a time. In general, the number of CPUs is always restricted, and therefore only a few processes can progress at once. An operating system component called the scheduler chooses the process that can progress. Some operating systems allow only nonpreemptable processes, which means that the scheduler is invoked only when a process voluntarily relinquishes the CPU. But processes of a multiuser system must be preemptable; the operating system tracks how long each process holds the CPU and periodically activates the scheduler. NOTE: See also Single-tasking and multi-tasking Preemption (computing) Unix is a multiprocessing operating system with preemptable processes . Unix-like operating systems adopt a process/kernel model . Each process has the illusion that it's the only process on the machine, and it has exclusive access to the operating system services. Whenever a process makes a system call (i.e., a request to the kernel, see Chapter 10), the hardware changes the privilege mode from User Mode to Kernel Mode , and the process starts the execution of a kernel procedure with a strictly limited purpose. In this way, the operating system acts within the execution context of the process in order to satisfy its request. Whenever the request is fully satisfied, the kernel procedure forces the hardware to return to User Mode and the process continues its execution from the instruction following the system call. NOTE: *process/kernel model*\u4f1a\u57281.6.1. The Process/Kernel Model\u8282\u8fdb\u884c\u8be6\u7ec6\u4ecb\u7ecd\u3002 1.4.4. Kernel Architecture As stated before, most Unix kernels are monolithic: each kernel layer is integrated into the whole kernel program and runs in Kernel Mode on behalf of the current process . In contrast, microkernel operating systems demand a very small set of functions from the kernel, generally including a few synchronization primitives , a simple scheduler , and an interprocess communication mechanism . Several system processes that run on top of the microkernel implement other operating system-layer functions , like memory allocators , device drivers , and system call handlers . Although academic research on operating systems is oriented toward microkernels , such operating systems are generally slower than monolithic ones, because the explicit message passing between the different layers of the operating system has a cost. However, microkernel operating systems might have some theoretical advantages over monolithic ones. Microkernels force the system programmers to adopt a modularized approach, because each operating system layer is a relatively independent program that must interact with the other layers through well-defined and clean software interfaces. Moreover, an existing microkernel operating system can be easily ported to other architectures fairly easily, because all hardware-dependent components are generally encapsulated in the microkernel code. Finally, microkernel operating systems tend to make better use of random access memory (RAM) than monolithic ones, because system processes that aren't implementing needed functionalities might be swapped out or destroyed. To achieve many of the theoretical advantages of microkernels without introducing performance penalties, the Linux kernel offers modules . A module is an object file whose code can be linked to (and unlinked from) the kernel at runtime. The object code usually consists of a set of functions that implements a filesystem, a device driver, or other features at the kernel's upper layer. The module, unlike the external layers of microkernel operating systems, does not run as a specific process. Instead, it is executed in Kernel Mode on behalf of the current process, like any other statically linked kernel function. The main advantages of using modules include: modularized approach Because any module can be linked and unlinked at runtime, system programmers must introduce well-defined software interfaces to access the data structures handled by modules. This makes it easy to develop new modules. Platform independence Even if it may rely on some specific hardware features, a module doesn't depend on a fixed hardware platform. For example, a disk driver module that relies on the SCSI standard works as well on an IBM-compatible PC as it does on Hewlett-Packard's Alpha. Frugal main memory usage A module can be linked to the running kernel when its functionality is required and unlinked when it is no longer useful; this is quite useful for small embedded systems. No performance penalty Once linked in, the object code of a module is equivalent to the object code of the statically linked kernel. Therefore, no explicit message passing is required when the functions of the module are invoked. [*] [*] A small performance penalty occurs when the module is linked and unlinked. However, this penalty can be compared to the penalty caused by the creation and deletion of system processes in microkernel operating systems.","title":"1.4-Basic-Operating-System-Concepts"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.4-Basic-Operating-System-Concepts/#14#basic#operating#system#concepts","text":"Each computer system includes a basic set of programs called the operating system . The most important program in the set is called the kernel . It is loaded into RAM when the system boots and contains many critical procedures that are needed for the system to operate. The other programs are less crucial utilities; they can provide a wide variety of interactive experiences for the user as well as doing all the jobs the user bought the computer for but the essential shape and capabilities of the system are determined by the kernel . The kernel provides key facilities to everything else on the system and determines many of the characteristics of higher software. Hence, we often use the term \"operating system\" as a synonym for \"kernel.\" NOTE: See also Operating system Kernel (operating system) The operating system must fulfill two main objectives: Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform. Provide an execution environment to the applications that run on the computer system (the so-called user programs). Some operating systems allow all user programs to directly play with the hardware components (a typical example is MS-DOS ). In contrast, a Unix-like operating system hides all low-level details concerning the physical organization of the computer from applications run by the user. When a program wants to use a hardware resource, it must issue a request to the operating system. The kernel evaluates the request and, if it chooses to grant the resource, interacts with the proper hardware components on behalf of the user program. To enforce this mechanism, modern operating systems rely on the availability of specific hardware features that forbid user programs to directly interact with low-level hardware components or to access arbitrary memory locations. In particular, the hardware introduces at least two different execution modes for the CPU: a nonprivileged mode for user programs and a privileged mode for the kernel. Unix calls these User Mode and Kernel Mode , respectively. NOTE: See also User space CPU modes Protection ring In the rest of this chapter, we introduce the basic concepts that have motivated the design of Unix over the past two decades, as well as Linux and other operating systems. While the concepts are probably familiar to you as a Linux user, these sections try to delve into them a bit more deeply than usual to explain the requirements they place on an operating system kernel. These broad considerations refer to virtually all Unix-like systems. The other chapters of this book will hopefully help you understand the Linux kernel internals.","title":"1.4. Basic Operating System Concepts"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.4-Basic-Operating-System-Concepts/#141#multiuser#systems","text":"A multiuser system is a computer that is able to concurrently and independently execute several applications belonging to two or more users . Concurrently means that applications can be active at the same time and contend for the various resources such as CPU, memory, hard disks, and so on. Independently means that each application can perform its task with no concern for what the applications of the other users are doing. Switching from one application to another, of course, slows down each of them and affects the response time seen by the users. Many of the complexities of modern operating system kernels, which we will examine in this book, are present to minimize the delays enforced on each program and to provide the user with responses that are as fast as possible. Multiuser operating systems must include several features: An authentication mechanism for verifying the user's identity A protection mechanism against buggy user programs that could block other applications running in the system A protection mechanism against malicious user programs that could interfere with or spy on the activity of other users An accounting mechanism that limits the amount of resource units assigned to each user To ensure safe protection mechanisms , operating systems must use the hardware protection associated with the CPU privileged mode . Otherwise, a user program would be able to directly access the system circuitry and overcome the imposed bounds. Unix is a multiuser system that enforces the hardware protection of system resources .","title":"1.4.1. Multiuser Systems"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.4-Basic-Operating-System-Concepts/#142#users#and#groups","text":"In a multiuser system , each user has a private space on the machine; typically, he owns some quota of the disk space to store files, receives private mail messages, and so on. The operating system must ensure that the private portion of a user space is visible only to its owner. In particular, it must ensure that no user can exploit a system application for the purpose of violating the private space of another user. All users are identified by a unique number called the User ID , or UID . Usually only a restricted number of persons are allowed to make use of a computer system. When one of these users starts a working session, the system asks for a login name and a password. If the user does not input a valid pair, the system denies access. Because the password is assumed to be secret, the user's privacy is ensured. To selectively share material with other users, each user is a member of one or more user groups , which are identified by a unique number called a user group ID . Each file is associated with exactly one group. For example, access can be set so the user owning the file has read and write privileges, the group has read-only privileges, and other users on the system are denied access to the file. Any Unix-like operating system has a special user called root or superuser . The system administrator must log in as root to handle user accounts, perform maintenance tasks such as system backups and program upgrades, and so on. The root user can do almost everything, because the operating system does not apply the usual protection mechanisms to her. In particular, the root user can access every file on the system and can manipulate every running user program.","title":"1.4.2. Users and Groups"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.4-Basic-Operating-System-Concepts/#143#processes","text":"NOTE: \u672c\u8282\u4e2d\u7684process\u6307\u7684\u662f\u6807\u51c6 Process All operating systems use one fundamental abstraction: the process . A process can be defined either as \"an instance of a program in execution\" or as the \"execution context\" of a running program. In traditional operating systems, a process executes a single sequence of instructions in an address space ; the address space is the set of memory addresses that the process is allowed to reference. Modern operating systems allow processes with multiple execution flows that is, multiple sequences of instructions executed in the same address space . NOTE: \u6bcf\u4e2aexecution flow\u5bf9\u5e94\u7684\u662f\u4e00\u4e2athread Multiuser systems must enforce an execution environment in which several processes can be active concurrently and contend for system resources, mainly the CPU. Systems that allow concurrent active processes are said to be multiprogramming or multiprocessing . [*] It is important to distinguish programs from processes; several processes can execute the same program concurrently, while the same process can execute several programs sequentially. [*] Some multiprocessing operating systems are not multiuser; an example is Microsoft Windows 98. On uniprocessor systems, just one process can hold the CPU, and hence just one execution flow can progress at a time. In general, the number of CPUs is always restricted, and therefore only a few processes can progress at once. An operating system component called the scheduler chooses the process that can progress. Some operating systems allow only nonpreemptable processes, which means that the scheduler is invoked only when a process voluntarily relinquishes the CPU. But processes of a multiuser system must be preemptable; the operating system tracks how long each process holds the CPU and periodically activates the scheduler. NOTE: See also Single-tasking and multi-tasking Preemption (computing) Unix is a multiprocessing operating system with preemptable processes . Unix-like operating systems adopt a process/kernel model . Each process has the illusion that it's the only process on the machine, and it has exclusive access to the operating system services. Whenever a process makes a system call (i.e., a request to the kernel, see Chapter 10), the hardware changes the privilege mode from User Mode to Kernel Mode , and the process starts the execution of a kernel procedure with a strictly limited purpose. In this way, the operating system acts within the execution context of the process in order to satisfy its request. Whenever the request is fully satisfied, the kernel procedure forces the hardware to return to User Mode and the process continues its execution from the instruction following the system call. NOTE: *process/kernel model*\u4f1a\u57281.6.1. The Process/Kernel Model\u8282\u8fdb\u884c\u8be6\u7ec6\u4ecb\u7ecd\u3002","title":"1.4.3. Processes"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.4-Basic-Operating-System-Concepts/#144#kernel#architecture","text":"As stated before, most Unix kernels are monolithic: each kernel layer is integrated into the whole kernel program and runs in Kernel Mode on behalf of the current process . In contrast, microkernel operating systems demand a very small set of functions from the kernel, generally including a few synchronization primitives , a simple scheduler , and an interprocess communication mechanism . Several system processes that run on top of the microkernel implement other operating system-layer functions , like memory allocators , device drivers , and system call handlers . Although academic research on operating systems is oriented toward microkernels , such operating systems are generally slower than monolithic ones, because the explicit message passing between the different layers of the operating system has a cost. However, microkernel operating systems might have some theoretical advantages over monolithic ones. Microkernels force the system programmers to adopt a modularized approach, because each operating system layer is a relatively independent program that must interact with the other layers through well-defined and clean software interfaces. Moreover, an existing microkernel operating system can be easily ported to other architectures fairly easily, because all hardware-dependent components are generally encapsulated in the microkernel code. Finally, microkernel operating systems tend to make better use of random access memory (RAM) than monolithic ones, because system processes that aren't implementing needed functionalities might be swapped out or destroyed. To achieve many of the theoretical advantages of microkernels without introducing performance penalties, the Linux kernel offers modules . A module is an object file whose code can be linked to (and unlinked from) the kernel at runtime. The object code usually consists of a set of functions that implements a filesystem, a device driver, or other features at the kernel's upper layer. The module, unlike the external layers of microkernel operating systems, does not run as a specific process. Instead, it is executed in Kernel Mode on behalf of the current process, like any other statically linked kernel function. The main advantages of using modules include: modularized approach Because any module can be linked and unlinked at runtime, system programmers must introduce well-defined software interfaces to access the data structures handled by modules. This makes it easy to develop new modules. Platform independence Even if it may rely on some specific hardware features, a module doesn't depend on a fixed hardware platform. For example, a disk driver module that relies on the SCSI standard works as well on an IBM-compatible PC as it does on Hewlett-Packard's Alpha. Frugal main memory usage A module can be linked to the running kernel when its functionality is required and unlinked when it is no longer useful; this is quite useful for small embedded systems. No performance penalty Once linked in, the object code of a module is equivalent to the object code of the statically linked kernel. Therefore, no explicit message passing is required when the functions of the module are invoked. [*] [*] A small performance penalty occurs when the module is linked and unlinked. However, this penalty can be compared to the penalty caused by the creation and deletion of system processes in microkernel operating systems.","title":"1.4.4. Kernel Architecture"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6-An-Overview-of-Unix-Kernels/","text":"1.6. An Overview of Unix Kernels 1.6. An Overview of Unix Kernels Unix kernels provide an execution environment in which applications may run. Therefore, the kernel must implement a set of services and corresponding interfaces . Applications use those interfaces and do not usually interact directly with hardware resources .","title":"1.6-An-Overview-of-Unix-Kernels"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6-An-Overview-of-Unix-Kernels/#16#an#overview#of#unix#kernels","text":"Unix kernels provide an execution environment in which applications may run. Therefore, the kernel must implement a set of services and corresponding interfaces . Applications use those interfaces and do not usually interact directly with hardware resources .","title":"1.6. An Overview of Unix Kernels"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.1-The-Process-Kernel-Model/","text":"1.6.1. The Process/Kernel Model When a program is executed in User Mode , it cannot directly access the kernel data structures or the kernel programs . When an application executes in Kernel Mode , however, these restrictions no longer apply. Each CPU model provides special instructions to switch from User Mode to Kernel Mode and vice versa. A program usually executes in User Mode and switches to Kernel Mode only when requesting a service provided by the kernel. When the kernel has satisfied the program's request, it puts the program back in User Mode . NOTE: See also User space CPU modes Protection ring Processes are dynamic entities that usually have a limited life span within the system. The task of creating, eliminating, and synchronizing the existing processes is delegated to a group of routines in the kernel. The kernel itself is not a process but a process manager . The process/kernel model assumes that processes that require a kernel service use specific programming constructs called system calls . Each system call sets up the group of parameters that identifies the process request and then executes the hardware-dependent CPU instruction to switch from User Mode to Kernel Mode . NOTE: See also System call Besides user processes, Unix systems include a few privileged processes called kernel threads with the following characteristics: They run in Kernel Mode in the kernel address space. They do not interact with users, and thus do not require terminal devices. They are usually created during system startup and remain alive until the system is shut down. NOTE : What is a Kernel thread? Understanding Kernel Threads On a uniprocessor system, only one process is running at a time, and it may run either in User or in Kernel Mode. If it runs in Kernel Mode , the processor is executing some kernel routine . Figure 1-2 illustrates examples of transitions between User and Kernel Mode. Process 1 in User Mode issues a system call , after which the process switches to Kernel Mode , and the system call is serviced. Process 1 then resumes execution in User Mode until a timer interrupt occurs, and the scheduler is activated in Kernel Mode . A process switch takes place, and Process 2 starts its execution in User Mode until a hardware device raises an interrupt. As a consequence of the interrupt, Process 2 switches to Kernel Mode and services the interrupt. Unix kernels do much more than handle system calls ; in fact, kernel routines can be activated in several ways: A process invokes a system call . The CPU executing the process signals an exception , which is an unusual condition such as an invalid instruction. The kernel handles the exception on behalf of the process that caused it. A peripheral device issues an interrupt signal to the CPU to notify it of an event such as a request for attention, a status change, or the completion of an I/O operation. Each interrupt signal is dealt by a kernel program called an interrupt handler . Because peripheral devices operate asynchronously with respect to the CPU, interrupts occur at unpredictable times. A kernel thread is executed. Because it runs in Kernel Mode, the corresponding program must be considered part of the kernel.","title":"1.6.1-The-Process-Kernel-Model"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.1-The-Process-Kernel-Model/#161#the#processkernel#model","text":"When a program is executed in User Mode , it cannot directly access the kernel data structures or the kernel programs . When an application executes in Kernel Mode , however, these restrictions no longer apply. Each CPU model provides special instructions to switch from User Mode to Kernel Mode and vice versa. A program usually executes in User Mode and switches to Kernel Mode only when requesting a service provided by the kernel. When the kernel has satisfied the program's request, it puts the program back in User Mode . NOTE: See also User space CPU modes Protection ring Processes are dynamic entities that usually have a limited life span within the system. The task of creating, eliminating, and synchronizing the existing processes is delegated to a group of routines in the kernel. The kernel itself is not a process but a process manager . The process/kernel model assumes that processes that require a kernel service use specific programming constructs called system calls . Each system call sets up the group of parameters that identifies the process request and then executes the hardware-dependent CPU instruction to switch from User Mode to Kernel Mode . NOTE: See also System call Besides user processes, Unix systems include a few privileged processes called kernel threads with the following characteristics: They run in Kernel Mode in the kernel address space. They do not interact with users, and thus do not require terminal devices. They are usually created during system startup and remain alive until the system is shut down. NOTE : What is a Kernel thread? Understanding Kernel Threads On a uniprocessor system, only one process is running at a time, and it may run either in User or in Kernel Mode. If it runs in Kernel Mode , the processor is executing some kernel routine . Figure 1-2 illustrates examples of transitions between User and Kernel Mode. Process 1 in User Mode issues a system call , after which the process switches to Kernel Mode , and the system call is serviced. Process 1 then resumes execution in User Mode until a timer interrupt occurs, and the scheduler is activated in Kernel Mode . A process switch takes place, and Process 2 starts its execution in User Mode until a hardware device raises an interrupt. As a consequence of the interrupt, Process 2 switches to Kernel Mode and services the interrupt. Unix kernels do much more than handle system calls ; in fact, kernel routines can be activated in several ways: A process invokes a system call . The CPU executing the process signals an exception , which is an unusual condition such as an invalid instruction. The kernel handles the exception on behalf of the process that caused it. A peripheral device issues an interrupt signal to the CPU to notify it of an event such as a request for attention, a status change, or the completion of an I/O operation. Each interrupt signal is dealt by a kernel program called an interrupt handler . Because peripheral devices operate asynchronously with respect to the CPU, interrupts occur at unpredictable times. A kernel thread is executed. Because it runs in Kernel Mode, the corresponding program must be considered part of the kernel.","title":"1.6.1. The Process/Kernel Model"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.2-Process-Implementation/","text":"1.6.2. Process Implementation To let the kernel manage processes, each process is represented by a process descriptor that includes information about the current state of the process. NOTE: *process descriptor*\u57283.2. Process Descriptor\u4e2d\u8fdb\u884c\u4e13\u95e8\u4ecb\u7ecd \u672c\u8282\u4e2d\u7684process\u6240\u6307\u4e3alightweight process\uff0c\u800c\u4e0d\u662f\u6807\u51c6\u7684 Process (computing) When the kernel stops the execution of a process, it saves the current contents of several processor registers in the process descriptor. These include: The program counter (PC) and stack pointer (SP) registers The general purpose registers The floating point registers The processor control registers (Processor Status Word) containing information about the CPU state The memory management registers used to keep track of the RAM accessed by the process NOTE: See also Program counter Stack register Processor register When the kernel decides to resume executing a process, it uses the proper process descriptor fields to load the CPU registers. Because the stored value of the program counter points to the instruction following the last instruction executed, the process resumes execution at the point where it was stopped. When a process is not executing on the CPU, it is waiting for some event. Unix kernels distinguish many wait states , which are usually implemented by queues of process descriptors ; each (possibly empty) queue corresponds to the set of processes waiting for a specific event. NOTE: \u53c2\u89c13.2.4. How Processes Are Organized","title":"1.6.2-Process-Implementation"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.2-Process-Implementation/#162#process#implementation","text":"To let the kernel manage processes, each process is represented by a process descriptor that includes information about the current state of the process. NOTE: *process descriptor*\u57283.2. Process Descriptor\u4e2d\u8fdb\u884c\u4e13\u95e8\u4ecb\u7ecd \u672c\u8282\u4e2d\u7684process\u6240\u6307\u4e3alightweight process\uff0c\u800c\u4e0d\u662f\u6807\u51c6\u7684 Process (computing) When the kernel stops the execution of a process, it saves the current contents of several processor registers in the process descriptor. These include: The program counter (PC) and stack pointer (SP) registers The general purpose registers The floating point registers The processor control registers (Processor Status Word) containing information about the CPU state The memory management registers used to keep track of the RAM accessed by the process NOTE: See also Program counter Stack register Processor register When the kernel decides to resume executing a process, it uses the proper process descriptor fields to load the CPU registers. Because the stored value of the program counter points to the instruction following the last instruction executed, the process resumes execution at the point where it was stopped. When a process is not executing on the CPU, it is waiting for some event. Unix kernels distinguish many wait states , which are usually implemented by queues of process descriptors ; each (possibly empty) queue corresponds to the set of processes waiting for a specific event. NOTE: \u53c2\u89c13.2.4. How Processes Are Organized","title":"1.6.2. Process Implementation"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.3-Reentrant-Kernels/","text":"1.6.3. Reentrant Kernels NOTE: \u4ece\u4e00\u4e2a\u5185\u6838\u8bbe\u8ba1\u8005\u7684\u89d2\u5ea6\u6765\u601d\u8003\u672c\u8282\u7684\u5185\u5bb9\uff0c\u5c06\u66f4\u52a0\u5bb9\u6613\u638c\u63e1\u4f5c\u8005\u6240\u8981\u4f20\u8fbe\u7684\u601d\u60f3\u3002\u5185\u6838\u7684\u8bbe\u8ba1\u8005\u4f1a\u8ffd\u6c42\u7cfb\u7edf\u80fd\u591f\u5feb\u901f\u5730\u54cd\u5e94\u7528\u6237\u7684\u8bf7\u6c42\uff0c\u7cfb\u7edf\u80fd\u591f\u9ad8\u6548\u5730\u8fd0\u884c\uff0c\u7cfb\u7edf\u9700\u8981\u5c3d\u53ef\u80fd\u7684\u538b\u7f29CPU\u7684\u7a7a\u95f2\u65f6\u95f4\uff0c\u8ba9CPU\u66f4\u591a\u5730\u8fdb\u884c\u8fd0\u8f6c\u3002\u6240\u4ee5\uff0c\u5b83\u5c31\u9700\u8981\u5728\u67d0\u4e2a\u8bf7\u6c42\u6682\u65f6\u65e0\u6cd5\u5b8c\u6210\u7684\u60c5\u51b5\u4e0b\uff0c\u5c06\u5b83\u6302\u8d77\u5e76\u8f6c\u5411\u53e6\u5916\u4e00\u4e2a\u8bf7\u6c42\uff1b\u5f53\u8be5\u8bf7\u6c42\u7684\u6267\u884c\u6761\u4ef6\u6ee1\u8db3\u7684\u65f6\u5019\u518d\u5c06\u5b83\u91cd\u542f\uff1b\u53e6\u5916\uff0ckernel\u8fd8\u9700\u8981\u5904\u7406\u65e0\u6cd5\u9884\u6d4b\u4f55\u65f6\u4f1a\u51fa\u73b0\u7684\u5404\u79cdinterrupt\u548cexception\uff0c\u6302\u8d77\u5f53\u524d\u7684\u8bf7\u6c42\u8f6c\u53bb\u6267\u884c\u76f8\u5e94\u7684handler\u3002\u8fd9\u79cd\u80fd\u529b\u5c31\u662f\u672c\u8282\u6240\u8ff0\u7684*reentrant*\u3002\u663e\u7136\u8fd9\u79cd\u8bbe\u8ba1\u80fd\u591f\u6700\u5927\u7a0b\u5ea6\u5730\u4fdd\u8bc1\u7cfb\u7edf\u7684\u9ad8\u6548\u3002\u8fd9\u79cd\u8bbe\u8ba1\u4e5f\u4e0d\u53ef\u907f\u514d\u5730\u5bfc\u81f4\u7cfb\u7edf\u7684\u590d\u6742\uff0c\u6b63\u5982\u5728\u672c\u8282\u540e\u9762\u6240\u8ff0\u7684\uff0c \u7cfb\u7edf\u662f\u5728\u591a\u4e2a*kernel control path*\u4e2d\u4ea4\u9519\u8fd0\u884c\u7684\uff0c\u8fd9\u79cd\u8bbe\u8ba1\u4f1a\u6d3e\u751f\u51fa\u4e00\u7cfb\u5217\u7684\u95ee\u9898\uff0c\u6bd4\u5982\u5c06\u57281.6.5. Synchronization and Critical Regions\u4e2d\u4ecb\u7ecd\u7684race condition\uff0c\u6240\u4ee5\u5b83kernel\u7684\u5b9e\u73b0\u63d0\u51fa\u4e86\u66f4\u9ad8\u7684\u8981\u6c42\u3002\u5f53\u7136\u53ef\u4ee5\u9884\u671f\u7684\u662f\uff0c\u7cfb\u7edf\u662f\u5728\u8fd9\u6837\u7684\u4ea4\u9519\u4e2d\u4e0d\u65ad\u5411\u524d\u8fdb\u7684\u3002 \u5982\u4f55\u6765\u5b9e\u73b0reentrant kernel\u5462\uff1f\u8fd9\u662f\u4e00\u4e2a\u9700\u8981\u7cfb\u7edf\u5730\u8fdb\u884c\u8bbe\u8ba1\u624d\u80fd\u591f\u89e3\u51b3\u7684\u95ee\u9898\uff0c\u4e0b\u9762\u603b\u7ed3\u4e86\u548c\u8fd9\u4e2a\u95ee\u9898\u76f8\u5173\u7684\u4e00\u4e9b\u7ae0\u8282\uff1a 1.6.4. Process Address Space Kernel control path refers to its own private kernel stack. 1.6.5. Synchronization and Critical Regions \u63cf\u8ff0\u4e86kernel control path\u7684Synchronization \u4e3a\u4e86\u4fbf\u4e8e\u63cf\u8ff0reentrant kernel\u7684\u5b9e\u73b0\uff0c\u672c\u6bb5\u4e2d\u4f5c\u8005\u63d0\u51fa\u4e86*kernel control path*\u7684\u6982\u5ff5\uff0c\u8fd9\u4e2a\u6982\u5ff5\u8868\u793a\u4e86kernel\u6240\u6709\u7684\u53ef\u80fd\u7684\u6d3b\u52a8\uff0c\u4e3b\u8981\u5305\u62ec\u5982\u4e0b\u4e24\u79cd\u60c5\u51b5\uff1a system call interrupt and exception \u4e5f\u5c31\u662f\u8bf4\uff1a \u5f53process\u5411kernel\u8bf7\u6c42\u4e00\u4e2asystem call\uff0c\u6b64\u65f6kernel\u4e2d\u5c31\u6267\u884c\u6b64system call\uff0c\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u7406\u89e3\u7684\u8bdd\uff0c\u5219\u662fkernel\u521b\u5efa\u4e86\u4e00\u4e2a\u6267\u884c\u8fd9\u4e2asystem call\u7684kernel control path\uff1b \u5f53\u4ea7\u751finterrupt\u6216exception\uff0c\u6b64\u65f6kernel\u8f6c\u53bb\u6267\u884c\u5b83\u4eec\u5bf9\u5e94\u7684handler\uff0c\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u7406\u89e3\u7684\u8bdd\uff0c\u53ef\u4ee5\u8ba4\u4e3akernel\u521b\u5efa\u4e86\u4e00\u4e2a\u6267\u884c\u8fd9\u4e2ahandler\u7684kernel control path\uff1b \u4e3a\u4ec0\u4e48\u8981\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u63cf\u8ff0\u5462\uff1f\u56e0\u4e3a\u6211\u4eec\u77e5\u9053\uff0coperating system\u7684kernel\u7684\u6267\u884c\u60c5\u51b5\u662f\u975e\u5e38\u590d\u6742\u7684\uff0c\u5b83\u9700\u8981\u540c\u65f6\u5904\u7406\u975e\u5e38\u591a\u7684\u4e8b\u60c5\uff0c\u6bd4\u5982process\u8bf7\u6c42\u7684system call\uff0c\u5728\u6b64\u8fc7\u7a0b\u4e2d\u662f\u4f1a\u4f34\u968f\u4e2d\u968f\u65f6\u53ef\u80fd\u53d1\u751f\u7684interrupt\u548cexception\u7684\u3002\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u94fa\u57ab\u4e86\uff0ckernel\u4e3a\u4e86\u4fdd\u6301\u9ad8\u6548\uff0c\u53ef\u80fd\u9700\u8981\u6302\u8d77\u6b63\u5728\u6267\u884c\u7684\u6d41\u7a0b\u8f6c\u53bb\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u6d41\u7a0b\uff0c\u800c\u540e\u5728\u91cd\u542f\u4e4b\u524d\u6302\u8d77\u7684\u6d41\u7a0b\u3002\u6b64\u5904\u6240\u8c13\u7684\u6d41\u7a0b\uff0c\u6211\u4eec\u4f7f\u7528\u66f4\u52a0\u4e13\u4e1a\u7684\u672f\u8bed\u5c31\u662fkernel control path\u3002\u663e\u7136\u4e0efunction\u76f8\u6bd4\uff0ckernel control path\u8574\u542b\u7740\u66f4\u52a0\u4e30\u5bcc\u7684\uff0c\u66f4\u52a0\u7b26\u5408kernel\u8c03\u5ea6\u60c5\u51b5\u7684\u5185\u6db5\uff0c\u6bd4\u5982\u5b83\u80fd\u591f\u8868\u793akernel\u7684suspend\uff0cresume\uff0c\u80fd\u591f\u8868\u793a\u591a\u4e2acontrol path\u7684interleave\u3002\u8fd9\u79cd\u901a\u8fc7\u521b\u9020\u65b0\u7684\u6982\u5ff5\u6765\u8bf4\u8868\u8ff0\u66f4\u52a0\u4fbf\u5229\u7684\u505a\u6cd5\u662f\u5728\u5404\u79cd\u5b66\u79d1\u975e\u5e38\u666e\u904d\u7684\u3002 \u5173\u4e8e\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0ckernel control path\u7684\u4e00\u4e9b\u6267\u884c\u7ec6\u8282\uff0c\u6bd4\u5982kernel control path\u548cprocess\u4e4b\u95f4\u7684\u5173\u8054\u662f\u672c\u4e66\u4e2d\u4f1a\u4e00\u76f4\u5f3a\u8c03\u7684\u5185\u5bb9\uff0c\u9700\u8981\u8fdb\u884c\u4e00\u4e0b\u603b\u7ed3\uff0c\u5176\u4e2d\u6700\u6700\u5178\u578b\u7684\u5c31\u662fkernel control path runs on behalf of process\u3002\u4e3a\u4e86\u4eca\u540e\u4fbf\u4e8e\u5feb\u901f\u5730\u68c0\u7d22\u5230\u8fd9\u4e9b\u5185\u5bb9\uff0c\u73b0\u5c06\u672c\u4e66\u4e2d\u6240\u6709\u7684\u4e0e\u6b64\u76f8\u5173\u5185\u5bb9\u7684\u4f4d\u7f6e\u5168\u90e8\u90fd\u6574\u7406\u5230\u8fd9\u91cc\uff1a chapter 1.6.3. Reentrant Kernels \u672c\u8282\u7684\u540e\u534a\u90e8\u5206\u5bf9kernel control path\u7684\u4e00\u4e9b\u53ef\u80fd\u60c5\u51b5\u8fdb\u884c\u4e86\u679a\u4e3e\uff0c\u5e76\u63cf\u8ff0\u4e86\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0ckernel control path\u548cprocess\u4e4b\u95f4\u7684\u5173\u7cfb Chapter 4. Interrupts and Exceptions \u4e3b\u8981\u63cf\u8ff0\u4e86Interrupts and Exceptions\u89e6\u53d1\u7684kernel control path\u7684\u6267\u884c\u60c5\u51b5\u3002\u5e76\u4e14\u5176\u4e2d\u8fd8\u5bf9\u6bd4\u4e86interrupt \u89e6\u53d1\u7684kernel control path\u548csystem call\u89e6\u53d1\u7684kernel control path\u4e4b\u95f4\u7684\u5dee\u5f02\u7b49\u5185\u5bb9\u3002 \u4e0b\u9762\u662f\u4e00\u4e9b\u8865\u5145\u5185\u5bb9\uff1a Kernel Control Path Definition All Unix kernels are reentrant . This means that several processes\uff08\u6307\u7684\u662flightweight process\uff09 may be executing in Kernel Mode at the same time. Of course, on uniprocessor systems, only one process can progress, but many can be blocked in Kernel Mode when waiting for the CPU or the completion of some I/O operation. For instance, after issuing a read to a disk on behalf of a process, the kernel lets the disk controller handle it and resumes executing other processes. An interrupt notifies the kernel when the device has satisfied the read, so the former process can resume the execution. One way to provide reentrancy is to write functions so that they modify only local variables and do not alter global data structures . Such functions are called reentrant functions . But a reentrant kernel is not limited only to such reentrant functions (although that is how some real-time kernels are implemented). Instead, the kernel can include nonreentrant functions and use locking mechanisms to ensure that only one process can execute a nonreentrant function at a time. If a hardware interrupt occurs, a reentrant kernel is able to suspend the current running process even if that process is in Kernel Mode . This capability is very important, because it improves the throughput of the device controllers that issue interrupts. Once a device has issued an interrupt, it waits until the CPU acknowledges it. If the kernel is able to answer quickly, the device controller will be able to perform other tasks while the CPU handles the interrupt. Now let's look at kernel reentrancy and its impact on the organization of the kernel. A kernel control path denotes the sequence of instructions executed by the kernel to handle a system call , an exception , or an interrupt . In the simplest case, the CPU executes a kernel control path sequentially from the first instruction to the last. When one of the following events occurs, however, the CPU interleaves the kernel control paths : A process executing in User Mode invokes a system call , and the corresponding kernel control path verifies that the request cannot be satisfied immediately; it then invokes the scheduler to select a new process to run. As a result, a process switch occurs. The first kernel control path is left unfinished, and the CPU resumes the execution of some other kernel control path . In this case, the two control paths are executed on behalf of two different processes. The CPU detects an exception for example, access to a page not present in RAM while running a kernel control path . The first control path is suspended, and the CPU starts the execution of a suitable procedure. In our example, this type of procedure can allocate a new page for the process and read its contents from disk. When the procedure terminates, the first control path can be resumed. In this case, the two control paths are executed on behalf of the same process. A hardware interrupt occurs while the CPU is running a kernel control path with the interrupts enabled. The first kernel control path is left unfinished, and the CPU starts processing another kernel control path to handle the interrupt. The first kernel control path resumes when the interrupt handler terminates. In this case, the two kernel control paths run in the execution context of the same process, and the total system CPU time is accounted to it. However, the interrupt handler doesn't necessarily operate on behalf of the process. An interrupt occurs while the CPU is running with kernel preemption enabled, and a higher priority process is runnable. In this case, the first kernel control path is left unfinished, and the CPU resumes executing another kernel control path on behalf of the higher priority process. This occurs only if the kernel has been compiled with kernel preemption support. Figure 1-3 illustrates a few examples of noninterleaved and interleaved kernel control paths. Three different CPU states are considered: Running a process in User Mode ( User ) Running an exception or a system call handler ( Excp ) Running an interrupt handler ( Intr )","title":"1.6.3-Reentrant-Kernels"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.3-Reentrant-Kernels/#163#reentrant#kernels","text":"NOTE: \u4ece\u4e00\u4e2a\u5185\u6838\u8bbe\u8ba1\u8005\u7684\u89d2\u5ea6\u6765\u601d\u8003\u672c\u8282\u7684\u5185\u5bb9\uff0c\u5c06\u66f4\u52a0\u5bb9\u6613\u638c\u63e1\u4f5c\u8005\u6240\u8981\u4f20\u8fbe\u7684\u601d\u60f3\u3002\u5185\u6838\u7684\u8bbe\u8ba1\u8005\u4f1a\u8ffd\u6c42\u7cfb\u7edf\u80fd\u591f\u5feb\u901f\u5730\u54cd\u5e94\u7528\u6237\u7684\u8bf7\u6c42\uff0c\u7cfb\u7edf\u80fd\u591f\u9ad8\u6548\u5730\u8fd0\u884c\uff0c\u7cfb\u7edf\u9700\u8981\u5c3d\u53ef\u80fd\u7684\u538b\u7f29CPU\u7684\u7a7a\u95f2\u65f6\u95f4\uff0c\u8ba9CPU\u66f4\u591a\u5730\u8fdb\u884c\u8fd0\u8f6c\u3002\u6240\u4ee5\uff0c\u5b83\u5c31\u9700\u8981\u5728\u67d0\u4e2a\u8bf7\u6c42\u6682\u65f6\u65e0\u6cd5\u5b8c\u6210\u7684\u60c5\u51b5\u4e0b\uff0c\u5c06\u5b83\u6302\u8d77\u5e76\u8f6c\u5411\u53e6\u5916\u4e00\u4e2a\u8bf7\u6c42\uff1b\u5f53\u8be5\u8bf7\u6c42\u7684\u6267\u884c\u6761\u4ef6\u6ee1\u8db3\u7684\u65f6\u5019\u518d\u5c06\u5b83\u91cd\u542f\uff1b\u53e6\u5916\uff0ckernel\u8fd8\u9700\u8981\u5904\u7406\u65e0\u6cd5\u9884\u6d4b\u4f55\u65f6\u4f1a\u51fa\u73b0\u7684\u5404\u79cdinterrupt\u548cexception\uff0c\u6302\u8d77\u5f53\u524d\u7684\u8bf7\u6c42\u8f6c\u53bb\u6267\u884c\u76f8\u5e94\u7684handler\u3002\u8fd9\u79cd\u80fd\u529b\u5c31\u662f\u672c\u8282\u6240\u8ff0\u7684*reentrant*\u3002\u663e\u7136\u8fd9\u79cd\u8bbe\u8ba1\u80fd\u591f\u6700\u5927\u7a0b\u5ea6\u5730\u4fdd\u8bc1\u7cfb\u7edf\u7684\u9ad8\u6548\u3002\u8fd9\u79cd\u8bbe\u8ba1\u4e5f\u4e0d\u53ef\u907f\u514d\u5730\u5bfc\u81f4\u7cfb\u7edf\u7684\u590d\u6742\uff0c\u6b63\u5982\u5728\u672c\u8282\u540e\u9762\u6240\u8ff0\u7684\uff0c \u7cfb\u7edf\u662f\u5728\u591a\u4e2a*kernel control path*\u4e2d\u4ea4\u9519\u8fd0\u884c\u7684\uff0c\u8fd9\u79cd\u8bbe\u8ba1\u4f1a\u6d3e\u751f\u51fa\u4e00\u7cfb\u5217\u7684\u95ee\u9898\uff0c\u6bd4\u5982\u5c06\u57281.6.5. Synchronization and Critical Regions\u4e2d\u4ecb\u7ecd\u7684race condition\uff0c\u6240\u4ee5\u5b83kernel\u7684\u5b9e\u73b0\u63d0\u51fa\u4e86\u66f4\u9ad8\u7684\u8981\u6c42\u3002\u5f53\u7136\u53ef\u4ee5\u9884\u671f\u7684\u662f\uff0c\u7cfb\u7edf\u662f\u5728\u8fd9\u6837\u7684\u4ea4\u9519\u4e2d\u4e0d\u65ad\u5411\u524d\u8fdb\u7684\u3002 \u5982\u4f55\u6765\u5b9e\u73b0reentrant kernel\u5462\uff1f\u8fd9\u662f\u4e00\u4e2a\u9700\u8981\u7cfb\u7edf\u5730\u8fdb\u884c\u8bbe\u8ba1\u624d\u80fd\u591f\u89e3\u51b3\u7684\u95ee\u9898\uff0c\u4e0b\u9762\u603b\u7ed3\u4e86\u548c\u8fd9\u4e2a\u95ee\u9898\u76f8\u5173\u7684\u4e00\u4e9b\u7ae0\u8282\uff1a 1.6.4. Process Address Space Kernel control path refers to its own private kernel stack. 1.6.5. Synchronization and Critical Regions \u63cf\u8ff0\u4e86kernel control path\u7684Synchronization \u4e3a\u4e86\u4fbf\u4e8e\u63cf\u8ff0reentrant kernel\u7684\u5b9e\u73b0\uff0c\u672c\u6bb5\u4e2d\u4f5c\u8005\u63d0\u51fa\u4e86*kernel control path*\u7684\u6982\u5ff5\uff0c\u8fd9\u4e2a\u6982\u5ff5\u8868\u793a\u4e86kernel\u6240\u6709\u7684\u53ef\u80fd\u7684\u6d3b\u52a8\uff0c\u4e3b\u8981\u5305\u62ec\u5982\u4e0b\u4e24\u79cd\u60c5\u51b5\uff1a system call interrupt and exception \u4e5f\u5c31\u662f\u8bf4\uff1a \u5f53process\u5411kernel\u8bf7\u6c42\u4e00\u4e2asystem call\uff0c\u6b64\u65f6kernel\u4e2d\u5c31\u6267\u884c\u6b64system call\uff0c\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u7406\u89e3\u7684\u8bdd\uff0c\u5219\u662fkernel\u521b\u5efa\u4e86\u4e00\u4e2a\u6267\u884c\u8fd9\u4e2asystem call\u7684kernel control path\uff1b \u5f53\u4ea7\u751finterrupt\u6216exception\uff0c\u6b64\u65f6kernel\u8f6c\u53bb\u6267\u884c\u5b83\u4eec\u5bf9\u5e94\u7684handler\uff0c\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u7406\u89e3\u7684\u8bdd\uff0c\u53ef\u4ee5\u8ba4\u4e3akernel\u521b\u5efa\u4e86\u4e00\u4e2a\u6267\u884c\u8fd9\u4e2ahandler\u7684kernel control path\uff1b \u4e3a\u4ec0\u4e48\u8981\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u63cf\u8ff0\u5462\uff1f\u56e0\u4e3a\u6211\u4eec\u77e5\u9053\uff0coperating system\u7684kernel\u7684\u6267\u884c\u60c5\u51b5\u662f\u975e\u5e38\u590d\u6742\u7684\uff0c\u5b83\u9700\u8981\u540c\u65f6\u5904\u7406\u975e\u5e38\u591a\u7684\u4e8b\u60c5\uff0c\u6bd4\u5982process\u8bf7\u6c42\u7684system call\uff0c\u5728\u6b64\u8fc7\u7a0b\u4e2d\u662f\u4f1a\u4f34\u968f\u4e2d\u968f\u65f6\u53ef\u80fd\u53d1\u751f\u7684interrupt\u548cexception\u7684\u3002\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u94fa\u57ab\u4e86\uff0ckernel\u4e3a\u4e86\u4fdd\u6301\u9ad8\u6548\uff0c\u53ef\u80fd\u9700\u8981\u6302\u8d77\u6b63\u5728\u6267\u884c\u7684\u6d41\u7a0b\u8f6c\u53bb\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u6d41\u7a0b\uff0c\u800c\u540e\u5728\u91cd\u542f\u4e4b\u524d\u6302\u8d77\u7684\u6d41\u7a0b\u3002\u6b64\u5904\u6240\u8c13\u7684\u6d41\u7a0b\uff0c\u6211\u4eec\u4f7f\u7528\u66f4\u52a0\u4e13\u4e1a\u7684\u672f\u8bed\u5c31\u662fkernel control path\u3002\u663e\u7136\u4e0efunction\u76f8\u6bd4\uff0ckernel control path\u8574\u542b\u7740\u66f4\u52a0\u4e30\u5bcc\u7684\uff0c\u66f4\u52a0\u7b26\u5408kernel\u8c03\u5ea6\u60c5\u51b5\u7684\u5185\u6db5\uff0c\u6bd4\u5982\u5b83\u80fd\u591f\u8868\u793akernel\u7684suspend\uff0cresume\uff0c\u80fd\u591f\u8868\u793a\u591a\u4e2acontrol path\u7684interleave\u3002\u8fd9\u79cd\u901a\u8fc7\u521b\u9020\u65b0\u7684\u6982\u5ff5\u6765\u8bf4\u8868\u8ff0\u66f4\u52a0\u4fbf\u5229\u7684\u505a\u6cd5\u662f\u5728\u5404\u79cd\u5b66\u79d1\u975e\u5e38\u666e\u904d\u7684\u3002 \u5173\u4e8e\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0ckernel control path\u7684\u4e00\u4e9b\u6267\u884c\u7ec6\u8282\uff0c\u6bd4\u5982kernel control path\u548cprocess\u4e4b\u95f4\u7684\u5173\u8054\u662f\u672c\u4e66\u4e2d\u4f1a\u4e00\u76f4\u5f3a\u8c03\u7684\u5185\u5bb9\uff0c\u9700\u8981\u8fdb\u884c\u4e00\u4e0b\u603b\u7ed3\uff0c\u5176\u4e2d\u6700\u6700\u5178\u578b\u7684\u5c31\u662fkernel control path runs on behalf of process\u3002\u4e3a\u4e86\u4eca\u540e\u4fbf\u4e8e\u5feb\u901f\u5730\u68c0\u7d22\u5230\u8fd9\u4e9b\u5185\u5bb9\uff0c\u73b0\u5c06\u672c\u4e66\u4e2d\u6240\u6709\u7684\u4e0e\u6b64\u76f8\u5173\u5185\u5bb9\u7684\u4f4d\u7f6e\u5168\u90e8\u90fd\u6574\u7406\u5230\u8fd9\u91cc\uff1a chapter 1.6.3. Reentrant Kernels \u672c\u8282\u7684\u540e\u534a\u90e8\u5206\u5bf9kernel control path\u7684\u4e00\u4e9b\u53ef\u80fd\u60c5\u51b5\u8fdb\u884c\u4e86\u679a\u4e3e\uff0c\u5e76\u63cf\u8ff0\u4e86\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0ckernel control path\u548cprocess\u4e4b\u95f4\u7684\u5173\u7cfb Chapter 4. Interrupts and Exceptions \u4e3b\u8981\u63cf\u8ff0\u4e86Interrupts and Exceptions\u89e6\u53d1\u7684kernel control path\u7684\u6267\u884c\u60c5\u51b5\u3002\u5e76\u4e14\u5176\u4e2d\u8fd8\u5bf9\u6bd4\u4e86interrupt \u89e6\u53d1\u7684kernel control path\u548csystem call\u89e6\u53d1\u7684kernel control path\u4e4b\u95f4\u7684\u5dee\u5f02\u7b49\u5185\u5bb9\u3002 \u4e0b\u9762\u662f\u4e00\u4e9b\u8865\u5145\u5185\u5bb9\uff1a Kernel Control Path Definition All Unix kernels are reentrant . This means that several processes\uff08\u6307\u7684\u662flightweight process\uff09 may be executing in Kernel Mode at the same time. Of course, on uniprocessor systems, only one process can progress, but many can be blocked in Kernel Mode when waiting for the CPU or the completion of some I/O operation. For instance, after issuing a read to a disk on behalf of a process, the kernel lets the disk controller handle it and resumes executing other processes. An interrupt notifies the kernel when the device has satisfied the read, so the former process can resume the execution. One way to provide reentrancy is to write functions so that they modify only local variables and do not alter global data structures . Such functions are called reentrant functions . But a reentrant kernel is not limited only to such reentrant functions (although that is how some real-time kernels are implemented). Instead, the kernel can include nonreentrant functions and use locking mechanisms to ensure that only one process can execute a nonreentrant function at a time. If a hardware interrupt occurs, a reentrant kernel is able to suspend the current running process even if that process is in Kernel Mode . This capability is very important, because it improves the throughput of the device controllers that issue interrupts. Once a device has issued an interrupt, it waits until the CPU acknowledges it. If the kernel is able to answer quickly, the device controller will be able to perform other tasks while the CPU handles the interrupt. Now let's look at kernel reentrancy and its impact on the organization of the kernel. A kernel control path denotes the sequence of instructions executed by the kernel to handle a system call , an exception , or an interrupt . In the simplest case, the CPU executes a kernel control path sequentially from the first instruction to the last. When one of the following events occurs, however, the CPU interleaves the kernel control paths : A process executing in User Mode invokes a system call , and the corresponding kernel control path verifies that the request cannot be satisfied immediately; it then invokes the scheduler to select a new process to run. As a result, a process switch occurs. The first kernel control path is left unfinished, and the CPU resumes the execution of some other kernel control path . In this case, the two control paths are executed on behalf of two different processes. The CPU detects an exception for example, access to a page not present in RAM while running a kernel control path . The first control path is suspended, and the CPU starts the execution of a suitable procedure. In our example, this type of procedure can allocate a new page for the process and read its contents from disk. When the procedure terminates, the first control path can be resumed. In this case, the two control paths are executed on behalf of the same process. A hardware interrupt occurs while the CPU is running a kernel control path with the interrupts enabled. The first kernel control path is left unfinished, and the CPU starts processing another kernel control path to handle the interrupt. The first kernel control path resumes when the interrupt handler terminates. In this case, the two kernel control paths run in the execution context of the same process, and the total system CPU time is accounted to it. However, the interrupt handler doesn't necessarily operate on behalf of the process. An interrupt occurs while the CPU is running with kernel preemption enabled, and a higher priority process is runnable. In this case, the first kernel control path is left unfinished, and the CPU resumes executing another kernel control path on behalf of the higher priority process. This occurs only if the kernel has been compiled with kernel preemption support. Figure 1-3 illustrates a few examples of noninterleaved and interleaved kernel control paths. Three different CPU states are considered: Running a process in User Mode ( User ) Running an exception or a system call handler ( Excp ) Running an interrupt handler ( Intr )","title":"1.6.3. Reentrant Kernels"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.4-Process-Address-Space/","text":"1.6.4. Process Address Space Each process runs in its private address space. A process running in User Mode refers to private stack, data, and code areas. When running in Kernel Mode, the process addresses the kernel data and code areas and uses another private stack. NOTE: \u4e0d\u540c\u7684mode\uff0c\u4f7f\u7528\u4e0d\u540c\u7684address space Because the kernel is reentrant, several kernel control paths each related to a different process may be executed in turn. In this case, each kernel control path refers to its own private kernel stack . NOTE : \u5173\u4e8ekernel stack\u53c2\u89c13.2.2.1. Process descriptors handling While it appears to each process that it has access to a private address space , there are times when part of the address space is shared among processes. In some cases, this sharing is explicitly requested by processes; in others, it is done automatically by the kernel to reduce memory usage. If the same program, say an editor, is needed simultaneously by several users, the program is loaded into memory only once, and its instructions can be shared by all of the users who need it. Its data, of course, must not be shared, because each user will have separate data. This kind of shared address space is done automatically by the kernel to save memory. Processes also can share parts of their address space as a kind of interprocess communication , using the \"shared memory\" technique introduced in System V and supported by Linux. Finally, Linux supports the mmap( ) system call, which allows part of a file or the information stored on a block device to be mapped into a part of a process address space. Memory mapping can provide an alternative to normal reads and writes for transferring data. If the same file is shared by several processes, its memory mapping is included in the address space of each of the processes that share it.","title":"1.6.4-Process-Address-Space"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.4-Process-Address-Space/#164#process#address#space","text":"Each process runs in its private address space. A process running in User Mode refers to private stack, data, and code areas. When running in Kernel Mode, the process addresses the kernel data and code areas and uses another private stack. NOTE: \u4e0d\u540c\u7684mode\uff0c\u4f7f\u7528\u4e0d\u540c\u7684address space Because the kernel is reentrant, several kernel control paths each related to a different process may be executed in turn. In this case, each kernel control path refers to its own private kernel stack . NOTE : \u5173\u4e8ekernel stack\u53c2\u89c13.2.2.1. Process descriptors handling While it appears to each process that it has access to a private address space , there are times when part of the address space is shared among processes. In some cases, this sharing is explicitly requested by processes; in others, it is done automatically by the kernel to reduce memory usage. If the same program, say an editor, is needed simultaneously by several users, the program is loaded into memory only once, and its instructions can be shared by all of the users who need it. Its data, of course, must not be shared, because each user will have separate data. This kind of shared address space is done automatically by the kernel to save memory. Processes also can share parts of their address space as a kind of interprocess communication , using the \"shared memory\" technique introduced in System V and supported by Linux. Finally, Linux supports the mmap( ) system call, which allows part of a file or the information stored on a block device to be mapped into a part of a process address space. Memory mapping can provide an alternative to normal reads and writes for transferring data. If the same file is shared by several processes, its memory mapping is included in the address space of each of the processes that share it.","title":"1.6.4. Process Address Space"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.5-Synchronization-and-Critical-Regions/","text":"1.6.5. Synchronization and Critical Regions NOTE: \u867d\u7136\u672c\u8282\u6240\u63cf\u8ff0\u7684\u662fkernel\u7684synchronization\uff0c\u4f46\u662f\u5176\u4e2d\u6240\u63cf\u8ff0\u7684\u65b9\u6cd5\u3001\u601d\u8def\u53ef\u4ee5\u5e7f\u6cdb\u5e94\u7528\u4e8e\u5176\u4ed6\u9886\u57df\u3002 Implementing a reentrant kernel requires the use of synchronization . If a kernel control path is suspended while acting on a kernel data structure, no other kernel control path should be allowed to act on the same data structure unless it has been reset to a consistent state . Otherwise, the interaction of the two control paths could corrupt the stored information. For example, suppose a global variable V contains the number of available items of some system resource. The first kernel control path, A , reads the variable and determines that there is just one available item. At this point, another kernel control path, B , is activated and reads the same variable, which still contains the value 1 . Thus, B decreases V and starts using the resource item. Then A resumes the execution; because it has already read the value of V , it assumes that it can decrease V and take the resource item, which B already uses. As a final result, V contains -1, and two kernel control paths use the same resource item with potentially disastrous effects. When the outcome of a computation depends on how two or more processes are scheduled, the code is incorrect. We say that there is a race condition . In general, safe access to a global variable is ensured by using atomic operations . In the previous example, data corruption is not possible if the two control paths read and decrease V with a single, noninterruptible operation . However, kernels contain many data structures that cannot be accessed with a single operation. For example, it usually isn't possible to remove an element from a linked list with a single operation, because the kernel needs to access at least two pointers at once. Any section of code that should be finished by each process that begins it before another process can enter it is called a critical region . [*] [*] Synchronization problems have been fully described in other works; we refer the interested reader to books on the Unix operating systems (see the Bibliography). These problems occur not only among kernel control paths but also among processes sharing common data. Several synchronization techniques have been adopted. The following section concentrates on how to synchronize kernel control paths . 1.6.5.1. Kernel preemption disabling To provide a drastically simple solution to synchronization problems, some traditional Unix kernels are nonpreemptive: when a process executes in Kernel Mode, it cannot be arbitrarily suspended and substituted with another process. Therefore, on a uniprocessor system, all kernel data structures that are not updated by interrupts or exception handlers are safe for the kernel to access. Of course, a process in Kernel Mode can voluntarily relinquish the CPU, but in this case, it must ensure that all data structures are left in a consistent state. Moreover, when it resumes its execution, it must recheck the value of any previously accessed data structures that could be changed. A synchronization mechanism applicable to preemptive kernels consists of disabling kernel preemption before entering a critical region and reenabling it right after leaving the region. Nonpreemptability is not enough for multiprocessor systems, because two kernel control paths running on different CPUs can concurrently access the same data structure. 1.6.5.2. Interrupt disabling Another synchronization mechanism for uniprocessor systems consists of disabling all hardware interrupts before entering a critical region and reenabling them right after leaving it. This mechanism, while simple, is far from optimal. If the critical region is large, interrupts can remain disabled for a relatively long time, potentially causing all hardware activities to freeze. 1.6.5.3. Semaphores A widely used mechanism, effective in both uniprocessor and multiprocessor systems, relies on the use of semaphores . A semaphore is simply a counter associated with a data structure; it is checked by all kernel threads before they try to access the data structure. Each semaphore may be viewed as an object composed of: An integer variable A list of waiting processes Two atomic methods: down( ) and up( ) The down( ) method decreases the value of the semaphore. If the new value is less than 0, the method adds the running process to the semaphore list and then blocks (i.e., invokes the scheduler ). The up( ) method increases the value of the semaphore and, if its new value is greater than or equal to 0, reactivates one or more processes in the semaphore list. Each data structure to be protected has its own semaphore, which is initialized to 1. When a kernel control path wishes to access the data structure, it executes the down( ) method on the proper semaphore. If the value of the new semaphore isn't negative, access to the data structure is granted. Otherwise, the process that is executing the kernel control path is added to the semaphore list and blocked. When another process executes the up( ) method on that semaphore, one of the processes in the semaphore list is allowed to proceed. 1.6.5.4. Spin locks In multiprocessor systems, semaphores are not always the best solution to the synchronization problems. Some kernel data structures should be protected from being concurrently accessed by kernel control paths that run on different CPUs. In this case, if the time required to update the data structure is short, a semaphore could be very inefficient. To check a semaphore, the kernel must insert a process in the semaphore list and then suspend it. Because both operations are relatively expensive, in the time it takes to complete them, the other kernel control path could have already released the semaphore. In these cases, multiprocessor operating systems use spin locks . A spin lock is very similar to a semaphore, but it has no process list ; when a process finds the lock closed by another process, it \"spins\" around repeatedly, executing a tight instruction loop until the lock becomes open. Of course, spin locks are useless in a uniprocessor environment. When a kernel control path tries to access a locked data structure, it starts an endless loop. Therefore, the kernel control path that is updating the protected data structure would not have a chance to continue the execution and release the spin lock. The final result would be that the system hangs. 1.6.5.5. Avoiding deadlocks Processes or kernel control paths that synchronize with other control paths may easily enter a deadlock state. The simplest case of deadlock occurs when process p1 gains access to data structure a and process p2 gains access to b , but p1 then waits for b and p2 waits for a . Other more complex cyclic waits among groups of processes also may occur. Of course, a deadlock condition causes a complete freeze of the affected processes or kernel control paths. As far as kernel design is concerned, deadlocks become an issue when the number of kernel locks used is high. In this case, it may be quite difficult to ensure that no deadlock state will ever be reached for all possible ways to interleave kernel control paths. Several operating systems, including Linux, avoid this problem by requesting locks in a predefined order.","title":"1.6.5-Synchronization-and-Critical-Regions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.5-Synchronization-and-Critical-Regions/#165#synchronization#and#critical#regions","text":"NOTE: \u867d\u7136\u672c\u8282\u6240\u63cf\u8ff0\u7684\u662fkernel\u7684synchronization\uff0c\u4f46\u662f\u5176\u4e2d\u6240\u63cf\u8ff0\u7684\u65b9\u6cd5\u3001\u601d\u8def\u53ef\u4ee5\u5e7f\u6cdb\u5e94\u7528\u4e8e\u5176\u4ed6\u9886\u57df\u3002 Implementing a reentrant kernel requires the use of synchronization . If a kernel control path is suspended while acting on a kernel data structure, no other kernel control path should be allowed to act on the same data structure unless it has been reset to a consistent state . Otherwise, the interaction of the two control paths could corrupt the stored information. For example, suppose a global variable V contains the number of available items of some system resource. The first kernel control path, A , reads the variable and determines that there is just one available item. At this point, another kernel control path, B , is activated and reads the same variable, which still contains the value 1 . Thus, B decreases V and starts using the resource item. Then A resumes the execution; because it has already read the value of V , it assumes that it can decrease V and take the resource item, which B already uses. As a final result, V contains -1, and two kernel control paths use the same resource item with potentially disastrous effects. When the outcome of a computation depends on how two or more processes are scheduled, the code is incorrect. We say that there is a race condition . In general, safe access to a global variable is ensured by using atomic operations . In the previous example, data corruption is not possible if the two control paths read and decrease V with a single, noninterruptible operation . However, kernels contain many data structures that cannot be accessed with a single operation. For example, it usually isn't possible to remove an element from a linked list with a single operation, because the kernel needs to access at least two pointers at once. Any section of code that should be finished by each process that begins it before another process can enter it is called a critical region . [*] [*] Synchronization problems have been fully described in other works; we refer the interested reader to books on the Unix operating systems (see the Bibliography). These problems occur not only among kernel control paths but also among processes sharing common data. Several synchronization techniques have been adopted. The following section concentrates on how to synchronize kernel control paths .","title":"1.6.5. Synchronization and Critical Regions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.5-Synchronization-and-Critical-Regions/#1651#kernel#preemption#disabling","text":"To provide a drastically simple solution to synchronization problems, some traditional Unix kernels are nonpreemptive: when a process executes in Kernel Mode, it cannot be arbitrarily suspended and substituted with another process. Therefore, on a uniprocessor system, all kernel data structures that are not updated by interrupts or exception handlers are safe for the kernel to access. Of course, a process in Kernel Mode can voluntarily relinquish the CPU, but in this case, it must ensure that all data structures are left in a consistent state. Moreover, when it resumes its execution, it must recheck the value of any previously accessed data structures that could be changed. A synchronization mechanism applicable to preemptive kernels consists of disabling kernel preemption before entering a critical region and reenabling it right after leaving the region. Nonpreemptability is not enough for multiprocessor systems, because two kernel control paths running on different CPUs can concurrently access the same data structure.","title":"1.6.5.1. Kernel preemption disabling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.5-Synchronization-and-Critical-Regions/#1652#interrupt#disabling","text":"Another synchronization mechanism for uniprocessor systems consists of disabling all hardware interrupts before entering a critical region and reenabling them right after leaving it. This mechanism, while simple, is far from optimal. If the critical region is large, interrupts can remain disabled for a relatively long time, potentially causing all hardware activities to freeze.","title":"1.6.5.2. Interrupt disabling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.5-Synchronization-and-Critical-Regions/#1653#semaphores","text":"A widely used mechanism, effective in both uniprocessor and multiprocessor systems, relies on the use of semaphores . A semaphore is simply a counter associated with a data structure; it is checked by all kernel threads before they try to access the data structure. Each semaphore may be viewed as an object composed of: An integer variable A list of waiting processes Two atomic methods: down( ) and up( ) The down( ) method decreases the value of the semaphore. If the new value is less than 0, the method adds the running process to the semaphore list and then blocks (i.e., invokes the scheduler ). The up( ) method increases the value of the semaphore and, if its new value is greater than or equal to 0, reactivates one or more processes in the semaphore list. Each data structure to be protected has its own semaphore, which is initialized to 1. When a kernel control path wishes to access the data structure, it executes the down( ) method on the proper semaphore. If the value of the new semaphore isn't negative, access to the data structure is granted. Otherwise, the process that is executing the kernel control path is added to the semaphore list and blocked. When another process executes the up( ) method on that semaphore, one of the processes in the semaphore list is allowed to proceed.","title":"1.6.5.3. Semaphores"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.5-Synchronization-and-Critical-Regions/#1654#spin#locks","text":"In multiprocessor systems, semaphores are not always the best solution to the synchronization problems. Some kernel data structures should be protected from being concurrently accessed by kernel control paths that run on different CPUs. In this case, if the time required to update the data structure is short, a semaphore could be very inefficient. To check a semaphore, the kernel must insert a process in the semaphore list and then suspend it. Because both operations are relatively expensive, in the time it takes to complete them, the other kernel control path could have already released the semaphore. In these cases, multiprocessor operating systems use spin locks . A spin lock is very similar to a semaphore, but it has no process list ; when a process finds the lock closed by another process, it \"spins\" around repeatedly, executing a tight instruction loop until the lock becomes open. Of course, spin locks are useless in a uniprocessor environment. When a kernel control path tries to access a locked data structure, it starts an endless loop. Therefore, the kernel control path that is updating the protected data structure would not have a chance to continue the execution and release the spin lock. The final result would be that the system hangs.","title":"1.6.5.4. Spin locks"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.5-Synchronization-and-Critical-Regions/#1655#avoiding#deadlocks","text":"Processes or kernel control paths that synchronize with other control paths may easily enter a deadlock state. The simplest case of deadlock occurs when process p1 gains access to data structure a and process p2 gains access to b , but p1 then waits for b and p2 waits for a . Other more complex cyclic waits among groups of processes also may occur. Of course, a deadlock condition causes a complete freeze of the affected processes or kernel control paths. As far as kernel design is concerned, deadlocks become an issue when the number of kernel locks used is high. In this case, it may be quite difficult to ensure that no deadlock state will ever be reached for all possible ways to interleave kernel control paths. Several operating systems, including Linux, avoid this problem by requesting locks in a predefined order.","title":"1.6.5.5. Avoiding deadlocks"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.6-Signals-and-Interprocess-Communication/","text":"1.6.6. Signals and Interprocess Communication Unix signals provide a mechanism for notifying processes of system events. Each event has its own signal number, which is usually referred to by a symbolic constant such as SIGTERM . There are two kinds of system events: Asynchronous notifications For instance, a user can send the interrupt signal SIGINT to a foreground process by pressing the interrupt keycode (usually Ctrl-C) at the terminal. Synchronous notifications For instance, the kernel sends the signal SIGSEGV to a process when it accesses a memory location at an invalid address.","title":"1.6.6-Signals-and-Interprocess-Communication"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.6-Signals-and-Interprocess-Communication/#166#signals#and#interprocess#communication","text":"Unix signals provide a mechanism for notifying processes of system events. Each event has its own signal number, which is usually referred to by a symbolic constant such as SIGTERM . There are two kinds of system events: Asynchronous notifications For instance, a user can send the interrupt signal SIGINT to a foreground process by pressing the interrupt keycode (usually Ctrl-C) at the terminal. Synchronous notifications For instance, the kernel sends the signal SIGSEGV to a process when it accesses a memory location at an invalid address.","title":"1.6.6. Signals and Interprocess Communication"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.7-Process-Management/","text":"1.6.7. Process Management Unix makes a neat distinction between the process and the program it is executing. To that end, the fork( ) and _exit( ) system calls are used respectively to create a new process and to terminate it, while an exec( ) -like system call is invoked to load a new program. After such a system call is executed, the process resumes execution with a brand new address space containing the loaded program. The process that invokes a fork( ) is the parent , while the new process is its child . Parents and children can find one another because the data structure describing each process includes a pointer to its immediate parent and pointers to all its immediate children. A naive implementation of the fork( ) would require both the parent's data and the parent's code to be duplicated and the copies assigned to the child. This would be quite time consuming. Current kernels that can rely on hardware paging units follow the Copy-On-Write approach, which defers page duplication until the last moment (i.e., until the parent or the child is required to write into a page). We shall describe how Linux implements this technique in the section \"Copy On Write\" in Chapter 9. The _exit( ) system call terminates a process. The kernel handles this system call by releasing the resources owned by the process and sending the parent process a SIGCHLD signal, which is ignored by default. 1.6.7.1. Zombie processes How can a parent process inquire about termination of its children? The wait4( ) system call allows a process to wait until one of its children terminates; it returns the process ID (PID) of the terminated child. When executing this system call, the kernel checks whether a child has already terminated. A special zombie process state is introduced to represent terminated processes: a process remains in that state until its parent process executes a wait4( ) system call on it. The system call handler extracts data about resource usage from the process descriptor fields; the process descriptor may be released once the data is collected. If no child process has already terminated when the wait4( ) system call is executed, the kernel usually puts the process in a wait state until a child terminates. Many kernels also implement a waitpid( ) system call, which allows a process to wait for a specific child process. Other variants of wait4( ) system calls are also quite common. It's good practice for the kernel to keep around information on a child process until the parent issues its wait4( ) call, but suppose the parent process terminates without issuing that call? The information takes up valuable memory slots that could be used to serve living processes. For example, many shells allow the user to start a command in the background and then log out. The process that is running the command shell terminates, but its children continue their execution. The solution lies in a special system process called init , which is created during system initialization. When a process terminates, the kernel changes the appropriate process descriptor pointers of all the existing children of the terminated process to make them become children of init . This process monitors the execution of all its children and routinely issues wait4( ) system calls, whose side effect is to get rid of all orphaned zombies. 1.6.7.2. Process groups and login sessions Modern Unix operating systems introduce the notion of process groups to represent a \"job\" abstraction. For example, in order to execute the command line: $ ls | sort | more a shell that supports process groups , such as bash , creates a new group for the three processes corresponding to ls , sort , and more . In this way, the shell acts on the three processes as if they were a single entity (the job , to be precise). Each process descriptor includes a field containing the process group ID . Each group of processes may have a group leader , which is the process whose PID coincides with the process group ID . A newly created process is initially inserted into the process group of its parent. Modern Unix kernels also introduce login sessions . Informally, a login session contains all processes that are descendants of the process that has started a working session on a specific terminal usually, the first command shell process created for the user. All processes in a process group must be in the same login session . A login session may have several process groups active simultaneously; one of these process groups is always in the foreground, which means that it has access to the terminal. The other active process groups are in the background. When a background process tries to access the terminal, it receives a SIGTTIN or SIGTTOUT signal. In many command shells, the internal commands bg and fg can be used to put a process group in either the background or the foreground.","title":"1.6.7-Process-Management"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.7-Process-Management/#167#process#management","text":"Unix makes a neat distinction between the process and the program it is executing. To that end, the fork( ) and _exit( ) system calls are used respectively to create a new process and to terminate it, while an exec( ) -like system call is invoked to load a new program. After such a system call is executed, the process resumes execution with a brand new address space containing the loaded program. The process that invokes a fork( ) is the parent , while the new process is its child . Parents and children can find one another because the data structure describing each process includes a pointer to its immediate parent and pointers to all its immediate children. A naive implementation of the fork( ) would require both the parent's data and the parent's code to be duplicated and the copies assigned to the child. This would be quite time consuming. Current kernels that can rely on hardware paging units follow the Copy-On-Write approach, which defers page duplication until the last moment (i.e., until the parent or the child is required to write into a page). We shall describe how Linux implements this technique in the section \"Copy On Write\" in Chapter 9. The _exit( ) system call terminates a process. The kernel handles this system call by releasing the resources owned by the process and sending the parent process a SIGCHLD signal, which is ignored by default.","title":"1.6.7. Process Management"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.7-Process-Management/#1671#zombie#processes","text":"How can a parent process inquire about termination of its children? The wait4( ) system call allows a process to wait until one of its children terminates; it returns the process ID (PID) of the terminated child. When executing this system call, the kernel checks whether a child has already terminated. A special zombie process state is introduced to represent terminated processes: a process remains in that state until its parent process executes a wait4( ) system call on it. The system call handler extracts data about resource usage from the process descriptor fields; the process descriptor may be released once the data is collected. If no child process has already terminated when the wait4( ) system call is executed, the kernel usually puts the process in a wait state until a child terminates. Many kernels also implement a waitpid( ) system call, which allows a process to wait for a specific child process. Other variants of wait4( ) system calls are also quite common. It's good practice for the kernel to keep around information on a child process until the parent issues its wait4( ) call, but suppose the parent process terminates without issuing that call? The information takes up valuable memory slots that could be used to serve living processes. For example, many shells allow the user to start a command in the background and then log out. The process that is running the command shell terminates, but its children continue their execution. The solution lies in a special system process called init , which is created during system initialization. When a process terminates, the kernel changes the appropriate process descriptor pointers of all the existing children of the terminated process to make them become children of init . This process monitors the execution of all its children and routinely issues wait4( ) system calls, whose side effect is to get rid of all orphaned zombies.","title":"1.6.7.1. Zombie processes"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.7-Process-Management/#1672#process#groups#and#login#sessions","text":"Modern Unix operating systems introduce the notion of process groups to represent a \"job\" abstraction. For example, in order to execute the command line: $ ls | sort | more a shell that supports process groups , such as bash , creates a new group for the three processes corresponding to ls , sort , and more . In this way, the shell acts on the three processes as if they were a single entity (the job , to be precise). Each process descriptor includes a field containing the process group ID . Each group of processes may have a group leader , which is the process whose PID coincides with the process group ID . A newly created process is initially inserted into the process group of its parent. Modern Unix kernels also introduce login sessions . Informally, a login session contains all processes that are descendants of the process that has started a working session on a specific terminal usually, the first command shell process created for the user. All processes in a process group must be in the same login session . A login session may have several process groups active simultaneously; one of these process groups is always in the foreground, which means that it has access to the terminal. The other active process groups are in the background. When a background process tries to access the terminal, it receives a SIGTTIN or SIGTTOUT signal. In many command shells, the internal commands bg and fg can be used to put a process group in either the background or the foreground.","title":"1.6.7.2. Process groups and login sessions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.8-Memory-Management/","text":"1.6.8. Memory Management Memory management is by far the most complex activity in a Unix kernel. More than a third of this book is dedicated just to describing how Linux handles memory management. This section illustrates some of the main issues related to memory management. 1.6.8.1. Virtual memory All recent Unix systems provide a useful abstraction called virtual memory . Virtual memory acts as a logical layer between the application memory requests and the hardware Memory Management Unit (MMU). Virtual memory has many purposes and advantages: Several processes can be executed concurrently. It is possible to run applications whose memory needs are larger than the available physical memory. Processes can execute a program whose code is only partially loaded in memory. Each process is allowed to access a subset of the available physical memory. Processes can share a single memory image of a library or program. Programs can be relocatable that is, they can be placed anywhere in physical memory. The main ingredient of a virtual memory subsystem is the notion of virtual address space . The set of memory references that a process can use is different from physical memory addresses. When a process uses a virtual address , [*] the kernel and the MMU cooperate to find the actual physical location of the requested memory item. [*] These addresses have different nomenclatures, depending on the computer architecture. As we'll see in Chapter 2, Intel manuals refer to them as \"logical addresses.\" Today's CPUs include hardware circuits that automatically translate the virtual addresses into physical ones. To that end, the available RAM is partitioned into page frames typically 4 or 8 KB in length and a set of Page Tables is introduced to specify how virtual addresses correspond to physical addresses . These circuits make memory allocation simpler, because a request for a block of contiguous virtual addresses can be satisfied by allocating a group of page frames having noncontiguous physical addresses. NOTE: \u672c\u8282\u7684\u5185\u5bb9\u4e3b\u8981\u662f\u5bf9\u5982\u4e0b\u7ae0\u8282\u7684\u5185\u5bb9\u7684\u6982\u62ec\uff1a chapter 2.1. Memory Addresses chapter 2.4. Paging in Hardware chapter 2.5. Paging in Linux 1.6.8.2. Random access memory usage All Unix operating systems clearly distinguish between two portions of the random access memory (RAM). A few megabytes are dedicated to storing the kernel image (i.e., the kernel code and the kernel static data structures). The remaining portion of RAM is usually handled by the virtual memory system and is used in three possible ways: To satisfy kernel requests for buffers, descriptors, and other dynamic kernel data structures To satisfy process requests for generic memory areas and for memory mapping of files To get better performance from disks and other buffered devices by means of caches NOTE: \u5173\u4e8eRAM\u7684usage\uff0c\u5728Chapter 8. Memory Management\u6709\u7c7b\u4f3c\u4e0a\u9762\u8fd9\u6bb5\u7684\u63cf\u8ff0\u3002 Each request type is valuable. On the other hand, because the available RAM is limited, some balancing among request types must be done, particularly when little available memory is left. Moreover, when some critical threshold of available memory is reached and a page-frame-reclaiming algorithm is invoked to free additional memory, which are the page frames most suitable for reclaiming? As we will see in Chapter 17, there is no simple answer to this question and very little support from theory. The only available solution lies in developing carefully tuned empirical algorithms. One major problem that must be solved by the virtual memory system is memory fragmentation . Ideally, a memory request should fail only when the number of free page frames is too small. However, the kernel is often forced to use physically contiguous memory areas. Hence the memory request could fail even if there is enough memory available, but it is not available as one contiguous chunk. 1.6.8.3. Kernel Memory Allocator The Kernel Memory Allocator (KMA) is a subsystem that tries to satisfy the requests for memory areas from all parts of the system. Some of these requests come from other kernel subsystems needing memory for kernel use, and some requests come via system calls from user programs to increase their processes' address spaces. A good KMA should have the following features: It must be fast. Actually, this is the most crucial attribute, because it is invoked by all kernel subsystems (including the interrupt handlers). It should minimize the amount of wasted memory. It should try to reduce the memory fragmentation problem. It should be able to cooperate with the other memory management subsystems to borrow and release page frames from them. Several proposed KMAs, which are based on a variety of different algorithmic techniques, include: Resource map allocator Power-of-two free lists McKusick-Karels allocator Buddy system Mach's Zone allocator Dynix allocator Solaris 's Slab allocator As we will see in Chapter 8, Linux's KMA uses a Slab allocator on top of a buddy system. NOTE: Memory Allocation Guide 1.6.8.4. Process virtual address space handling The address space of a process contains all the virtual memory addresses that the process is allowed to reference. The kernel usually stores a process virtual address space as a list of memory area descriptors . For example, when a process starts the execution of some program via an exec( ) -like system call, the kernel assigns to the process a virtual address space that comprises memory areas for: The executable code of the program The initialized data of the program The uninitialized data of the program The initial program stack (i.e., the User Mode stack) The executable code and data of needed shared libraries The heap (the memory dynamically requested by the program) All recent Unix operating systems adopt a memory allocation strategy called demand paging . With demand paging, a process can start program execution with none of its pages in physical memory. As it accesses a nonpresent page, the MMU generates an exception; the exception handler finds the affected memory region, allocates a free page, and initializes it with the appropriate data. In a similar fashion, when the process dynamically requires memory by using malloc( ) , or the brk( ) system call (which is invoked internally by malloc( ) ), the kernel just updates the size of the heap memory region of the process. A page frame is assigned to the process only when it generates an exception by trying to refer its virtual memory addresses. Virtual address spaces also allow other efficient strategies, such as the Copy On Write strategy mentioned earlier. For example, when a new process is created, the kernel just assigns the parent's page frames to the child address space, but marks them read-only. An exception is raised as soon the parent or the child tries to modify the contents of a page. The exception handler assigns a new page frame to the affected process and initializes it with the contents of the original page. 1.6.8.5. Caching A good part of the available physical memory is used as cache for hard disks and other block devices. This is because hard drives are very slow: a disk access requires several milliseconds, which is a very long time compared with the RAM access time. Therefore, disks are often the bottleneck in system performance. As a general rule, one of the policies already implemented in the earliest Unix system is to defer writing to disk as long as possible. As a result, data read previously from disk and no longer used by any process continue to stay in RAM. This strategy is based on the fact that there is a good chance that new processes will require data read from or written to disk by processes that no longer exist. When a process asks to access a disk, the kernel checks first whether the required data are in the cache. Each time this happens (a cache hit), the kernel is able to service the process request without accessing the disk. The sync( ) system call forces disk synchronization by writing all of the \"dirty\" buffers (i.e., all the buffers whose contents differ from that of the corresponding disk blocks) into disk. To avoid data loss, all operating systems take care to periodically write dirty buffers back to disk.","title":"1.6.8-Memory-Management"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.8-Memory-Management/#168#memory#management","text":"Memory management is by far the most complex activity in a Unix kernel. More than a third of this book is dedicated just to describing how Linux handles memory management. This section illustrates some of the main issues related to memory management.","title":"1.6.8. Memory Management"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.8-Memory-Management/#1681#virtual#memory","text":"All recent Unix systems provide a useful abstraction called virtual memory . Virtual memory acts as a logical layer between the application memory requests and the hardware Memory Management Unit (MMU). Virtual memory has many purposes and advantages: Several processes can be executed concurrently. It is possible to run applications whose memory needs are larger than the available physical memory. Processes can execute a program whose code is only partially loaded in memory. Each process is allowed to access a subset of the available physical memory. Processes can share a single memory image of a library or program. Programs can be relocatable that is, they can be placed anywhere in physical memory. The main ingredient of a virtual memory subsystem is the notion of virtual address space . The set of memory references that a process can use is different from physical memory addresses. When a process uses a virtual address , [*] the kernel and the MMU cooperate to find the actual physical location of the requested memory item. [*] These addresses have different nomenclatures, depending on the computer architecture. As we'll see in Chapter 2, Intel manuals refer to them as \"logical addresses.\" Today's CPUs include hardware circuits that automatically translate the virtual addresses into physical ones. To that end, the available RAM is partitioned into page frames typically 4 or 8 KB in length and a set of Page Tables is introduced to specify how virtual addresses correspond to physical addresses . These circuits make memory allocation simpler, because a request for a block of contiguous virtual addresses can be satisfied by allocating a group of page frames having noncontiguous physical addresses. NOTE: \u672c\u8282\u7684\u5185\u5bb9\u4e3b\u8981\u662f\u5bf9\u5982\u4e0b\u7ae0\u8282\u7684\u5185\u5bb9\u7684\u6982\u62ec\uff1a chapter 2.1. Memory Addresses chapter 2.4. Paging in Hardware chapter 2.5. Paging in Linux","title":"1.6.8.1. Virtual memory"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.8-Memory-Management/#1682#random#access#memory#usage","text":"All Unix operating systems clearly distinguish between two portions of the random access memory (RAM). A few megabytes are dedicated to storing the kernel image (i.e., the kernel code and the kernel static data structures). The remaining portion of RAM is usually handled by the virtual memory system and is used in three possible ways: To satisfy kernel requests for buffers, descriptors, and other dynamic kernel data structures To satisfy process requests for generic memory areas and for memory mapping of files To get better performance from disks and other buffered devices by means of caches NOTE: \u5173\u4e8eRAM\u7684usage\uff0c\u5728Chapter 8. Memory Management\u6709\u7c7b\u4f3c\u4e0a\u9762\u8fd9\u6bb5\u7684\u63cf\u8ff0\u3002 Each request type is valuable. On the other hand, because the available RAM is limited, some balancing among request types must be done, particularly when little available memory is left. Moreover, when some critical threshold of available memory is reached and a page-frame-reclaiming algorithm is invoked to free additional memory, which are the page frames most suitable for reclaiming? As we will see in Chapter 17, there is no simple answer to this question and very little support from theory. The only available solution lies in developing carefully tuned empirical algorithms. One major problem that must be solved by the virtual memory system is memory fragmentation . Ideally, a memory request should fail only when the number of free page frames is too small. However, the kernel is often forced to use physically contiguous memory areas. Hence the memory request could fail even if there is enough memory available, but it is not available as one contiguous chunk.","title":"1.6.8.2. Random access memory usage"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.8-Memory-Management/#1683#kernel#memory#allocator","text":"The Kernel Memory Allocator (KMA) is a subsystem that tries to satisfy the requests for memory areas from all parts of the system. Some of these requests come from other kernel subsystems needing memory for kernel use, and some requests come via system calls from user programs to increase their processes' address spaces. A good KMA should have the following features: It must be fast. Actually, this is the most crucial attribute, because it is invoked by all kernel subsystems (including the interrupt handlers). It should minimize the amount of wasted memory. It should try to reduce the memory fragmentation problem. It should be able to cooperate with the other memory management subsystems to borrow and release page frames from them. Several proposed KMAs, which are based on a variety of different algorithmic techniques, include: Resource map allocator Power-of-two free lists McKusick-Karels allocator Buddy system Mach's Zone allocator Dynix allocator Solaris 's Slab allocator As we will see in Chapter 8, Linux's KMA uses a Slab allocator on top of a buddy system. NOTE: Memory Allocation Guide","title":"1.6.8.3. Kernel Memory Allocator"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.8-Memory-Management/#1684#process#virtual#address#space#handling","text":"The address space of a process contains all the virtual memory addresses that the process is allowed to reference. The kernel usually stores a process virtual address space as a list of memory area descriptors . For example, when a process starts the execution of some program via an exec( ) -like system call, the kernel assigns to the process a virtual address space that comprises memory areas for: The executable code of the program The initialized data of the program The uninitialized data of the program The initial program stack (i.e., the User Mode stack) The executable code and data of needed shared libraries The heap (the memory dynamically requested by the program) All recent Unix operating systems adopt a memory allocation strategy called demand paging . With demand paging, a process can start program execution with none of its pages in physical memory. As it accesses a nonpresent page, the MMU generates an exception; the exception handler finds the affected memory region, allocates a free page, and initializes it with the appropriate data. In a similar fashion, when the process dynamically requires memory by using malloc( ) , or the brk( ) system call (which is invoked internally by malloc( ) ), the kernel just updates the size of the heap memory region of the process. A page frame is assigned to the process only when it generates an exception by trying to refer its virtual memory addresses. Virtual address spaces also allow other efficient strategies, such as the Copy On Write strategy mentioned earlier. For example, when a new process is created, the kernel just assigns the parent's page frames to the child address space, but marks them read-only. An exception is raised as soon the parent or the child tries to modify the contents of a page. The exception handler assigns a new page frame to the affected process and initializes it with the contents of the original page.","title":"1.6.8.4. Process virtual address space handling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.8-Memory-Management/#1685#caching","text":"A good part of the available physical memory is used as cache for hard disks and other block devices. This is because hard drives are very slow: a disk access requires several milliseconds, which is a very long time compared with the RAM access time. Therefore, disks are often the bottleneck in system performance. As a general rule, one of the policies already implemented in the earliest Unix system is to defer writing to disk as long as possible. As a result, data read previously from disk and no longer used by any process continue to stay in RAM. This strategy is based on the fact that there is a good chance that new processes will require data read from or written to disk by processes that no longer exist. When a process asks to access a disk, the kernel checks first whether the required data are in the cache. Each time this happens (a cache hit), the kernel is able to service the process request without accessing the disk. The sync( ) system call forces disk synchronization by writing all of the \"dirty\" buffers (i.e., all the buffers whose contents differ from that of the corresponding disk blocks) into disk. To avoid data loss, all operating systems take care to periodically write dirty buffers back to disk.","title":"1.6.8.5. Caching"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.9-Device-Drivers/","text":"1.6.9. Device Drivers The kernel interacts with I/O devices by means of device drivers . Device drivers are included in the kernel and consist of data structures and functions that control one or more devices, such as hard disks, keyboards, mouses, monitors, network interfaces, and devices connected to an SCSI bus. Each driver interacts with the remaining part of the kernel (even with other drivers) through a specific interface. This approach has the following advantages: Device-specific code can be encapsulated in a specific module. Vendors can add new devices without knowing the kernel source code; only the interface specifications must be known. The kernel deals with all devices in a uniform way and accesses them through the same interface. It is possible to write a device driver as a module that can be dynamically loaded in the kernel without requiring the system to be rebooted. It is also possible to dynamically unload a module that is no longer needed, therefore minimizing the size of the kernel image stored in RAM. Figure 1-4 illustrates how device drivers interface with the rest of the kernel and with the processes. Figure 1-4. Device driver interface Some user programs (P) wish to operate on hardware devices. They make requests to the kernel using the usual file-related system calls and the device files normally found in the /dev directory. Actually, the device files are the user-visible portion of the device driver interface. Each device file refers to a specific device driver, which is invoked by the kernel to perform the requested operation on the hardware component. At the time Unix was introduced, graphical terminals were uncommon and expensive, so only alphanumeric terminals were handled directly by Unix kernels. When graphical terminals became widespread, ad hoc applications such as the X Window System were introduced that ran as standard processes and accessed the I/O ports of the graphics interface and the RAM video area directly. Some recent Unix kernels, such as Linux 2.6, provide an abstraction for the frame buffer of the graphic card and allow application software to access them without needing to know anything about the I/O ports of the graphics interface (see the section \"Levels of Kernel Support\" in Chapter 13.)","title":"1.6.9-Device-Drivers"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/1.6.9-Device-Drivers/#169#device#drivers","text":"The kernel interacts with I/O devices by means of device drivers . Device drivers are included in the kernel and consist of data structures and functions that control one or more devices, such as hard disks, keyboards, mouses, monitors, network interfaces, and devices connected to an SCSI bus. Each driver interacts with the remaining part of the kernel (even with other drivers) through a specific interface. This approach has the following advantages: Device-specific code can be encapsulated in a specific module. Vendors can add new devices without knowing the kernel source code; only the interface specifications must be known. The kernel deals with all devices in a uniform way and accesses them through the same interface. It is possible to write a device driver as a module that can be dynamically loaded in the kernel without requiring the system to be rebooted. It is also possible to dynamically unload a module that is no longer needed, therefore minimizing the size of the kernel image stored in RAM. Figure 1-4 illustrates how device drivers interface with the rest of the kernel and with the processes. Figure 1-4. Device driver interface Some user programs (P) wish to operate on hardware devices. They make requests to the kernel using the usual file-related system calls and the device files normally found in the /dev directory. Actually, the device files are the user-visible portion of the device driver interface. Each device file refers to a specific device driver, which is invoked by the kernel to perform the requested operation on the hardware component. At the time Unix was introduced, graphical terminals were uncommon and expensive, so only alphanumeric terminals were handled directly by Unix kernels. When graphical terminals became widespread, ad hoc applications such as the X Window System were introduced that ran as standard processes and accessed the I/O ports of the graphics interface and the RAM video area directly. Some recent Unix kernels, such as Linux 2.6, provide an abstraction for the frame buffer of the graphic card and allow application software to access them without needing to know anything about the I/O ports of the graphics interface (see the section \"Levels of Kernel Support\" in Chapter 13.)","title":"1.6.9. Device Drivers"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/Chapter-1-Introduction/","text":"Chapter 1. Introduction NOTE: \u5173\u4e8e\u66f4\u52a0\u8be6\u7ec6\u7684linux\u7684\u4ecb\u7ecd\uff0c\u53c2\u89c1\u5982\u4e0b\u6587\u7ae0\uff1a Linux Linux kernel","title":"Chapter-1-Introduction"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/Chapter-1-Introduction/#chapter#1#introduction","text":"NOTE: \u5173\u4e8e\u66f4\u52a0\u8be6\u7ec6\u7684linux\u7684\u4ecb\u7ecd\uff0c\u53c2\u89c1\u5982\u4e0b\u6587\u7ae0\uff1a Linux Linux kernel","title":"Chapter 1. Introduction"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/Giant-lock/","text":"Giant lock Linux Giant lock In operating systems , a giant lock , also known as a big-lock or kernel-lock , is a lock that may be used in the kernel to provide concurrency control required by symmetric multiprocessing (SMP) systems. A giant lock is a solitary global lock that is held whenever a thread enters kernel space and released when the thread returns to user space ; a system call is the archetypal example. In this model, threads in user space can run concurrently on any available processors or processor cores , but no more than one thread can run in kernel space; any other threads that try to enter kernel space are forced to wait. In other words, the giant lock eliminates all concurrency in kernel space. By isolating the kernel from concurrency, many parts of the kernel no longer need to be modified to support SMP. However, as in giant-lock SMP systems only one processor can run the kernel code at a time, performance for applications spending significant amounts of time in the kernel is not much improved. Accordingly, the giant-lock approach is commonly seen as a preliminary means of bringing SMP support to an operating system, yielding benefits only in user space. Most modern operating systems use a fine-grained locking approach. Linux The Linux kernel had a big kernel lock (BKL) since the introduction of SMP, until Arnd Bergmann removed it in 2011 in kernel version 2.6.39, with the remaining uses of the big lock removed or replaced by finer-grained locking. Linux distributions at or above CentOS 7 , Debian 7 (Wheezy) and Ubuntu 11.10 are therefore not using BKL.","title":"Giant-lock"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/Giant-lock/#giant#lock","text":"In operating systems , a giant lock , also known as a big-lock or kernel-lock , is a lock that may be used in the kernel to provide concurrency control required by symmetric multiprocessing (SMP) systems. A giant lock is a solitary global lock that is held whenever a thread enters kernel space and released when the thread returns to user space ; a system call is the archetypal example. In this model, threads in user space can run concurrently on any available processors or processor cores , but no more than one thread can run in kernel space; any other threads that try to enter kernel space are forced to wait. In other words, the giant lock eliminates all concurrency in kernel space. By isolating the kernel from concurrency, many parts of the kernel no longer need to be modified to support SMP. However, as in giant-lock SMP systems only one processor can run the kernel code at a time, performance for applications spending significant amounts of time in the kernel is not much improved. Accordingly, the giant-lock approach is commonly seen as a preliminary means of bringing SMP support to an operating system, yielding benefits only in user space. Most modern operating systems use a fine-grained locking approach.","title":"Giant lock"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-1-Introduction/Giant-lock/#linux","text":"The Linux kernel had a big kernel lock (BKL) since the introduction of SMP, until Arnd Bergmann removed it in 2011 in kernel version 2.6.39, with the remaining uses of the big lock removed or replaced by finer-grained locking. Linux distributions at or above CentOS 7 , Debian 7 (Wheezy) and Ubuntu 11.10 are therefore not using BKL.","title":"Linux"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.1-Memory-Addresses/","text":"2.1. Memory Addresses Logical address Linear address (also known as virtual address) Physical address 2.1. Memory Addresses Programmers casually refer to a memory address as the way to access the contents of a memory cell. But when dealing with 80 x 86 microprocessors, we have to distinguish three kinds of addresses: Logical address Included in the machine language instructions to specify the address of an operand or of an instruction. This type of address embodies the well-known 80 x 86 segmented architecture that forces MS-DOS and Windows programmers to divide their programs into segments . Each logical address consists of a segment and an offset (or displacement) that denotes the distance from the start of the segment to the actual address. Linear address (also known as virtual address ) A single 32-bit unsigned integer that can be used to address up to 4 GB that is, up to 4,294,967,296 memory cells. Linear addresses are usually represented in hexadecimal notation; their values range from 0x00000000 to 0xffffffff . NOTE: \u6bcf\u4e2aprocess\u90fd\u4e00\u4e2a\u72ec\u7acb\u7684 Virtual address space \uff0c\u4ece\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u662f\u5426\u53ef\u4ee5\u63a8\u65ad\u51fa\u6bcf\u4e2aprocess\u7684virtual address space\u7684address value range\u662f\u5426\u4e00\u81f4\uff1b\u53c2\u89c1\u8fd9\u7bc7\u6587\u7ae0 In virtual memory, can two different processes have the same address? Physical address Used to address memory cells in memory chips. They correspond to the electrical signals sent along the address pins of the microprocessor to the memory bus . Physical addresses are represented as 32-bit or 36-bit unsigned integers. The Memory Management Unit ( MMU ) transforms a logical address into a linear address by means of a hardware circuit called a segmentation unit ; subsequently, a second hardware circuit called a paging unit transforms the linear address into a physical address (see Figure 2-1). In multiprocessor systems, all CPUs usually share the same memory; this means that RAM chips may be accessed concurrently by independent CPUs. Because read or write operations on a RAM chip must be performed serially, a hardware circuit called a memory arbiter is inserted between the bus and every RAM chip. Its role is to grant access to a CPU if the chip is free and to delay it if the chip is busy servicing a request by another processor. Even uniprocessor systems use memory arbiters , because they include specialized processors called DMA controllers that operate concurrently with the CPU (see the section \"Direct Memory Access (DMA)\" in Chapter 13). In the case of multiprocessor systems, the structure of the arbiter is more complex because it has more input ports. The dual Pentium, for instance, maintains a two-port arbiter at each chip entrance and requires that the two CPUs exchange synchronization messages before attempting to use the common bus. From the programming point of view, the arbiter is hidden because it is managed by hardware circuits.","title":"2.1-Memory-Addresses"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.1-Memory-Addresses/#21#memory#addresses","text":"Programmers casually refer to a memory address as the way to access the contents of a memory cell. But when dealing with 80 x 86 microprocessors, we have to distinguish three kinds of addresses:","title":"2.1. Memory Addresses"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.1-Memory-Addresses/#logical#address","text":"Included in the machine language instructions to specify the address of an operand or of an instruction. This type of address embodies the well-known 80 x 86 segmented architecture that forces MS-DOS and Windows programmers to divide their programs into segments . Each logical address consists of a segment and an offset (or displacement) that denotes the distance from the start of the segment to the actual address.","title":"Logical address"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.1-Memory-Addresses/#linear#address#also#known#as#virtual#address","text":"A single 32-bit unsigned integer that can be used to address up to 4 GB that is, up to 4,294,967,296 memory cells. Linear addresses are usually represented in hexadecimal notation; their values range from 0x00000000 to 0xffffffff . NOTE: \u6bcf\u4e2aprocess\u90fd\u4e00\u4e2a\u72ec\u7acb\u7684 Virtual address space \uff0c\u4ece\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u662f\u5426\u53ef\u4ee5\u63a8\u65ad\u51fa\u6bcf\u4e2aprocess\u7684virtual address space\u7684address value range\u662f\u5426\u4e00\u81f4\uff1b\u53c2\u89c1\u8fd9\u7bc7\u6587\u7ae0 In virtual memory, can two different processes have the same address?","title":"Linear address (also known as virtual address)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.1-Memory-Addresses/#physical#address","text":"Used to address memory cells in memory chips. They correspond to the electrical signals sent along the address pins of the microprocessor to the memory bus . Physical addresses are represented as 32-bit or 36-bit unsigned integers. The Memory Management Unit ( MMU ) transforms a logical address into a linear address by means of a hardware circuit called a segmentation unit ; subsequently, a second hardware circuit called a paging unit transforms the linear address into a physical address (see Figure 2-1). In multiprocessor systems, all CPUs usually share the same memory; this means that RAM chips may be accessed concurrently by independent CPUs. Because read or write operations on a RAM chip must be performed serially, a hardware circuit called a memory arbiter is inserted between the bus and every RAM chip. Its role is to grant access to a CPU if the chip is free and to delay it if the chip is busy servicing a request by another processor. Even uniprocessor systems use memory arbiters , because they include specialized processors called DMA controllers that operate concurrently with the CPU (see the section \"Direct Memory Access (DMA)\" in Chapter 13). In the case of multiprocessor systems, the structure of the arbiter is more complex because it has more input ports. The dual Pentium, for instance, maintains a two-port arbiter at each chip entrance and requires that the two CPUs exchange synchronization messages before attempting to use the common bus. From the programming point of view, the arbiter is hidden because it is managed by hardware circuits.","title":"Physical address"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.2-Segmentation-in-Hardware/","text":"2.2. Segmentation in Hardware 2.2.1. Segment Selectors and Segmentation Registers 2.2.2. Segment Descriptors 2.2.3. Fast Access to Segment Descriptors 2.2.4. Segmentation Unit 2.2. Segmentation in Hardware Starting with the 80286 model, Intel microprocessors perform address translation in two different ways called real mode and protected mode . We'll focus in the next sections on address translation when protected mode is enabled. Real mode exists mostly to maintain processor compatibility with older models and to allow the operating system to bootstrap (see Appendix A for a short description of real mode). 2.2.1. Segment Selectors and Segmentation Registers A logical address consists of two parts: a segment identifier and an offset that specifies the relative address within the segment. The segment identifier is a 16-bit field called the Segment Selector (see Figure 2-2), while the offset is a 32-bit field. We'll describe the fields of Segment Selectors in the section \"Fast Access to Segment Descriptors\" later in this chapter. SUMMARY : \u4ece\u4e0a\u9762\u7684\u4ecb\u7ecd\u6765\u770b\uff0c\u5730\u5740\u7684\u957f\u5ea6\u662f\uff1a16 + 32 = 48 SUMMARY : \u4ece\u56fe\u4e2d\u53ef\u4ee5\u770b\u51fa\uff0cSegment Selector\u9664\u4e86\u5305\u542b\u6709table index\u4e4b\u5916\uff0c\u8fd8\u5305\u542b\u6709\u5176\u4ed6\u7684\u4fe1\u606f\uff1b To make it easy to retrieve segment selectors quickly, the processor provides segmentation registers whose only purpose is to hold Segment Selectors; these registers are called cs , ss , ds , es , fs , and gs . Although there are only six of them, a program can reuse the same segmentation register for different purposes by saving its content in memory and then restoring it later. Three of the six segmentation registers have specific purposes: cs The code segment register, which points to a segment containing program instructions ss The stack segment register, which points to a segment containing the current program stack ds The data segment register, which points to a segment containing global and static data The remaining three segmentation registers are general purpose and may refer to arbitrary data segments. The cs register has another important function: it includes a 2-bit field that specifies the Current Privilege Level (CPL) of the CPU. The value 0 denotes the highest privilege level, while the value 3 denotes the lowest one. Linux uses only levels 0 and 3, which are respectively called Kernel Mode and User Mode . 2.2.2. Segment Descriptors Each segment is represented by an 8-byte Segment Descriptor that describes the segment characteristics. Segment Descriptors are stored either in the Global Descriptor Table ( GDT ) or in the Local Descriptor Table( LDT ) . Usually only one GDT is defined, while each process is permitted to have its own LDT if it needs to create additional segments besides those stored in the GDT . The address and size of the GDT in main memory are contained in the gdtr control register, while the address and size of the currently used LDT are contained in the ldtr control register. Figure 2-3 illustrates the format of a Segment Descriptor ; the meaning of the various fields is explained in Table 2-1. Table 2-1. Segment Descriptor fields Field name Description Base Contains the linear address of the first byte of the segment. G Granularity flag : if it is cleared (equal to 0), the segment size is expressed in bytes; otherwise, it is expressed in multiples of 4096 bytes. Limit Holds the offset of the last memory cell in the segment, thus binding the segment length. When G is set to 0, the size of a segment may vary between 1 byte and 1 MB; otherwise, it may vary between 4 KB and 4 GB. S System flag : if it is cleared, the segment is a system segment that stores critical data structures such as the Local Descriptor Table ; otherwise, it is a normal code or data segment. Type Characterizes the segment type and its access rights (see the text that follows this table). DPL Descriptor Privilege Level: used to restrict accesses to the segment. It represents the minimal CPU privilege level requested for accessing the segment. Therefore, a segment with its DPL set to 0 is accessible only when the CPL is 0 that is, in Kernel Mode while a segment with its DPL set to 3 is accessible with every CPL value. P Segment-Present flag : is equal to 0 if the segment is not stored currently in main memory. Linux always sets this flag (bit 47) to 1, because it never swaps out whole segments to disk. There are several types of segments, and thus several types of Segment Descriptors . The following list shows the types that are widely used in Linux. Code Segment Descriptor Indicates that the Segment Descriptor refers to a code segment; it may be included either in the GDT or in the LDT . The descriptor has the S flag set (non-system segment). Data Segment Descriptor Indicates that the Segment Descriptor refers to a data segment ; it may be included either in the GDT or in the LDT . The descriptor has the S flag set. Stack segments are implemented by means of generic data segments. Task State Segment Descriptor (TSSD) Indicates that the Segment Descriptor refers to a Task State Segment (TSS) that is, a segment used to save the contents of the processor registers (see the section \"Task State Segment\" in Chapter 3); it can appear only in the GDT. The corresponding Type field has the value 11 or 9, depending on whether the corresponding process is currently executing on a CPU. The S flag of such descriptors is set to 0. SUMMARY : \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6ca1\u6709stack segment descriptor\uff1b\u6839\u636e\u7b2c2.3\u7ae0\u7684\u5185\u5bb9\u6765\u770b\uff0c\u8fd9\u662f\u56e0\u4e3astack segment\u662f inside data segment\u7684\uff1b 2.2.3. Fast Access to Segment Descriptors We recall that logical addresses consist of a 16-bit Segment Selector and a 32-bit Offset, and that segmentation registers store only the Segment Selector. To speed up the translation of logical addresses into linear addresses , the 80 x 86 processor provides an additional nonprogrammable register that is, a register that cannot be set by a programmer for each of the six programmable segmentation registers. Each nonprogrammable register contains the 8-byte Segment Descriptor (described in the previous section) specified by the Segment Selector contained in the corresponding segmentation register . Every time a Segment Selector is loaded in a segmentation register , the corresponding Segment Descriptor is loaded from memory into the matching nonprogrammable CPU register. From then on, translations of logical addresses referring to that segment can be performed without accessing the GDT or LDT stored in main memory; the processor can refer only directly to the CPU register containing the Segment Descriptor. Accesses to the GDT or LDT are necessary only when the contents of the segmentation registers change (see Figure 2-4). Any Segment Selector includes three fields that are described in Table 2-2. Table 2-2. Segment Selector fields Field name Description index Identifies the Segment Descriptor entry contained in the GDT or in the LDT (described further in the text following this table). TI Table Indicator : specifies whether the Segment Descriptor is included in the GDT (TI = 0) or in the LDT (TI = 1). RPL Requestor Privilege Level : specifies the Current Privilege Level of the CPU when the corresponding Segment Selector is loaded into the cs register; it also may be used to selectively weaken the processor privilege level when accessing data segments (see Intel documentation for details). Because a Segment Descriptor is 8 bytes long, its relative address inside the GDT or the LDT is obtained by multiplying the 13-bit index field of the Segment Selector by 8. For instance, if the GDT is at 0x00020000 (the value stored in the gdtr register) and the index specified by the Segment Selector is 2, the address of the corresponding Segment Descriptor is 0x00020000 + (2 x 8) , or 0x00020010 . 2.2.4. Segmentation Unit Figure 2-5 shows in detail how a logical address is translated into a corresponding linear address . The segmentation unit performs the following operations: Examines the TI field of the Segment Selector to determine which Descriptor Table stores the Segment Descriptor . This field indicates that the Descriptor is either in the GDT (in which case the segmentation unit gets the base linear address of the GDT from the gdtr register) or in the active LDT (in which case the segmentation unit gets the base linear address of that LDT from the ldtr register). Computes the address of the Segment Descriptor from the index field of the Segment Selector. The index field is multiplied by 8 (the size of a Segment Descriptor), and the result is added to the content of the gdtr or ldtr register. Adds the offset of the logical address to the Base field of the Segment Descriptor, thus obtaining the linear address. Notice that, thanks to the nonprogrammable registers associated with the segmentation registers, the first two operations need to be performed only when a segmentation register has been changed.","title":"2.2-Segmentation-in-Hardware"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.2-Segmentation-in-Hardware/#22#segmentation#in#hardware","text":"Starting with the 80286 model, Intel microprocessors perform address translation in two different ways called real mode and protected mode . We'll focus in the next sections on address translation when protected mode is enabled. Real mode exists mostly to maintain processor compatibility with older models and to allow the operating system to bootstrap (see Appendix A for a short description of real mode).","title":"2.2. Segmentation in Hardware"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.2-Segmentation-in-Hardware/#221#segment#selectors#and#segmentation#registers","text":"A logical address consists of two parts: a segment identifier and an offset that specifies the relative address within the segment. The segment identifier is a 16-bit field called the Segment Selector (see Figure 2-2), while the offset is a 32-bit field. We'll describe the fields of Segment Selectors in the section \"Fast Access to Segment Descriptors\" later in this chapter. SUMMARY : \u4ece\u4e0a\u9762\u7684\u4ecb\u7ecd\u6765\u770b\uff0c\u5730\u5740\u7684\u957f\u5ea6\u662f\uff1a16 + 32 = 48 SUMMARY : \u4ece\u56fe\u4e2d\u53ef\u4ee5\u770b\u51fa\uff0cSegment Selector\u9664\u4e86\u5305\u542b\u6709table index\u4e4b\u5916\uff0c\u8fd8\u5305\u542b\u6709\u5176\u4ed6\u7684\u4fe1\u606f\uff1b To make it easy to retrieve segment selectors quickly, the processor provides segmentation registers whose only purpose is to hold Segment Selectors; these registers are called cs , ss , ds , es , fs , and gs . Although there are only six of them, a program can reuse the same segmentation register for different purposes by saving its content in memory and then restoring it later. Three of the six segmentation registers have specific purposes: cs The code segment register, which points to a segment containing program instructions ss The stack segment register, which points to a segment containing the current program stack ds The data segment register, which points to a segment containing global and static data The remaining three segmentation registers are general purpose and may refer to arbitrary data segments. The cs register has another important function: it includes a 2-bit field that specifies the Current Privilege Level (CPL) of the CPU. The value 0 denotes the highest privilege level, while the value 3 denotes the lowest one. Linux uses only levels 0 and 3, which are respectively called Kernel Mode and User Mode .","title":"2.2.1. Segment Selectors and Segmentation Registers"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.2-Segmentation-in-Hardware/#222#segment#descriptors","text":"Each segment is represented by an 8-byte Segment Descriptor that describes the segment characteristics. Segment Descriptors are stored either in the Global Descriptor Table ( GDT ) or in the Local Descriptor Table( LDT ) . Usually only one GDT is defined, while each process is permitted to have its own LDT if it needs to create additional segments besides those stored in the GDT . The address and size of the GDT in main memory are contained in the gdtr control register, while the address and size of the currently used LDT are contained in the ldtr control register. Figure 2-3 illustrates the format of a Segment Descriptor ; the meaning of the various fields is explained in Table 2-1. Table 2-1. Segment Descriptor fields Field name Description Base Contains the linear address of the first byte of the segment. G Granularity flag : if it is cleared (equal to 0), the segment size is expressed in bytes; otherwise, it is expressed in multiples of 4096 bytes. Limit Holds the offset of the last memory cell in the segment, thus binding the segment length. When G is set to 0, the size of a segment may vary between 1 byte and 1 MB; otherwise, it may vary between 4 KB and 4 GB. S System flag : if it is cleared, the segment is a system segment that stores critical data structures such as the Local Descriptor Table ; otherwise, it is a normal code or data segment. Type Characterizes the segment type and its access rights (see the text that follows this table). DPL Descriptor Privilege Level: used to restrict accesses to the segment. It represents the minimal CPU privilege level requested for accessing the segment. Therefore, a segment with its DPL set to 0 is accessible only when the CPL is 0 that is, in Kernel Mode while a segment with its DPL set to 3 is accessible with every CPL value. P Segment-Present flag : is equal to 0 if the segment is not stored currently in main memory. Linux always sets this flag (bit 47) to 1, because it never swaps out whole segments to disk. There are several types of segments, and thus several types of Segment Descriptors . The following list shows the types that are widely used in Linux. Code Segment Descriptor Indicates that the Segment Descriptor refers to a code segment; it may be included either in the GDT or in the LDT . The descriptor has the S flag set (non-system segment). Data Segment Descriptor Indicates that the Segment Descriptor refers to a data segment ; it may be included either in the GDT or in the LDT . The descriptor has the S flag set. Stack segments are implemented by means of generic data segments. Task State Segment Descriptor (TSSD) Indicates that the Segment Descriptor refers to a Task State Segment (TSS) that is, a segment used to save the contents of the processor registers (see the section \"Task State Segment\" in Chapter 3); it can appear only in the GDT. The corresponding Type field has the value 11 or 9, depending on whether the corresponding process is currently executing on a CPU. The S flag of such descriptors is set to 0. SUMMARY : \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6ca1\u6709stack segment descriptor\uff1b\u6839\u636e\u7b2c2.3\u7ae0\u7684\u5185\u5bb9\u6765\u770b\uff0c\u8fd9\u662f\u56e0\u4e3astack segment\u662f inside data segment\u7684\uff1b","title":"2.2.2. Segment Descriptors"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.2-Segmentation-in-Hardware/#223#fast#access#to#segment#descriptors","text":"We recall that logical addresses consist of a 16-bit Segment Selector and a 32-bit Offset, and that segmentation registers store only the Segment Selector. To speed up the translation of logical addresses into linear addresses , the 80 x 86 processor provides an additional nonprogrammable register that is, a register that cannot be set by a programmer for each of the six programmable segmentation registers. Each nonprogrammable register contains the 8-byte Segment Descriptor (described in the previous section) specified by the Segment Selector contained in the corresponding segmentation register . Every time a Segment Selector is loaded in a segmentation register , the corresponding Segment Descriptor is loaded from memory into the matching nonprogrammable CPU register. From then on, translations of logical addresses referring to that segment can be performed without accessing the GDT or LDT stored in main memory; the processor can refer only directly to the CPU register containing the Segment Descriptor. Accesses to the GDT or LDT are necessary only when the contents of the segmentation registers change (see Figure 2-4). Any Segment Selector includes three fields that are described in Table 2-2. Table 2-2. Segment Selector fields Field name Description index Identifies the Segment Descriptor entry contained in the GDT or in the LDT (described further in the text following this table). TI Table Indicator : specifies whether the Segment Descriptor is included in the GDT (TI = 0) or in the LDT (TI = 1). RPL Requestor Privilege Level : specifies the Current Privilege Level of the CPU when the corresponding Segment Selector is loaded into the cs register; it also may be used to selectively weaken the processor privilege level when accessing data segments (see Intel documentation for details). Because a Segment Descriptor is 8 bytes long, its relative address inside the GDT or the LDT is obtained by multiplying the 13-bit index field of the Segment Selector by 8. For instance, if the GDT is at 0x00020000 (the value stored in the gdtr register) and the index specified by the Segment Selector is 2, the address of the corresponding Segment Descriptor is 0x00020000 + (2 x 8) , or 0x00020010 .","title":"2.2.3. Fast Access to Segment Descriptors"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.2-Segmentation-in-Hardware/#224#segmentation#unit","text":"Figure 2-5 shows in detail how a logical address is translated into a corresponding linear address . The segmentation unit performs the following operations: Examines the TI field of the Segment Selector to determine which Descriptor Table stores the Segment Descriptor . This field indicates that the Descriptor is either in the GDT (in which case the segmentation unit gets the base linear address of the GDT from the gdtr register) or in the active LDT (in which case the segmentation unit gets the base linear address of that LDT from the ldtr register). Computes the address of the Segment Descriptor from the index field of the Segment Selector. The index field is multiplied by 8 (the size of a Segment Descriptor), and the result is added to the content of the gdtr or ldtr register. Adds the offset of the logical address to the Base field of the Segment Descriptor, thus obtaining the linear address. Notice that, thanks to the nonprogrammable registers associated with the segmentation registers, the first two operations need to be performed only when a segmentation register has been changed.","title":"2.2.4. Segmentation Unit"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.3-Segmentation-in-Linux/","text":"2.3. Segmentation in Linux 2.3.1. The Linux GDT \u8865\u5145\u5185\u5bb9 Segmentation in Linux : Segmentation & Paging are redundant? A Does Linux not use segmentation but only paging? A A x86 memory segmentation Later developments 2.3. Segmentation in Linux Segmentation has been included in 80 x 86 microprocessors to encourage programmers to split their applications into logically related entities, such as subroutines or global and local data areas. However, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons: Memory management is simpler when all processes use the same segment register values that is, when they share the same set of linear addresses . One of the design objectives of Linux is portability to a wide range of architectures; RISC architectures in particular have limited support for segmentation. The 2.6 version of Linux uses segmentation only when required by the 80 x 86 architecture. All Linux processes running in User Mode use the same pair of segments to address instructions and data. These segments are called user code segment and user data segment , respectively. Similarly, all Linux processes running in Kernel Mode use the same pair of segments to address instructions and data: they are called kernel code segment and kernel data segment , respectively. Table 2-3 shows the values of the Segment Descriptor fields for these four crucial segments. Notice that the linear addresses associated with such segments all start at 0 and reach the addressing limit of 2^{32} -1 2^{32} -1 . This means that all processes, either in User Mode or in Kernel Mode, may use the same logical addresses. SUMMARY : \u4e0a\u8ff0\u65ad\u8a00\u975e\u5e38\u5177\u6709\u4ef7\u503c Another important consequence of having all segments start at 0x00000000 is that in Linux, logical addresses coincide with linear addresses; that is, the value of the Offset field of a logical address always coincides with the value of the corresponding linear address . As stated earlier, the Current Privilege Level of the CPU indicates whether the processor is in User or Kernel Mode and is specified by the RPL field of the Segment Selector stored in the cs register. Whenever the CPL is changed, some segmentation registers must be correspondingly updated. For instance, when the CPL is equal to 3 (User Mode), the ds register must contain the Segment Selector of the user data segment, but when the CPL is equal to 0, the ds register must contain the Segment Selector of the kernel data segment. A similar situation occurs for the ss register. It must refer to a User Mode stack inside the user data segment when the CPL is 3, and it must refer to a Kernel Mode stack inside the kernel data segment when the CPL is 0. When switching from User Mode to Kernel Mode, Linux always makes sure that the ss register contains the Segment Selector of the kernel data segment . SUMMARY : stack\u662finside data segment\u7684\uff0c\u5e76\u4e14\u5b83\u4eec\u5171\u7528\u540c\u4e00\u4e2adescriptor\uff1b When saving a pointer to an instruction or to a data structure, the kernel does not need to store the Segment Selector component of the logical address , because the ss register contains the current Segment Selector . As an example, when the kernel invokes a function, it executes a call assembly language instruction specifying just the Offset component of its logical address; the Segment Selector is implicitly selected as the one referred to by the cs register. Because there is just one segment of type \"executable in Kernel Mode,\" namely the code segment identified by __KERNEL_CS , it is sufficient to load __ KERNEL_CS into cs whenever the CPU switches to Kernel Mode. The same argument goes for pointers to kernel data structures (implicitly using the ds register), as well as for pointers to user data structures (the kernel explicitly uses the es register). SUMMARY : \u6ca1\u6709\u8bfb\u61c2 Besides the four segments just described, Linux makes use of a few other specialized segments. We'll introduce them in the next section while describing the Linux GDT . 2.3.1. The Linux GDT In uniprocessor systems there is only one GDT , while in multiprocessor systems there is one GDT for every CPU in the system. All GDT s are stored in the cpu_gdt_table array, while the addresses and sizes of the GDT s (used when initializing the gdtr registers) are stored in the cpu_gdt_descr array. If you look in the Source Code Index, you can see that these symbols are defined in the file arch/i386/kernel/head.S . Every macro, function, and other symbol in this book is listed in the Source Code Index, so you can quickly find it in the source code. \u8865\u5145\u5185\u5bb9 Segmentation in Linux : Segmentation & Paging are redundant? I'm reading \"Understanding Linux Kernel\". This is the snippet that explains how Linux uses Segmentation which I didn't understand. Segmentation has been included in 80 x 86 microprocessors to encourage programmers to split their applications into logically related entities, such as subroutines or global and local data areas. However, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant , because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons: Memory management is simpler when all processes use the same segment register values that is, when they share the same set of linear addresses. One of the design objectives of Linux is portability to a wide range of architectures; RISC architectures in particular have limited support for segmentation. All Linux processes running in User Mode use the same pair of segments to address instructions and data. These segments are called user code segment and user data segment , respectively. Similarly, all Linux processes running in Kernel Mode use the same pair of segments to address instructions and data: they are called kernel code segment and kernel data segment , respectively. Table 2-3 shows the values of the Segment Descriptor fields for these four crucial segments. I'm unable to understand 1 st and last paragraph. A The 80x86 family of CPUs generate a real address by adding the contents of a CPU register called a segment register to that of the program counter. Thus by changing the segment register contents you can change the physical addresses that the program accesses. Paging does something similar by mapping the same virtual address to different real addresses . Linux using uses the latter - the segment registers for Linux processes will always have the same unchanging contents. +1. Linux, and everyone else too nowadays. \u2013 Billy ONeal Jun 12 '10 at 15:14 7 In protected mode it's not actually the contents of the segment register itself that is added to addresses; the segment register contains a reference to a segment descriptor (stored in memory, in a descriptor table), and one of the fields of the segment descriptor is the base address of the segment, which is added to the offset to generate a linear address. \u2013 caf Jun 16 '10 at 7:42 Segmentation was dropped in x86-64 architecture (or amd64 is Linux calls it). This newer architecture uses the flat memory model. \u2013 hebbo May 19 '14 at 3:43 @caf Thanks for the elaboration about protected mode. Here's more info about the different CPU modes for those who are curious. \u2013 GDP2 Nov 12 '17 at 20:18 Does Linux not use segmentation but only paging? The Linux Programming Interface shows the layout of a virtual address space of a process. Is each region in the diagram a segment? From Understanding The Linux Kernel , is it correct that the following means that the segmentation unit in MMU maps the segments and offsets within segments into the virtual memory address, and the paging unit then maps the virtual memory address to the physical memory address? The Memory Management Unit (MMU) transforms a logical address into a linear address by means of a hardware circuit called a segmentation unit; subsequently, a second hardware circuit called a paging unit transforms the linear address into a physical address (see Figure 2-1). Then why does it say that Linux doesn't use segmentation but only paging? Segmentation has been included in 80x86 microprocessors to encourage programmers to split their applications into logically related entities, such as subroutines or global and local data areas. However, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons: \u2022 Memory management is simpler when all processes use the same segment register values\u2014that is, when they share the same set of linear addresses. \u2022 One of the design objectives of Linux is portability to a wide range of architectures; RISC architectures, in particular, have limited support for segmentation. The 2.6 version of Linux uses segmentation only when required by the 80x86 architecture. A The x86-64 architecture does not use segmentation in long mode (64-bit mode). Four of the segment registers: CS, SS, DS, and ES are forced to 0, and the limit to 2^64. https://en.wikipedia.org/wiki/X86_memory_segmentation#Later_developments It is no longer possible for the OS to limit which ranges of the \"linear addresses\" are available. Therefore it cannot use segmentation for memory protection; it must rely entirely on paging. Do not worry about the details of x86 CPUs which would only apply when running in the legacy 32-bit modes. Linux for the 32-bit modes is not used as much. It may even be considered \"in a state of benign neglect for several years\". See 32-Bit x86 support in Fedora [LWN.net, 2017]. (It happens that 32-bit Linux does not use segmentation either. But you don't need to trust me on that, you can just ignore it :-). A As the x86 has segments, it is not possible to not use them. But both cs (code segment) and ds (data segment) base addresses are set to zero, so the segmentation is not really used. An exception is thread local data, one of the normally unused segment registers points to thread local data . But that is mainly to avoid reserving one of the general purpose registers for this task. It doesn't say that Linux doesn't use segmentation on the x86, as that would not be possible. You already highlighted one part, Linux uses segmentation in a very limited way . The second part is Linux uses segmentation only when required by the 80x86 architecture You already quoted the reasons, paging is easier and more portable. x86 memory segmentation Later developments","title":"2.3-Segmentation-in-Linux"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.3-Segmentation-in-Linux/#23#segmentation#in#linux","text":"Segmentation has been included in 80 x 86 microprocessors to encourage programmers to split their applications into logically related entities, such as subroutines or global and local data areas. However, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons: Memory management is simpler when all processes use the same segment register values that is, when they share the same set of linear addresses . One of the design objectives of Linux is portability to a wide range of architectures; RISC architectures in particular have limited support for segmentation. The 2.6 version of Linux uses segmentation only when required by the 80 x 86 architecture. All Linux processes running in User Mode use the same pair of segments to address instructions and data. These segments are called user code segment and user data segment , respectively. Similarly, all Linux processes running in Kernel Mode use the same pair of segments to address instructions and data: they are called kernel code segment and kernel data segment , respectively. Table 2-3 shows the values of the Segment Descriptor fields for these four crucial segments. Notice that the linear addresses associated with such segments all start at 0 and reach the addressing limit of 2^{32} -1 2^{32} -1 . This means that all processes, either in User Mode or in Kernel Mode, may use the same logical addresses. SUMMARY : \u4e0a\u8ff0\u65ad\u8a00\u975e\u5e38\u5177\u6709\u4ef7\u503c Another important consequence of having all segments start at 0x00000000 is that in Linux, logical addresses coincide with linear addresses; that is, the value of the Offset field of a logical address always coincides with the value of the corresponding linear address . As stated earlier, the Current Privilege Level of the CPU indicates whether the processor is in User or Kernel Mode and is specified by the RPL field of the Segment Selector stored in the cs register. Whenever the CPL is changed, some segmentation registers must be correspondingly updated. For instance, when the CPL is equal to 3 (User Mode), the ds register must contain the Segment Selector of the user data segment, but when the CPL is equal to 0, the ds register must contain the Segment Selector of the kernel data segment. A similar situation occurs for the ss register. It must refer to a User Mode stack inside the user data segment when the CPL is 3, and it must refer to a Kernel Mode stack inside the kernel data segment when the CPL is 0. When switching from User Mode to Kernel Mode, Linux always makes sure that the ss register contains the Segment Selector of the kernel data segment . SUMMARY : stack\u662finside data segment\u7684\uff0c\u5e76\u4e14\u5b83\u4eec\u5171\u7528\u540c\u4e00\u4e2adescriptor\uff1b When saving a pointer to an instruction or to a data structure, the kernel does not need to store the Segment Selector component of the logical address , because the ss register contains the current Segment Selector . As an example, when the kernel invokes a function, it executes a call assembly language instruction specifying just the Offset component of its logical address; the Segment Selector is implicitly selected as the one referred to by the cs register. Because there is just one segment of type \"executable in Kernel Mode,\" namely the code segment identified by __KERNEL_CS , it is sufficient to load __ KERNEL_CS into cs whenever the CPU switches to Kernel Mode. The same argument goes for pointers to kernel data structures (implicitly using the ds register), as well as for pointers to user data structures (the kernel explicitly uses the es register). SUMMARY : \u6ca1\u6709\u8bfb\u61c2 Besides the four segments just described, Linux makes use of a few other specialized segments. We'll introduce them in the next section while describing the Linux GDT .","title":"2.3. Segmentation in Linux"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.3-Segmentation-in-Linux/#231#the#linux#gdt","text":"In uniprocessor systems there is only one GDT , while in multiprocessor systems there is one GDT for every CPU in the system. All GDT s are stored in the cpu_gdt_table array, while the addresses and sizes of the GDT s (used when initializing the gdtr registers) are stored in the cpu_gdt_descr array. If you look in the Source Code Index, you can see that these symbols are defined in the file arch/i386/kernel/head.S . Every macro, function, and other symbol in this book is listed in the Source Code Index, so you can quickly find it in the source code.","title":"2.3.1. The Linux GDT"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.3-Segmentation-in-Linux/#_1","text":"","title":"\u8865\u5145\u5185\u5bb9"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.3-Segmentation-in-Linux/#segmentation#in#linux#segmentation#paging#are#redundant","text":"I'm reading \"Understanding Linux Kernel\". This is the snippet that explains how Linux uses Segmentation which I didn't understand. Segmentation has been included in 80 x 86 microprocessors to encourage programmers to split their applications into logically related entities, such as subroutines or global and local data areas. However, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant , because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons: Memory management is simpler when all processes use the same segment register values that is, when they share the same set of linear addresses. One of the design objectives of Linux is portability to a wide range of architectures; RISC architectures in particular have limited support for segmentation. All Linux processes running in User Mode use the same pair of segments to address instructions and data. These segments are called user code segment and user data segment , respectively. Similarly, all Linux processes running in Kernel Mode use the same pair of segments to address instructions and data: they are called kernel code segment and kernel data segment , respectively. Table 2-3 shows the values of the Segment Descriptor fields for these four crucial segments. I'm unable to understand 1 st and last paragraph.","title":"Segmentation in Linux : Segmentation &amp; Paging are redundant?"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.3-Segmentation-in-Linux/#a","text":"The 80x86 family of CPUs generate a real address by adding the contents of a CPU register called a segment register to that of the program counter. Thus by changing the segment register contents you can change the physical addresses that the program accesses. Paging does something similar by mapping the same virtual address to different real addresses . Linux using uses the latter - the segment registers for Linux processes will always have the same unchanging contents. +1. Linux, and everyone else too nowadays. \u2013 Billy ONeal Jun 12 '10 at 15:14 7 In protected mode it's not actually the contents of the segment register itself that is added to addresses; the segment register contains a reference to a segment descriptor (stored in memory, in a descriptor table), and one of the fields of the segment descriptor is the base address of the segment, which is added to the offset to generate a linear address. \u2013 caf Jun 16 '10 at 7:42 Segmentation was dropped in x86-64 architecture (or amd64 is Linux calls it). This newer architecture uses the flat memory model. \u2013 hebbo May 19 '14 at 3:43 @caf Thanks for the elaboration about protected mode. Here's more info about the different CPU modes for those who are curious. \u2013 GDP2 Nov 12 '17 at 20:18","title":"A"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.3-Segmentation-in-Linux/#does#linux#not#use#segmentation#but#only#paging","text":"The Linux Programming Interface shows the layout of a virtual address space of a process. Is each region in the diagram a segment? From Understanding The Linux Kernel , is it correct that the following means that the segmentation unit in MMU maps the segments and offsets within segments into the virtual memory address, and the paging unit then maps the virtual memory address to the physical memory address? The Memory Management Unit (MMU) transforms a logical address into a linear address by means of a hardware circuit called a segmentation unit; subsequently, a second hardware circuit called a paging unit transforms the linear address into a physical address (see Figure 2-1). Then why does it say that Linux doesn't use segmentation but only paging? Segmentation has been included in 80x86 microprocessors to encourage programmers to split their applications into logically related entities, such as subroutines or global and local data areas. However, Linux uses segmentation in a very limited way. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces. Linux prefers paging to segmentation for the following reasons: \u2022 Memory management is simpler when all processes use the same segment register values\u2014that is, when they share the same set of linear addresses. \u2022 One of the design objectives of Linux is portability to a wide range of architectures; RISC architectures, in particular, have limited support for segmentation. The 2.6 version of Linux uses segmentation only when required by the 80x86 architecture.","title":"Does Linux not use segmentation but only paging?"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.3-Segmentation-in-Linux/#a_1","text":"The x86-64 architecture does not use segmentation in long mode (64-bit mode). Four of the segment registers: CS, SS, DS, and ES are forced to 0, and the limit to 2^64. https://en.wikipedia.org/wiki/X86_memory_segmentation#Later_developments It is no longer possible for the OS to limit which ranges of the \"linear addresses\" are available. Therefore it cannot use segmentation for memory protection; it must rely entirely on paging. Do not worry about the details of x86 CPUs which would only apply when running in the legacy 32-bit modes. Linux for the 32-bit modes is not used as much. It may even be considered \"in a state of benign neglect for several years\". See 32-Bit x86 support in Fedora [LWN.net, 2017]. (It happens that 32-bit Linux does not use segmentation either. But you don't need to trust me on that, you can just ignore it :-).","title":"A"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.3-Segmentation-in-Linux/#a_2","text":"As the x86 has segments, it is not possible to not use them. But both cs (code segment) and ds (data segment) base addresses are set to zero, so the segmentation is not really used. An exception is thread local data, one of the normally unused segment registers points to thread local data . But that is mainly to avoid reserving one of the general purpose registers for this task. It doesn't say that Linux doesn't use segmentation on the x86, as that would not be possible. You already highlighted one part, Linux uses segmentation in a very limited way . The second part is Linux uses segmentation only when required by the 80x86 architecture You already quoted the reasons, paging is easier and more portable.","title":"A"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.3-Segmentation-in-Linux/#x86#memory#segmentation#later#developments","text":"","title":"x86 memory segmentation Later developments"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.4-Paging-in-Hardware/","text":"2.4. Paging in Hardware The paging unit translates linear addresses into physical ones . One key task in the unit is to check the requested access type against the access rights of the linear address . If the memory access is not valid, it generates a Page Fault exception (see Chapter 4 and Chapter 8). For the sake of efficiency, linear addresses are grouped in fixed-length intervals called pages ; contiguous linear addresses within a page are mapped into contiguous physical addresses. In this way, the kernel can specify the physical address and the access rights of a page instead of those of all the linear addresses included in it. Following the usual convention, we shall use the term \"page\" to refer both to a set of linear addresses and to the data contained in this group of addresses. The paging unit thinks of all RAM as partitioned into fixed-length page frames (sometimes referred to as physical pages ). Each page frame contains a page that is, the length of a page frame coincides with that of a page . A page frame is a constituent of main memory, and hence it is a storage area. It is important to distinguish a page from a page frame ; the former is just a block of data, which may be stored in any page frame or on disk . The data structures that map linear to physical addresses are called page tables ; they are stored in main memory and must be properly initialized by the kernel before enabling the paging unit . NOTE: \u6709\u5fc5\u8981\u68b3\u7406\u4e00\u4e0bpaging unit\u548cpage tables\u4e4b\u95f4\u7684\u5173\u7cfb\uff1a\u4e24\u8005\u7ec4\u5408\u8d77\u6765\u5b9e\u73b0\u5c06linear address\u8f6c\u6362\u4e3aphysical address\uff0cpaging unit\u9700\u8981\u4f9d\u8d56\u4e8epage tables\u4e2d\u7684\u6570\u636e\u3002 Starting with the 80386, all 80 x 86 processors support paging ; it is enabled by setting the PG flag of a control register named cr0 . When PG = 0 , linear addresses are interpreted as physical addresses . 2.4.1. Regular Paging Starting with the 80386, the paging unit of Intel processors handles 4 KB pages. The 32 bits of a linear address are divided into three fields: Directory The most significant 10 bits Table The intermediate 10 bits Offset The least significant 12 bits The translation of linear addresses is accomplished in two steps, each based on a type of translation table . The first translation table is called the Page Directory , and the second is called the Page Table . [ * ] [ * ] In the discussion that follows, the lowercase \"page table\" term denotes any page storing the mapping between linear and physical addresses, while the capitalized \"Page Table\" term denotes a page in the last level of page tables. The aim of this two-level scheme is to reduce the amount of RAM required for per-process Page Tables . If a simple one-level Page Table was used, then it would require up to 220 entries (i.e., at 4 bytes per entry, 4 MB of RAM) to represent the Page Table for each process (if the process used a full 4 GB linear address space), even though a process does not use all addresses in that range. The two-level scheme reduces the memory by requiring Page Tables only for those virtual memory regions actually used by a process. Each active process must have a Page Directory assigned to it. However, there is no need to allocate RAM for all Page Tables of a process at once; it is more efficient to allocate RAM for a Page Table only when the process effectively needs it. NOTE: \u7efc\u5408\u4e0a\u9762\u7684\u5185\u5bb9\u53ef\u4ee5\u77e5\u9053\uff0cpage table\u7684\u5b9e\u73b0\u53ef\u4ee5\u4e0e\u4e24\u79cd\u65b9\u6848\uff1a \u4f7f\u7528\u7ebf\u6027\u7ed3\u6784\uff0c\u4e5f\u5c31\u662f\u4e0a\u9762\u6240\u8bf4\u7684one-level page table \u4f7f\u7528multi-level\u7ed3\u6784\uff0cmulti-level\u7ed3\u6784\u5176\u5b9e\u672c\u8d28\u4e0a\u662fTree\u7ed3\u6784\uff0c\u4e0a\u8ff0two-level scheme\u6240\u5bf9\u5e94\u7684page table\u7684\u7ed3\u6784\u5c31\u662f\u4e00\u4e2atwo-level\u7ed3\u6784\uff0c\u53c2\u89c1Figure 2-7\u3002\u5b83\u7684Tree\u7ed3\u6784\u662f\u8fd9\u6837\u7684\uff1a cr3 \u76f8\u5f53\u4e8eroot\u8282\u70b9\uff0c\u8fd9\u4e2aroot\u8282\u70b9\u53ea\u6709\u4e00\u4e2a\u5b50\u8282\u70b9Page Directory\uff0cPage Directory\u5171\u6709 2^{10} 2^{10} \u4e2aentry\uff0c\u6bcf\u4e2aentry\u6307\u5411\u4e00\u4e2aPage Table\uff0c\u5373Page Directory\u5171\u6709 2^{10} 2^{10} \u4e2a\u5b50\u8282\u70b9\uff0c\u5b50\u8282\u70b9\u7684\u7c7b\u578b\u662fPage Table\u3002\u6bcf\u4e2aPage Table\u6709 2^{10} 2^{10} \u4e2apage\uff0c\u5373Page Table\u6709 2^{10} 2^{10} \u4e2a\u5b50\u8282\u70b9\uff0c\u5b50\u8282\u70b9\u7684\u7c7b\u578b\u662fpage\uff0cpage\u6ca1\u6709\u5b50\u8282\u70b9\uff0c\u6240\u4ee5\u5b83\u662fleaf\u3002\u5728multi-level\u7ed3\u6784\u7684page table\u4e2d\u8fdb\u884c\u6620\u5c04\u7684\u8fc7\u7a0b\u76f8\u5f53\u4e8e\u4eceroot\u8282\u70b9\u6cbf\u7740\u5185\u8282\u70b9\u5230leaf\u3002 \u6bcf\u4e2aprocess\u6709\u4e00\u4e2a**Page Directory** \uff0c\u800c\u4e0d\u662f**Page Directory** \u4e2d\u7684\u4e00\u6761\u8bb0\u5f55\uff1b\u4e3a\u4ec0\u4e48two-level scheme\u80fd\u591f\u51cf\u5c11\u9700\u8981\u7684RAM\uff0c\u53c2\u89c1\u4e0b\u9762\u5185\u5bb9\uff1a Multilevel Paging in Operating System https://www.clear.rice.edu/comp425/slides/L31.pdf How does multi-level page table save memory space? The physical address of the Page Directory in use is stored in a control register named cr3 . The Directory field within the linear address determines the entry in the Page Directory that points to the proper Page Table . The address's Table field, in turn, determines the entry in the Page Table that contains the physical address of the page frame containing the page. The Offset field determines the relative position within the page frame (see Figure 2-7). Because it is 12 bits long, each page consists of 4096 bytes of data. Both the Directory and the Table fields are 10 bits long, so Page Directories and Page Tables can include up to 1,024\uff08 2^{10}=1024 2^{10}=1024 \uff09 entries. It follows that a Page Directory can address up to 1024 * 1024 * 4096=2^{32} 1024 * 1024 * 4096=2^{32} memory cells, as you'd expect in 32-bit addresses. The entries of Page Directories and Page Tables have the same structure. Each entry includes the following fields: Present flag If it is set, the referred-to page (or Page Table) is contained in main memory; if the flag is 0, the page is not contained in main memory and the remaining entry bits may be used by the operating system for its own purposes. If the entry of a Page Table or Page Directory needed to perform an address translation has the Present flag cleared, the paging unit stores the linear address in a control register named cr2 and generates exception 14: the Page Fault exception. (We will see in Chapter 17 how Linux uses this field.) NOTE: \u4ea7\u751f\u4e86Page Fault exception\u540e\uff0c\u5c31\u9700\u8981\u5c06demand page swap\u5230memory\u4e2d Field containing the 20 most significant bits of a page frame physical address Accessed flag Dirty flag 2.4.2. Extended Paging Starting with the Pentium model, 80 x 86 microprocessors introduce extended paging , which allows page frames to be 4 MB instead of 4 KB in size (see Figure 2-8). Extended paging is used to translate large contiguous linear address ranges into corresponding physical ones; in these cases, the kernel can do without intermediate Page Tables and thus save memory and preserve TLB entries (see the section \"Translation Lookaside Buffers (TLB)\"). 2.4.3. Hardware Protection Scheme 2.4.4. An Example of Regular Paging 2.4.5. The Physical Address Extension (PAE) Paging Mechanism 2.4.6. Paging for 64-bit Architectures 2.4.7. Hardware Cache 2.4.8. Translation Lookaside Buffers (TLB)","title":"2.4-Paging-in-Hardware"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.4-Paging-in-Hardware/#24#paging#in#hardware","text":"The paging unit translates linear addresses into physical ones . One key task in the unit is to check the requested access type against the access rights of the linear address . If the memory access is not valid, it generates a Page Fault exception (see Chapter 4 and Chapter 8). For the sake of efficiency, linear addresses are grouped in fixed-length intervals called pages ; contiguous linear addresses within a page are mapped into contiguous physical addresses. In this way, the kernel can specify the physical address and the access rights of a page instead of those of all the linear addresses included in it. Following the usual convention, we shall use the term \"page\" to refer both to a set of linear addresses and to the data contained in this group of addresses. The paging unit thinks of all RAM as partitioned into fixed-length page frames (sometimes referred to as physical pages ). Each page frame contains a page that is, the length of a page frame coincides with that of a page . A page frame is a constituent of main memory, and hence it is a storage area. It is important to distinguish a page from a page frame ; the former is just a block of data, which may be stored in any page frame or on disk . The data structures that map linear to physical addresses are called page tables ; they are stored in main memory and must be properly initialized by the kernel before enabling the paging unit . NOTE: \u6709\u5fc5\u8981\u68b3\u7406\u4e00\u4e0bpaging unit\u548cpage tables\u4e4b\u95f4\u7684\u5173\u7cfb\uff1a\u4e24\u8005\u7ec4\u5408\u8d77\u6765\u5b9e\u73b0\u5c06linear address\u8f6c\u6362\u4e3aphysical address\uff0cpaging unit\u9700\u8981\u4f9d\u8d56\u4e8epage tables\u4e2d\u7684\u6570\u636e\u3002 Starting with the 80386, all 80 x 86 processors support paging ; it is enabled by setting the PG flag of a control register named cr0 . When PG = 0 , linear addresses are interpreted as physical addresses .","title":"2.4. Paging in Hardware"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.4-Paging-in-Hardware/#241#regular#paging","text":"Starting with the 80386, the paging unit of Intel processors handles 4 KB pages. The 32 bits of a linear address are divided into three fields: Directory The most significant 10 bits Table The intermediate 10 bits Offset The least significant 12 bits The translation of linear addresses is accomplished in two steps, each based on a type of translation table . The first translation table is called the Page Directory , and the second is called the Page Table . [ * ] [ * ] In the discussion that follows, the lowercase \"page table\" term denotes any page storing the mapping between linear and physical addresses, while the capitalized \"Page Table\" term denotes a page in the last level of page tables. The aim of this two-level scheme is to reduce the amount of RAM required for per-process Page Tables . If a simple one-level Page Table was used, then it would require up to 220 entries (i.e., at 4 bytes per entry, 4 MB of RAM) to represent the Page Table for each process (if the process used a full 4 GB linear address space), even though a process does not use all addresses in that range. The two-level scheme reduces the memory by requiring Page Tables only for those virtual memory regions actually used by a process. Each active process must have a Page Directory assigned to it. However, there is no need to allocate RAM for all Page Tables of a process at once; it is more efficient to allocate RAM for a Page Table only when the process effectively needs it. NOTE: \u7efc\u5408\u4e0a\u9762\u7684\u5185\u5bb9\u53ef\u4ee5\u77e5\u9053\uff0cpage table\u7684\u5b9e\u73b0\u53ef\u4ee5\u4e0e\u4e24\u79cd\u65b9\u6848\uff1a \u4f7f\u7528\u7ebf\u6027\u7ed3\u6784\uff0c\u4e5f\u5c31\u662f\u4e0a\u9762\u6240\u8bf4\u7684one-level page table \u4f7f\u7528multi-level\u7ed3\u6784\uff0cmulti-level\u7ed3\u6784\u5176\u5b9e\u672c\u8d28\u4e0a\u662fTree\u7ed3\u6784\uff0c\u4e0a\u8ff0two-level scheme\u6240\u5bf9\u5e94\u7684page table\u7684\u7ed3\u6784\u5c31\u662f\u4e00\u4e2atwo-level\u7ed3\u6784\uff0c\u53c2\u89c1Figure 2-7\u3002\u5b83\u7684Tree\u7ed3\u6784\u662f\u8fd9\u6837\u7684\uff1a cr3 \u76f8\u5f53\u4e8eroot\u8282\u70b9\uff0c\u8fd9\u4e2aroot\u8282\u70b9\u53ea\u6709\u4e00\u4e2a\u5b50\u8282\u70b9Page Directory\uff0cPage Directory\u5171\u6709 2^{10} 2^{10} \u4e2aentry\uff0c\u6bcf\u4e2aentry\u6307\u5411\u4e00\u4e2aPage Table\uff0c\u5373Page Directory\u5171\u6709 2^{10} 2^{10} \u4e2a\u5b50\u8282\u70b9\uff0c\u5b50\u8282\u70b9\u7684\u7c7b\u578b\u662fPage Table\u3002\u6bcf\u4e2aPage Table\u6709 2^{10} 2^{10} \u4e2apage\uff0c\u5373Page Table\u6709 2^{10} 2^{10} \u4e2a\u5b50\u8282\u70b9\uff0c\u5b50\u8282\u70b9\u7684\u7c7b\u578b\u662fpage\uff0cpage\u6ca1\u6709\u5b50\u8282\u70b9\uff0c\u6240\u4ee5\u5b83\u662fleaf\u3002\u5728multi-level\u7ed3\u6784\u7684page table\u4e2d\u8fdb\u884c\u6620\u5c04\u7684\u8fc7\u7a0b\u76f8\u5f53\u4e8e\u4eceroot\u8282\u70b9\u6cbf\u7740\u5185\u8282\u70b9\u5230leaf\u3002 \u6bcf\u4e2aprocess\u6709\u4e00\u4e2a**Page Directory** \uff0c\u800c\u4e0d\u662f**Page Directory** \u4e2d\u7684\u4e00\u6761\u8bb0\u5f55\uff1b\u4e3a\u4ec0\u4e48two-level scheme\u80fd\u591f\u51cf\u5c11\u9700\u8981\u7684RAM\uff0c\u53c2\u89c1\u4e0b\u9762\u5185\u5bb9\uff1a Multilevel Paging in Operating System https://www.clear.rice.edu/comp425/slides/L31.pdf How does multi-level page table save memory space? The physical address of the Page Directory in use is stored in a control register named cr3 . The Directory field within the linear address determines the entry in the Page Directory that points to the proper Page Table . The address's Table field, in turn, determines the entry in the Page Table that contains the physical address of the page frame containing the page. The Offset field determines the relative position within the page frame (see Figure 2-7). Because it is 12 bits long, each page consists of 4096 bytes of data. Both the Directory and the Table fields are 10 bits long, so Page Directories and Page Tables can include up to 1,024\uff08 2^{10}=1024 2^{10}=1024 \uff09 entries. It follows that a Page Directory can address up to 1024 * 1024 * 4096=2^{32} 1024 * 1024 * 4096=2^{32} memory cells, as you'd expect in 32-bit addresses. The entries of Page Directories and Page Tables have the same structure. Each entry includes the following fields: Present flag If it is set, the referred-to page (or Page Table) is contained in main memory; if the flag is 0, the page is not contained in main memory and the remaining entry bits may be used by the operating system for its own purposes. If the entry of a Page Table or Page Directory needed to perform an address translation has the Present flag cleared, the paging unit stores the linear address in a control register named cr2 and generates exception 14: the Page Fault exception. (We will see in Chapter 17 how Linux uses this field.) NOTE: \u4ea7\u751f\u4e86Page Fault exception\u540e\uff0c\u5c31\u9700\u8981\u5c06demand page swap\u5230memory\u4e2d Field containing the 20 most significant bits of a page frame physical address Accessed flag Dirty flag","title":"2.4.1. Regular Paging"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.4-Paging-in-Hardware/#242#extended#paging","text":"Starting with the Pentium model, 80 x 86 microprocessors introduce extended paging , which allows page frames to be 4 MB instead of 4 KB in size (see Figure 2-8). Extended paging is used to translate large contiguous linear address ranges into corresponding physical ones; in these cases, the kernel can do without intermediate Page Tables and thus save memory and preserve TLB entries (see the section \"Translation Lookaside Buffers (TLB)\").","title":"2.4.2. Extended Paging"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.4-Paging-in-Hardware/#243#hardware#protection#scheme","text":"","title":"2.4.3. Hardware Protection Scheme"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.4-Paging-in-Hardware/#244#an#example#of#regular#paging","text":"","title":"2.4.4. An Example of Regular Paging"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.4-Paging-in-Hardware/#245#the#physical#address#extension#pae#paging#mechanism","text":"","title":"2.4.5. The Physical Address Extension (PAE) Paging Mechanism"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.4-Paging-in-Hardware/#246#paging#for#64-bit#architectures","text":"","title":"2.4.6. Paging for 64-bit Architectures"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.4-Paging-in-Hardware/#247#hardware#cache","text":"","title":"2.4.7. Hardware Cache"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.4-Paging-in-Hardware/#248#translation#lookaside#buffers#tlb","text":"","title":"2.4.8. Translation Lookaside Buffers (TLB)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.5-Paging-in-Linux/","text":"2.5. Paging in Linux Linux adopts a common paging model that fits both 32-bit and 64-bit architectures. As explained in the earlier section \"Paging for 64-bit Architectures,\" two paging levels are sufficient for 32-bit architectures, while 64-bit architectures require a higher number of paging levels. Up to version 2.6.10, the Linux paging model consisted of three paging levels . Starting with version 2.6.11, a four-level paging model has been adopted. [ * ] The four types of page tables illustrated in Figure 2-12 are called: [ * ] This change has been made to fully support the linear address bit splitting used by the x86_64 platform (see Table 2-4). Page Global Directory Page Upper Directory Page Middle Directory Page Table Figure 2-12. The Linux paging model The Page Global Directory includes the addresses of several Page Upper Directories , which in turn include the addresses of several Page Middle Directories , which in turn include the addresses of several Page Tables . Each Page Table entry points to a page frame . Thus the linear address can be split into up to five parts. Figure 2-12 does not show the bit numbers, because the size of each part depends on the computer architecture. For 32-bit architectures with no Physical Address Extension , two paging levels are sufficient. Linux essentially eliminates the Page Upper Directory and the Page Middle Directory fields by saying that they contain zero bits. However, the positions of the Page Upper Directory and the Page Middle Directory in the sequence of pointers are kept so that the same code can work on 32-bit and 64-bit architectures. The kernel keeps a position for the Page Upper Directory and the Page Middle Directory by setting the number of entries in them to 1 and mapping these two entries into the proper entry of the Page Global Directory . Finally, for 64-bit architectures three or four levels of paging are used depending on the linear address bit splitting performed by the hardware (see Table 2-2). Linux's handling of processes relies heavily on paging . In fact, the automatic translation of linear addresses into physical ones makes the following design objectives feasible: Assign a different physical address space to each process, ensuring an efficient protection against addressing errors. Distinguish pages (groups of data) from page frames (physical addresses in main memory). This allows the same page to be stored in a page frame, then saved to disk and later reloaded in a different page frame. This is the basic ingredient of the virtual memory mechanism (see Chapter 17). In the remaining part of this chapter, we will refer for the sake of concreteness to the paging circuitry used by the 80 x 86 processors. As we will see in Chapter 9, each process has its own Page Global Directory and its own set of Page Tables . When a process switch occurs (see the section \"Process Switch\" in Chapter 3), Linux saves the cr3 control register in the descriptor of the process previously in execution and then loads cr3 with the value stored in the descriptor of the process to be executed next. Thus, when the new process resumes its execution on the CPU, the paging unit refers to the correct set of Page Tables . Mapping linear to physical addresses now becomes a mechanical task, although it is still somewhat complex. The next few sections of this chapter are a rather tedious list of functions and macros that retrieve information the kernel needs to find addresses and manage the tables; most of the functions are one or two lines long. You may want to only skim these sections now, but it is useful to know the role of these functions and macros, because you'll see them often in discussions throughout this book. 2.5.1. The Linear Address Fields The following macros simplify Page Table handling:","title":"2.5-Paging-in-Linux"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.5-Paging-in-Linux/#25#paging#in#linux","text":"Linux adopts a common paging model that fits both 32-bit and 64-bit architectures. As explained in the earlier section \"Paging for 64-bit Architectures,\" two paging levels are sufficient for 32-bit architectures, while 64-bit architectures require a higher number of paging levels. Up to version 2.6.10, the Linux paging model consisted of three paging levels . Starting with version 2.6.11, a four-level paging model has been adopted. [ * ] The four types of page tables illustrated in Figure 2-12 are called: [ * ] This change has been made to fully support the linear address bit splitting used by the x86_64 platform (see Table 2-4). Page Global Directory Page Upper Directory Page Middle Directory Page Table Figure 2-12. The Linux paging model The Page Global Directory includes the addresses of several Page Upper Directories , which in turn include the addresses of several Page Middle Directories , which in turn include the addresses of several Page Tables . Each Page Table entry points to a page frame . Thus the linear address can be split into up to five parts. Figure 2-12 does not show the bit numbers, because the size of each part depends on the computer architecture. For 32-bit architectures with no Physical Address Extension , two paging levels are sufficient. Linux essentially eliminates the Page Upper Directory and the Page Middle Directory fields by saying that they contain zero bits. However, the positions of the Page Upper Directory and the Page Middle Directory in the sequence of pointers are kept so that the same code can work on 32-bit and 64-bit architectures. The kernel keeps a position for the Page Upper Directory and the Page Middle Directory by setting the number of entries in them to 1 and mapping these two entries into the proper entry of the Page Global Directory . Finally, for 64-bit architectures three or four levels of paging are used depending on the linear address bit splitting performed by the hardware (see Table 2-2). Linux's handling of processes relies heavily on paging . In fact, the automatic translation of linear addresses into physical ones makes the following design objectives feasible: Assign a different physical address space to each process, ensuring an efficient protection against addressing errors. Distinguish pages (groups of data) from page frames (physical addresses in main memory). This allows the same page to be stored in a page frame, then saved to disk and later reloaded in a different page frame. This is the basic ingredient of the virtual memory mechanism (see Chapter 17). In the remaining part of this chapter, we will refer for the sake of concreteness to the paging circuitry used by the 80 x 86 processors. As we will see in Chapter 9, each process has its own Page Global Directory and its own set of Page Tables . When a process switch occurs (see the section \"Process Switch\" in Chapter 3), Linux saves the cr3 control register in the descriptor of the process previously in execution and then loads cr3 with the value stored in the descriptor of the process to be executed next. Thus, when the new process resumes its execution on the CPU, the paging unit refers to the correct set of Page Tables . Mapping linear to physical addresses now becomes a mechanical task, although it is still somewhat complex. The next few sections of this chapter are a rather tedious list of functions and macros that retrieve information the kernel needs to find addresses and manage the tables; most of the functions are one or two lines long. You may want to only skim these sections now, but it is useful to know the role of these functions and macros, because you'll see them often in discussions throughout this book.","title":"2.5. Paging in Linux"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/2.5-Paging-in-Linux/#251#the#linear#address#fields","text":"The following macros simplify Page Table handling:","title":"2.5.1. The Linear Address Fields"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/Chapter-2-Memory-Addressing/","text":"Chapter 2. Memory Addressing This chapter deals with addressing techniques. Luckily, an operating system is not forced to keep track of physical memory all by itself; today's microprocessors include several hardware circuits to make memory management both more efficient and more robust so that programming errors cannot cause improper accesses to memory outside the program. As in the rest of this book, we offer details in this chapter on how 80 x 86 microprocessors address memory chips and how Linux uses the available addressing circuits. You will find, we hope, that when you learn the implementation details on Linux's most popular platform you will better understand both the general theory of paging and how to research the implementation on other platforms. This is the first of three chapters related to memory management; Chapter 8 discusses how the kernel allocates main memory to itself, while Chapter 9 considers how linear addresses are assigned to processes . NOTE: \u76ee\u524dlinux\u91c7\u7528\u7684\u662f\u57fa\u4e8epage\u7684memory management\uff0c\u6240\u4ee5\u672c\u7ae0\u76842.2. Segmentation in Hardware\u548c2.3. Segmentation in Linux\u7701\u7565\u4e86\u3002","title":"Chapter-2-Memory-Addressing"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/Chapter-2-Memory-Addressing/#chapter#2#memory#addressing","text":"This chapter deals with addressing techniques. Luckily, an operating system is not forced to keep track of physical memory all by itself; today's microprocessors include several hardware circuits to make memory management both more efficient and more robust so that programming errors cannot cause improper accesses to memory outside the program. As in the rest of this book, we offer details in this chapter on how 80 x 86 microprocessors address memory chips and how Linux uses the available addressing circuits. You will find, we hope, that when you learn the implementation details on Linux's most popular platform you will better understand both the general theory of paging and how to research the implementation on other platforms. This is the first of three chapters related to memory management; Chapter 8 discusses how the kernel allocates main memory to itself, while Chapter 9 considers how linear addresses are assigned to processes . NOTE: \u76ee\u524dlinux\u91c7\u7528\u7684\u662f\u57fa\u4e8epage\u7684memory management\uff0c\u6240\u4ee5\u672c\u7ae0\u76842.2. Segmentation in Hardware\u548c2.3. Segmentation in Linux\u7701\u7565\u4e86\u3002","title":"Chapter 2. Memory Addressing"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/How-are-the-segment-registers-used-in-Linux/","text":"How are the segment registers (fs, gs, cs, ss, ds, es) used in Linux?","title":"[How are the segment registers (fs, gs, cs, ss, ds, es) used in Linux?](https://reverseengineering.stackexchange.com/questions/2006/how-are-the-segment-registers-fs-gs-cs-ss-ds-es-used-in-linux)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/How-are-the-segment-registers-used-in-Linux/#how#are#the#segment#registers#fs#gs#cs#ss#ds#es#used#in#linux","text":"","title":"How are the segment registers (fs, gs, cs, ss, ds, es) used in Linux?"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/Memory-Addresses-note/","text":"A logical address consists of two parts: a segment identifier and an offset that specifies the relative address within the segment. The segment identifier is a 16-bit field called the Segment Selector (see Figure 2-2), while the offset is a 32-bit field. the processor provides segmentation registers whose only purpose is to hold Segment Selectors SUMMARY : \u5728Segment Selector\u4e2d\u6709Request Privilege Level\u5b57\u6bb5\uff0cThe cs register has another important function: it includes a 2-bit field that specifies the Current Privilege Level (CPL) of the CPU. Segment Selector\u7684Request Privilege Level\u5b57\u6bb5\u4e0e cs register \u7684Current Privilege Level (CPL) \u5b57\u6bb5\u76f8\u5bf9\u5e94\uff1b\u53c2\u89c1Table 2-2. Segment Selector fields\uff0c\u5176\u4e2d\u6709\u8fd9\u6837\u7684\u4e00\u6bb5\u63cf\u8ff0\uff1a Requestor Privilege Level : specifies the Current Privilege Level of the CPU when the corresponding Segment Selector is loaded into the cs register; it also may be used to selectively weaken the processor privilege level when accessing data segments (see Intel documentation for details).","title":"Memory Addresses note"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/Multilevel-Paging-in-Operating-System/","text":"Multilevel Paging in Operating System Multilevel Paging in Operating System Prerequisite \u2013 Paging Multilevel Paging is a paging scheme which consist of two or more levels of page tables in a hierarchical manner. It is also known as hierarchical paging. The entries of the level 1 page table are pointers to a level 2 page table and entries of the level 2 page tables are pointers to a level 3 page table and so on. The entries of the last level page table are stores actual frame information. Level 1 contain single page table and address of that table is stored in PTBR (Page Table Base Register). Virtual address: In multilevel paging whatever may be levels of paging all the page tables will be stored in main memory.So it requires more than one memory access to get the physical address of page frame. One access for each level needed. Each page table entry except the last level page table entry contains base address of the next level page table. Reference to actual page frame: Reference to PTE in level 1 page table = PTBR value + Level 1 offset present in virtual address. Reference to PTE in level 2 page table = Base address (present in Level 1 PTE) + Level 2 offset (present in VA). Reference to PTE in level 3 page table= Base address (present in Level 2 PTE) + Level 3 offset (present in VA). Actual page frame address = PTE (present in level 3). Generally the page table size will be equal to the size of page. Assumptions: Byte addressable memory, and n is the number of bits used to represent virtual address. Important formula: Number of entries in page table: = (virtual address space size) / (page size) = Number of pages Virtual address space size: = 2^{n} B Size of page table: <>= (number of entries in page table)*(size of PTE) If page table size > desired size then create 1 more level. Disadvantage: Extra memory references to access address translation tables can slow programs down by a factor of two or more. Use translation look aside buffer (TLB) to speed up address translation by storing page table entries. Example: Q. Consider a virtual memory system with physical memory of 8GB, a page size of 8KB and 46 bit virtual address. Assume every page table exactly fits into a single page . If page table entry size is 4B then how many levels of page tables would be required. Explanation: Page size = 8KB = 2^{13} B Virtual address space size = 2^{46} B PTE = 4B = 2^2 B Number of pages or number of entries in page table, = (virtual address space size) / (page size) = 2^{46} B/2^{13} B = 2^{33} Size of page table, = (number of entries in page table)*(size of PTE) = 2^{33} * 2^2 B = 2^{35} B To create one more level, Size of page table > page size Number of page tables in last level, = 2^{35} B / 2^{13} B = 2^{22}","title":"Multilevel Paging in Operating System"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-2-Memory-Addressing/Multilevel-Paging-in-Operating-System/#multilevel#paging#in#operating#system","text":"Prerequisite \u2013 Paging Multilevel Paging is a paging scheme which consist of two or more levels of page tables in a hierarchical manner. It is also known as hierarchical paging. The entries of the level 1 page table are pointers to a level 2 page table and entries of the level 2 page tables are pointers to a level 3 page table and so on. The entries of the last level page table are stores actual frame information. Level 1 contain single page table and address of that table is stored in PTBR (Page Table Base Register). Virtual address: In multilevel paging whatever may be levels of paging all the page tables will be stored in main memory.So it requires more than one memory access to get the physical address of page frame. One access for each level needed. Each page table entry except the last level page table entry contains base address of the next level page table. Reference to actual page frame: Reference to PTE in level 1 page table = PTBR value + Level 1 offset present in virtual address. Reference to PTE in level 2 page table = Base address (present in Level 1 PTE) + Level 2 offset (present in VA). Reference to PTE in level 3 page table= Base address (present in Level 2 PTE) + Level 3 offset (present in VA). Actual page frame address = PTE (present in level 3). Generally the page table size will be equal to the size of page. Assumptions: Byte addressable memory, and n is the number of bits used to represent virtual address. Important formula: Number of entries in page table: = (virtual address space size) / (page size) = Number of pages Virtual address space size: = 2^{n} B Size of page table: <>= (number of entries in page table)*(size of PTE) If page table size > desired size then create 1 more level. Disadvantage: Extra memory references to access address translation tables can slow programs down by a factor of two or more. Use translation look aside buffer (TLB) to speed up address translation by storing page table entries. Example: Q. Consider a virtual memory system with physical memory of 8GB, a page size of 8KB and 46 bit virtual address. Assume every page table exactly fits into a single page . If page table entry size is 4B then how many levels of page tables would be required. Explanation: Page size = 8KB = 2^{13} B Virtual address space size = 2^{46} B PTE = 4B = 2^2 B Number of pages or number of entries in page table, = (virtual address space size) / (page size) = 2^{46} B/2^{13} B = 2^{33} Size of page table, = (number of entries in page table)*(size of PTE) = 2^{33} * 2^2 B = 2^{35} B To create one more level, Size of page table > page size Number of page tables in last level, = 2^{35} B / 2^{13} B = 2^{22}","title":"Multilevel Paging in Operating System"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.1-Processes-and-Lightweight-Processes-and-Threads/","text":"3.1. Processes, Lightweight Processes, and Threads The term \"process\" is often used with several different meanings. In this book, we stick to the usual OS textbook definition: a process is an instance of a program in execution. You might think of it as the collection of data structures that fully describes how far the execution of the program has progressed. NOTE: \u672c\u8282\u4e2d\u7684process\u6307\u7684\u662f\u6807\u51c6 Process Processes are like human beings: they are generated, they have a more or less significant life, they optionally generate one or more child processes, and eventually they die. A small difference is that sex is not really common among processes each process has just one parent. NOTE: process\u7684\u751f\u547d\u5468\u671f From the kernel's point of view, the purpose of a process is to act as an entity to which system resources (CPU time, memory, etc.) are allocated. When a process is created, it is almost identical to its parent. It receives a (logical) copy of the parent's address space and executes the same code as the parent, beginning at the next instruction following the process creation system call. Although the parent and child may share the pages containing the program code (text), they have separate copies of the data (stack and heap), so that changes by the child to a memory location are invisible to the parent (and vice versa). While earlier Unix kernels employed this simple model, modern Unix systems do not. They support multithreaded applications user programs having many relatively independent execution flows sharing a large portion of the application data structures. In such systems, a process is composed of several user threads (or simply threads ), each of which represents an execution flow of the process. Nowadays, most multithreaded applications are written using standard sets of library functions called pthread (POSIX thread) libraries . NOTE : \u8fd9\u6bb5\u8bdd\u4e2d\u7684**user threads**\u5177\u6709\u7279\u6b8a\u7684\u542b\u4e49\uff0c\u5728\u300a VS-process-VS-thread-VS-lightweight process.md \u300b\u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u5206\u6790\u3002\u7406\u89e3\u5b83\u5bf9\u4e8e\u7406\u89e3\u672c\u6bb5\u662f\u6bd4\u8f83\u91cd\u8981\u7684\u3002 Older versions of the Linux kernel offered no support for multithreaded applications. From the kernel point of view, a multithreaded application was just a normal process . The multiple execution flows of a multithreaded application were created, handled, and scheduled entirely in User Mode , usually by means of a POSIX-compliant pthread library. NOTE: \u5728\u300a VS-process-VS-thread-VS-lightweight process.md \u300b\u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u6df1\u523b\u5206\u6790 However, such an implementation of multithreaded applications is not very satisfactory. For instance, suppose a chess program uses two threads: one of them controls the graphical chessboard, waiting for the moves of the human player and showing the moves of the computer, while the other thread ponders the next move of the game. While the first thread waits for the human move, the second thread should run continuously, thus exploiting the thinking time of the human player. However, if the chess program is just a single process, the first thread cannot simply issue a blocking system call waiting for a user action; otherwise, the second thread is blocked as well. Instead, the first thread must employ sophisticated nonblocking techniques to ensure that the process remains runnable. NOTE : \u663e\u7136Older versions of the Linux kernel offered no support for multithreaded applications. Linux uses lightweight processes to offer better support for multithreaded applications. Basically, two lightweight processes may share some resources, like the address space , the open files , and so on. Whenever one of them modifies a shared resource, the other immediately sees the change. Of course, the two processes must synchronize themselves when accessing the shared resource. A straightforward way to implement multithreaded applications is to associate a lightweight process with each thread . In this way, the threads can access the same set of application data structures by simply sharing the same memory address space, the same set of open files, and so on; at the same time, each thread can be scheduled independently by the kernel so that one may sleep while another remains runnable. Examples of POSIX-compliant pthread libraries that use Linux's lightweight processes are LinuxThreads, Native POSIX Thread Library (NPTL), and IBM's Next Generation Posix Threading Package (NGPT). NOTE: \u5173\u4e8eLinuxThreads\u3001Native POSIX Thread Library (NPTL)\uff0c\u53c2\u89c1 PTHREADS(7) \uff0c\u5176\u4e2d\u7684Linux implementations of POSIX threads\u7ae0\u8282\u63cf\u8ff0\u4e86linux\u7684GNU C library\u5b9e\u73b0POSIX threads\u7684\u65b9\u5f0f\u7684\u7ec6\u8282\uff0c\u5176\u4e2d\u7ed9\u51fa\u4e86\u5982\u4f55\u67e5\u770b\u7cfb\u7edf\u7684 pthread libraries\u7684\u5b9e\u73b0\u65b9\u5f0f\u7684\u547d\u4ee4\u3002 POSIX-compliant multithreaded applications are best handled by kernels that support \" thread groups .\" In Linux a thread group is basically a set of lightweight processes that implement a multithreaded application and act as a whole with regards to some system calls such as getpid( ) , kill( ) , and _exit( ) . We are going to describe them at length later in this chapter. NOTE : \u65b0\u7248\u672c\u7684linux\u4f7f\u7528 **lightweight process**\u6765\u5b9e\u73b0thread\uff1b\u4f7f\u7528**thread group**\u6765\u4f5c\u4e3aprocess\uff1b \u5176\u5b9elinux kernel\u63d0\u4f9b\u4e86\u975e\u5e38\u7075\u6d3b\u7684 CLONE(2) system call\u6765\u8ba9\u7528\u6237\u7075\u6d3b\u5730\u521b\u5efaprocess\u6216thread\u3002","title":"3.1-Processes-and-Lightweight-Processes-and-Threads"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.1-Processes-and-Lightweight-Processes-and-Threads/#31#processes#lightweight#processes#and#threads","text":"The term \"process\" is often used with several different meanings. In this book, we stick to the usual OS textbook definition: a process is an instance of a program in execution. You might think of it as the collection of data structures that fully describes how far the execution of the program has progressed. NOTE: \u672c\u8282\u4e2d\u7684process\u6307\u7684\u662f\u6807\u51c6 Process Processes are like human beings: they are generated, they have a more or less significant life, they optionally generate one or more child processes, and eventually they die. A small difference is that sex is not really common among processes each process has just one parent. NOTE: process\u7684\u751f\u547d\u5468\u671f From the kernel's point of view, the purpose of a process is to act as an entity to which system resources (CPU time, memory, etc.) are allocated. When a process is created, it is almost identical to its parent. It receives a (logical) copy of the parent's address space and executes the same code as the parent, beginning at the next instruction following the process creation system call. Although the parent and child may share the pages containing the program code (text), they have separate copies of the data (stack and heap), so that changes by the child to a memory location are invisible to the parent (and vice versa). While earlier Unix kernels employed this simple model, modern Unix systems do not. They support multithreaded applications user programs having many relatively independent execution flows sharing a large portion of the application data structures. In such systems, a process is composed of several user threads (or simply threads ), each of which represents an execution flow of the process. Nowadays, most multithreaded applications are written using standard sets of library functions called pthread (POSIX thread) libraries . NOTE : \u8fd9\u6bb5\u8bdd\u4e2d\u7684**user threads**\u5177\u6709\u7279\u6b8a\u7684\u542b\u4e49\uff0c\u5728\u300a VS-process-VS-thread-VS-lightweight process.md \u300b\u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u5206\u6790\u3002\u7406\u89e3\u5b83\u5bf9\u4e8e\u7406\u89e3\u672c\u6bb5\u662f\u6bd4\u8f83\u91cd\u8981\u7684\u3002 Older versions of the Linux kernel offered no support for multithreaded applications. From the kernel point of view, a multithreaded application was just a normal process . The multiple execution flows of a multithreaded application were created, handled, and scheduled entirely in User Mode , usually by means of a POSIX-compliant pthread library. NOTE: \u5728\u300a VS-process-VS-thread-VS-lightweight process.md \u300b\u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u6df1\u523b\u5206\u6790 However, such an implementation of multithreaded applications is not very satisfactory. For instance, suppose a chess program uses two threads: one of them controls the graphical chessboard, waiting for the moves of the human player and showing the moves of the computer, while the other thread ponders the next move of the game. While the first thread waits for the human move, the second thread should run continuously, thus exploiting the thinking time of the human player. However, if the chess program is just a single process, the first thread cannot simply issue a blocking system call waiting for a user action; otherwise, the second thread is blocked as well. Instead, the first thread must employ sophisticated nonblocking techniques to ensure that the process remains runnable. NOTE : \u663e\u7136Older versions of the Linux kernel offered no support for multithreaded applications. Linux uses lightweight processes to offer better support for multithreaded applications. Basically, two lightweight processes may share some resources, like the address space , the open files , and so on. Whenever one of them modifies a shared resource, the other immediately sees the change. Of course, the two processes must synchronize themselves when accessing the shared resource. A straightforward way to implement multithreaded applications is to associate a lightweight process with each thread . In this way, the threads can access the same set of application data structures by simply sharing the same memory address space, the same set of open files, and so on; at the same time, each thread can be scheduled independently by the kernel so that one may sleep while another remains runnable. Examples of POSIX-compliant pthread libraries that use Linux's lightweight processes are LinuxThreads, Native POSIX Thread Library (NPTL), and IBM's Next Generation Posix Threading Package (NGPT). NOTE: \u5173\u4e8eLinuxThreads\u3001Native POSIX Thread Library (NPTL)\uff0c\u53c2\u89c1 PTHREADS(7) \uff0c\u5176\u4e2d\u7684Linux implementations of POSIX threads\u7ae0\u8282\u63cf\u8ff0\u4e86linux\u7684GNU C library\u5b9e\u73b0POSIX threads\u7684\u65b9\u5f0f\u7684\u7ec6\u8282\uff0c\u5176\u4e2d\u7ed9\u51fa\u4e86\u5982\u4f55\u67e5\u770b\u7cfb\u7edf\u7684 pthread libraries\u7684\u5b9e\u73b0\u65b9\u5f0f\u7684\u547d\u4ee4\u3002 POSIX-compliant multithreaded applications are best handled by kernels that support \" thread groups .\" In Linux a thread group is basically a set of lightweight processes that implement a multithreaded application and act as a whole with regards to some system calls such as getpid( ) , kill( ) , and _exit( ) . We are going to describe them at length later in this chapter. NOTE : \u65b0\u7248\u672c\u7684linux\u4f7f\u7528 **lightweight process**\u6765\u5b9e\u73b0thread\uff1b\u4f7f\u7528**thread group**\u6765\u4f5c\u4e3aprocess\uff1b \u5176\u5b9elinux kernel\u63d0\u4f9b\u4e86\u975e\u5e38\u7075\u6d3b\u7684 CLONE(2) system call\u6765\u8ba9\u7528\u6237\u7075\u6d3b\u5730\u521b\u5efaprocess\u6216thread\u3002","title":"3.1. Processes, Lightweight Processes, and Threads"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2-Process-Descriptor/","text":"3.2. Process Descriptor To manage processes, the kernel must have a clear picture of what each process is doing. It must know, for instance, the process's priority\uff08\u8c03\u5ea6\u7684\u4f18\u5148\u7ea7\uff09, whether it is running on a CPU or blocked on an event, what address space has been assigned to it, which files it is allowed to address, and so on. This is the role of the process descriptor a task_struct type structure whose fields contain all the information related to a single process . [ * ] As the repository of so much information, the process descriptor is rather complex. In addition to a large number of fields containing process attributes, the process descriptor contains several pointers to other data structures that, in turn, contain pointers to other structures. Figure 3-1 describes the Linux process descriptor schematically\uff08\u6309\u7167\u56fe\u5f0f\uff09. [ * ] The kernel also defines the task_t data type to be equivalent to struct task_struct NOTE : task_struct \u7684\u6e90\u4ee3\u7801\u53c2\u89c1\uff1a https://elixir.bootlin.com/linux/latest/ident/task_struct https://github.com/torvalds/linux/blob/master/include/linux/sched.h \u5173\u4e8e task_struct \u548cprocess\uff0cthread\u4e4b\u95f4\u7684\u5bf9\u5e94\u5173\u7cfb\uff0c\u5728Chapter 3. Processes\u4e2d\u8fdb\u884c\u4e86\u7ec6\u81f4\u7684\u5206\u6790\uff1b\u6b64\u5904\u4e0d\u518d\u8d58\u8ff0\uff1b The six data structures on the right side of the figure refer to specific resources owned by the process. Most of these resources will be covered in future chapters. This chapter focuses on two types of fields that refer to the process state and to process parent/child relationships . Figure 3-1. The Linux process descriptor task_structure \u7684\u6210\u5458\u53d8\u91cf name type note pid lightweight process ID\uff0c\u79c1\u6709 chapter 3.2.2. Identifying a Process tgid \u6807\u51c6process id\uff0c\u5171\u4eab chapter 3.2.2. Identifying a Process thread_info \u79c1\u6709 mm_struct process address space\uff0c\u5171\u4eab 9.2. The Memory Descriptor","title":"3.2-Process-Descriptor"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2-Process-Descriptor/#32#process#descriptor","text":"To manage processes, the kernel must have a clear picture of what each process is doing. It must know, for instance, the process's priority\uff08\u8c03\u5ea6\u7684\u4f18\u5148\u7ea7\uff09, whether it is running on a CPU or blocked on an event, what address space has been assigned to it, which files it is allowed to address, and so on. This is the role of the process descriptor a task_struct type structure whose fields contain all the information related to a single process . [ * ] As the repository of so much information, the process descriptor is rather complex. In addition to a large number of fields containing process attributes, the process descriptor contains several pointers to other data structures that, in turn, contain pointers to other structures. Figure 3-1 describes the Linux process descriptor schematically\uff08\u6309\u7167\u56fe\u5f0f\uff09. [ * ] The kernel also defines the task_t data type to be equivalent to struct task_struct NOTE : task_struct \u7684\u6e90\u4ee3\u7801\u53c2\u89c1\uff1a https://elixir.bootlin.com/linux/latest/ident/task_struct https://github.com/torvalds/linux/blob/master/include/linux/sched.h \u5173\u4e8e task_struct \u548cprocess\uff0cthread\u4e4b\u95f4\u7684\u5bf9\u5e94\u5173\u7cfb\uff0c\u5728Chapter 3. Processes\u4e2d\u8fdb\u884c\u4e86\u7ec6\u81f4\u7684\u5206\u6790\uff1b\u6b64\u5904\u4e0d\u518d\u8d58\u8ff0\uff1b The six data structures on the right side of the figure refer to specific resources owned by the process. Most of these resources will be covered in future chapters. This chapter focuses on two types of fields that refer to the process state and to process parent/child relationships . Figure 3-1. The Linux process descriptor","title":"3.2. Process Descriptor"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2-Process-Descriptor/#task_structure","text":"name type note pid lightweight process ID\uff0c\u79c1\u6709 chapter 3.2.2. Identifying a Process tgid \u6807\u51c6process id\uff0c\u5171\u4eab chapter 3.2.2. Identifying a Process thread_info \u79c1\u6709 mm_struct process address space\uff0c\u5171\u4eab 9.2. The Memory Descriptor","title":"task_structure\u7684\u6210\u5458\u53d8\u91cf"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.1-Process-State/","text":"3.2.1. Process State As its name implies, the state field of the process descriptor describes what is currently happening to the process. It consists of an array of flags, each of which describes a possible process state. In the current Linux version, these states are mutually exclusive , and hence exactly one flag of state always is set; the remaining flags are cleared. The following are the possible process states: TASK_RUNNING The process is either executing on a CPU or waiting to be executed. TASK_INTERRUPTIBLE The process is suspended ( sleeping ) until some condition becomes true. Raising a hardware interrupt, releasing a system resource the process is waiting for, or delivering a signal are examples of conditions that might wake up the process (put its state back to TASK_RUNNING ). NOTE \uff1a **sleeping**\u76f8\u5f53\u4e8esuspended TASK_UNINTERRUPTIBLE Like TASK_INTERRUPTIBLE , except that delivering a signal to the sleeping process leaves its state unchanged. This process state is seldom used. It is valuable, however, under certain specific conditions in which a process must wait until a given event occurs without being interrupted. For instance, this state may be used when a process opens a device file and the corresponding device driver starts probing for a corresponding hardware device . The device driver must not be interrupted until the probing is complete, or the hardware device could be left in an unpredictable state. TASK_STOPPED Process execution has been stopped; the process enters this state after receiving a SIGSTOP , SIGTSTP , SIGTTIN , or SIGTTOU signal. TASK_TRACED Process execution has been stopped by a debugger. When a process is being monitored by another (such as when a debugger executes a ptrace( ) system call to monitor a test program), each signal may put the process in the TASK_TRACED state. Two additional states of the process can be stored both in the state field and in the exit_state field of the process descriptor; as the field name suggests, a process reaches one of these two states only when its execution is terminated: EXIT_ZOMBIE Process execution is terminated, but the parent process has not yet issued a wait4( ) or waitpid( ) system call to return information about the dead process. [*] Before the wait( )-like call is issued, the kernel cannot discard the data contained in the dead process descriptor because the parent might need it. (See the section \"Process Removal\" near the end of this chapter.) [*] There are other wait( )-like library functions, such as wait3( ) and wait( ) , but in Linux they are implemented by means of the wait4( ) and waitpid( ) system calls. EXIT_DEAD The final state: the process is being removed by the system because the parent process has just issued a wait4( ) or waitpid( ) system call for it. Changing its state from EXIT_ZOMBIE to EXIT_DEAD avoids race conditions due to other threads of execution that execute wait( ) -like calls on the same process (see Chapter 5). The value of the state field is usually set with a simple assignment. For instance: p -> state = TASK_RUNNING ; The kernel also uses the set_task_state and set_current_state macros: they set the state of a specified process and of the process currently executed, respectively. Moreover, these macros ensure that the assignment operation is not mixed with other instructions by the compiler or the CPU control unit . Mixing the instruction order may sometimes lead to catastrophic results (see Chapter 5). NOTE: process state \u8865\u5145\u5185\u5bb9\uff1a https://lwn.net/Articles/288056/","title":"3.2.1-Process-State"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.1-Process-State/#321#process#state","text":"As its name implies, the state field of the process descriptor describes what is currently happening to the process. It consists of an array of flags, each of which describes a possible process state. In the current Linux version, these states are mutually exclusive , and hence exactly one flag of state always is set; the remaining flags are cleared. The following are the possible process states:","title":"3.2.1. Process State"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.1-Process-State/#task_running","text":"The process is either executing on a CPU or waiting to be executed.","title":"TASK_RUNNING"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.1-Process-State/#task_interruptible","text":"The process is suspended ( sleeping ) until some condition becomes true. Raising a hardware interrupt, releasing a system resource the process is waiting for, or delivering a signal are examples of conditions that might wake up the process (put its state back to TASK_RUNNING ). NOTE \uff1a **sleeping**\u76f8\u5f53\u4e8esuspended","title":"TASK_INTERRUPTIBLE"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.1-Process-State/#task_uninterruptible","text":"Like TASK_INTERRUPTIBLE , except that delivering a signal to the sleeping process leaves its state unchanged. This process state is seldom used. It is valuable, however, under certain specific conditions in which a process must wait until a given event occurs without being interrupted. For instance, this state may be used when a process opens a device file and the corresponding device driver starts probing for a corresponding hardware device . The device driver must not be interrupted until the probing is complete, or the hardware device could be left in an unpredictable state.","title":"TASK_UNINTERRUPTIBLE"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.1-Process-State/#task_stopped","text":"Process execution has been stopped; the process enters this state after receiving a SIGSTOP , SIGTSTP , SIGTTIN , or SIGTTOU signal.","title":"TASK_STOPPED"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.1-Process-State/#task_traced","text":"Process execution has been stopped by a debugger. When a process is being monitored by another (such as when a debugger executes a ptrace( ) system call to monitor a test program), each signal may put the process in the TASK_TRACED state. Two additional states of the process can be stored both in the state field and in the exit_state field of the process descriptor; as the field name suggests, a process reaches one of these two states only when its execution is terminated:","title":"TASK_TRACED"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.1-Process-State/#exit_zombie","text":"Process execution is terminated, but the parent process has not yet issued a wait4( ) or waitpid( ) system call to return information about the dead process. [*] Before the wait( )-like call is issued, the kernel cannot discard the data contained in the dead process descriptor because the parent might need it. (See the section \"Process Removal\" near the end of this chapter.) [*] There are other wait( )-like library functions, such as wait3( ) and wait( ) , but in Linux they are implemented by means of the wait4( ) and waitpid( ) system calls.","title":"EXIT_ZOMBIE"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.1-Process-State/#exit_dead","text":"The final state: the process is being removed by the system because the parent process has just issued a wait4( ) or waitpid( ) system call for it. Changing its state from EXIT_ZOMBIE to EXIT_DEAD avoids race conditions due to other threads of execution that execute wait( ) -like calls on the same process (see Chapter 5). The value of the state field is usually set with a simple assignment. For instance: p -> state = TASK_RUNNING ; The kernel also uses the set_task_state and set_current_state macros: they set the state of a specified process and of the process currently executed, respectively. Moreover, these macros ensure that the assignment operation is not mixed with other instructions by the compiler or the CPU control unit . Mixing the instruction order may sometimes lead to catastrophic results (see Chapter 5). NOTE: process state \u8865\u5145\u5185\u5bb9\uff1a https://lwn.net/Articles/288056/","title":"EXIT_DEAD"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2-Identifying-a-Process/","text":"3.2.2. Identifying a Process 3.2.2. Identifying a Process \u6ce8\u610f\uff1a \u672c\u6587\u4e2d\u7684process\u6240\u6307\u4e3alightweight process\uff0c pid \u6240\u6307\u6307\u4e3alightweight process\u7684 pid \uff0c\u5e76\u975e\u6807\u51c6\u7684process\u548c\u6807\u51c6\u7684 pid \u3002\u5728\u672c\u6587\u4e2d\uff0cthread group\u8868\u793a\u7684\u662f\u6807\u51c6\u7684process\uff0c tgid \u4e3a\u6807\u51c6\u7684 pid \u3002 As a general rule, each execution context that can be independently scheduled must have its own process descriptor ; therefore, even lightweight processes , which share a large portion of their kernel data structures, have their own task_struct structures. The strict one-to-one correspondence between the process and process descriptor makes the 32-bit address [ ] of the task_struct structure a useful means for the kernel to identify processes. These addresses are referred to as process descriptor pointers . Most of the references to processes that the kernel makes are through process descriptor pointers . [ ] As already noted in the section \"Segmentation in Linux\" in Chapter 2, although technically these 32 bits are only the offset component of a logical address, they coincide with the linear address On the other hand, Unix-like operating systems allow users to identify processes by means of a number called the Process ID (or PID ), which is stored in the pid field of the process descriptor . PIDs are numbered sequentially: the PID of a newly created process is normally the PID of the previously created process increased by one. Of course, there is an upper limit on the PID values; when the kernel reaches such limit, it must start recycling the lower, unused PIDs. By default, the maximum PID number is 32,767 ( PID_MAX_DEFAULT - 1 ); the system administrator may reduce this limit by writing a smaller value into the /proc/sys/kernel/pid_max file (/proc is the mount point of a special filesystem, see the section \"Special Filesystems\" in Chapter 12). In 64-bit architectures, the system administrator can enlarge the maximum PID number up to 4,194,303. When recycling PID numbers, the kernel must manage a pidmap_array bitmap that denotes which are the PIDs currently assigned and which are the free ones. Because a page frame contains 32,768\uff08 4K \uff09 bits, in 32-bit architectures the pidmap_array bitmap is stored in a single page. In 64-bit architectures, however, additional pages can be added to the bitmap when the kernel assigns a PID number too large for the current bitmap size. These pages are never released. NOTE: \u5173\u4e8e pidmap_array \uff0c\u53c2\u89c1 - https://elixir.bootlin.com/linux/v2.6.17.7/source/kernel/pid.c#L46 - https://blog.csdn.net/Jay14/article/details/54863073 Linux associates a different PID with each process or lightweight process in the system. (As we shall see later in this chapter, there is a tiny exception on multiprocessor systems.) This approach allows the maximum flexibility, because every execution context in the system can be uniquely identified. On the other hand, Unix programmers expect threads in the same group to have a common PID . For instance, it should be possible to a send a signal specifying a PID that affects all threads in the group. In fact, the POSIX 1003.1c standard states that all threads of a multithreaded application must have the same PID . To comply with this standard, Linux makes use of thread groups . The identifier shared by the threads is the PID of the thread group leader , that is, the PID of the first lightweight process in the group; it is stored in the tgid field of the process descriptors . The getpid( ) system call returns the value of tgid relative to the current process instead of the value of pid , so all the threads of a multithreaded application share the same identifier. Most processes belong to a thread group consisting of a single member; as thread group leaders, they have the tgid field equal to the pid field, thus the getpid( ) system call works as usual for this kind of process. Later, we'll show you how it is possible to derive a true process descriptor pointer efficiently from its respective PID . Efficiency is important because many system calls such as kill( ) use the PID to denote the affected process.","title":"3.2.2-Identifying-a-Process"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2-Identifying-a-Process/#322#identifying#a#process","text":"\u6ce8\u610f\uff1a \u672c\u6587\u4e2d\u7684process\u6240\u6307\u4e3alightweight process\uff0c pid \u6240\u6307\u6307\u4e3alightweight process\u7684 pid \uff0c\u5e76\u975e\u6807\u51c6\u7684process\u548c\u6807\u51c6\u7684 pid \u3002\u5728\u672c\u6587\u4e2d\uff0cthread group\u8868\u793a\u7684\u662f\u6807\u51c6\u7684process\uff0c tgid \u4e3a\u6807\u51c6\u7684 pid \u3002 As a general rule, each execution context that can be independently scheduled must have its own process descriptor ; therefore, even lightweight processes , which share a large portion of their kernel data structures, have their own task_struct structures. The strict one-to-one correspondence between the process and process descriptor makes the 32-bit address [ ] of the task_struct structure a useful means for the kernel to identify processes. These addresses are referred to as process descriptor pointers . Most of the references to processes that the kernel makes are through process descriptor pointers . [ ] As already noted in the section \"Segmentation in Linux\" in Chapter 2, although technically these 32 bits are only the offset component of a logical address, they coincide with the linear address On the other hand, Unix-like operating systems allow users to identify processes by means of a number called the Process ID (or PID ), which is stored in the pid field of the process descriptor . PIDs are numbered sequentially: the PID of a newly created process is normally the PID of the previously created process increased by one. Of course, there is an upper limit on the PID values; when the kernel reaches such limit, it must start recycling the lower, unused PIDs. By default, the maximum PID number is 32,767 ( PID_MAX_DEFAULT - 1 ); the system administrator may reduce this limit by writing a smaller value into the /proc/sys/kernel/pid_max file (/proc is the mount point of a special filesystem, see the section \"Special Filesystems\" in Chapter 12). In 64-bit architectures, the system administrator can enlarge the maximum PID number up to 4,194,303. When recycling PID numbers, the kernel must manage a pidmap_array bitmap that denotes which are the PIDs currently assigned and which are the free ones. Because a page frame contains 32,768\uff08 4K \uff09 bits, in 32-bit architectures the pidmap_array bitmap is stored in a single page. In 64-bit architectures, however, additional pages can be added to the bitmap when the kernel assigns a PID number too large for the current bitmap size. These pages are never released. NOTE: \u5173\u4e8e pidmap_array \uff0c\u53c2\u89c1 - https://elixir.bootlin.com/linux/v2.6.17.7/source/kernel/pid.c#L46 - https://blog.csdn.net/Jay14/article/details/54863073 Linux associates a different PID with each process or lightweight process in the system. (As we shall see later in this chapter, there is a tiny exception on multiprocessor systems.) This approach allows the maximum flexibility, because every execution context in the system can be uniquely identified. On the other hand, Unix programmers expect threads in the same group to have a common PID . For instance, it should be possible to a send a signal specifying a PID that affects all threads in the group. In fact, the POSIX 1003.1c standard states that all threads of a multithreaded application must have the same PID . To comply with this standard, Linux makes use of thread groups . The identifier shared by the threads is the PID of the thread group leader , that is, the PID of the first lightweight process in the group; it is stored in the tgid field of the process descriptors . The getpid( ) system call returns the value of tgid relative to the current process instead of the value of pid , so all the threads of a multithreaded application share the same identifier. Most processes belong to a thread group consisting of a single member; as thread group leaders, they have the tgid field equal to the pid field, thus the getpid( ) system call works as usual for this kind of process. Later, we'll show you how it is possible to derive a true process descriptor pointer efficiently from its respective PID . Efficiency is important because many system calls such as kill( ) use the PID to denote the affected process.","title":"3.2.2. Identifying a Process"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.1-Process-descriptors-handling/","text":"3.2.2.1. Process descriptors handling Processes are dynamic entities whose lifetimes range from a few milliseconds to months. Thus, the kernel must be able to handle many processes at the same time, and process descriptors are stored in dynamic memory rather than in the memory area permanently assigned to the kernel. For each process, Linux packs two different data structures in a single per-process memory area : a small data structure linked to the process descriptor , namely the thread_info structure the Kernel Mode process stack . The length of this memory area is usually 8,192 bytes (two page frames). For reasons of efficiency the kernel stores the 8-KB memory area in two consecutive page frames with the first page frame aligned to a multiple of 2^{13} 2^{13} ; this may turn out to be a problem when little dynamic memory is available, because the free memory may become highly fragmented (see the section \"The Buddy System Algorithm\" in Chapter 8). Therefore, in the 80x86 architecture the kernel can be configured at compilation time so that the memory area including stack and thread_info structure spans a single page frame (4,096 bytes). NOTE: \u4e0a\u9762\u8fd9\u6bb5\u4e2d\u7684 dynamic memory \u5728Chapter 8. Memory Management\u4e2d\u5b9a\u4e49\u3002 NOTE: 1.6.3. Reentrant Kernels\u4e2d**Kernel Mode process stack**\u662f\u4e3a**kernel control path**\u800c\u51c6\u5907\u7684\uff0ckernel control path\u7684\u6267\u884c\u662fReentrant\u7684\u3002 In the section \"Segmentation in Linux\" in Chapter 2, we learned that a process in Kernel Mode accesses a stack contained in the kernel data segment , which is different from the stack used by the process in User Mode . Because kernel control paths make little use of the stack, only a few thousand bytes of kernel stack are required. Therefore, 8 KB is ample space for the stack and the thread_info structure. However, when stack and thread_info structure are contained in a single page frame, the kernel uses a few additional stacks to avoid the overflows caused by deeply nested interrupts and exceptions (see Chapter 4). NOTE: \u4e00\u4e2aprocess\u6709\u4e24\u4e2astack\uff1a Kernel Mode process stack\uff0c\u7531**kernel control path**\u4f7f\u7528 User Mode process stack Figure 3-2 shows how the two data structures are stored in the 2-page (8 KB) memory area. The thread_info structure resides at the beginning of the memory area, and the stack grows downward from the end. The figure also shows that the thread_info structure and the task_struct structure are mutually linked by means of the fields task and thread_info , respectively. Figure 3-2. Storing the thread_info structure and the process kernel stack in two page frames The esp register is the CPU stack pointer , which is used to address the stack's top location. On 80x86 systems, the stack starts at the end and grows toward the beginning of the memory area \uff08\u5373\u4ece\u4f4e\u5730\u5740\u5411\u9ad8\u5730\u5740\uff09. Right after switching from User Mode to Kernel Mode , the kernel stack of a process is always empty, and therefore the esp register points to the byte immediately following the stack. The value of the esp is decreased as soon as data is written into the stack. Because the thread_info structure is 52 bytes long, the kernel stack can expand up to 8,140 bytes. The C language allows the thread_info structure and the kernel stack of a process to be conveniently represented by means of the following union construct: union thread_union { struct thread_info thread_info ; unsigned long stack [ 2048 ]; /* 1024 for 4KB stacks */ }; NOTE: thread_union \u5c31\u662f\u4e0a\u8ff0\u7684memory area\u7684\u5b9e\u73b0\u3002 thread_union \u6e90\u7801\uff1a https://elixir.bootlin.com/linux/latest/ident/thread_union The thread_info structure shown in Figure 3-2 is stored starting at address 0x015fa000 , and the stack is stored starting at address 0x015fc000 . The value of the esp register points to the current top of the stack at 0x015fa878 . The kernel uses the alloc_thread_info and free_thread_info macros to allocate and release the memory area storing a thread_info structure and a kernel stack . \u6ce8\u89e3 The figure also shows that the thread_info structure and the task_struct structure are mutually linked by means of the fields task and tHRead_info , respectively. \u8981\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u8bdd\uff0c\u9700\u8981\u641e\u6e05\u695a struct thread_info \u7684\u5b9a\u4e49\uff0c\u4ee5\u4e0b\u662f i386\u7684 struct thread_info struct thread_info { struct task_struct * task ; /* main task structure */ struct exec_domain * exec_domain ; /* execution domain */ unsigned long flags ; /* low level flags */ unsigned long status ; /* thread-synchronous flags */ __u32 cpu ; /* current CPU */ __s32 preempt_count ; /* 0 => preemptable, <0 => BUG */ mm_segment_t addr_limit ; /* thread address space: 0-0xBFFFFFFF for user-thead 0-0xFFFFFFFF for kernel-thread */ struct restart_block restart_block ; unsigned long previous_esp ; /* ESP of the previous stack in case of nested (IRQ) stacks */ __u8 supervisor_stack [ 0 ]; }; \u53ef\u4ee5\u770b\u5230 struct thread_info \u6709\u6210\u5458\u53d8\u91cf struct task_struct *task \uff0c\u800c\u5728 struct task_struct \u4e2d\uff0c\u6709\u6210\u5458\u53d8\u91cf struct thread_info *thread_info; \uff0c\u8fd9\u5c31\u662f\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u6700\u540e\u4e00\u53e5\u6240\u63cf\u8ff0\u7684\uff1a thread_union \u662f\u4fdd\u5b58\u5728per-process memory area\uff0c\u8fd9\u4e5f\u5c31\u610f\u5473\u7740\uff1a Kernel Mode process stack**\u4e5f\u4fdd\u5b58\u5728per-process memory area\u4e2d\uff1b\u800c\u8fd9\u4e00\u6bb5\u4e2d\u53c8\u63d0\u53ca\uff1aa process in **Kernel Mode accesses a stack contained in the kernel data segment \uff1b\u90a3kernel data segment\u662f\u5b58\u653e\u5728\u4f55\u5904\u5462\uff1f \u4e00\u4e2a\u5173\u952e\u70b9\u662f\u8981\u77e5\u9053\u672c\u4e66\u7684\u57fa\u4e8e i386 \u67b6\u6784\u6765\u8fdb\u884c\u63cf\u8ff0\u7684\uff0c\u5728 i386 \u4e2d\uff0c\u4f7f\u7528\u4e86segmentation\uff0c\u4f46\u662f\u5728\u540e\u6765\u8fd9\u79cd\u65b9\u5f0f\u88ab\u53d6\u4ee3\u4e86\uff1b\u6240\u4ee5\u5f88\u591a\u67b6\u6784\u4e2d\u538b\u6839\u53ef\u80fd\u5c31\u6ca1\u6709 Kernel Mode stack contained in the **kernel data segment**\u7684\u8fd9\u79cd\u7ed3\u6784\uff0c\u5728 How are the segment registers (fs, gs, cs, ss, ds, es) used in Linux? \u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u8bf4\u660e\u3002 \u57fa\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u8fdb\u884c\u4e86Google\uff1a is kernel data segment in process address space \uff1b\u76ee\u524d\u6240\u6709\u7684\u548c\u8fd9\u4e2a\u95ee\u9898\u76f8\u5173\u7684\u5185\u5bb9\u90fd\u5728\u300a virtual-memory-address-space-thinking.md \u300b\u4e2d\uff1b\u5728\u9605\u8bfb\u8fd9\u4e00\u6bb5\u7684\u65f6\u5019\uff0c","title":"3.2.2.1-Process-descriptors-handling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.1-Process-descriptors-handling/#3221#process#descriptors#handling","text":"Processes are dynamic entities whose lifetimes range from a few milliseconds to months. Thus, the kernel must be able to handle many processes at the same time, and process descriptors are stored in dynamic memory rather than in the memory area permanently assigned to the kernel. For each process, Linux packs two different data structures in a single per-process memory area : a small data structure linked to the process descriptor , namely the thread_info structure the Kernel Mode process stack . The length of this memory area is usually 8,192 bytes (two page frames). For reasons of efficiency the kernel stores the 8-KB memory area in two consecutive page frames with the first page frame aligned to a multiple of 2^{13} 2^{13} ; this may turn out to be a problem when little dynamic memory is available, because the free memory may become highly fragmented (see the section \"The Buddy System Algorithm\" in Chapter 8). Therefore, in the 80x86 architecture the kernel can be configured at compilation time so that the memory area including stack and thread_info structure spans a single page frame (4,096 bytes). NOTE: \u4e0a\u9762\u8fd9\u6bb5\u4e2d\u7684 dynamic memory \u5728Chapter 8. Memory Management\u4e2d\u5b9a\u4e49\u3002 NOTE: 1.6.3. Reentrant Kernels\u4e2d**Kernel Mode process stack**\u662f\u4e3a**kernel control path**\u800c\u51c6\u5907\u7684\uff0ckernel control path\u7684\u6267\u884c\u662fReentrant\u7684\u3002 In the section \"Segmentation in Linux\" in Chapter 2, we learned that a process in Kernel Mode accesses a stack contained in the kernel data segment , which is different from the stack used by the process in User Mode . Because kernel control paths make little use of the stack, only a few thousand bytes of kernel stack are required. Therefore, 8 KB is ample space for the stack and the thread_info structure. However, when stack and thread_info structure are contained in a single page frame, the kernel uses a few additional stacks to avoid the overflows caused by deeply nested interrupts and exceptions (see Chapter 4). NOTE: \u4e00\u4e2aprocess\u6709\u4e24\u4e2astack\uff1a Kernel Mode process stack\uff0c\u7531**kernel control path**\u4f7f\u7528 User Mode process stack Figure 3-2 shows how the two data structures are stored in the 2-page (8 KB) memory area. The thread_info structure resides at the beginning of the memory area, and the stack grows downward from the end. The figure also shows that the thread_info structure and the task_struct structure are mutually linked by means of the fields task and thread_info , respectively. Figure 3-2. Storing the thread_info structure and the process kernel stack in two page frames The esp register is the CPU stack pointer , which is used to address the stack's top location. On 80x86 systems, the stack starts at the end and grows toward the beginning of the memory area \uff08\u5373\u4ece\u4f4e\u5730\u5740\u5411\u9ad8\u5730\u5740\uff09. Right after switching from User Mode to Kernel Mode , the kernel stack of a process is always empty, and therefore the esp register points to the byte immediately following the stack. The value of the esp is decreased as soon as data is written into the stack. Because the thread_info structure is 52 bytes long, the kernel stack can expand up to 8,140 bytes. The C language allows the thread_info structure and the kernel stack of a process to be conveniently represented by means of the following union construct: union thread_union { struct thread_info thread_info ; unsigned long stack [ 2048 ]; /* 1024 for 4KB stacks */ }; NOTE: thread_union \u5c31\u662f\u4e0a\u8ff0\u7684memory area\u7684\u5b9e\u73b0\u3002 thread_union \u6e90\u7801\uff1a https://elixir.bootlin.com/linux/latest/ident/thread_union The thread_info structure shown in Figure 3-2 is stored starting at address 0x015fa000 , and the stack is stored starting at address 0x015fc000 . The value of the esp register points to the current top of the stack at 0x015fa878 . The kernel uses the alloc_thread_info and free_thread_info macros to allocate and release the memory area storing a thread_info structure and a kernel stack .","title":"3.2.2.1. Process descriptors handling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.1-Process-descriptors-handling/#_1","text":"The figure also shows that the thread_info structure and the task_struct structure are mutually linked by means of the fields task and tHRead_info , respectively. \u8981\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u8bdd\uff0c\u9700\u8981\u641e\u6e05\u695a struct thread_info \u7684\u5b9a\u4e49\uff0c\u4ee5\u4e0b\u662f i386\u7684 struct thread_info struct thread_info { struct task_struct * task ; /* main task structure */ struct exec_domain * exec_domain ; /* execution domain */ unsigned long flags ; /* low level flags */ unsigned long status ; /* thread-synchronous flags */ __u32 cpu ; /* current CPU */ __s32 preempt_count ; /* 0 => preemptable, <0 => BUG */ mm_segment_t addr_limit ; /* thread address space: 0-0xBFFFFFFF for user-thead 0-0xFFFFFFFF for kernel-thread */ struct restart_block restart_block ; unsigned long previous_esp ; /* ESP of the previous stack in case of nested (IRQ) stacks */ __u8 supervisor_stack [ 0 ]; }; \u53ef\u4ee5\u770b\u5230 struct thread_info \u6709\u6210\u5458\u53d8\u91cf struct task_struct *task \uff0c\u800c\u5728 struct task_struct \u4e2d\uff0c\u6709\u6210\u5458\u53d8\u91cf struct thread_info *thread_info; \uff0c\u8fd9\u5c31\u662f\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u6700\u540e\u4e00\u53e5\u6240\u63cf\u8ff0\u7684\uff1a thread_union \u662f\u4fdd\u5b58\u5728per-process memory area\uff0c\u8fd9\u4e5f\u5c31\u610f\u5473\u7740\uff1a Kernel Mode process stack**\u4e5f\u4fdd\u5b58\u5728per-process memory area\u4e2d\uff1b\u800c\u8fd9\u4e00\u6bb5\u4e2d\u53c8\u63d0\u53ca\uff1aa process in **Kernel Mode accesses a stack contained in the kernel data segment \uff1b\u90a3kernel data segment\u662f\u5b58\u653e\u5728\u4f55\u5904\u5462\uff1f \u4e00\u4e2a\u5173\u952e\u70b9\u662f\u8981\u77e5\u9053\u672c\u4e66\u7684\u57fa\u4e8e i386 \u67b6\u6784\u6765\u8fdb\u884c\u63cf\u8ff0\u7684\uff0c\u5728 i386 \u4e2d\uff0c\u4f7f\u7528\u4e86segmentation\uff0c\u4f46\u662f\u5728\u540e\u6765\u8fd9\u79cd\u65b9\u5f0f\u88ab\u53d6\u4ee3\u4e86\uff1b\u6240\u4ee5\u5f88\u591a\u67b6\u6784\u4e2d\u538b\u6839\u53ef\u80fd\u5c31\u6ca1\u6709 Kernel Mode stack contained in the **kernel data segment**\u7684\u8fd9\u79cd\u7ed3\u6784\uff0c\u5728 How are the segment registers (fs, gs, cs, ss, ds, es) used in Linux? \u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u8bf4\u660e\u3002 \u57fa\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u8fdb\u884c\u4e86Google\uff1a is kernel data segment in process address space \uff1b\u76ee\u524d\u6240\u6709\u7684\u548c\u8fd9\u4e2a\u95ee\u9898\u76f8\u5173\u7684\u5185\u5bb9\u90fd\u5728\u300a virtual-memory-address-space-thinking.md \u300b\u4e2d\uff1b\u5728\u9605\u8bfb\u8fd9\u4e00\u6bb5\u7684\u65f6\u5019\uff0c","title":"\u6ce8\u89e3"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.2-Identifying-the-current-process/","text":"3.2.2.2. Identifying the current process The close association between the thread_info structure and the Kernel Mode stack just described offers a key benefit in terms of efficiency: the kernel can easily obtain the address of the thread_info structure of the process currently running on a CPU from the value of the esp register. In fact, if the thread_union structure is 8 KB ( 2^{13} 2^{13} bytes) long, the kernel masks out the 13 least significant bits of esp to obtain the base address of the thread_info structure; on the other hand, if the thread_union structure is 4 KB long, the kernel masks out the 12 least significant bits of esp . This is done by the current_thread_info( ) function, which produces assembly language instructions like the following: movl $0xffffe000,%ecx /* or 0xfffff000 for 4KB stacks */ andl %esp,%ecx movl %ecx,p After executing these three instructions, p contains the thread_info structure pointer of the process running on the CPU that executes the instruction. Most often the kernel needs the address of the process descriptor rather than the address of the thread_info structure. To get the process descriptor pointer of the process currently running on a CPU, the kernel makes use of the current macro, which is essentially equivalent to current_thread_info( )->task and produces assembly language instructions like the following: movl $0xffffe000 , % ecx /* or 0xfffff000 for 4KB stacks */ andl % esp , % ecx movl ( % ecx ), p Because the task field is at offset 0 in the thread_info structure, after executing these three instructions p contains the process descriptor pointer of the process running on the CPU. The current macro often appears in kernel code as a prefix to fields of the process descriptor . For example, current->pid returns the process ID of the process currently running on the CPU. Another advantage of storing the process descriptor with the stack emerges on multiprocessor systems: the correct current process for each hardware processor can be derived just by checking the stack, as shown previously. Earlier versions of Linux did not store the kernel stack and the process descriptor together. Instead, they were forced to introduce a global static variable called current to identify the process descriptor of the running process. On multiprocessor systems, it was necessary to define current as an array one element for each available CPU. SUMMARY : \u6240\u6709\u7684**process descriptor** \u548c kernel stack \u90fd\u662f\u4f4d\u4e8ekernel\u4e2d\uff1b\u7531kernel\u6765\u6267\u884c\u8c03\u5ea6\uff1b\u5f53CPU\u9700\u8981\u6267\u884c\u67d0\u4e2a**process descriptor**\u7684\u65f6\u5019\uff0c\u5b83\u9700\u8981\u8bfb\u53d6\u8fd9\u4e2a**process descriptor**\u7684\u4e00\u4e9b\u6570\u636e\uff0c\u6bd4\u5982\u4e4b\u524d\u4fdd\u5b58\u7684register\u6570\u636e\u7b49\u4ee5\u4fbfresume\uff1b\u4ece\u4e0a\u9762\u7684\u63cf\u8ff0\u53ef\u4ee5\u770b\u51fa\uff0cCPU\u662f\u6839\u636e esp \u7684\u503c\u6765\u83b7\u5f97**process descriptor**\u7684\u5730\u5740\uff0c\u5e76\u4e14\uff0c\u4ece\u524d\u9762\u7684\u63cf\u8ff0\u6765\u770b\uff0c\u6bcf\u4e2a thread_union \u90fd\u6709\u4e00\u4e2a\u81ea\u5df1\u7684 kernel stack \uff0c\u800c\u4ece\u4e0a\u9762\u7684\u63cf\u8ff0\u6765\u770b\uff0c\u662f\u6839\u636e esp \u7684\u503c\u6765\u83b7\u5f97**process descriptor**\u7684\u5730\u5740\uff0c\u6240\u4ee5CPU\u662f\u5728\u67d0\u4e2a`thread_union\u7684 kernel stack**\u4e2d\u6267\u884c\uff0c\u7136\u540e\u5f97\u5230\u5bf9\u5e94\u7684**process descriptor \uff1b SUMMARY : \u56e0\u4e3ascheduler\u5728\u8c03\u5ea6\u4e00\u4e2atask\u5f00\u59cb\u8fd0\u884c\u4e4b\u524d\u4f1a\u5c06\u8fd9\u4e2atask\u7684\u6240\u6709\u7684register\u90fd\u6062\u590d\u5230CPU\u4e2d\uff0c\u6240\u4ee5\u5fc5\u7136\u4f1a\u5305\u542b esp \uff0c\u6240\u4ee5\u5b83\u5c31\u53ef\u4ee5\u6839\u636e esp \u5feb\u901f\u5730\u5b9a\u4f4d\u5230process descriptor\uff1b","title":"3.2.2.2-Identifying-the-current-process"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.2-Identifying-the-current-process/#3222#identifying#the#current#process","text":"The close association between the thread_info structure and the Kernel Mode stack just described offers a key benefit in terms of efficiency: the kernel can easily obtain the address of the thread_info structure of the process currently running on a CPU from the value of the esp register. In fact, if the thread_union structure is 8 KB ( 2^{13} 2^{13} bytes) long, the kernel masks out the 13 least significant bits of esp to obtain the base address of the thread_info structure; on the other hand, if the thread_union structure is 4 KB long, the kernel masks out the 12 least significant bits of esp . This is done by the current_thread_info( ) function, which produces assembly language instructions like the following: movl $0xffffe000,%ecx /* or 0xfffff000 for 4KB stacks */ andl %esp,%ecx movl %ecx,p After executing these three instructions, p contains the thread_info structure pointer of the process running on the CPU that executes the instruction. Most often the kernel needs the address of the process descriptor rather than the address of the thread_info structure. To get the process descriptor pointer of the process currently running on a CPU, the kernel makes use of the current macro, which is essentially equivalent to current_thread_info( )->task and produces assembly language instructions like the following: movl $0xffffe000 , % ecx /* or 0xfffff000 for 4KB stacks */ andl % esp , % ecx movl ( % ecx ), p Because the task field is at offset 0 in the thread_info structure, after executing these three instructions p contains the process descriptor pointer of the process running on the CPU. The current macro often appears in kernel code as a prefix to fields of the process descriptor . For example, current->pid returns the process ID of the process currently running on the CPU. Another advantage of storing the process descriptor with the stack emerges on multiprocessor systems: the correct current process for each hardware processor can be derived just by checking the stack, as shown previously. Earlier versions of Linux did not store the kernel stack and the process descriptor together. Instead, they were forced to introduce a global static variable called current to identify the process descriptor of the running process. On multiprocessor systems, it was necessary to define current as an array one element for each available CPU. SUMMARY : \u6240\u6709\u7684**process descriptor** \u548c kernel stack \u90fd\u662f\u4f4d\u4e8ekernel\u4e2d\uff1b\u7531kernel\u6765\u6267\u884c\u8c03\u5ea6\uff1b\u5f53CPU\u9700\u8981\u6267\u884c\u67d0\u4e2a**process descriptor**\u7684\u65f6\u5019\uff0c\u5b83\u9700\u8981\u8bfb\u53d6\u8fd9\u4e2a**process descriptor**\u7684\u4e00\u4e9b\u6570\u636e\uff0c\u6bd4\u5982\u4e4b\u524d\u4fdd\u5b58\u7684register\u6570\u636e\u7b49\u4ee5\u4fbfresume\uff1b\u4ece\u4e0a\u9762\u7684\u63cf\u8ff0\u53ef\u4ee5\u770b\u51fa\uff0cCPU\u662f\u6839\u636e esp \u7684\u503c\u6765\u83b7\u5f97**process descriptor**\u7684\u5730\u5740\uff0c\u5e76\u4e14\uff0c\u4ece\u524d\u9762\u7684\u63cf\u8ff0\u6765\u770b\uff0c\u6bcf\u4e2a thread_union \u90fd\u6709\u4e00\u4e2a\u81ea\u5df1\u7684 kernel stack \uff0c\u800c\u4ece\u4e0a\u9762\u7684\u63cf\u8ff0\u6765\u770b\uff0c\u662f\u6839\u636e esp \u7684\u503c\u6765\u83b7\u5f97**process descriptor**\u7684\u5730\u5740\uff0c\u6240\u4ee5CPU\u662f\u5728\u67d0\u4e2a`thread_union\u7684 kernel stack**\u4e2d\u6267\u884c\uff0c\u7136\u540e\u5f97\u5230\u5bf9\u5e94\u7684**process descriptor \uff1b SUMMARY : \u56e0\u4e3ascheduler\u5728\u8c03\u5ea6\u4e00\u4e2atask\u5f00\u59cb\u8fd0\u884c\u4e4b\u524d\u4f1a\u5c06\u8fd9\u4e2atask\u7684\u6240\u6709\u7684register\u90fd\u6062\u590d\u5230CPU\u4e2d\uff0c\u6240\u4ee5\u5fc5\u7136\u4f1a\u5305\u542b esp \uff0c\u6240\u4ee5\u5b83\u5c31\u53ef\u4ee5\u6839\u636e esp \u5feb\u901f\u5730\u5b9a\u4f4d\u5230process descriptor\uff1b","title":"3.2.2.2. Identifying the current process"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.3-Doubly-linked-lists/","text":"3.2.2.3. Doubly linked lists Before moving on and describing how the kernel keeps track of the various processes in the system, we would like to emphasize the role of special data structures that implement doubly linked lists. For each list, a set of primitive operations must be implemented: initializing the list, inserting and deleting an element, scanning the list, and so on. It would be both a waste of programmers' efforts and a waste of memory to replicate the primitive operations for each different list. Therefore, the Linux kernel defines the list_head data structure, whose only fields next and prev represent the forward and back pointers of a generic doubly linked list element, respectively. It is important to note, however, that the pointers in a list_head field store the addresses of other list_head fields rather than the addresses of the whole data structures in which the list_head structure is included; see Figure 3-3 (a). SUMMARY : list_head A new list is created by using the LIST_HEAD(list_name) macro. It declares a new variable named list_name of type list_head , which is a dummy first element that acts as a placeholder for the head of the new list, and initializes the prev and next fields of the list_head data structure so as to point to the list_name variable itself; see Figure 3-3 (b). Several functions and macros implement the primitives, including those shown in Table Table 3-1. The Linux kernel 2.6 sports another kind of doubly linked list, which mainly differs from a list_head list because it is not circular; it is mainly used for hash tables , where space is important, and finding the the last element in constant time is not. The list head is stored in an hlist_head data structure, which is simply a pointer to the first element in the list ( NULL if the list is empty). Each element is represented by an hlist_node data structure, which includes a pointer next to the next element, and a pointer pprev to the next field of the previous element. Because the list is not circular, the pprev field of the first element and the next field of the last element are set to NULL . The list can be handled by means of several helper functions and macros similar to those listed in Table 3-1: hlist_add_head( ) , hlist_del( ) , hlist_empty( ) , hlist_entry , hlist_for_each_entry , and so on.","title":"3.2.2.3-Doubly-linked-lists"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.3-Doubly-linked-lists/#3223#doubly#linked#lists","text":"Before moving on and describing how the kernel keeps track of the various processes in the system, we would like to emphasize the role of special data structures that implement doubly linked lists. For each list, a set of primitive operations must be implemented: initializing the list, inserting and deleting an element, scanning the list, and so on. It would be both a waste of programmers' efforts and a waste of memory to replicate the primitive operations for each different list. Therefore, the Linux kernel defines the list_head data structure, whose only fields next and prev represent the forward and back pointers of a generic doubly linked list element, respectively. It is important to note, however, that the pointers in a list_head field store the addresses of other list_head fields rather than the addresses of the whole data structures in which the list_head structure is included; see Figure 3-3 (a). SUMMARY : list_head A new list is created by using the LIST_HEAD(list_name) macro. It declares a new variable named list_name of type list_head , which is a dummy first element that acts as a placeholder for the head of the new list, and initializes the prev and next fields of the list_head data structure so as to point to the list_name variable itself; see Figure 3-3 (b). Several functions and macros implement the primitives, including those shown in Table Table 3-1. The Linux kernel 2.6 sports another kind of doubly linked list, which mainly differs from a list_head list because it is not circular; it is mainly used for hash tables , where space is important, and finding the the last element in constant time is not. The list head is stored in an hlist_head data structure, which is simply a pointer to the first element in the list ( NULL if the list is empty). Each element is represented by an hlist_node data structure, which includes a pointer next to the next element, and a pointer pprev to the next field of the previous element. Because the list is not circular, the pprev field of the first element and the next field of the last element are set to NULL . The list can be handled by means of several helper functions and macros similar to those listed in Table 3-1: hlist_add_head( ) , hlist_del( ) , hlist_empty( ) , hlist_entry , hlist_for_each_entry , and so on.","title":"3.2.2.3. Doubly linked lists"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.4-The-process-list/","text":"3.2.2.4. The process list The first example of a doubly linked list we will examine is the process list , a list that links together all existing process descriptors. Each task_struct structure includes a tasks field of type list_head whose prev and next fields point, respectively, to the previous and to the next task_struct element. The head of the process list is the init_task task_struct descriptor; it is the process descriptor of the so-called process 0 or swapper (see the section \"Kernel Threads\" later in this chapter). The tasks->prev field of init_task points to the tasks field of the process descriptor inserted last in the list. The SET_LINKS and REMOVE_LINKS macros are used to insert and to remove a process descriptor in the process list , respectively. These macros also take care of the parenthood relationship of the process (see the section \"How Processes Are Organized\" later in this chapter). Another useful macro, called for_each_process , scans the whole process list. It is defined as: #define for_each_process(p) \\ for (p=&init_task; (p=list_entry((p)->tasks.next, \\ struct task_struct, tasks) \\ ) != &init_task; ) The macro is the loop control statement after which the kernel programmer supplies the loop. Notice how the init_task process descriptor just plays the role of list header . The macro starts by moving past init_task to the next task and continues until it reaches init_task again (thanks to the circularity of the list). At each iteration, the variable passed as the argument of the macro contains the address of the currently scanned process descriptor, as returned by the list_entry macro. SUMMARY : \u5728multiprocessor\u4e2d\uff0c\u662f\u5426\u662f\u6bcf\u4e2aprocessor\u90fd\u6709\u4e00\u4e2aprocess list\uff0c\u8fd8\u662f\u8bf4\u6240\u6709\u7684process descriptor\u90fd\u653e\u5728\u4e00\u4e2aprocess list\u4e2d\uff1f","title":"3.2.2.4-The-process-list"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.4-The-process-list/#3224#the#process#list","text":"The first example of a doubly linked list we will examine is the process list , a list that links together all existing process descriptors. Each task_struct structure includes a tasks field of type list_head whose prev and next fields point, respectively, to the previous and to the next task_struct element. The head of the process list is the init_task task_struct descriptor; it is the process descriptor of the so-called process 0 or swapper (see the section \"Kernel Threads\" later in this chapter). The tasks->prev field of init_task points to the tasks field of the process descriptor inserted last in the list. The SET_LINKS and REMOVE_LINKS macros are used to insert and to remove a process descriptor in the process list , respectively. These macros also take care of the parenthood relationship of the process (see the section \"How Processes Are Organized\" later in this chapter). Another useful macro, called for_each_process , scans the whole process list. It is defined as: #define for_each_process(p) \\ for (p=&init_task; (p=list_entry((p)->tasks.next, \\ struct task_struct, tasks) \\ ) != &init_task; ) The macro is the loop control statement after which the kernel programmer supplies the loop. Notice how the init_task process descriptor just plays the role of list header . The macro starts by moving past init_task to the next task and continues until it reaches init_task again (thanks to the circularity of the list). At each iteration, the variable passed as the argument of the macro contains the address of the currently scanned process descriptor, as returned by the list_entry macro. SUMMARY : \u5728multiprocessor\u4e2d\uff0c\u662f\u5426\u662f\u6bcf\u4e2aprocessor\u90fd\u6709\u4e00\u4e2aprocess list\uff0c\u8fd8\u662f\u8bf4\u6240\u6709\u7684process descriptor\u90fd\u653e\u5728\u4e00\u4e2aprocess list\u4e2d\uff1f","title":"3.2.2.4. The process list"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.5-The-lists-of-TASK_RUNNING-processes/","text":"3.2.2.5. The lists of TASK_RUNNING processes When looking for a new process to run on a CPU, the kernel has to consider only the runnable processes (that is, the processes in the TASK_RUNNING state). Earlier Linux versions put all runnable processes in the same list called runqueue . Because it would be too costly to maintain the list ordered according to process priorities, the earlier schedulers were compelled to scan the whole list in order to select the \"best\" runnable process. Linux 2.6 implements the runqueue differently. The aim is to allow the scheduler to select the best runnable process in constant time, independently of the number of runnable processes. We'll defer to Chapter 7 a detailed description of this new kind of runqueue , and we'll provide here only some basic information. The trick used to achieve the scheduler speedup consists of splitting the runqueue in many lists of runnable processes, one list per process priority . Each task_struct descriptor includes a run_list field of type list_head . If the process priority is equal to k (a value ranging between 0 and 139), the run_list field links the process descriptor into the list of runnable processes having priority k . Furthermore, on a multiprocessor system, each CPU has its own runqueue , that is, its own set of lists of processes. This is a classic example of making a data structures more complex to improve performance: to make scheduler operations more efficient, the runqueue list has been split into 140 different lists! As we'll see, the kernel must preserve a lot of data for every runqueue in the system; however, the main data structures of a runqueue are the lists of process descriptors belonging to the runqueue ; all these lists are implemented by a single prio_array_t data structure, whose fields are shown in Table 3-2. SUMMARY : prio_array The enqueue_task(p,array) function inserts a process descriptor into a runqueue list; its code is essentially equivalent to: list_add_tail ( & p -> run_list , & array -> queue [ p -> prio ]); __set_bit ( p -> prio , array -> bitmap ); array -> nr_active ++ ; p -> array = array ; The prio field of the process descriptor stores the dynamic priority of the process, while the array field is a pointer to the prio_array_t data structure of its current runqueue . Similarly, the dequeue_task(p,array) function removes a process descriptor from a runqueue list.","title":"3.2.2.5-The-lists-of-TASK_RUNNING-processes"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.2.5-The-lists-of-TASK_RUNNING-processes/#3225#the#lists#of#task_running#processes","text":"When looking for a new process to run on a CPU, the kernel has to consider only the runnable processes (that is, the processes in the TASK_RUNNING state). Earlier Linux versions put all runnable processes in the same list called runqueue . Because it would be too costly to maintain the list ordered according to process priorities, the earlier schedulers were compelled to scan the whole list in order to select the \"best\" runnable process. Linux 2.6 implements the runqueue differently. The aim is to allow the scheduler to select the best runnable process in constant time, independently of the number of runnable processes. We'll defer to Chapter 7 a detailed description of this new kind of runqueue , and we'll provide here only some basic information. The trick used to achieve the scheduler speedup consists of splitting the runqueue in many lists of runnable processes, one list per process priority . Each task_struct descriptor includes a run_list field of type list_head . If the process priority is equal to k (a value ranging between 0 and 139), the run_list field links the process descriptor into the list of runnable processes having priority k . Furthermore, on a multiprocessor system, each CPU has its own runqueue , that is, its own set of lists of processes. This is a classic example of making a data structures more complex to improve performance: to make scheduler operations more efficient, the runqueue list has been split into 140 different lists! As we'll see, the kernel must preserve a lot of data for every runqueue in the system; however, the main data structures of a runqueue are the lists of process descriptors belonging to the runqueue ; all these lists are implemented by a single prio_array_t data structure, whose fields are shown in Table 3-2. SUMMARY : prio_array The enqueue_task(p,array) function inserts a process descriptor into a runqueue list; its code is essentially equivalent to: list_add_tail ( & p -> run_list , & array -> queue [ p -> prio ]); __set_bit ( p -> prio , array -> bitmap ); array -> nr_active ++ ; p -> array = array ; The prio field of the process descriptor stores the dynamic priority of the process, while the array field is a pointer to the prio_array_t data structure of its current runqueue . Similarly, the dequeue_task(p,array) function removes a process descriptor from a runqueue list.","title":"3.2.2.5. The lists of TASK_RUNNING processes"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.3-Relationships-Among-Processes/","text":"3.2.3. Relationships Among Processes 3.2.3.1. The pidhash table and chained lists 3.2.3. Relationships Among Processes Processes created by a program have a parent/child relationship . When a process creates multiple children , these children have sibling relationships . Several fields must be introduced in a process descriptor to represent these relationships; they are listed in Table 3-3 with respect to a given process P . Processes 0 and 1 are created by the kernel ; as we'll see later in the chapter, process 1 ( init ) is the ancestor of all other processes. Table 3-3. Fields of a process descriptor used to express parenthood relationships Field name Description real_parent Points to the process descriptor of the process that created P or to the descriptor of process 1 ( init ) if the parent process no longer exists. (Therefore, when a user starts a background process and exits the shell, the background process becomes the child of init .) parent Points to the current parent of P (this is the process that must be signaled when the child process terminates); its value usually coincides with that of real_parent . It may occasionally differ, such as when another process issues a ptrace( ) system call requesting that it be allowed to monitor P (see the section \"Execution Tracing\" in Chapter 20). children The head of the list containing all children created by P . sibling The pointers to the next and previous elements in the list of the sibling processes, those that have the same parent as P . Figure 3-4 illustrates the parent and sibling relationships of a group of processes. Process P0 successively created P1 , P2 , and P3 . Process P3 , in turn, created process P4 . Furthermore, there exist other relationships among processes: a process can be a leader of a process group or of a login session (see \"Process Management\" in Chapter 1), it can be a leader of a thread group (see \"Identifying a Process\" earlier in this chapter), and it can also trace the execution of other processes (see the section \"Execution Tracing\" in Chapter 20). Table 3-4 lists the fields of the process descriptor that establish these relationships between a process P and the other processes. Table 3-4. The fields of the process descriptor that establish non-parenthood relationships Field name Description group_leader Process descriptor pointer of the group leader of P SUMMARY : \u662fthread group leader signal->pgrp PID of the group leader of P SUMMARY : \u662fprocess group tgid PID of the thread group leader of P signal->session PID of the login session leader of P ptrace_children The head of a list containing all children of P being traced by a debugger ptrace_list The pointers to the next and previous elements in the real parent's list of traced processes (used when P is being traced) SUMMARY : struct signal_struct SUMMARY : pgrp \u8868\u793a\u7684\u662fprocess group\uff0c tgid \u8868\u793a\u7684\u662fthread group ID\u3002 SUMMARY : How does Linux tell threads apart from child processes? 3.2.3.1. The pidhash table and chained lists In several circumstances, the kernel must be able to derive the process descriptor pointer corresponding to a PID . This occurs, for instance, in servicing the kill( ) system call. When process P1 wishes to send a signal to another process, P2 , it invokes the kill( ) system call specifying the PID of P2 as the parameter. The kernel derives the process descriptor pointer from the PID and then extracts the pointer to the data structure that records the pending signals from P2 's process descriptor. Scanning the process list sequentially and checking the pid fields of the process descriptors is feasible but rather inefficient. To speed up the search, four hash tables have been introduced. Why multiple hash tables? Simply because the process descriptor includes fields that represent different types of PID (see Table 3-5), and each type of PID requires its own hash table. Table 3-5. The four hash tables and corresponding fields in the process descriptor Hash table type Field name Description PIDTYPE_PID pid PID of the process PIDTYPE_TGID tgid PID of thread group leader process PIDTYPE_PGID pgrp PID of the group leader process PIDTYPE_SID session PID of the session leader process The four hash tables are dynamically allocated during the kernel initialization phase , and their addresses are stored in the pid_hash array. The size of a single hash table depends on the amount of available RAM; for example, for systems having 512 MB of RAM, each hash table is stored in four page frames and includes 2,048 entries. SUMMARY : pid_hash \u5728 / kernel / pid.c \u4e2d\u5b9a\u4e49\uff0c\u5b9a\u4e49\u5982\u4e0b\uff1a static struct hlist_head * pid_hash [ PIDTYPE_MAX ]; hlist_head \u5728 / include / linux / list.h \u4e2d\u5b9a\u4e49\uff1b SUMMARY :2018\u8868\u793a\u7684\u662fhash table\u7684\u957f\u5ea6\uff0c\u6240\u4ee5hash\u51fd\u6570\u9700\u8981\u5c06 pid \u6620\u5c04\u5230 [0-2017] \u8303\u56f4\u5185\uff1b The PID is transformed into a table index using the pid_hashfn macro, which expands to: #define pid_hashfn(x) hash_long((unsigned long) x, pidhash_shift) The pidhash_shift variable stores the length in bits of a table index (11, in our example). The hash_long( ) function is used by many hash functions; on a 32-bit architecture it is essentially equivalent to: unsigned long hash_long ( unsigned long val , unsigned int bits ) { unsigned long hash = val * 0x9e370001UL ; return hash >> ( 32 - bits ); } Because in our example pidhash_shift is equal to 11, pid_hashfn yields values ranging between 0 and 2^{11} - 1 = 2047 2^{11} - 1 = 2047 . The Magic Constant You might wonder where the 0x9e370001 constant (= 2,654,404,609) comes from. This hash function is based on a multiplication of the index by a suitable large number, so that the result overflows and the value remaining in the 32-bit variable can be considered as the result of a modulus operation. Knuth suggested that good results are obtained when the large multiplier is a prime approximately in golden ratio to 2 32 (32 bit being the size of the 80x86's registers). Now, 2,654,404,609 is a prime near to that can also be easily multiplied by additions and bit shifts, because it is equal to SUMMARY : \u53c2\u89c1 \u9b54\u6570\u5e38\u91cf The Magic Constant As every basic computer science course explains, a hash function does not always ensure a one-to- one correspondence between PID s and table indexes. Two different PID s that hash into the same table index are said to be colliding . Linux uses chaining to handle colliding PID s; each table entry is the head of a doubly linked list of colliding process descriptors . Figure 3-5 illustrates a PID hash table with two lists. The processes having PID s 2,890 and 29,384 hash into the 200 th element of the table, while the process having PID 29,385 hashes into the 1,466 th element of the table. Hashing with chaining is preferable to a linear transformation from PID s to table indexes because at any given instance, the number of processes in the system is usually far below 32,768 (the maximum number of allowed PID s). It would be a waste of storage to define a table consisting of 32,768 entries, if, at any given instance, most such entries are unused. The data structures used in the PID hash tables are quite sophisticated, because they must keep track of the relationships between the processes. As an example, suppose that the kernel must retrieve all processes belonging to a given thread group , that is, all processes whose tgid field is equal to a given number. Looking in the hash table for the given thread group number returns just one process descriptor , that is, the descriptor of the thread group leader . To quickly retrieve the other processes in the group, the kernel must maintain a list of processes for each thread group . The same situation arises when looking for the processes belonging to a given login session or belonging to a given process group . The PID hash table**s' data structures solve all these problems, because they allow the definition of a list of processes for any PID number included in a **hash table . The core data structure is an array of four pid structures embedded in the pids field of the process descriptor ; the fields of the pid structure are shown in Table 3-6. Table 3-6. The fields of the pid data structures Type Name Description int nr The PID number struct hlist_node pid_chain The links to the next and previous elements in the hash chain list struct list_head pid_list The head of the per- PID list SUMMARY : **per- PID list**\u5176\u5b9e\u5c31\u662fthread group SUMMARY : hlist_node SUMMARY : / include / linux / pid.h Figure 3-6 shows an example based on the PIDTYPE_TGID hash table. The second entry of the pid_hash array stores the address of the hash table , that is, the array of hlist_head structures representing the heads of the chain lists. In the chain list rooted at the 71 st entry of the hash table, there are two process descriptors corresponding to the PID numbers 246 and 4,351 (double-arrow lines represent a couple of forward and backward pointers). The PID numbers are stored in the nr field of the pid structure embedded in the process descriptor (by the way, because the thread group number coincides with the PID of its leader, these numbers also are stored in the pid field of the process descriptors ). Let us consider the per- PID list of the thread group 4,351: the head of the list is stored in the pid_list field of the process descriptor included in the hash table, while the links to the next and previous elements of the per- PID list also are stored in the pid_list field of each list element. The following functions and macros are used to handle the PID hash tables: do_each_task_pid ( nr , type , task ); SUMMARY : type \u5728 / include / linux / pid.h \u4e2d\u5b9a\u4e49 while_each_task_pid ( nr , type , task ); Mark begin and end of a do-while loop that iterates over the per- PID list associated with the PID number nr of type type ; in any iteration, task points to the process descriptor of the currently scanned element. find_task_by_pid_type ( type , nr ) Looks for the process having PID nr in the hash table of type type . The function returns a process descriptor pointer if a match is found, otherwise it returns NULL . find_task_by_pid ( nr ) Same as find_task_by_pid_type(PIDTYPE_PID, nr) . attach_pid ( task , type , nr ) Inserts the process descriptor pointed to by task in the PID hash table of type type according to the PID number nr ; if a process descriptor having PID nr is already in the hash table, the function simply inserts task in the per- PID list of the already present process. detach_pid ( task , type ) Removes the process descriptor pointed to by task from the per- PID list of type type to which the descriptor belongs. If the per- PID list does not become empty, the function terminates. Otherwise, the function removes the process descriptor from the hash table of type type ; finally, if the PID number does not occur in any other hash table, the function clears the corresponding bit in the PID bitmap, so that the number can be recycled. next_thread ( task ) Returns the process descriptor address of the lightweight process that follows task in the hash table list of type PIDTYPE_TGID . Because the hash table list is circular, when applied to a conventional process the macro returns the descriptor address of the process itself.","title":"3.2.3-Relationships-Among-Processes"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.3-Relationships-Among-Processes/#323#relationships#among#processes","text":"Processes created by a program have a parent/child relationship . When a process creates multiple children , these children have sibling relationships . Several fields must be introduced in a process descriptor to represent these relationships; they are listed in Table 3-3 with respect to a given process P . Processes 0 and 1 are created by the kernel ; as we'll see later in the chapter, process 1 ( init ) is the ancestor of all other processes. Table 3-3. Fields of a process descriptor used to express parenthood relationships Field name Description real_parent Points to the process descriptor of the process that created P or to the descriptor of process 1 ( init ) if the parent process no longer exists. (Therefore, when a user starts a background process and exits the shell, the background process becomes the child of init .) parent Points to the current parent of P (this is the process that must be signaled when the child process terminates); its value usually coincides with that of real_parent . It may occasionally differ, such as when another process issues a ptrace( ) system call requesting that it be allowed to monitor P (see the section \"Execution Tracing\" in Chapter 20). children The head of the list containing all children created by P . sibling The pointers to the next and previous elements in the list of the sibling processes, those that have the same parent as P . Figure 3-4 illustrates the parent and sibling relationships of a group of processes. Process P0 successively created P1 , P2 , and P3 . Process P3 , in turn, created process P4 . Furthermore, there exist other relationships among processes: a process can be a leader of a process group or of a login session (see \"Process Management\" in Chapter 1), it can be a leader of a thread group (see \"Identifying a Process\" earlier in this chapter), and it can also trace the execution of other processes (see the section \"Execution Tracing\" in Chapter 20). Table 3-4 lists the fields of the process descriptor that establish these relationships between a process P and the other processes. Table 3-4. The fields of the process descriptor that establish non-parenthood relationships Field name Description group_leader Process descriptor pointer of the group leader of P SUMMARY : \u662fthread group leader signal->pgrp PID of the group leader of P SUMMARY : \u662fprocess group tgid PID of the thread group leader of P signal->session PID of the login session leader of P ptrace_children The head of a list containing all children of P being traced by a debugger ptrace_list The pointers to the next and previous elements in the real parent's list of traced processes (used when P is being traced) SUMMARY : struct signal_struct SUMMARY : pgrp \u8868\u793a\u7684\u662fprocess group\uff0c tgid \u8868\u793a\u7684\u662fthread group ID\u3002 SUMMARY : How does Linux tell threads apart from child processes?","title":"3.2.3. Relationships Among Processes"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.3-Relationships-Among-Processes/#3231#the#pidhash#table#and#chained#lists","text":"In several circumstances, the kernel must be able to derive the process descriptor pointer corresponding to a PID . This occurs, for instance, in servicing the kill( ) system call. When process P1 wishes to send a signal to another process, P2 , it invokes the kill( ) system call specifying the PID of P2 as the parameter. The kernel derives the process descriptor pointer from the PID and then extracts the pointer to the data structure that records the pending signals from P2 's process descriptor. Scanning the process list sequentially and checking the pid fields of the process descriptors is feasible but rather inefficient. To speed up the search, four hash tables have been introduced. Why multiple hash tables? Simply because the process descriptor includes fields that represent different types of PID (see Table 3-5), and each type of PID requires its own hash table. Table 3-5. The four hash tables and corresponding fields in the process descriptor Hash table type Field name Description PIDTYPE_PID pid PID of the process PIDTYPE_TGID tgid PID of thread group leader process PIDTYPE_PGID pgrp PID of the group leader process PIDTYPE_SID session PID of the session leader process The four hash tables are dynamically allocated during the kernel initialization phase , and their addresses are stored in the pid_hash array. The size of a single hash table depends on the amount of available RAM; for example, for systems having 512 MB of RAM, each hash table is stored in four page frames and includes 2,048 entries. SUMMARY : pid_hash \u5728 / kernel / pid.c \u4e2d\u5b9a\u4e49\uff0c\u5b9a\u4e49\u5982\u4e0b\uff1a static struct hlist_head * pid_hash [ PIDTYPE_MAX ]; hlist_head \u5728 / include / linux / list.h \u4e2d\u5b9a\u4e49\uff1b SUMMARY :2018\u8868\u793a\u7684\u662fhash table\u7684\u957f\u5ea6\uff0c\u6240\u4ee5hash\u51fd\u6570\u9700\u8981\u5c06 pid \u6620\u5c04\u5230 [0-2017] \u8303\u56f4\u5185\uff1b The PID is transformed into a table index using the pid_hashfn macro, which expands to: #define pid_hashfn(x) hash_long((unsigned long) x, pidhash_shift) The pidhash_shift variable stores the length in bits of a table index (11, in our example). The hash_long( ) function is used by many hash functions; on a 32-bit architecture it is essentially equivalent to: unsigned long hash_long ( unsigned long val , unsigned int bits ) { unsigned long hash = val * 0x9e370001UL ; return hash >> ( 32 - bits ); } Because in our example pidhash_shift is equal to 11, pid_hashfn yields values ranging between 0 and 2^{11} - 1 = 2047 2^{11} - 1 = 2047 . The Magic Constant You might wonder where the 0x9e370001 constant (= 2,654,404,609) comes from. This hash function is based on a multiplication of the index by a suitable large number, so that the result overflows and the value remaining in the 32-bit variable can be considered as the result of a modulus operation. Knuth suggested that good results are obtained when the large multiplier is a prime approximately in golden ratio to 2 32 (32 bit being the size of the 80x86's registers). Now, 2,654,404,609 is a prime near to that can also be easily multiplied by additions and bit shifts, because it is equal to SUMMARY : \u53c2\u89c1 \u9b54\u6570\u5e38\u91cf The Magic Constant As every basic computer science course explains, a hash function does not always ensure a one-to- one correspondence between PID s and table indexes. Two different PID s that hash into the same table index are said to be colliding . Linux uses chaining to handle colliding PID s; each table entry is the head of a doubly linked list of colliding process descriptors . Figure 3-5 illustrates a PID hash table with two lists. The processes having PID s 2,890 and 29,384 hash into the 200 th element of the table, while the process having PID 29,385 hashes into the 1,466 th element of the table. Hashing with chaining is preferable to a linear transformation from PID s to table indexes because at any given instance, the number of processes in the system is usually far below 32,768 (the maximum number of allowed PID s). It would be a waste of storage to define a table consisting of 32,768 entries, if, at any given instance, most such entries are unused. The data structures used in the PID hash tables are quite sophisticated, because they must keep track of the relationships between the processes. As an example, suppose that the kernel must retrieve all processes belonging to a given thread group , that is, all processes whose tgid field is equal to a given number. Looking in the hash table for the given thread group number returns just one process descriptor , that is, the descriptor of the thread group leader . To quickly retrieve the other processes in the group, the kernel must maintain a list of processes for each thread group . The same situation arises when looking for the processes belonging to a given login session or belonging to a given process group . The PID hash table**s' data structures solve all these problems, because they allow the definition of a list of processes for any PID number included in a **hash table . The core data structure is an array of four pid structures embedded in the pids field of the process descriptor ; the fields of the pid structure are shown in Table 3-6. Table 3-6. The fields of the pid data structures Type Name Description int nr The PID number struct hlist_node pid_chain The links to the next and previous elements in the hash chain list struct list_head pid_list The head of the per- PID list SUMMARY : **per- PID list**\u5176\u5b9e\u5c31\u662fthread group SUMMARY : hlist_node SUMMARY : / include / linux / pid.h Figure 3-6 shows an example based on the PIDTYPE_TGID hash table. The second entry of the pid_hash array stores the address of the hash table , that is, the array of hlist_head structures representing the heads of the chain lists. In the chain list rooted at the 71 st entry of the hash table, there are two process descriptors corresponding to the PID numbers 246 and 4,351 (double-arrow lines represent a couple of forward and backward pointers). The PID numbers are stored in the nr field of the pid structure embedded in the process descriptor (by the way, because the thread group number coincides with the PID of its leader, these numbers also are stored in the pid field of the process descriptors ). Let us consider the per- PID list of the thread group 4,351: the head of the list is stored in the pid_list field of the process descriptor included in the hash table, while the links to the next and previous elements of the per- PID list also are stored in the pid_list field of each list element. The following functions and macros are used to handle the PID hash tables: do_each_task_pid ( nr , type , task ); SUMMARY : type \u5728 / include / linux / pid.h \u4e2d\u5b9a\u4e49 while_each_task_pid ( nr , type , task ); Mark begin and end of a do-while loop that iterates over the per- PID list associated with the PID number nr of type type ; in any iteration, task points to the process descriptor of the currently scanned element. find_task_by_pid_type ( type , nr ) Looks for the process having PID nr in the hash table of type type . The function returns a process descriptor pointer if a match is found, otherwise it returns NULL . find_task_by_pid ( nr ) Same as find_task_by_pid_type(PIDTYPE_PID, nr) . attach_pid ( task , type , nr ) Inserts the process descriptor pointed to by task in the PID hash table of type type according to the PID number nr ; if a process descriptor having PID nr is already in the hash table, the function simply inserts task in the per- PID list of the already present process. detach_pid ( task , type ) Removes the process descriptor pointed to by task from the per- PID list of type type to which the descriptor belongs. If the per- PID list does not become empty, the function terminates. Otherwise, the function removes the process descriptor from the hash table of type type ; finally, if the PID number does not occur in any other hash table, the function clears the corresponding bit in the PID bitmap, so that the number can be recycled. next_thread ( task ) Returns the process descriptor address of the lightweight process that follows task in the hash table list of type PIDTYPE_TGID . Because the hash table list is circular, when applied to a conventional process the macro returns the descriptor address of the process itself.","title":"3.2.3.1. The pidhash table and chained lists"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.4-How-Processes-Are-Organized/","text":"3.2.4. How Processes Are Organized 3.2.4.1. Wait queues 3.2.4.2. Handling wait queues 3.2.4. How Processes Are Organized The runqueue lists group all processes in a TASK_RUNNING state. When it comes to grouping processes in other states, the various states call for different types of treatment, with Linux opting for one of the choices shown in the following list. Processes in a TASK_STOPPED , EXIT_ZOMBIE , or EXIT_DEAD state are not linked in specific lists. There is no need to group processes in any of these three states, because stopped, zombie, and dead processes are accessed only via PID or via linked lists of the child processes for a particular parent. Processes in a TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE state are subdivided into many classes, each of which corresponds to a specific event . In this case, the process state does not provide enough information to retrieve the process quickly, so it is necessary to introduce additional lists of processes. These are called wait queues and are discussed next. 3.2.4.1. Wait queues Wait queues have several uses in the kernel, particularly for interrupt handling , process synchronization , and timing . Because these topics are discussed in later chapters, we'll just say here that a process must often wait for some event to occur, such as for a disk operation to terminate, a system resource to be released, or a fixed interval of time to elapse. Wait queues implement conditional waits on events: a process wishing to wait for a specific event places itself in the proper wait queue and relinquishes\uff08\u8ba9\u6e21\uff09 control. Therefore, a wait queue represents a set of sleeping processes , which are woken up by the kernel when some condition becomes true. Wait queues are implemented as doubly linked lists whose elements include pointers to process descriptors . Each wait queue is identified by a wait queue head , a data structure of type wait_queue_head_t : struct __wait_queue_head { spinlock_t lock ; struct list_head task_list ; }; typedef struct __wait_queue_head wait_queue_head_t ; Because wait queues are modified by interrupt handlers as well as by major kernel functions, the doubly linked lists must be protected from concurrent accesses, which could induce unpredictable results (see Chapter 5). Synchronization is achieved by the lock spin lock in the wait queue head. The task_list field is the head of the list of waiting processes. SUMMARY : \u57281.6.3. Reentrant Kernels\u4e2d\u6709\u8fd9\u6837\u7684\u4e00\u6bb5\u63cf\u8ff0\uff0c\u975e\u5e38\u6709\u4ef7\u503c\uff1a All Unix kernels are reentrant. This means that several processes may be executing in Kernel Mode at the same time. Of course, on uniprocessor systems, only one process can progress, but many can be blocked in Kernel Mode when waiting for the CPU or the completion of some I/O operation. For instance, after issuing a read to a disk on behalf of a process, the kernel lets the disk controller handle it and resumes executing other processes. An interrupt notifies the kernel when the device has satisfied the read, so the former process can resume the execution. Elements of a wait queue list are of type wait_queue_t : struct __wait_queue { unsigned int flags ; struct task_struct * task ; wait_queue_func_t func ; struct list_head task_list ; }; typedef struct __wait_queue wait_queue_t ; Each element in the wait queue list represents a sleeping process , which is waiting for some event to occur; its descriptor address is stored in the task field. The task_list field contains the pointers that link this element to the list of processes waiting for the same event. However, it is not always convenient to wake up all sleeping processes in a wait queue. For instance, if two or more processes are waiting for exclusive access to some resource to be released, it makes sense to wake up just one process in the wait queue . This process takes the resource, while the other processes continue to sleep. (This avoids a problem known as the \" thundering herd ,\" with which multiple processes are wakened only to race for a resource that can be accessed by one of them, with the result that remaining processes must once more be put back to sleep.) Thus, there are two kinds of sleeping processes: exclusive processes (denoted by the value 1 in the flags field of the corresponding wait queue element) are selectively woken up by the kernel , while nonexclusive processes (denoted by the value 0 in the flags field) are always woken up by the kernel when the event occurs. A process waiting for a resource that can be granted to just one process at a time is a typical exclusive process . Processes waiting for an event that may concern any of them are nonexclusive . Consider, for instance, a group of processes that are waiting for the termination of a group of disk block transfers: as soon as the transfers complete, all waiting processes must be woken up. As we'll see next, the func field of a wait queue element is used to specify how the processes sleeping in the wait queue should be woken up. 3.2.4.2. Handling wait queues A new wait queue head may be defined by using the DECLARE_WAIT_QUEUE_HEAD(name) macro, which statically declares a new wait queue head variable called name and initializes its lock and task_list fields. The init_waitqueue_head( ) function may be used to initialize a wait queue head variable that was allocated dynamically. The init_waitqueue_entry(q,p ) function initializes a wait_queue_t structure q as follows: q -> flags = 0 ; q -> task = p ; q -> func = default_wake_function ; The nonexclusive process p will be awakened by default_wake_function( ) , which is a simple wrapper for the try_to_wake_up( ) function discussed in Chapter 7. Alternatively, the DEFINE_WAIT macro declares a new wait_queue_t variable and initializes it with the descriptor of the process currently executing on the CPU and the address of the autoremove_wake_function( ) wake-up function. This function invokes default_wake_function( ) to awaken the sleeping process, and then removes the wait queue element from the wait queue list . Finally, a kernel developer can define a custom awakening function by initializing the wait queue element with the init_waitqueue_func_entry( ) function. Once an element is defined, it must be inserted into a wait queue . The add_wait_queue( ) function inserts a nonexclusive process in the first position of a wait queue list. The add_wait_queue_exclusive( ) function inserts an exclusive process in the last position of a wait queue list. The remove_wait_queue( ) function removes a process from a wait queue list. The waitqueue_active( ) function checks whether a given wait queue list is empty. A process wishing to wait for a specific condition can invoke any of the functions shown in the following list. The sleep_on( ) function operates on the current process: void sleep_on ( wait_queue_head_t * wq ) { wait_queue_t wait ; init_waitqueue_entry ( & wait , current ); current -> state = TASK_UNINTERRUPTIBLE ; add_wait_queue ( wq , & wait ); /* wq points to the wait queue head */ schedule ( ); remove_wait_queue ( wq , & wait ); } The function sets the state of the current process to TASK_UNINTERRUPTIBLE and inserts it into the specified wait queue. Then it invokes the scheduler, which resumes the execution of another process. When the sleeping process is awakened, the scheduler resumes execution of the sleep_on( ) function, which removes the process from the wait queue. SUMMARY :Wait queues implement conditional waits on events: a process wishing to wait for a specific event places itself in the proper wait queue and relinquishes control.\u663e\u7136\uff0c\u4e0a\u8ff0\u4ee3\u7801\u4e2d\u7684 schedule( ) \u5c31\u8868\u793arelinquishes control\uff0c\u663e\u7136\uff0c\u8fd9\u5c31\u662f\u53d1\u751f\u5728chapter 3.3\u4e2d\u4ecb\u7ecd\u7684Process Switch\uff1b\u663e\u7136\uff0c\u5f53\u8fd9\u4e2aprocess\u518d\u6b21\u88ab\u5524\u9192\u7684\u65f6\u5019\uff0c\u5b83\u5c31\u9700\u8981\u63a5\u7740\u5b83\u4e0a\u6b21\u88ab\u7ec8\u6b62\u7684\u5730\u65b9\u7ee7\u7eed\u8fd0\u884c\uff0c\u5373\u4ece remove_wait_queue(wq, &wait); \u5f00\u59cb\u8fd0\u884c\u3002 The interruptible_sleep_on( ) function is identical to sleep_on( ) , except that it sets the state of the current process to TASK_INTERRUPTIBLE instead of setting it to TASK_UNINTERRUPTIBLE , so that the process also can be woken up by receiving a signal. The sleep_on_timeout( ) and interruptible_sleep_on_timeout( ) functions are similar to the previous ones, but they also allow the caller to define a time interval after which the process will be woken up by the kernel. To do this, they invoke the schedule_timeout( ) function instead of schedule( ) (see the section \"An Application of Dynamic Timers: the nanosleep( ) System Call\" in Chapter 6). The prepare_to_wait( ) , prepare_to_wait_exclusive( ) , and finish_wait( ) functions, introduced in Linux 2.6, offer yet another way to put the current process to sleep in a wait queue. Typically, they are used as follows: DEFINE_WAIT ( wait ); prepare_to_wait_exclusive ( & wq , & wait , TASK_INTERRUPTIBLE ); /* wq is the head of the wait queue */ ... if ( ! condition ) schedule (); finish_wait ( & wq , & wait ); The prepare_to_wait( ) and prepare_to_wait_exclusive( ) functions set the process state to the value passed as the third parameter, then set the exclusive flag in the wait queue element respectively to 0 (nonexclusive) or 1 (exclusive), and finally insert the wait queue element wait into the list of the wait queue head wq . As soon as the process is awakened, it executes the finish_wait( ) function, which sets again the process state to TASK_RUNNING (just in case the awaking condition becomes true before invoking schedule( ) ), and removes the wait queue element from the wait queue list (unless this has already been done by the wake-up function). The wait_event and wait_event_interruptible macros put the calling process to sleep on a wait queue until a given condition is verified. For instance, the wait_event(wq,condition) macro essentially yields the following fragment: DEFINE_WAIT ( _ _wait ); for (;;) { prepare_to_wait ( & wq , & _ _wait , TASK_UNINTERRUPTIBLE ); if ( condition ) break ; schedule ( ); } finish_wait ( & wq , & _ _wait ); SUMMARY : \u963b\u585e\u7684\u7cfb\u7edf\u8c03\u7528\u4e5f\u4f1a\u5bfc\u81f4kernel\u8fdb\u884cschedule\u3002 SUMMARY : \u4e3a\u4ec0\u4e48\u8981\u52a0\u4e0a for \uff1f A few comments on the functions mentioned in the above list: the sleep_on( ) -like functions cannot be used in the common situation where one has to test a condition and atomically put the process to sleep when the condition is not verified; therefore, because they are a well-known source of race conditions, their use is discouraged\uff08 Time-of-check to time-of-use \uff09. Moreover, in order to insert an exclusive process into a wait queue , the kernel must make use of the prepare_to_wait_exclusive( ) function (or just invoke add_wait_queue_exclusive( ) directly); any other helper function inserts the process as nonexclusive. Finally, unless DEFINE_WAIT or finish_wait( ) are used, the kernel must remove the wait queue element from the list after the waiting process has been awakened. The kernel awakens processes in the wait queues , putting them in the TASK_RUNNING state, by means of one of the following macros: wake_up , wake_up_nr , wake_up_all , wake_up_interruptible , wake_up_interruptible_nr , wake_up_interruptible_all , wake_up_interruptible_sync , and wake_up_locked . One can understand what each of these nine macros does from its name: All macros take into consideration sleeping processes in the TASK_INTERRUPTIBLE state; if the macro name does not include the string \"interruptible,\" sleeping processes in the TASK_UNINTERRUPTIBLE state also are considered. SUMMARY : \u6ca1\u6709\u641e\u6e05\u695a\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u542b\u4e49 All macros wake all nonexclusive processes having the required state (see the previous bullet item). The macros whose name include the string \" nr \" wake a given number of exclusive processes having the required state; this number is a parameter of the macro. The macros whose names include the string \" all \" wake all exclusive processes having the required state. Finally, the macros whose names don't include \" nr \" or \" all \" wake exactly one exclusive process that has the required state. The macros whose names don't include the string \" sync \" check whether the priority of any of the woken processes is higher than that of the processes currently running in the systems and invoke schedule( ) if necessary. These checks are not made by the macro whose name includes the string \" sync \"; as a result, execution of a high priority process might be slightly delayed. The wake_up_locked macro is similar to wake_up , except that it is called when the spin lock in wait_queue_head_t is already held. For instance, the wake_up macro is essentially equivalent to the following code fragment: void wake_up ( wait_queue_head_t * q ) { struct list_head * tmp ; wait_queue_t * curr ; list_for_each ( tmp , & q -> task_list ) { curr = list_entry ( tmp , wait_queue_t , task_list ); if ( curr -> func ( curr , TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE , 0 , NULL ) && curr -> flags ) break ; } } The list_for_each macro scans all items in the q->task_list doubly linked list, that is, all processes in the wait queue . For each item, the list_entry macro computes the address of the corresponding wait_queue_t variable. The func field of this variable stores the address of the wake-up function, which tries to wake up the process identified by the task field of the wait queue element. If a process has been effectively awakened (the function returned 1) and if the process is exclusive ( curr->flags equal to 1), the loop terminates. Because all nonexclusive processes are always at the beginning of the doubly linked list and all exclusive processes are at the end, the function always wakes the nonexclusive processes and then wakes one exclusive process, if any exists. [ * ] [ * ] By the way, it is rather uncommon that a wait queue includes both exclusive and nonexclusive processes.","title":"3.2.4-How-Processes-Are-Organized"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.4-How-Processes-Are-Organized/#324#how#processes#are#organized","text":"The runqueue lists group all processes in a TASK_RUNNING state. When it comes to grouping processes in other states, the various states call for different types of treatment, with Linux opting for one of the choices shown in the following list. Processes in a TASK_STOPPED , EXIT_ZOMBIE , or EXIT_DEAD state are not linked in specific lists. There is no need to group processes in any of these three states, because stopped, zombie, and dead processes are accessed only via PID or via linked lists of the child processes for a particular parent. Processes in a TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE state are subdivided into many classes, each of which corresponds to a specific event . In this case, the process state does not provide enough information to retrieve the process quickly, so it is necessary to introduce additional lists of processes. These are called wait queues and are discussed next.","title":"3.2.4. How Processes Are Organized"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.4-How-Processes-Are-Organized/#3241#wait#queues","text":"Wait queues have several uses in the kernel, particularly for interrupt handling , process synchronization , and timing . Because these topics are discussed in later chapters, we'll just say here that a process must often wait for some event to occur, such as for a disk operation to terminate, a system resource to be released, or a fixed interval of time to elapse. Wait queues implement conditional waits on events: a process wishing to wait for a specific event places itself in the proper wait queue and relinquishes\uff08\u8ba9\u6e21\uff09 control. Therefore, a wait queue represents a set of sleeping processes , which are woken up by the kernel when some condition becomes true. Wait queues are implemented as doubly linked lists whose elements include pointers to process descriptors . Each wait queue is identified by a wait queue head , a data structure of type wait_queue_head_t : struct __wait_queue_head { spinlock_t lock ; struct list_head task_list ; }; typedef struct __wait_queue_head wait_queue_head_t ; Because wait queues are modified by interrupt handlers as well as by major kernel functions, the doubly linked lists must be protected from concurrent accesses, which could induce unpredictable results (see Chapter 5). Synchronization is achieved by the lock spin lock in the wait queue head. The task_list field is the head of the list of waiting processes. SUMMARY : \u57281.6.3. Reentrant Kernels\u4e2d\u6709\u8fd9\u6837\u7684\u4e00\u6bb5\u63cf\u8ff0\uff0c\u975e\u5e38\u6709\u4ef7\u503c\uff1a All Unix kernels are reentrant. This means that several processes may be executing in Kernel Mode at the same time. Of course, on uniprocessor systems, only one process can progress, but many can be blocked in Kernel Mode when waiting for the CPU or the completion of some I/O operation. For instance, after issuing a read to a disk on behalf of a process, the kernel lets the disk controller handle it and resumes executing other processes. An interrupt notifies the kernel when the device has satisfied the read, so the former process can resume the execution. Elements of a wait queue list are of type wait_queue_t : struct __wait_queue { unsigned int flags ; struct task_struct * task ; wait_queue_func_t func ; struct list_head task_list ; }; typedef struct __wait_queue wait_queue_t ; Each element in the wait queue list represents a sleeping process , which is waiting for some event to occur; its descriptor address is stored in the task field. The task_list field contains the pointers that link this element to the list of processes waiting for the same event. However, it is not always convenient to wake up all sleeping processes in a wait queue. For instance, if two or more processes are waiting for exclusive access to some resource to be released, it makes sense to wake up just one process in the wait queue . This process takes the resource, while the other processes continue to sleep. (This avoids a problem known as the \" thundering herd ,\" with which multiple processes are wakened only to race for a resource that can be accessed by one of them, with the result that remaining processes must once more be put back to sleep.) Thus, there are two kinds of sleeping processes: exclusive processes (denoted by the value 1 in the flags field of the corresponding wait queue element) are selectively woken up by the kernel , while nonexclusive processes (denoted by the value 0 in the flags field) are always woken up by the kernel when the event occurs. A process waiting for a resource that can be granted to just one process at a time is a typical exclusive process . Processes waiting for an event that may concern any of them are nonexclusive . Consider, for instance, a group of processes that are waiting for the termination of a group of disk block transfers: as soon as the transfers complete, all waiting processes must be woken up. As we'll see next, the func field of a wait queue element is used to specify how the processes sleeping in the wait queue should be woken up.","title":"3.2.4.1. Wait queues"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.4-How-Processes-Are-Organized/#3242#handling#wait#queues","text":"A new wait queue head may be defined by using the DECLARE_WAIT_QUEUE_HEAD(name) macro, which statically declares a new wait queue head variable called name and initializes its lock and task_list fields. The init_waitqueue_head( ) function may be used to initialize a wait queue head variable that was allocated dynamically. The init_waitqueue_entry(q,p ) function initializes a wait_queue_t structure q as follows: q -> flags = 0 ; q -> task = p ; q -> func = default_wake_function ; The nonexclusive process p will be awakened by default_wake_function( ) , which is a simple wrapper for the try_to_wake_up( ) function discussed in Chapter 7. Alternatively, the DEFINE_WAIT macro declares a new wait_queue_t variable and initializes it with the descriptor of the process currently executing on the CPU and the address of the autoremove_wake_function( ) wake-up function. This function invokes default_wake_function( ) to awaken the sleeping process, and then removes the wait queue element from the wait queue list . Finally, a kernel developer can define a custom awakening function by initializing the wait queue element with the init_waitqueue_func_entry( ) function. Once an element is defined, it must be inserted into a wait queue . The add_wait_queue( ) function inserts a nonexclusive process in the first position of a wait queue list. The add_wait_queue_exclusive( ) function inserts an exclusive process in the last position of a wait queue list. The remove_wait_queue( ) function removes a process from a wait queue list. The waitqueue_active( ) function checks whether a given wait queue list is empty. A process wishing to wait for a specific condition can invoke any of the functions shown in the following list. The sleep_on( ) function operates on the current process: void sleep_on ( wait_queue_head_t * wq ) { wait_queue_t wait ; init_waitqueue_entry ( & wait , current ); current -> state = TASK_UNINTERRUPTIBLE ; add_wait_queue ( wq , & wait ); /* wq points to the wait queue head */ schedule ( ); remove_wait_queue ( wq , & wait ); } The function sets the state of the current process to TASK_UNINTERRUPTIBLE and inserts it into the specified wait queue. Then it invokes the scheduler, which resumes the execution of another process. When the sleeping process is awakened, the scheduler resumes execution of the sleep_on( ) function, which removes the process from the wait queue. SUMMARY :Wait queues implement conditional waits on events: a process wishing to wait for a specific event places itself in the proper wait queue and relinquishes control.\u663e\u7136\uff0c\u4e0a\u8ff0\u4ee3\u7801\u4e2d\u7684 schedule( ) \u5c31\u8868\u793arelinquishes control\uff0c\u663e\u7136\uff0c\u8fd9\u5c31\u662f\u53d1\u751f\u5728chapter 3.3\u4e2d\u4ecb\u7ecd\u7684Process Switch\uff1b\u663e\u7136\uff0c\u5f53\u8fd9\u4e2aprocess\u518d\u6b21\u88ab\u5524\u9192\u7684\u65f6\u5019\uff0c\u5b83\u5c31\u9700\u8981\u63a5\u7740\u5b83\u4e0a\u6b21\u88ab\u7ec8\u6b62\u7684\u5730\u65b9\u7ee7\u7eed\u8fd0\u884c\uff0c\u5373\u4ece remove_wait_queue(wq, &wait); \u5f00\u59cb\u8fd0\u884c\u3002 The interruptible_sleep_on( ) function is identical to sleep_on( ) , except that it sets the state of the current process to TASK_INTERRUPTIBLE instead of setting it to TASK_UNINTERRUPTIBLE , so that the process also can be woken up by receiving a signal. The sleep_on_timeout( ) and interruptible_sleep_on_timeout( ) functions are similar to the previous ones, but they also allow the caller to define a time interval after which the process will be woken up by the kernel. To do this, they invoke the schedule_timeout( ) function instead of schedule( ) (see the section \"An Application of Dynamic Timers: the nanosleep( ) System Call\" in Chapter 6). The prepare_to_wait( ) , prepare_to_wait_exclusive( ) , and finish_wait( ) functions, introduced in Linux 2.6, offer yet another way to put the current process to sleep in a wait queue. Typically, they are used as follows: DEFINE_WAIT ( wait ); prepare_to_wait_exclusive ( & wq , & wait , TASK_INTERRUPTIBLE ); /* wq is the head of the wait queue */ ... if ( ! condition ) schedule (); finish_wait ( & wq , & wait ); The prepare_to_wait( ) and prepare_to_wait_exclusive( ) functions set the process state to the value passed as the third parameter, then set the exclusive flag in the wait queue element respectively to 0 (nonexclusive) or 1 (exclusive), and finally insert the wait queue element wait into the list of the wait queue head wq . As soon as the process is awakened, it executes the finish_wait( ) function, which sets again the process state to TASK_RUNNING (just in case the awaking condition becomes true before invoking schedule( ) ), and removes the wait queue element from the wait queue list (unless this has already been done by the wake-up function). The wait_event and wait_event_interruptible macros put the calling process to sleep on a wait queue until a given condition is verified. For instance, the wait_event(wq,condition) macro essentially yields the following fragment: DEFINE_WAIT ( _ _wait ); for (;;) { prepare_to_wait ( & wq , & _ _wait , TASK_UNINTERRUPTIBLE ); if ( condition ) break ; schedule ( ); } finish_wait ( & wq , & _ _wait ); SUMMARY : \u963b\u585e\u7684\u7cfb\u7edf\u8c03\u7528\u4e5f\u4f1a\u5bfc\u81f4kernel\u8fdb\u884cschedule\u3002 SUMMARY : \u4e3a\u4ec0\u4e48\u8981\u52a0\u4e0a for \uff1f A few comments on the functions mentioned in the above list: the sleep_on( ) -like functions cannot be used in the common situation where one has to test a condition and atomically put the process to sleep when the condition is not verified; therefore, because they are a well-known source of race conditions, their use is discouraged\uff08 Time-of-check to time-of-use \uff09. Moreover, in order to insert an exclusive process into a wait queue , the kernel must make use of the prepare_to_wait_exclusive( ) function (or just invoke add_wait_queue_exclusive( ) directly); any other helper function inserts the process as nonexclusive. Finally, unless DEFINE_WAIT or finish_wait( ) are used, the kernel must remove the wait queue element from the list after the waiting process has been awakened. The kernel awakens processes in the wait queues , putting them in the TASK_RUNNING state, by means of one of the following macros: wake_up , wake_up_nr , wake_up_all , wake_up_interruptible , wake_up_interruptible_nr , wake_up_interruptible_all , wake_up_interruptible_sync , and wake_up_locked . One can understand what each of these nine macros does from its name: All macros take into consideration sleeping processes in the TASK_INTERRUPTIBLE state; if the macro name does not include the string \"interruptible,\" sleeping processes in the TASK_UNINTERRUPTIBLE state also are considered. SUMMARY : \u6ca1\u6709\u641e\u6e05\u695a\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u542b\u4e49 All macros wake all nonexclusive processes having the required state (see the previous bullet item). The macros whose name include the string \" nr \" wake a given number of exclusive processes having the required state; this number is a parameter of the macro. The macros whose names include the string \" all \" wake all exclusive processes having the required state. Finally, the macros whose names don't include \" nr \" or \" all \" wake exactly one exclusive process that has the required state. The macros whose names don't include the string \" sync \" check whether the priority of any of the woken processes is higher than that of the processes currently running in the systems and invoke schedule( ) if necessary. These checks are not made by the macro whose name includes the string \" sync \"; as a result, execution of a high priority process might be slightly delayed. The wake_up_locked macro is similar to wake_up , except that it is called when the spin lock in wait_queue_head_t is already held. For instance, the wake_up macro is essentially equivalent to the following code fragment: void wake_up ( wait_queue_head_t * q ) { struct list_head * tmp ; wait_queue_t * curr ; list_for_each ( tmp , & q -> task_list ) { curr = list_entry ( tmp , wait_queue_t , task_list ); if ( curr -> func ( curr , TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE , 0 , NULL ) && curr -> flags ) break ; } } The list_for_each macro scans all items in the q->task_list doubly linked list, that is, all processes in the wait queue . For each item, the list_entry macro computes the address of the corresponding wait_queue_t variable. The func field of this variable stores the address of the wake-up function, which tries to wake up the process identified by the task field of the wait queue element. If a process has been effectively awakened (the function returned 1) and if the process is exclusive ( curr->flags equal to 1), the loop terminates. Because all nonexclusive processes are always at the beginning of the doubly linked list and all exclusive processes are at the end, the function always wakes the nonexclusive processes and then wakes one exclusive process, if any exists. [ * ] [ * ] By the way, it is rather uncommon that a wait queue includes both exclusive and nonexclusive processes.","title":"3.2.4.2. Handling wait queues"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.2.5-Process-Resource-Limits/","text":"","title":"3.2.5-Process-Resource-Limits"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.3-Process-Switch/","text":"3.3. Process Switch NOTE: \u672c\u8282\u6240\u63cf\u8ff0\u7684process switch\u7684\u5185\u5bb9\u662f\u52a0\u8f7dnext process\uff0c\u81f3\u4e8e\u5982\u4f55\u4fdd\u5b58previous process\uff0c\u672c\u8282\u6ca1\u6709\u8fdb\u884c\u6df1\u5165\u7684\u63cf\u8ff0\u3002 To control the execution of processes, the kernel must be able to suspend the execution of the process running on the CPU and resume the execution of some other process previously suspended. This activity goes variously by the names process switch , task switch , or context switch . The next sections describe the elements of process switching in Linux. 3.3.1. Hardware Context While each process can have its own address space , all processes have to share the CPU registers . So before resuming the execution of a process, the kernel must ensure that each such register is loaded with the value it had when the process was suspended. The set of data that must be loaded into the registers before the process resumes its execution on the CPU is called the hardware context . The hardware context is a subset of the process execution context , which includes all information needed for the process execution. In Linux, a part of the hardware context of a process is stored in the process descriptor , while the remaining part is saved in the Kernel Mode stack . NOTE : \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u975e\u5e38\u91cd\u8981 In the description that follows, we will assume the prev local variable refers to the process descriptor of the process being switched out and next refers to the one being switched in to replace it. We can thus define a process switch as the activity consisting of saving the hardware context of prev and replacing it with the hardware context of next . Because process switches occur quite often, it is important to minimize the time spent in saving and loading hardware contexts. Old versions of Linux took advantage of the hardware support offered by the 80x86 architecture and performed a process switch through a far jmp instruction [ * ] to the selector of the Task State Segment Descriptor of the next process. While executing the instruction, the CPU performs a hardware context switch by automatically saving the old hardware context and loading a new one. But Linux 2.6 uses software to perform a process switch for the following reasons: [ * ] far jmp instructions modify both the cs and eip registers, while simple jmp instructions modify only eip Step-by-step switching performed through a sequence of mov instructions allows better control over the validity of the data being loaded. In particular, it is possible to check the values of the ds and es segmentation registers , which might have been forged by a malicious user. This type of checking is not possible when using a single far jmp instruction. The amount of time required by the old approach and the new approach is about the same. However, it is not possible to optimize a hardware context switch , while there might be room for improving the current switching code. Process switching occurs only in Kernel Mode . The contents of all registers used by a process in User Mode have already been saved on the Kernel Mode stack before performing process switching (see Chapter 4). This includes the contents of the ss and esp pair that specifies the User Mode stack pointer address . 3.3.2. Task State Segment The 80x86 architecture includes a specific segment type called the Task State Segment (TSS), to store hardware contexts. Although Linux doesn't use hardware context switches , it is nonetheless forced to set up a TSS for each distinct CPU in the system. This is done for two main reasons: When an 80x86 CPU switches from User Mode to Kernel Mode , it fetches the address of the Kernel Mode stack from the TSS (see the sections \"Hardware Handling of Interrupts and Exceptions\" in Chapter 4 and \"Issuing a System Call via the sysenter Instruction\" in Chapter 10). When a User Mode process attempts to access an I/O port by means of an in or out instruction, the CPU may need to access an I/O Permission Bitmap stored in the TSS to verify whether the process is allowed to address the port. 3.3.2.1. The thread field At every process switch, the hardware context of the process being replaced must be saved somewhere. It cannot be saved on the TSS, as in the original Intel design, because Linux uses a single TSS for each processor, instead of one for every process. Thus, each process descriptor includes a field called thread of type thread_struct , in which the kernel saves the hardware context whenever the process is being switched out. As we'll see later, this data structure includes fields for most of the CPU registers, except the general-purpose registers such as eax , ebx , etc., which are stored in the Kernel Mode stack . 3.3.3. Performing the Process Switch A process switch may occur at just one well-defined point: the schedule( ) function, which is discussed at length in Chapter 7. Here, we are only concerned with how the kernel performs a process switch. Essentially, every process switch consists of two steps: Switching the Page Global Directory to install a new address space; we'll describe this step in Chapter 9. Switching the Kernel Mode stack and the hardware context, which provides all the information needed by the kernel to execute the new process, including the CPU registers.","title":"3.3-Process-Switch"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.3-Process-Switch/#33#process#switch","text":"NOTE: \u672c\u8282\u6240\u63cf\u8ff0\u7684process switch\u7684\u5185\u5bb9\u662f\u52a0\u8f7dnext process\uff0c\u81f3\u4e8e\u5982\u4f55\u4fdd\u5b58previous process\uff0c\u672c\u8282\u6ca1\u6709\u8fdb\u884c\u6df1\u5165\u7684\u63cf\u8ff0\u3002 To control the execution of processes, the kernel must be able to suspend the execution of the process running on the CPU and resume the execution of some other process previously suspended. This activity goes variously by the names process switch , task switch , or context switch . The next sections describe the elements of process switching in Linux.","title":"3.3. Process Switch"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.3-Process-Switch/#331#hardware#context","text":"While each process can have its own address space , all processes have to share the CPU registers . So before resuming the execution of a process, the kernel must ensure that each such register is loaded with the value it had when the process was suspended. The set of data that must be loaded into the registers before the process resumes its execution on the CPU is called the hardware context . The hardware context is a subset of the process execution context , which includes all information needed for the process execution. In Linux, a part of the hardware context of a process is stored in the process descriptor , while the remaining part is saved in the Kernel Mode stack . NOTE : \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u975e\u5e38\u91cd\u8981 In the description that follows, we will assume the prev local variable refers to the process descriptor of the process being switched out and next refers to the one being switched in to replace it. We can thus define a process switch as the activity consisting of saving the hardware context of prev and replacing it with the hardware context of next . Because process switches occur quite often, it is important to minimize the time spent in saving and loading hardware contexts. Old versions of Linux took advantage of the hardware support offered by the 80x86 architecture and performed a process switch through a far jmp instruction [ * ] to the selector of the Task State Segment Descriptor of the next process. While executing the instruction, the CPU performs a hardware context switch by automatically saving the old hardware context and loading a new one. But Linux 2.6 uses software to perform a process switch for the following reasons: [ * ] far jmp instructions modify both the cs and eip registers, while simple jmp instructions modify only eip Step-by-step switching performed through a sequence of mov instructions allows better control over the validity of the data being loaded. In particular, it is possible to check the values of the ds and es segmentation registers , which might have been forged by a malicious user. This type of checking is not possible when using a single far jmp instruction. The amount of time required by the old approach and the new approach is about the same. However, it is not possible to optimize a hardware context switch , while there might be room for improving the current switching code. Process switching occurs only in Kernel Mode . The contents of all registers used by a process in User Mode have already been saved on the Kernel Mode stack before performing process switching (see Chapter 4). This includes the contents of the ss and esp pair that specifies the User Mode stack pointer address .","title":"3.3.1. Hardware Context"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.3-Process-Switch/#332#task#state#segment","text":"The 80x86 architecture includes a specific segment type called the Task State Segment (TSS), to store hardware contexts. Although Linux doesn't use hardware context switches , it is nonetheless forced to set up a TSS for each distinct CPU in the system. This is done for two main reasons: When an 80x86 CPU switches from User Mode to Kernel Mode , it fetches the address of the Kernel Mode stack from the TSS (see the sections \"Hardware Handling of Interrupts and Exceptions\" in Chapter 4 and \"Issuing a System Call via the sysenter Instruction\" in Chapter 10). When a User Mode process attempts to access an I/O port by means of an in or out instruction, the CPU may need to access an I/O Permission Bitmap stored in the TSS to verify whether the process is allowed to address the port.","title":"3.3.2. Task State Segment"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.3-Process-Switch/#3321#the#thread#field","text":"At every process switch, the hardware context of the process being replaced must be saved somewhere. It cannot be saved on the TSS, as in the original Intel design, because Linux uses a single TSS for each processor, instead of one for every process. Thus, each process descriptor includes a field called thread of type thread_struct , in which the kernel saves the hardware context whenever the process is being switched out. As we'll see later, this data structure includes fields for most of the CPU registers, except the general-purpose registers such as eax , ebx , etc., which are stored in the Kernel Mode stack .","title":"3.3.2.1. The thread field"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.3-Process-Switch/#333#performing#the#process#switch","text":"A process switch may occur at just one well-defined point: the schedule( ) function, which is discussed at length in Chapter 7. Here, we are only concerned with how the kernel performs a process switch. Essentially, every process switch consists of two steps: Switching the Page Global Directory to install a new address space; we'll describe this step in Chapter 9. Switching the Kernel Mode stack and the hardware context, which provides all the information needed by the kernel to execute the new process, including the CPU registers.","title":"3.3.3. Performing the Process Switch"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4-Creating-Processes/","text":"3.4. Creating Processes Unix operating systems rely heavily on process creation to satisfy user requests. For example, the shell creates a new process that executes another copy of the shell whenever the user enters a command. Traditional Unix systems treat all processes in the same way: resources owned by the parent process are duplicated in the child process. This approach makes process creation very slow and inefficient, because it requires copying the entire address space of the parent process. The child process rarely needs to read or modify all the resources inherited from the parent; in many cases, it issues an immediate execve( ) and wipes out the address space that was so carefully copied. Modern Unix kernels solve this problem by introducing three different mechanisms: The Copy On Write technique allows both the parent and the child to read the same physical pages. Whenever either one tries to write on a physical page, the kernel copies its contents into a new physical page that is assigned to the writing process. The implementation of this technique in Linux is fully explained in Chapter 9. Lightweight processes allow both the parent and the child to share many per-process kernel data structures , such as the paging tables (and therefore the entire User Mode address space ), the open file tables, and the signal dispositions . The vfork( ) system call creates a process that shares the memory address space of its parent. To prevent the parent from overwriting data needed by the child, the parent's execution is blocked until the child exits or executes a new program. We'll learn more about the vfork( ) system call in the following section. 3.4.1. The clone( ) , fork( ) , and vfork( ) System Calls Lightweight processes are created in Linux by using a function named clone( ) , which uses the following parameters: NOTE: \u53c2\u89c1\u8be5\u51fd\u6570\u7684man page\u83b7\u53d6\u5173\u4e8e\u8be5\u51fd\u6570\u7684\u5404\u79cd\u4fe1\u606f\u3002 fn Specifies a function to be executed by the new process; when the function returns, the child terminates. The function returns an integer, which represents the exit code for the child process. arg Points to data passed to the fn( ) function. flags Miscellaneous information. The low byte specifies the signal number to be sent to the parent process when the child terminates; the SIGCHLD signal is generally selected. The remaining three bytes encode a group of clone flags , which are shown in Table 3-8. child_stack Specifies the User Mode stack pointer to be assigned to the esp register of the child process. The invoking process (the parent) should always allocate a new stack for the child. tls Specifies the address of a data structure that defines a Thread Local Storage segment for the new lightweight process (see the section \"The Linux GDT\" in Chapter 2). Meaningful only if the CLONE_SETTLS flag is set. ptid Specifies the address of a User Mode variable of the parent process that will hold the PID of the new lightweight process. Meaningful only if the CLONE_PARENT_SETTID flag is set. ctid Specifies the address of a User Mode variable of the new lightweight process that will hold the PID of such process. Meaningful only if the CLONE_CHILD_SETTID flag is set. Table 3-8. Clone flags Flag name Description CLONE_VM Shares the memory descriptor and all Page Tables (see Chapter 9). CLONE_FS Shares the table that identifies the root directory and the current working directory, as well as the value of the bitmask used to mask the initial file permissions of a new file (the so-called file umask ). CLONE_FILES Shares the table that identifies the open files (see Chapter 12). CLONE_SIGHAND Shares the tables that identify the signal handlers and the blocked and pending signals (see Chapter 11). If this flag is true, the CLONE_VM flag must also be set. CLONE_PTRACE If traced, the parent wants the child to be traced too. Furthermore, the debugger may want to trace the child on its own; in this case, the kernel forces the flag to 1. CLONE_VFORK Set when the system call issued is a vfork( ) (see later in this section). CLONE_PARENT Sets the parent of the child ( parent and real_parent fields in the process descriptor) to the parent of the calling process. CLONE_THREAD Inserts the child into the same thread group of the parent, and forces the child to share the signal descriptor of the parent. The child's tgid and group_leader fields are set accordingly. If this flag is true, the CLONE_SIGHAND flag must also be set. CLONE_NEWNS Set if the clone needs its own namespace, that is, its own view of the mounted filesystems (see Chapter 12); it is not possible to specify both CLONE_NEWNS and CLONE_FS . CLONE_SYSVSEM Shares the System V IPC undoable semaphore operations (see the section \"IPC Semaphores\" in Chapter 19). CLONE_SETTLS Creates a new Thread Local Storage (TLS) segment for the lightweight process; the segment is described in the structure pointed to by the tls parameter. CLONE_PARENT_SETTID Writes the PID of the child into the User Mode variable of the parent pointed to by the ptid parameter. CLONE_CHILD_CLEARTID When set, the kernel sets up a mechanism to be triggered when the child process will exit or when it will start executing a new program. In these cases, the kernel will clear the User Mode variable pointed to by the ctid parameter and will awaken any process waiting for this event. CLONE_DETACHED A legacy flag ignored by the kernel. CLONE_UNTRACED Set by the kernel to override the value of the CLONE_PTRACE flag (used for disabling tracing of kernel threads ; see the section \"Kernel Threads\" later in this chapter). CLONE_CHILD_SETTID Writes the PID of the child into the User Mode variable of the child pointed to by the ctid parameter. CLONE_STOPPED Forces the child to start in the TASK_STOPPED state. clone( ) is actually a wrapper function defined in the C library (see the section \"POSIX APIs and System Calls\" in Chapter 10), which sets up the stack of the new lightweight process and invokes a clone( ) system call hidden to the programmer. The sys_clone( ) service routine that implements the clone( ) system call does not have the fn and arg parameters. In fact, the wrapper function saves the pointer fn into the child's stack position corresponding to the return address of the wrapper function itself; the pointer arg is saved on the child's stack right below fn . When the wrapper function terminates, the CPU fetches the return address from the stack and executes the fn(arg) function. The traditional fork( ) system call is implemented by Linux as a clone( ) system call whose flags parameter specifies both a SIGCHLD signal and all the clone flags cleared, and whose child_stack parameter is the current parent stack pointer . Therefore, the parent and child temporarily share the same User Mode stack . But thanks to the Copy On Write mechanism, they usually get separate copies of the User Mode stack as soon as one tries to change the stack. The vfork( ) system call, introduced in the previous section, is implemented by Linux as a clone( ) system call whose flags parameter specifies both a SIGCHLD signal and the flags CLONE_VM and CLONE_VFORK , and whose child_stack parameter is equal to the current parent stack pointer .","title":"3.4-Creating-Processes"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4-Creating-Processes/#34#creating#processes","text":"Unix operating systems rely heavily on process creation to satisfy user requests. For example, the shell creates a new process that executes another copy of the shell whenever the user enters a command. Traditional Unix systems treat all processes in the same way: resources owned by the parent process are duplicated in the child process. This approach makes process creation very slow and inefficient, because it requires copying the entire address space of the parent process. The child process rarely needs to read or modify all the resources inherited from the parent; in many cases, it issues an immediate execve( ) and wipes out the address space that was so carefully copied. Modern Unix kernels solve this problem by introducing three different mechanisms: The Copy On Write technique allows both the parent and the child to read the same physical pages. Whenever either one tries to write on a physical page, the kernel copies its contents into a new physical page that is assigned to the writing process. The implementation of this technique in Linux is fully explained in Chapter 9. Lightweight processes allow both the parent and the child to share many per-process kernel data structures , such as the paging tables (and therefore the entire User Mode address space ), the open file tables, and the signal dispositions . The vfork( ) system call creates a process that shares the memory address space of its parent. To prevent the parent from overwriting data needed by the child, the parent's execution is blocked until the child exits or executes a new program. We'll learn more about the vfork( ) system call in the following section.","title":"3.4. Creating Processes"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4-Creating-Processes/#341#the#clone#fork#and#vfork#system#calls","text":"Lightweight processes are created in Linux by using a function named clone( ) , which uses the following parameters: NOTE: \u53c2\u89c1\u8be5\u51fd\u6570\u7684man page\u83b7\u53d6\u5173\u4e8e\u8be5\u51fd\u6570\u7684\u5404\u79cd\u4fe1\u606f\u3002 fn Specifies a function to be executed by the new process; when the function returns, the child terminates. The function returns an integer, which represents the exit code for the child process. arg Points to data passed to the fn( ) function. flags Miscellaneous information. The low byte specifies the signal number to be sent to the parent process when the child terminates; the SIGCHLD signal is generally selected. The remaining three bytes encode a group of clone flags , which are shown in Table 3-8. child_stack Specifies the User Mode stack pointer to be assigned to the esp register of the child process. The invoking process (the parent) should always allocate a new stack for the child. tls Specifies the address of a data structure that defines a Thread Local Storage segment for the new lightweight process (see the section \"The Linux GDT\" in Chapter 2). Meaningful only if the CLONE_SETTLS flag is set. ptid Specifies the address of a User Mode variable of the parent process that will hold the PID of the new lightweight process. Meaningful only if the CLONE_PARENT_SETTID flag is set. ctid Specifies the address of a User Mode variable of the new lightweight process that will hold the PID of such process. Meaningful only if the CLONE_CHILD_SETTID flag is set. Table 3-8. Clone flags Flag name Description CLONE_VM Shares the memory descriptor and all Page Tables (see Chapter 9). CLONE_FS Shares the table that identifies the root directory and the current working directory, as well as the value of the bitmask used to mask the initial file permissions of a new file (the so-called file umask ). CLONE_FILES Shares the table that identifies the open files (see Chapter 12). CLONE_SIGHAND Shares the tables that identify the signal handlers and the blocked and pending signals (see Chapter 11). If this flag is true, the CLONE_VM flag must also be set. CLONE_PTRACE If traced, the parent wants the child to be traced too. Furthermore, the debugger may want to trace the child on its own; in this case, the kernel forces the flag to 1. CLONE_VFORK Set when the system call issued is a vfork( ) (see later in this section). CLONE_PARENT Sets the parent of the child ( parent and real_parent fields in the process descriptor) to the parent of the calling process. CLONE_THREAD Inserts the child into the same thread group of the parent, and forces the child to share the signal descriptor of the parent. The child's tgid and group_leader fields are set accordingly. If this flag is true, the CLONE_SIGHAND flag must also be set. CLONE_NEWNS Set if the clone needs its own namespace, that is, its own view of the mounted filesystems (see Chapter 12); it is not possible to specify both CLONE_NEWNS and CLONE_FS . CLONE_SYSVSEM Shares the System V IPC undoable semaphore operations (see the section \"IPC Semaphores\" in Chapter 19). CLONE_SETTLS Creates a new Thread Local Storage (TLS) segment for the lightweight process; the segment is described in the structure pointed to by the tls parameter. CLONE_PARENT_SETTID Writes the PID of the child into the User Mode variable of the parent pointed to by the ptid parameter. CLONE_CHILD_CLEARTID When set, the kernel sets up a mechanism to be triggered when the child process will exit or when it will start executing a new program. In these cases, the kernel will clear the User Mode variable pointed to by the ctid parameter and will awaken any process waiting for this event. CLONE_DETACHED A legacy flag ignored by the kernel. CLONE_UNTRACED Set by the kernel to override the value of the CLONE_PTRACE flag (used for disabling tracing of kernel threads ; see the section \"Kernel Threads\" later in this chapter). CLONE_CHILD_SETTID Writes the PID of the child into the User Mode variable of the child pointed to by the ctid parameter. CLONE_STOPPED Forces the child to start in the TASK_STOPPED state. clone( ) is actually a wrapper function defined in the C library (see the section \"POSIX APIs and System Calls\" in Chapter 10), which sets up the stack of the new lightweight process and invokes a clone( ) system call hidden to the programmer. The sys_clone( ) service routine that implements the clone( ) system call does not have the fn and arg parameters. In fact, the wrapper function saves the pointer fn into the child's stack position corresponding to the return address of the wrapper function itself; the pointer arg is saved on the child's stack right below fn . When the wrapper function terminates, the CPU fetches the return address from the stack and executes the fn(arg) function. The traditional fork( ) system call is implemented by Linux as a clone( ) system call whose flags parameter specifies both a SIGCHLD signal and all the clone flags cleared, and whose child_stack parameter is the current parent stack pointer . Therefore, the parent and child temporarily share the same User Mode stack . But thanks to the Copy On Write mechanism, they usually get separate copies of the User Mode stack as soon as one tries to change the stack. The vfork( ) system call, introduced in the previous section, is implemented by Linux as a clone( ) system call whose flags parameter specifies both a SIGCHLD signal and the flags CLONE_VM and CLONE_VFORK , and whose child_stack parameter is equal to the current parent stack pointer .","title":"3.4.1. The clone( ), fork( ), and vfork( ) System Calls"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4.2-Kernel-Threads/","text":"3.4.2. Kernel Threads 3.4.2.1. Creating a kernel thread 3.4.2.2. Process 0 3.4.2.3. Process 1 3.4.2.4. Other kernel threads 3.4.2. Kernel Threads Traditional Unix systems delegate some critical tasks to intermittently(\u95f4\u6b47\u5730) running processes, including flushing disk caches, swapping out unused pages, servicing network connections, and so on. Indeed, it is not efficient to perform these tasks in strict linear fashion; both their functions and the end user processes get better response if they are scheduled in the background . Because some of the system processes run only in Kernel Mode , modern operating systems delegate their functions to kernel threads , which are not encumbered(\u963b\u788d) with the unnecessary User Mode context . In Linux, kernel threads differ from regular processes in the following ways: Kernel threads run only in Kernel Mode , while regular processes run alternatively in Kernel Mode and in User Mode . Because kernel threads run only in Kernel Mode, they use only linear addresses greater than PAGE_OFFSET . Regular processes, on the other hand, use all four gigabytes of linear addresses, in either User Mode or Kernel Mode. SUMMARY : \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e0d\u662f\u6240\u6709\u7684system process\u90fd\u8fd0\u884c\u5728kernel mode\uff1b SUMMARY : \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684user mode context\u6240\u6307\u7684\u662f\u4ec0\u4e48\uff1f 3.4.2.1. Creating a kernel thread The kernel_thread( ) function creates a new kernel thread. It receives as parameters the address of the kernel function to be executed ( fn ), the argument to be passed to that function ( arg ), and a set of clone flags ( flags ). The function essentially invokes do_fork( ) as follows: do_fork ( flags | CLONE_VM | CLONE_UNTRACED , 0 , pregs , 0 , NULL , NULL ); The CLONE_VM flag avoids the duplication of the page tables of the calling process: this duplication would be a waste of time and memory, because the new kernel thread will not access the User Mode address space anyway. The CLONE_UNTRACED flag ensures that no process will be able to trace the new kernel thread, even if the calling process is being traced. SUMMARY \uff1a kernel_thread The pregs parameter passed to do_fork( ) corresponds to the address in the Kernel Mode stack where the copy_thread( ) function will find the initial values of the CPU registers for the new thread. The kernel_thread( ) function builds up this stack area so that: The ebx and edx registers will be set by copy_thread() to the values of the parameters fn and arg , respectively. The eip register will be set to the address of the following assembly language fragment: movl %edx,%eax pushl %edx call *%ebx pushl %eax call do_exit Therefore, the new kernel thread starts by executing the fn(arg) function. If this function terminates, the kernel thread executes the _exit( ) system call passing to it the return value of fn() (see the section \"Destroying Processes\" later in this chapter). 3.4.2.2. Process 0 The ancestor of all processes, called process 0 , the idle process , or, for historical reasons, the swapper process , is a kernel thread created from scratch during the initialization phase of Linux (see Appendix A). This ancestor process uses the following statically allocated data structures (data structures for all other processes are dynamically allocated): SUMMARY : statically allocated data structures (data structures for all other processes are dynamically allocated)\u7684\u5177\u4f53\u542b\u4e49\u662f\u4ec0\u4e48\uff1f\u5b83\u6709\u4ec0\u4e48\u7279\u522b\u4e4b\u5904\u5462\uff1f A process descriptor stored in the init_task variable, which is initialized by the INIT_TASK macro. A thread_info descriptor and a Kernel Mode stack stored in the init_thread_union variable and initialized by the INIT_THREAD_INFO macro. The following tables, which the process descriptor points to: init_mm init_fs init_files init_signals init_sighand The tables are initialized, respectively, by the following macros: INIT_MM INIT_FS INIT_FILES INIT_SIGNALS INIT_SIGHAND The master kernel Page Global Directory stored in swapper_pg_dir (see the section \"Kernel Page Tables\" in Chapter 2). The start_kernel( ) function initializes all the data structures needed by the kernel, enables interrupts, and creates another kernel thread , named process 1 (more commonly referred to as the init process ): kernel_thread ( init , NULL , CLONE_FS | CLONE_SIGHAND ); The newly created kernel thread has PID 1 and shares all per-process kernel data structures with process 0 . When selected by the scheduler, the init process starts executing the init( ) function. After having created the init process , process 0 executes the cpu_idle( ) function, which essentially consists of repeatedly executing the hlt assembly language instruction with the interrupts enabled (see Chapter 4). Process 0 is selected by the scheduler only when there are no other processes in the TASK_RUNNING state. In multiprocessor systems there is a process 0 for each CPU. Right after the power-on, the BIOS of the computer starts a single CPU while disabling the others. The swapper process running on CPU 0 initializes the kernel data structures, then enables the other CPUs and creates the additional swapper processes by means of the copy_process( ) function passing to it the value 0 as the new PID . Moreover, the kernel sets the cpu field of the thread_info descriptor of each forked process to the proper CPU index. 3.4.2.3. Process 1 The kernel thread created by process 0 executes the init( ) function, which in turn completes the initialization of the kernel. Then init( ) invokes the execve( ) system call to load the executable program init . As a result, the init kernel thread becomes a regular process having its own per-process kernel data structure (see Chapter 20). The init process stays alive until the system is shut down, because it creates and monitors the activity of all processes that implement the outer layers of the operating system. 3.4.2.4. Other kernel threads Linux uses many other kernel threads . Some of them are created in the initialization phase and run until shutdown; others are created \"on demand,\" when the kernel must execute a task that is better performed in its own execution context . A few examples of kernel threads (besides process 0 and process 1) are: keventd (also called events) Executes the functions in the keventd_wq workqueue (see Chapter 4). kapmd Handles the events related to the Advanced Power Management (APM). kswapd Reclaims memory, as described in the section \"Periodic Reclaiming\" in Chapter 17. pdflush Flushes \"dirty\" buffers to disk to reclaim\uff08\u56de\u6536\u518d\u5229\u7528\uff09 memory, as described in the section \"The pdflush Kernel Threads\" in Chapter 15. kblockd Executes the functions in the kblockd_workqueue workqueue. Essentially, it periodically activates the block device drivers, as described in the section \"Activating the Block Device Driver\" in Chapter 14. ksoftirqd Runs the tasklets (see section \"Softirqs and Tasklets\" in Chapter 4); there is one of these kernel threads for each CPU in the system.","title":"3.4.2-Kernel-Threads"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4.2-Kernel-Threads/#342#kernel#threads","text":"Traditional Unix systems delegate some critical tasks to intermittently(\u95f4\u6b47\u5730) running processes, including flushing disk caches, swapping out unused pages, servicing network connections, and so on. Indeed, it is not efficient to perform these tasks in strict linear fashion; both their functions and the end user processes get better response if they are scheduled in the background . Because some of the system processes run only in Kernel Mode , modern operating systems delegate their functions to kernel threads , which are not encumbered(\u963b\u788d) with the unnecessary User Mode context . In Linux, kernel threads differ from regular processes in the following ways: Kernel threads run only in Kernel Mode , while regular processes run alternatively in Kernel Mode and in User Mode . Because kernel threads run only in Kernel Mode, they use only linear addresses greater than PAGE_OFFSET . Regular processes, on the other hand, use all four gigabytes of linear addresses, in either User Mode or Kernel Mode. SUMMARY : \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e0d\u662f\u6240\u6709\u7684system process\u90fd\u8fd0\u884c\u5728kernel mode\uff1b SUMMARY : \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684user mode context\u6240\u6307\u7684\u662f\u4ec0\u4e48\uff1f","title":"3.4.2. Kernel Threads"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4.2-Kernel-Threads/#3421#creating#a#kernel#thread","text":"The kernel_thread( ) function creates a new kernel thread. It receives as parameters the address of the kernel function to be executed ( fn ), the argument to be passed to that function ( arg ), and a set of clone flags ( flags ). The function essentially invokes do_fork( ) as follows: do_fork ( flags | CLONE_VM | CLONE_UNTRACED , 0 , pregs , 0 , NULL , NULL ); The CLONE_VM flag avoids the duplication of the page tables of the calling process: this duplication would be a waste of time and memory, because the new kernel thread will not access the User Mode address space anyway. The CLONE_UNTRACED flag ensures that no process will be able to trace the new kernel thread, even if the calling process is being traced. SUMMARY \uff1a kernel_thread The pregs parameter passed to do_fork( ) corresponds to the address in the Kernel Mode stack where the copy_thread( ) function will find the initial values of the CPU registers for the new thread. The kernel_thread( ) function builds up this stack area so that: The ebx and edx registers will be set by copy_thread() to the values of the parameters fn and arg , respectively. The eip register will be set to the address of the following assembly language fragment: movl %edx,%eax pushl %edx call *%ebx pushl %eax call do_exit Therefore, the new kernel thread starts by executing the fn(arg) function. If this function terminates, the kernel thread executes the _exit( ) system call passing to it the return value of fn() (see the section \"Destroying Processes\" later in this chapter).","title":"3.4.2.1. Creating a kernel thread"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4.2-Kernel-Threads/#3422#process#0","text":"The ancestor of all processes, called process 0 , the idle process , or, for historical reasons, the swapper process , is a kernel thread created from scratch during the initialization phase of Linux (see Appendix A). This ancestor process uses the following statically allocated data structures (data structures for all other processes are dynamically allocated): SUMMARY : statically allocated data structures (data structures for all other processes are dynamically allocated)\u7684\u5177\u4f53\u542b\u4e49\u662f\u4ec0\u4e48\uff1f\u5b83\u6709\u4ec0\u4e48\u7279\u522b\u4e4b\u5904\u5462\uff1f A process descriptor stored in the init_task variable, which is initialized by the INIT_TASK macro. A thread_info descriptor and a Kernel Mode stack stored in the init_thread_union variable and initialized by the INIT_THREAD_INFO macro. The following tables, which the process descriptor points to: init_mm init_fs init_files init_signals init_sighand The tables are initialized, respectively, by the following macros: INIT_MM INIT_FS INIT_FILES INIT_SIGNALS INIT_SIGHAND The master kernel Page Global Directory stored in swapper_pg_dir (see the section \"Kernel Page Tables\" in Chapter 2). The start_kernel( ) function initializes all the data structures needed by the kernel, enables interrupts, and creates another kernel thread , named process 1 (more commonly referred to as the init process ): kernel_thread ( init , NULL , CLONE_FS | CLONE_SIGHAND ); The newly created kernel thread has PID 1 and shares all per-process kernel data structures with process 0 . When selected by the scheduler, the init process starts executing the init( ) function. After having created the init process , process 0 executes the cpu_idle( ) function, which essentially consists of repeatedly executing the hlt assembly language instruction with the interrupts enabled (see Chapter 4). Process 0 is selected by the scheduler only when there are no other processes in the TASK_RUNNING state. In multiprocessor systems there is a process 0 for each CPU. Right after the power-on, the BIOS of the computer starts a single CPU while disabling the others. The swapper process running on CPU 0 initializes the kernel data structures, then enables the other CPUs and creates the additional swapper processes by means of the copy_process( ) function passing to it the value 0 as the new PID . Moreover, the kernel sets the cpu field of the thread_info descriptor of each forked process to the proper CPU index.","title":"3.4.2.2. Process 0"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4.2-Kernel-Threads/#3423#process#1","text":"The kernel thread created by process 0 executes the init( ) function, which in turn completes the initialization of the kernel. Then init( ) invokes the execve( ) system call to load the executable program init . As a result, the init kernel thread becomes a regular process having its own per-process kernel data structure (see Chapter 20). The init process stays alive until the system is shut down, because it creates and monitors the activity of all processes that implement the outer layers of the operating system.","title":"3.4.2.3. Process 1"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/3.4.2-Kernel-Threads/#3424#other#kernel#threads","text":"Linux uses many other kernel threads . Some of them are created in the initialization phase and run until shutdown; others are created \"on demand,\" when the kernel must execute a task that is better performed in its own execution context . A few examples of kernel threads (besides process 0 and process 1) are: keventd (also called events) Executes the functions in the keventd_wq workqueue (see Chapter 4). kapmd Handles the events related to the Advanced Power Management (APM). kswapd Reclaims memory, as described in the section \"Periodic Reclaiming\" in Chapter 17. pdflush Flushes \"dirty\" buffers to disk to reclaim\uff08\u56de\u6536\u518d\u5229\u7528\uff09 memory, as described in the section \"The pdflush Kernel Threads\" in Chapter 15. kblockd Executes the functions in the kblockd_workqueue workqueue. Essentially, it periodically activates the block device drivers, as described in the section \"Activating the Block Device Driver\" in Chapter 14. ksoftirqd Runs the tasklets (see section \"Softirqs and Tasklets\" in Chapter 4); there is one of these kernel threads for each CPU in the system.","title":"3.4.2.4. Other kernel threads"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/Chapter-3-Processes/","text":"Chapter 3. Processes The concept of a process is fundamental to any multiprogramming operating system. A process is usually defined as an instance of a program in execution; thus, if 16 users are running vi at once, there are 16 separate processes (although they can share the same executable code). Processes are often called tasks or threads in the Linux source code. \u6ce8\u610f\uff0c tasks \u548c threads \u90fd\u662f\u590d\u6570\u5f62\u5f0f\uff0c\u5b83\u8868\u793a\u4e00\u4e2aprocess\u7531\u591a\u4e2atask\u6216\u8005thread\u6765\u7ec4\u6210\uff1b\u57283.2. Process Descriptor\u4e2d\u4ecb\u7ecd\u4e86 task_struct \uff0c\u4f5c\u8005\u5c06\u5b83\u53eb\u505a*process descriptor*\uff0c\u5176\u5b9e\u8fd9\u662f\u6bd4\u8f83\u5bb9\u6613\u5bf9\u8bfb\u8005\u9020\u6210\u8bef\u89e3\u7684\uff0c\u6211\u89c9\u5f97\u53eb\u4ed6task\u6700\u6700\u51c6\u786e\uff0c\u5f53\u7136\u5b83\u66f4\u52a0\u63a5\u8fd1\u4e8ethread\uff1b\u4ee5\u4e0b\u4e24\u7bc7\u6587\u7ae0\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u975e\u5e38\u597d\u7684\u5206\u6790\uff1a Process Control Block , Process Descriptor in Linux and task_struct? Neither of those terms (\"Process Control Block\" or \"Process Descriptor\") are considered \"terms of art\" in Linux kernel development. Of course, there is no official Linux kernel glossary so people are free to call things whatever makes sense to them. In contrast, however, task_struct is a specific C structure that is used by the linux kernel to maintain state about a task . A task in Linux corresponds roughly to a thread. Each user process has at least one thread so each process maps to one or more task_structs . More particularly, a process is one or more tasks that happen to share certain resources -- file descriptors, address space / memory map, signal handling, process and process group IDs, etc. Each thread in a process has its own individual version of certain other resources: registers/execution context, scheduling parameters, and so forth. It's quite common for a process to have only a single thread. In that case, you could consider a process to be represented by a single task_struct . How does Linux tell threads apart from child processes? From a task_struct perspective, a process\u2019s threads have the same thread group leader ( group_leader in task_struct ), whereas child processes have a different thread group leader (each individual child process). This information is exposed to user space via the /proc file system. You can trace parents and children by looking at the ppid field in /proc/${pid}/stat or .../status (this gives the parent pid); you can trace threads by looking at the tgid field in .../status (this gives the thread group id, which is also the group leader\u2019s pid). A process\u2019s threads are made visible in the /proc/${pid}/task directory: each thread gets its own subdirectory. (Every process has at least one thread.) In practice, programs wishing to keep track of their own threads would rely on APIs provided by the threading library they\u2019re using, instead of using OS-specific information. Typically on Unix-like systems that means using pthreads. \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u6240\u63d0\u53ca\u7684**thread group**\u57283.1. Processes, Lightweight Processes, and Threads\u4e2d\u7ed9\u51fa\u5b9a\u4e49\uff0c **thread group leader**\u57283.2.2. Identifying a Process\u4e2d\u7ed9\u51fa\u5b9a\u4e49\u3002 In this chapter, we discuss static properties of processes and then describe how process switching is performed by the kernel. The last two sections describe how processes can be created and destroyed. We also describe how Linux supports multithreaded applications as mentioned in Chapter 1, it relies on so-called lightweight processes (LWP) .","title":"Chapter-3-Processes"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/Chapter-3-Processes/#chapter#3#processes","text":"The concept of a process is fundamental to any multiprogramming operating system. A process is usually defined as an instance of a program in execution; thus, if 16 users are running vi at once, there are 16 separate processes (although they can share the same executable code). Processes are often called tasks or threads in the Linux source code. \u6ce8\u610f\uff0c tasks \u548c threads \u90fd\u662f\u590d\u6570\u5f62\u5f0f\uff0c\u5b83\u8868\u793a\u4e00\u4e2aprocess\u7531\u591a\u4e2atask\u6216\u8005thread\u6765\u7ec4\u6210\uff1b\u57283.2. Process Descriptor\u4e2d\u4ecb\u7ecd\u4e86 task_struct \uff0c\u4f5c\u8005\u5c06\u5b83\u53eb\u505a*process descriptor*\uff0c\u5176\u5b9e\u8fd9\u662f\u6bd4\u8f83\u5bb9\u6613\u5bf9\u8bfb\u8005\u9020\u6210\u8bef\u89e3\u7684\uff0c\u6211\u89c9\u5f97\u53eb\u4ed6task\u6700\u6700\u51c6\u786e\uff0c\u5f53\u7136\u5b83\u66f4\u52a0\u63a5\u8fd1\u4e8ethread\uff1b\u4ee5\u4e0b\u4e24\u7bc7\u6587\u7ae0\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u975e\u5e38\u597d\u7684\u5206\u6790\uff1a Process Control Block , Process Descriptor in Linux and task_struct? Neither of those terms (\"Process Control Block\" or \"Process Descriptor\") are considered \"terms of art\" in Linux kernel development. Of course, there is no official Linux kernel glossary so people are free to call things whatever makes sense to them. In contrast, however, task_struct is a specific C structure that is used by the linux kernel to maintain state about a task . A task in Linux corresponds roughly to a thread. Each user process has at least one thread so each process maps to one or more task_structs . More particularly, a process is one or more tasks that happen to share certain resources -- file descriptors, address space / memory map, signal handling, process and process group IDs, etc. Each thread in a process has its own individual version of certain other resources: registers/execution context, scheduling parameters, and so forth. It's quite common for a process to have only a single thread. In that case, you could consider a process to be represented by a single task_struct . How does Linux tell threads apart from child processes? From a task_struct perspective, a process\u2019s threads have the same thread group leader ( group_leader in task_struct ), whereas child processes have a different thread group leader (each individual child process). This information is exposed to user space via the /proc file system. You can trace parents and children by looking at the ppid field in /proc/${pid}/stat or .../status (this gives the parent pid); you can trace threads by looking at the tgid field in .../status (this gives the thread group id, which is also the group leader\u2019s pid). A process\u2019s threads are made visible in the /proc/${pid}/task directory: each thread gets its own subdirectory. (Every process has at least one thread.) In practice, programs wishing to keep track of their own threads would rely on APIs provided by the threading library they\u2019re using, instead of using OS-specific information. Typically on Unix-like systems that means using pthreads. \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u6240\u63d0\u53ca\u7684**thread group**\u57283.1. Processes, Lightweight Processes, and Threads\u4e2d\u7ed9\u51fa\u5b9a\u4e49\uff0c **thread group leader**\u57283.2.2. Identifying a Process\u4e2d\u7ed9\u51fa\u5b9a\u4e49\u3002 In this chapter, we discuss static properties of processes and then describe how process switching is performed by the kernel. The last two sections describe how processes can be created and destroyed. We also describe how Linux supports multithreaded applications as mentioned in Chapter 1, it relies on so-called lightweight processes (LWP) .","title":"Chapter 3. Processes"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/wikipedia-Copy-on-write/","text":"Copy-on-write In virtual memory management Copy-on-write Copy-on-write ( CoW or COW ), sometimes referred to as implicit sharing or shadowing , is a resource-management technique used in computer programming to efficiently implement a \"duplicate\" or \"copy\" operation on modifiable resources. If a resource is duplicated but not modified, it is not necessary to create a new resource; the resource can be shared between the copy and the original. Modifications must still create a copy, hence the technique: the copy operation is deferred to the first write \uff08\u8fd9\u53e5\u8bdd\u662f\u5bf9copy on write\u7684\u6700\u597d\u7684\u89e3\u91ca\uff09. By sharing resources in this way, it is possible to significantly reduce the resource consumption of unmodified copies, while adding a small overhead to resource-modifying operations. NOTE : \u4e0a\u9762\u6240\u63d0\u53ca\u7684resource management\u8ba9\u6211\u60f3\u5230\u4e86 C++ \u4e2d\u7684RAII\uff0c\u548cpython\u4e2d\u7684with\uff0c\u663e\u7136\u8fd9\u4e24\u8005\u90fd\u4fa7\u91cd\u4e8e\u907f\u514dresource leak\u3002 In virtual memory management Copy-on-write finds its main use in sharing the virtual memory of operating system processes , in the implementation of the fork system call . Typically, the process does not modify any memory and immediately executes a new process, replacing the address space entirely. Thus, it would be wasteful to copy all of the process's memory during a fork, and instead the copy-on-write technique is used. Copy-on-write can be implemented efficiently using the page table by marking\uff08\u6807\u5fd7\uff09 certain pages of memory as read-only and keeping a count of the number of references\uff08\u5f15\u7528\u8ba1\u6570\uff09 to the page. When data is written to these pages, the kernel intercepts\uff08\u62e6\u622a\uff09 the write attempt and allocates a new physical page, initialized with the copy-on-write data, although the allocation can be skipped if there is only one reference. The kernel then updates the page table with the new (writable) page, decrements the number of references, and performs the write. The new allocation ensures that a change in the memory of one process is not visible in another's. The copy-on-write technique can be extended to support efficient memory allocation by having a page of physical memory filled with zeros. When the memory is allocated, all the pages returned refer to the page of zeros and are all marked copy-on-write. This way, physical memory is not allocated for the process until data is written, allowing processes to reserve more virtual memory than physical memory and use memory sparsely, at the risk of running out of virtual address space. The combined algorithm is similar to demand paging . Copy-on-write pages are also used in the Linux kernel 's kernel same-page merging feature. Loading the libraries for an application is also a use of copy-on-write technique. The dynamic linker maps libraries as private like follows. Any writing action on the libraries will trigger a COW in virtual memory management. openat(AT_FDCWD, \"/lib64/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3 mmap(NULL, 3906144, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) mmap(0x7f8a3ced4000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000)","title":"Copy-on-write"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/wikipedia-Copy-on-write/#copy-on-write","text":"Copy-on-write ( CoW or COW ), sometimes referred to as implicit sharing or shadowing , is a resource-management technique used in computer programming to efficiently implement a \"duplicate\" or \"copy\" operation on modifiable resources. If a resource is duplicated but not modified, it is not necessary to create a new resource; the resource can be shared between the copy and the original. Modifications must still create a copy, hence the technique: the copy operation is deferred to the first write \uff08\u8fd9\u53e5\u8bdd\u662f\u5bf9copy on write\u7684\u6700\u597d\u7684\u89e3\u91ca\uff09. By sharing resources in this way, it is possible to significantly reduce the resource consumption of unmodified copies, while adding a small overhead to resource-modifying operations. NOTE : \u4e0a\u9762\u6240\u63d0\u53ca\u7684resource management\u8ba9\u6211\u60f3\u5230\u4e86 C++ \u4e2d\u7684RAII\uff0c\u548cpython\u4e2d\u7684with\uff0c\u663e\u7136\u8fd9\u4e24\u8005\u90fd\u4fa7\u91cd\u4e8e\u907f\u514dresource leak\u3002","title":"Copy-on-write"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-3-Processes/wikipedia-Copy-on-write/#in#virtual#memory#management","text":"Copy-on-write finds its main use in sharing the virtual memory of operating system processes , in the implementation of the fork system call . Typically, the process does not modify any memory and immediately executes a new process, replacing the address space entirely. Thus, it would be wasteful to copy all of the process's memory during a fork, and instead the copy-on-write technique is used. Copy-on-write can be implemented efficiently using the page table by marking\uff08\u6807\u5fd7\uff09 certain pages of memory as read-only and keeping a count of the number of references\uff08\u5f15\u7528\u8ba1\u6570\uff09 to the page. When data is written to these pages, the kernel intercepts\uff08\u62e6\u622a\uff09 the write attempt and allocates a new physical page, initialized with the copy-on-write data, although the allocation can be skipped if there is only one reference. The kernel then updates the page table with the new (writable) page, decrements the number of references, and performs the write. The new allocation ensures that a change in the memory of one process is not visible in another's. The copy-on-write technique can be extended to support efficient memory allocation by having a page of physical memory filled with zeros. When the memory is allocated, all the pages returned refer to the page of zeros and are all marked copy-on-write. This way, physical memory is not allocated for the process until data is written, allowing processes to reserve more virtual memory than physical memory and use memory sparsely, at the risk of running out of virtual address space. The combined algorithm is similar to demand paging . Copy-on-write pages are also used in the Linux kernel 's kernel same-page merging feature. Loading the libraries for an application is also a use of copy-on-write technique. The dynamic linker maps libraries as private like follows. Any writing action on the libraries will trigger a COW in virtual memory management. openat(AT_FDCWD, \"/lib64/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3 mmap(NULL, 3906144, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) mmap(0x7f8a3ced4000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000)","title":"In virtual memory management"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.1-The-Role-of-Interrupt-Signals/","text":"4.1. The Role of Interrupt Signals As the name suggests, interrupt signals provide a way to divert\uff08\u8f6c\u6362\uff09 the processor to code outside the normal flow of control. When an interrupt signal arrives, the CPU must stop what it's currently doing and switch to a new activity; it does this by saving the current value of the program counter (i.e., the content of the eip and cs registers) in the Kernel Mode stack and by placing an address related to the interrupt type into the program counter . NOTE: context switch There are some things in this chapter that will remind you of the context switch described in the previous chapter, carried out when a kernel substitutes one process for another. But there is a key difference between interrupt handling and process switching : the code executed by an interrupt or by an exception handler is not a process. Rather, it is a kernel control path that runs at the expense of the same process that was running when the interrupt occurred (see the later section \"Nested Execution of Exception and Interrupt Handlers\"). As a kernel control path , the interrupt handler is lighter than a process (it has less context and requires less time to set up or tear down). Interrupt handling is one of the most sensitive tasks performed by the kernel, because it must satisfy the following constraints: Interrupts can come anytime, when the kernel may want to finish something else it was trying to do. The kernel's goal is therefore to get the interrupt out of the way as soon as possible and defer as much processing as it can. For instance, suppose a block of data has arrived on a network line . When the hardware interrupts the kernel , it could simply mark the presence of data, give the processor back to whatever was running before, and do the rest of the processing later (such as moving the data into a buffer where its recipient process can find it, and then restarting the process). The activities that the kernel needs to perform in response to an interrupt are thus divided into a critical urgent part that the kernel executes right away and a deferrable part that is left for later. Because interrupts can come anytime, the kernel might be handling one of them while another one (of a different type) occurs. This should be allowed as much as possible, because it keeps the I/O devices busy (see the later section \"Nested Execution of Exception and Interrupt Handlers\"). As a result, the interrupt handlers must be coded so that the corresponding kernel control paths can be executed in a nested manner. When the last kernel control path terminates, the kernel must be able to resume execution of the interrupted process or switch to another process if the interrupt signal has caused a rescheduling activity. Although the kernel may accept a new interrupt signal while handling a previous one, some critical regions exist inside the kernel code where interrupts must be disabled. Such critical regions must be limited as much as possible because, according to the previous requirement, the kernel, and particularly the interrupt handlers, should run most of the time with the interrupts enabled.","title":"4.1-The-Role-of-Interrupt-Signals"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.1-The-Role-of-Interrupt-Signals/#41#the#role#of#interrupt#signals","text":"As the name suggests, interrupt signals provide a way to divert\uff08\u8f6c\u6362\uff09 the processor to code outside the normal flow of control. When an interrupt signal arrives, the CPU must stop what it's currently doing and switch to a new activity; it does this by saving the current value of the program counter (i.e., the content of the eip and cs registers) in the Kernel Mode stack and by placing an address related to the interrupt type into the program counter . NOTE: context switch There are some things in this chapter that will remind you of the context switch described in the previous chapter, carried out when a kernel substitutes one process for another. But there is a key difference between interrupt handling and process switching : the code executed by an interrupt or by an exception handler is not a process. Rather, it is a kernel control path that runs at the expense of the same process that was running when the interrupt occurred (see the later section \"Nested Execution of Exception and Interrupt Handlers\"). As a kernel control path , the interrupt handler is lighter than a process (it has less context and requires less time to set up or tear down). Interrupt handling is one of the most sensitive tasks performed by the kernel, because it must satisfy the following constraints: Interrupts can come anytime, when the kernel may want to finish something else it was trying to do. The kernel's goal is therefore to get the interrupt out of the way as soon as possible and defer as much processing as it can. For instance, suppose a block of data has arrived on a network line . When the hardware interrupts the kernel , it could simply mark the presence of data, give the processor back to whatever was running before, and do the rest of the processing later (such as moving the data into a buffer where its recipient process can find it, and then restarting the process). The activities that the kernel needs to perform in response to an interrupt are thus divided into a critical urgent part that the kernel executes right away and a deferrable part that is left for later. Because interrupts can come anytime, the kernel might be handling one of them while another one (of a different type) occurs. This should be allowed as much as possible, because it keeps the I/O devices busy (see the later section \"Nested Execution of Exception and Interrupt Handlers\"). As a result, the interrupt handlers must be coded so that the corresponding kernel control paths can be executed in a nested manner. When the last kernel control path terminates, the kernel must be able to resume execution of the interrupted process or switch to another process if the interrupt signal has caused a rescheduling activity. Although the kernel may accept a new interrupt signal while handling a previous one, some critical regions exist inside the kernel code where interrupts must be disabled. Such critical regions must be limited as much as possible because, according to the previous requirement, the kernel, and particularly the interrupt handlers, should run most of the time with the interrupts enabled.","title":"4.1. The Role of Interrupt Signals"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/","text":"4.2. Interrupts and Exceptions The Intel documentation classifies interrupts and exceptions as follows: Interrupts: Maskable interrupts All Interrupt Requests (IRQs) issued by I/O devices give rise to maskable interrupts . A maskable interrupt can be in two states: masked or unmasked; a masked interrupt is ignored by the control unit as long as it remains masked. Nonmaskable interrupts Only a few critical events (such as hardware failures) give rise to nonmaskable interrupts . Nonmaskable interrupts are always recognized by the CPU. Exceptions: NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0cIntel\u5c06exception\u5206\u4e3a\u4e24\u7c7b\uff1a Processor-detected exceptions Programmed exceptions Processor-detected exceptions Generated when the CPU detects an anomalous\uff08\u5f02\u5e38\u7684\uff09 condition while executing an instruction. These are further divided into three groups, depending on the value of the eip register that is saved on the Kernel Mode stack when the CPU control unit raises the exception. Faults Can generally be corrected; once corrected, the program is allowed to restart with no loss of continuity. The saved value of eip is the address of the instruction that caused the fault , and hence that instruction can be resumed when the exception handler terminates. As we'll see in the section \"Page Fault Exception Handler\" in Chapter 9, resuming the same instruction is necessary whenever the handler is able to correct the anomalous condition that caused the exception. NOTE: \u7ed3\u5408\u7f3a\u9875\u4e2d\u65ad\uff0c\u8fd9\u4e2a\u662f\u975e\u5e38\u5bb9\u6613\u7406\u89e3\u7684\u3002 Traps Reported immediately following the execution of the trapping instruction ; after the kernel returns control to the program, it is allowed to continue its execution with no loss of continuity. The saved value of eip is the address of the instruction that should be executed after the one that caused the trap. A trap is triggered only when there is no need to reexecute the instruction that terminated. The main use of traps is for debugging purposes. The role of the interrupt signal in this case is to notify the debugger that a specific instruction has been executed (for instance, a breakpoint has been reached within a program). Once the user has examined the data provided by the debugger, she may ask that execution of the debugged program resume, starting from the next instruction. NOTE: see also\uff1a Traps Aborts A serious error occurred; the control unit is in trouble, and it may be unable to store in the eip register the precise location of the instruction causing the exception. Aborts are used to report severe errors , such as hardware failures and invalid or inconsistent values in system tables. The interrupt signal sent by the control unit is an emergency signal used to switch control to the corresponding abort exception handler . This handler has no choice but to force the affected process to terminate. Programmed exceptions Occur at the request of the programmer. They are triggered by int or int3 instructions; the into (check for overflow) and bound (check on address bound) instructions also give rise to a programmed exception when the condition they are checking is not true. Programmed exceptions are handled by the control unit as traps ; they are often called software interrupts . Such exceptions have two common uses: to implement system calls and to notify a debugger of a specific event (see Chapter 10). NOTE: \u5173\u4e8e int \u3001 int3 \u3001 into \u3001 bound \uff0c\u53c2\u89c1\u5de5\u7a0b Hardware \u7684\u6587\u7ae0 INT \u3002 Each interrupt or exception is identified by a number ranging from 0 to 255; Intel calls this 8-bit unsigned number a vector. The vectors of nonmaskable interrupts and exceptions are fixed, while those of maskable interrupts can be altered by programming the Interrupt Controller (see the next section). 4.2.1. IRQs and Interrupts NOTE: Interrupt request (PC architecture) Programmable interrupt controller Interrupt vector table 4.2.2. Exceptions The 80x86 microprocessors issue roughly 20 different exceptions . [*] The kernel must provide a dedicated exception handler for each exception type. For some exceptions, the CPU control unit also generates a hardware error code and pushes it on the Kernel Mode stack before starting the exception handler . [*] The exact number depends on the processor model. The following list gives the vector, the name, the type, and a brief description of the exceptions found in 80x86 processors. Additional information may be found in the Intel technical documentation. 0 - \"Divide error\" (fault) Raised when a program issues an integer division by 0. 1- \"Debug\" (trap or fault) Raised when the TF flag of eflags is set (quite useful to implement single-step execution of a debugged program) or when the address of an instruction or operand falls within the range of an active debug register (see the section \"Hardware Context\" in Chapter 3). NOTE: \u5173\u4e8e TF \uff0c \u53c2\u89c1\u53c2\u89c1\u5de5\u7a0b Hardware \u7684\u6587\u7ae0 FLAGS-register \u3002 2 - Not used Reserved for nonmaskable interrupts (those that use the NMI pin). 3 - \"Breakpoint\" (trap) Caused by an int3 (breakpoint) instruction (usually inserted by a debugger). NOTE: \u5173\u4e8e int3 \uff0c\u53c2\u89c1\u53c2\u89c1\u5de5\u7a0b Hardware \u7684\u6587\u7ae0 INT \u3002 4 - \"Overflow\" (trap) An into (check for overflow) instruction has been executed while the OF (overflow) flag of eflags is set. NOTE: \u5173\u4e8e into \uff0c\u53c2\u89c1\u53c2\u89c1\u5de5\u7a0b Hardware \u7684\u6587\u7ae0 INT \u3002 5 - \"Bounds check\" (fault) A bound (check on address bound) instruction is executed with the operand outside of the valid address bounds. NOTE: \u5173\u4e8e bound \uff0c\u53c2\u89c1\u5de5\u7a0b Hardware \u7684\u6587\u7ae0 Bound \u3002 6 - \"Invalid opcode\" (fault) The CPU execution unit has detected an invalid opcode (the part of the machine instruction that determines the operation performed). 7 - \"Device not available\" (fault) An ESCAPE, MMX, or SSE/SSE2 instruction has been executed with the TS flag of cr0 set (see the section \"Saving and Loading the FPU, MMX, and XMM Registers\" in Chapter 3). 9 - \"Coprocessor segment overrun\" (abort) Problems with the external mathematical coprocessor (applies only to old 80386 microprocessors). 10 - \"Invalid TSS\" (fault) The CPU has attempted a context switch to a process having an invalid Task State Segment. 11 - \"Segment not present\" (fault) A reference was made to a segment not present in memory (one in which the Segment-Present flag of the Segment Descriptor was cleared). 12 - \"Stack segment fault\" (fault) The instruction attempted to exceed the stack segment limit, or the segment identified by ss is not present in memory. 13 - \"General protection\" (fault) One of the protection rules in the protected mode of the 80x86 has been violated. 14 - \"Page Fault\" (fault) The addressed page is not present in memory, the corresponding Page Table entry is null, or a violation of the paging protection mechanism has occurred. 15 - Reserved by Intel 16 - \"Floating-point error\" (fault) The floating-point unit integrated into the CPU chip has signaled an error condition, such as numeric overflow or division by 0. [ * ] [ * ] The 80 x 86 microprocessors also generate this exception when performing a signed division whose result cannot be stored as a signed integer (for instance, a division between -2,147,483,648 and -1). 17 - \"Alignment check\" (fault) The address of an operand is not correctly aligned (for instance, the address of a long integer is not a multiple of 4). 18 - \"Machine check\" (abort) A machine-check mechanism has detected a CPU or bus error. 19 - \"SIMD floating point exception\" (fault) The SSE or SSE2 unit integrated in the CPU chip has signaled an error condition on a floating-point operation. The values from 20 to 31 are reserved by Intel for future development. As illustrated in Table 4-1, each exception is handled by a specific exception handler (see the section \"Exception Handling\" later in this chapter), which usually sends a Unix signal to the process that caused the exception. Table 4-1. Signals sent by the exception handlers # Exception Exception handler Signal 0 Divide error divide_error( ) SIGFPE 1 Debug debug( ) SIGTRAP 2 NMI nmi( ) None 3 Breakpoint int3( ) SIGTRAP 4 Overflow overflow( ) SIGSEGV 5 Bounds check bounds( ) SIGSEGV 6 Invalid opcode invalid_op( ) SIGILL 7 Device not available device_not_available( ) None 8 Double fault doublefault_fn( ) None 9 Coprocessor segment overrun coprocessor_segment_overrun( ) SIGFPE 10 Invalid TSS invalid_TSS( ) SIGSEGV 11 Segment not present segment_not_present( ) SIGBUS 12 Stack segment fault stack_segment( ) SIGBUS 13 General protection general_protection( ) SIGSEGV 14 Page Fault page_fault( ) SIGSEGV 15 Intel-reserved None None 16 Floating-point error coprocessor_error( ) SIGFPE 17 Alignment check alignment_check( ) SIGBUS 18 Machine check machine_check( ) None 19 SIMD floating point simd_coprocessor_error( ) SIGFPE 4.2.3. Interrupt Descriptor Table NOTE: Interrupt descriptor table A system table called Interrupt Descriptor Table (IDT ) associates each interrupt or exception vector with the address of the corresponding interrupt or exception handler. The IDT must be properly initialized before the kernel enables interrupts. 4.2.4. Hardware Handling of Interrupts and Exceptions We now describe how the CPU control unit handles interrupts and exceptions. We assume that the kernel has been initialized, and thus the CPU is operating in Protected Mode . After executing an instruction, the cs and eip pair of registers contain the logical address of the next instruction to be executed. Before dealing with that instruction, the control unit checks whether an interrupt or an exception occurred while the control unit executed the previous instruction. If one occurred, the control unit does the following: Determines the vector i (0 <= i <= 255) associated with the interrupt or the exception. Reads the i th entry of the IDT referred by the idtr register (we assume in the following description that the entry contains an interrupt or a trap gate). Gets the base address of the GDT from the gdtr register and looks in the GDT to read the Segment Descriptor identified by the selector in the IDT entry. This descriptor specifies the base address of the segment that includes the interrupt or exception handler. Makes sure the interrupt was issued by an authorized source. First, it compares the Current Privilege Level (CPL), which is stored in the two least significant bits of the cs register, with the Descriptor Privilege Level (DPL ) of the Segment Descriptor included in the GDT. Raises a \"General protection \" exception if the CPL is lower than the DPL, because the interrupt handler cannot have a lower privilege than the program that caused the interrupt. For programmed exceptions , makes a further security check: compares the CPL with the DPL of the gate descriptor included in the IDT and raises a \"General protection\" exception if the DPL is lower than the CPL. This last check makes it possible to prevent access by user applications to specific trap or interrupt gates. Checks whether a change of privilege level is taking place that is, if CPL is different from the selected Segment Descriptor's DPL. If so, the control unit must start using the stack that is associated with the new privilege level. It does this by performing the following steps: Reads the tr register to access the TSS segment of the running process. Loads the ss and esp registers with the proper values for the stack segment and stack pointer associated with the new privilege level. These values are found in the TSS (see the section \"Task State Segment\" in Chapter 3). In the new stack, it saves the previous values of ss and esp , which define the logical address of the stack associated with the old privilege level. If a fault has occurred, it loads cs and eip with the logical address of the instruction that caused the exception so that it can be executed again. Saves the contents of eflags , cs , and eip in the stack. If the exception carries a hardware error code, it saves it on the stack. Loads cs and eip , respectively, with the Segment Selector and the Offset fields of the Gate Descriptor stored in the i th entry of the IDT. These values define the logical address of the first instruction of the interrupt or exception handler. The last step performed by the control unit is equivalent to a jump to the interrupt or exception handler. In other words, the instruction processed by the control unit after dealing with the interrupt signal is the first instruction of the selected handler. After the interrupt or exception is processed, the corresponding handler must relinquish control to the interrupted process by issuing the iret instruction, which forces the control unit to: Load the cs , eip , and eflags registers with the values saved on the stack. If a hardware error code has been pushed in the stack on top of the eip contents, it must be popped before executing iret . Check whether the CPL of the handler is equal to the value contained in the two least significant bits of cs (this means the interrupted process was running at the same privilege level as the handler). If so, iret concludes execution; otherwise, go to the next step. Load the ss and esp registers from the stack and return to the stack associated with the old privilege level. Examine the contents of the ds , es , fs , and gs segment registers; if any of them contains a selector that refers to a Segment Descriptor whose DPL value is lower than CPL, clear the corresponding segment register. The control unit does this to forbid User Mode programs that run with a CPL equal to 3 from using segment registers previously used by kernel routines (with a DPL equal to 0). If these registers were not cleared, malicious User Mode programs could exploit them in order to access the kernel address space.","title":"4.2-Interrupts-and-Exceptions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#42#interrupts#and#exceptions","text":"The Intel documentation classifies interrupts and exceptions as follows:","title":"4.2. Interrupts and Exceptions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#interrupts","text":"","title":"Interrupts:"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#maskable#interrupts","text":"All Interrupt Requests (IRQs) issued by I/O devices give rise to maskable interrupts . A maskable interrupt can be in two states: masked or unmasked; a masked interrupt is ignored by the control unit as long as it remains masked.","title":"Maskable interrupts"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#nonmaskable#interrupts","text":"Only a few critical events (such as hardware failures) give rise to nonmaskable interrupts . Nonmaskable interrupts are always recognized by the CPU.","title":"Nonmaskable interrupts"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#exceptions","text":"NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0cIntel\u5c06exception\u5206\u4e3a\u4e24\u7c7b\uff1a Processor-detected exceptions Programmed exceptions","title":"Exceptions:"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#processor-detected#exceptions","text":"Generated when the CPU detects an anomalous\uff08\u5f02\u5e38\u7684\uff09 condition while executing an instruction. These are further divided into three groups, depending on the value of the eip register that is saved on the Kernel Mode stack when the CPU control unit raises the exception.","title":"Processor-detected exceptions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#faults","text":"Can generally be corrected; once corrected, the program is allowed to restart with no loss of continuity. The saved value of eip is the address of the instruction that caused the fault , and hence that instruction can be resumed when the exception handler terminates. As we'll see in the section \"Page Fault Exception Handler\" in Chapter 9, resuming the same instruction is necessary whenever the handler is able to correct the anomalous condition that caused the exception. NOTE: \u7ed3\u5408\u7f3a\u9875\u4e2d\u65ad\uff0c\u8fd9\u4e2a\u662f\u975e\u5e38\u5bb9\u6613\u7406\u89e3\u7684\u3002","title":"Faults"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#traps","text":"Reported immediately following the execution of the trapping instruction ; after the kernel returns control to the program, it is allowed to continue its execution with no loss of continuity. The saved value of eip is the address of the instruction that should be executed after the one that caused the trap. A trap is triggered only when there is no need to reexecute the instruction that terminated. The main use of traps is for debugging purposes. The role of the interrupt signal in this case is to notify the debugger that a specific instruction has been executed (for instance, a breakpoint has been reached within a program). Once the user has examined the data provided by the debugger, she may ask that execution of the debugged program resume, starting from the next instruction. NOTE: see also\uff1a Traps","title":"Traps"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#aborts","text":"A serious error occurred; the control unit is in trouble, and it may be unable to store in the eip register the precise location of the instruction causing the exception. Aborts are used to report severe errors , such as hardware failures and invalid or inconsistent values in system tables. The interrupt signal sent by the control unit is an emergency signal used to switch control to the corresponding abort exception handler . This handler has no choice but to force the affected process to terminate.","title":"Aborts"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#programmed#exceptions","text":"Occur at the request of the programmer. They are triggered by int or int3 instructions; the into (check for overflow) and bound (check on address bound) instructions also give rise to a programmed exception when the condition they are checking is not true. Programmed exceptions are handled by the control unit as traps ; they are often called software interrupts . Such exceptions have two common uses: to implement system calls and to notify a debugger of a specific event (see Chapter 10). NOTE: \u5173\u4e8e int \u3001 int3 \u3001 into \u3001 bound \uff0c\u53c2\u89c1\u5de5\u7a0b Hardware \u7684\u6587\u7ae0 INT \u3002 Each interrupt or exception is identified by a number ranging from 0 to 255; Intel calls this 8-bit unsigned number a vector. The vectors of nonmaskable interrupts and exceptions are fixed, while those of maskable interrupts can be altered by programming the Interrupt Controller (see the next section).","title":"Programmed exceptions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#421#irqs#and#interrupts","text":"NOTE: Interrupt request (PC architecture) Programmable interrupt controller Interrupt vector table","title":"4.2.1. IRQs and Interrupts"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#422#exceptions","text":"The 80x86 microprocessors issue roughly 20 different exceptions . [*] The kernel must provide a dedicated exception handler for each exception type. For some exceptions, the CPU control unit also generates a hardware error code and pushes it on the Kernel Mode stack before starting the exception handler . [*] The exact number depends on the processor model. The following list gives the vector, the name, the type, and a brief description of the exceptions found in 80x86 processors. Additional information may be found in the Intel technical documentation.","title":"4.2.2. Exceptions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#0#-#divide#error#fault","text":"Raised when a program issues an integer division by 0.","title":"0 - \"Divide error\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#1-#debug#trap#or#fault","text":"Raised when the TF flag of eflags is set (quite useful to implement single-step execution of a debugged program) or when the address of an instruction or operand falls within the range of an active debug register (see the section \"Hardware Context\" in Chapter 3). NOTE: \u5173\u4e8e TF \uff0c \u53c2\u89c1\u53c2\u89c1\u5de5\u7a0b Hardware \u7684\u6587\u7ae0 FLAGS-register \u3002","title":"1- \"Debug\" (trap or fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#2#-#not#used","text":"Reserved for nonmaskable interrupts (those that use the NMI pin).","title":"2 - Not used"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#3#-#breakpoint#trap","text":"Caused by an int3 (breakpoint) instruction (usually inserted by a debugger). NOTE: \u5173\u4e8e int3 \uff0c\u53c2\u89c1\u53c2\u89c1\u5de5\u7a0b Hardware \u7684\u6587\u7ae0 INT \u3002","title":"3 - \"Breakpoint\" (trap)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#4#-#overflow#trap","text":"An into (check for overflow) instruction has been executed while the OF (overflow) flag of eflags is set. NOTE: \u5173\u4e8e into \uff0c\u53c2\u89c1\u53c2\u89c1\u5de5\u7a0b Hardware \u7684\u6587\u7ae0 INT \u3002","title":"4 - \"Overflow\" (trap)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#5#-#bounds#check#fault","text":"A bound (check on address bound) instruction is executed with the operand outside of the valid address bounds. NOTE: \u5173\u4e8e bound \uff0c\u53c2\u89c1\u5de5\u7a0b Hardware \u7684\u6587\u7ae0 Bound \u3002","title":"5 - \"Bounds check\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#6#-#invalid#opcode#fault","text":"The CPU execution unit has detected an invalid opcode (the part of the machine instruction that determines the operation performed).","title":"6 - \"Invalid opcode\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#7#-#device#not#available#fault","text":"An ESCAPE, MMX, or SSE/SSE2 instruction has been executed with the TS flag of cr0 set (see the section \"Saving and Loading the FPU, MMX, and XMM Registers\" in Chapter 3).","title":"7 - \"Device not available\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#9#-#coprocessor#segment#overrun#abort","text":"Problems with the external mathematical coprocessor (applies only to old 80386 microprocessors).","title":"9 - \"Coprocessor segment overrun\" (abort)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#10#-#invalid#tss#fault","text":"The CPU has attempted a context switch to a process having an invalid Task State Segment.","title":"10 - \"Invalid TSS\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#11#-#segment#not#present#fault","text":"A reference was made to a segment not present in memory (one in which the Segment-Present flag of the Segment Descriptor was cleared).","title":"11 - \"Segment not present\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#12#-#stack#segment#fault#fault","text":"The instruction attempted to exceed the stack segment limit, or the segment identified by ss is not present in memory.","title":"12 - \"Stack segment fault\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#13#-#general#protection#fault","text":"One of the protection rules in the protected mode of the 80x86 has been violated.","title":"13 - \"General protection\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#14#-#page#fault#fault","text":"The addressed page is not present in memory, the corresponding Page Table entry is null, or a violation of the paging protection mechanism has occurred.","title":"14 - \"Page Fault\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#15#-#reserved#by#intel","text":"","title":"15 - Reserved by Intel"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#16#-#floating-point#error#fault","text":"The floating-point unit integrated into the CPU chip has signaled an error condition, such as numeric overflow or division by 0. [ * ] [ * ] The 80 x 86 microprocessors also generate this exception when performing a signed division whose result cannot be stored as a signed integer (for instance, a division between -2,147,483,648 and -1).","title":"16 - \"Floating-point error\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#17#-#alignment#check#fault","text":"The address of an operand is not correctly aligned (for instance, the address of a long integer is not a multiple of 4).","title":"17 - \"Alignment check\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#18#-#machine#check#abort","text":"A machine-check mechanism has detected a CPU or bus error.","title":"18 - \"Machine check\" (abort)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#19#-#simd#floating#point#exception#fault","text":"The SSE or SSE2 unit integrated in the CPU chip has signaled an error condition on a floating-point operation. The values from 20 to 31 are reserved by Intel for future development. As illustrated in Table 4-1, each exception is handled by a specific exception handler (see the section \"Exception Handling\" later in this chapter), which usually sends a Unix signal to the process that caused the exception. Table 4-1. Signals sent by the exception handlers # Exception Exception handler Signal 0 Divide error divide_error( ) SIGFPE 1 Debug debug( ) SIGTRAP 2 NMI nmi( ) None 3 Breakpoint int3( ) SIGTRAP 4 Overflow overflow( ) SIGSEGV 5 Bounds check bounds( ) SIGSEGV 6 Invalid opcode invalid_op( ) SIGILL 7 Device not available device_not_available( ) None 8 Double fault doublefault_fn( ) None 9 Coprocessor segment overrun coprocessor_segment_overrun( ) SIGFPE 10 Invalid TSS invalid_TSS( ) SIGSEGV 11 Segment not present segment_not_present( ) SIGBUS 12 Stack segment fault stack_segment( ) SIGBUS 13 General protection general_protection( ) SIGSEGV 14 Page Fault page_fault( ) SIGSEGV 15 Intel-reserved None None 16 Floating-point error coprocessor_error( ) SIGFPE 17 Alignment check alignment_check( ) SIGBUS 18 Machine check machine_check( ) None 19 SIMD floating point simd_coprocessor_error( ) SIGFPE","title":"19 - \"SIMD floating point exception\" (fault)"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#423#interrupt#descriptor#table","text":"NOTE: Interrupt descriptor table A system table called Interrupt Descriptor Table (IDT ) associates each interrupt or exception vector with the address of the corresponding interrupt or exception handler. The IDT must be properly initialized before the kernel enables interrupts.","title":"4.2.3. Interrupt Descriptor Table"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.2-Interrupts-and-Exceptions/#424#hardware#handling#of#interrupts#and#exceptions","text":"We now describe how the CPU control unit handles interrupts and exceptions. We assume that the kernel has been initialized, and thus the CPU is operating in Protected Mode . After executing an instruction, the cs and eip pair of registers contain the logical address of the next instruction to be executed. Before dealing with that instruction, the control unit checks whether an interrupt or an exception occurred while the control unit executed the previous instruction. If one occurred, the control unit does the following: Determines the vector i (0 <= i <= 255) associated with the interrupt or the exception. Reads the i th entry of the IDT referred by the idtr register (we assume in the following description that the entry contains an interrupt or a trap gate). Gets the base address of the GDT from the gdtr register and looks in the GDT to read the Segment Descriptor identified by the selector in the IDT entry. This descriptor specifies the base address of the segment that includes the interrupt or exception handler. Makes sure the interrupt was issued by an authorized source. First, it compares the Current Privilege Level (CPL), which is stored in the two least significant bits of the cs register, with the Descriptor Privilege Level (DPL ) of the Segment Descriptor included in the GDT. Raises a \"General protection \" exception if the CPL is lower than the DPL, because the interrupt handler cannot have a lower privilege than the program that caused the interrupt. For programmed exceptions , makes a further security check: compares the CPL with the DPL of the gate descriptor included in the IDT and raises a \"General protection\" exception if the DPL is lower than the CPL. This last check makes it possible to prevent access by user applications to specific trap or interrupt gates. Checks whether a change of privilege level is taking place that is, if CPL is different from the selected Segment Descriptor's DPL. If so, the control unit must start using the stack that is associated with the new privilege level. It does this by performing the following steps: Reads the tr register to access the TSS segment of the running process. Loads the ss and esp registers with the proper values for the stack segment and stack pointer associated with the new privilege level. These values are found in the TSS (see the section \"Task State Segment\" in Chapter 3). In the new stack, it saves the previous values of ss and esp , which define the logical address of the stack associated with the old privilege level. If a fault has occurred, it loads cs and eip with the logical address of the instruction that caused the exception so that it can be executed again. Saves the contents of eflags , cs , and eip in the stack. If the exception carries a hardware error code, it saves it on the stack. Loads cs and eip , respectively, with the Segment Selector and the Offset fields of the Gate Descriptor stored in the i th entry of the IDT. These values define the logical address of the first instruction of the interrupt or exception handler. The last step performed by the control unit is equivalent to a jump to the interrupt or exception handler. In other words, the instruction processed by the control unit after dealing with the interrupt signal is the first instruction of the selected handler. After the interrupt or exception is processed, the corresponding handler must relinquish control to the interrupted process by issuing the iret instruction, which forces the control unit to: Load the cs , eip , and eflags registers with the values saved on the stack. If a hardware error code has been pushed in the stack on top of the eip contents, it must be popped before executing iret . Check whether the CPL of the handler is equal to the value contained in the two least significant bits of cs (this means the interrupted process was running at the same privilege level as the handler). If so, iret concludes execution; otherwise, go to the next step. Load the ss and esp registers from the stack and return to the stack associated with the old privilege level. Examine the contents of the ds , es , fs , and gs segment registers; if any of them contains a selector that refers to a Segment Descriptor whose DPL value is lower than CPL, clear the corresponding segment register. The control unit does this to forbid User Mode programs that run with a CPL equal to 3 from using segment registers previously used by kernel routines (with a DPL equal to 0). If these registers were not cleared, malicious User Mode programs could exploit them in order to access the kernel address space.","title":"4.2.4. Hardware Handling of Interrupts and Exceptions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.3-Nested-Execution-of-Exception-and-Interrupt-Handlers/","text":"4.3. Nested Execution of Exception and Interrupt Handlers Every interrupt or exception gives rise to a kernel control path or separate sequence of instructions that execute in Kernel Mode on behalf of the current process . For instance, when an I/O device raises an interrupt, the first instructions of the corresponding kernel control path are those that save the contents of the CPU registers in the Kernel Mode stack , while the last are those that restore the contents of the registers. Kernel control paths may be arbitrarily nested; an interrupt handler may be interrupted by another interrupt handler , thus giving rise to a nested execution of kernel control paths , as shown in Figure 4-3. As a result, the last instructions of a kernel control path that is taking care of an interrupt do not always put the current process back into User Mode: if the level of nesting is greater than 1, these instructions will put into execution the kernel control path that was interrupted last, and the CPU will continue to run in Kernel Mode. The price to pay for allowing nested kernel control paths is that an interrupt handler must never block, that is, no process switch can take place until an interrupt handler is running. In fact, all the data needed to resume a nested kernel control path is stored in the Kernel Mode stack, which is tightly bound to the current process. Assuming that the kernel is bug free, most exceptions can occur only while the CPU is in User Mode . Indeed, they are either caused by programming errors or triggered by debuggers. However, the \"Page Fault \" exception may occur in Kernel Mode. This happens when the process attempts to address a page that belongs to its address space but is not currently in RAM. While handling such an exception, the kernel may suspend the current process and replace it with another one until the requested page is available. The kernel control path that handles the \"Page Fault\" exception resumes execution as soon as the process gets the processor again. Because the \"Page Fault\" exception handler never gives rise to further exceptions, at most two kernel control paths associated with exceptions (the first one caused by a system call invocation, the second one caused by a Page Fault) may be stacked, one on top of the other. In contrast to exceptions, interrupts issued by I/O devices do not refer to data structures specific to the current process , although the kernel control paths that handle them run on behalf of that process. As a matter of fact, it is impossible to predict which process will be running when a given interrupt occurs. An interrupt handler may preempt both other interrupt handlers and exception handlers . Conversely, an exception handler never preempts an interrupt handler . The only exception that can be triggered in Kernel Mode is \"Page Fault,\" which we just described. But interrupt handlers never perform operations that can induce page faults, and thus, potentially, a process switch. Linux interleaves kernel control paths for two major reasons: To improve the throughput of programmable interrupt controllers and device controllers . Assume that a device controller issues a signal on an IRQ line: the PIC transforms it into an external interrupt, and then both the PIC and the device controller remain blocked until the PIC receives an acknowledgment from the CPU. Thanks to kernel control path interleaving, the kernel is able to send the acknowledgment even when it is handling a previous interrupt. To implement an interrupt model without priority levels. Because each interrupt handler may be deferred by another one, there is no need to establish predefined priorities among hardware devices. This simplifies the kernel code and improves its portability. On multiprocessor systems, several kernel control paths may execute concurrently. Moreover, a kernel control path associated with an exception may start executing on a CPU and, due to a process switch, migrate to another CPU.","title":"4.3-Nested-Execution-of-Exception-and-Interrupt-Handlers"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.3-Nested-Execution-of-Exception-and-Interrupt-Handlers/#43#nested#execution#of#exception#and#interrupt#handlers","text":"Every interrupt or exception gives rise to a kernel control path or separate sequence of instructions that execute in Kernel Mode on behalf of the current process . For instance, when an I/O device raises an interrupt, the first instructions of the corresponding kernel control path are those that save the contents of the CPU registers in the Kernel Mode stack , while the last are those that restore the contents of the registers. Kernel control paths may be arbitrarily nested; an interrupt handler may be interrupted by another interrupt handler , thus giving rise to a nested execution of kernel control paths , as shown in Figure 4-3. As a result, the last instructions of a kernel control path that is taking care of an interrupt do not always put the current process back into User Mode: if the level of nesting is greater than 1, these instructions will put into execution the kernel control path that was interrupted last, and the CPU will continue to run in Kernel Mode. The price to pay for allowing nested kernel control paths is that an interrupt handler must never block, that is, no process switch can take place until an interrupt handler is running. In fact, all the data needed to resume a nested kernel control path is stored in the Kernel Mode stack, which is tightly bound to the current process. Assuming that the kernel is bug free, most exceptions can occur only while the CPU is in User Mode . Indeed, they are either caused by programming errors or triggered by debuggers. However, the \"Page Fault \" exception may occur in Kernel Mode. This happens when the process attempts to address a page that belongs to its address space but is not currently in RAM. While handling such an exception, the kernel may suspend the current process and replace it with another one until the requested page is available. The kernel control path that handles the \"Page Fault\" exception resumes execution as soon as the process gets the processor again. Because the \"Page Fault\" exception handler never gives rise to further exceptions, at most two kernel control paths associated with exceptions (the first one caused by a system call invocation, the second one caused by a Page Fault) may be stacked, one on top of the other. In contrast to exceptions, interrupts issued by I/O devices do not refer to data structures specific to the current process , although the kernel control paths that handle them run on behalf of that process. As a matter of fact, it is impossible to predict which process will be running when a given interrupt occurs. An interrupt handler may preempt both other interrupt handlers and exception handlers . Conversely, an exception handler never preempts an interrupt handler . The only exception that can be triggered in Kernel Mode is \"Page Fault,\" which we just described. But interrupt handlers never perform operations that can induce page faults, and thus, potentially, a process switch. Linux interleaves kernel control paths for two major reasons: To improve the throughput of programmable interrupt controllers and device controllers . Assume that a device controller issues a signal on an IRQ line: the PIC transforms it into an external interrupt, and then both the PIC and the device controller remain blocked until the PIC receives an acknowledgment from the CPU. Thanks to kernel control path interleaving, the kernel is able to send the acknowledgment even when it is handling a previous interrupt. To implement an interrupt model without priority levels. Because each interrupt handler may be deferred by another one, there is no need to establish predefined priorities among hardware devices. This simplifies the kernel code and improves its portability. On multiprocessor systems, several kernel control paths may execute concurrently. Moreover, a kernel control path associated with an exception may start executing on a CPU and, due to a process switch, migrate to another CPU.","title":"4.3. Nested Execution of Exception and Interrupt Handlers"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.4-Initializing-the-Interrupt-Descriptor-Table/","text":"4.4. Initializing the Interrupt Descriptor Table \u672c\u8282\u7684\u5185\u5bb9\u504f\u786c\u4ef6\uff0cpass\u3002","title":"4.4-Initializing-the-Interrupt-Descriptor-Table"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.4-Initializing-the-Interrupt-Descriptor-Table/#44#initializing#the#interrupt#descriptor#table","text":"\u672c\u8282\u7684\u5185\u5bb9\u504f\u786c\u4ef6\uff0cpass\u3002","title":"4.4. Initializing the Interrupt Descriptor Table"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.5-Exception-Handling/","text":"4.5. Exception Handling Most exceptions issued by the CPU are interpreted by Linux as error conditions . When one of them occurs, the kernel sends a signal to the process that caused the exception to notify it of an anomalous condition. If, for instance, a process performs a division by zero, the CPU raises a \"Divide error \" exception, and the corresponding exception handler sends a SIGFPE signal to the current process, which then takes the necessary steps to recover or (if no signal handler is set for that signal) abort. There are a couple of cases, however, where Linux exploits CPU exceptions to manage hardware resources more efficiently. A first case is already described in the section \"Saving and Loading the FPU, MMX, and XMM Registers\" in Chapter 3. The \"Device not available \" exception is used together with the TS flag of the cr0 register to force the kernel to load the floating point registers of the CPU with new values. A second case involves the \" Page Fault \" exception, which is used to defer allocating new page frames to the process until the last possible moment. The corresponding handler is complex because the exception may, or may not, denote an error condition (see the section \"Page Fault Exception Handler\" in Chapter 9). Exception handlers have a standard structure consisting of three steps: Save the contents of most registers in the Kernel Mode stack (this part is coded in assembly language). Handle the exception by means of a high-level C function. 2. Exit from the handler by means of the ret_from_exception( ) function.","title":"4.5-Exception-Handling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.5-Exception-Handling/#45#exception#handling","text":"Most exceptions issued by the CPU are interpreted by Linux as error conditions . When one of them occurs, the kernel sends a signal to the process that caused the exception to notify it of an anomalous condition. If, for instance, a process performs a division by zero, the CPU raises a \"Divide error \" exception, and the corresponding exception handler sends a SIGFPE signal to the current process, which then takes the necessary steps to recover or (if no signal handler is set for that signal) abort. There are a couple of cases, however, where Linux exploits CPU exceptions to manage hardware resources more efficiently. A first case is already described in the section \"Saving and Loading the FPU, MMX, and XMM Registers\" in Chapter 3. The \"Device not available \" exception is used together with the TS flag of the cr0 register to force the kernel to load the floating point registers of the CPU with new values. A second case involves the \" Page Fault \" exception, which is used to defer allocating new page frames to the process until the last possible moment. The corresponding handler is complex because the exception may, or may not, denote an error condition (see the section \"Page Fault Exception Handler\" in Chapter 9). Exception handlers have a standard structure consisting of three steps: Save the contents of most registers in the Kernel Mode stack (this part is coded in assembly language). Handle the exception by means of a high-level C function. 2. Exit from the handler by means of the ret_from_exception( ) function.","title":"4.5. Exception Handling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/","text":"4.6. Interrupt Handling As we explained earlier, most exceptions are handled simply by sending a Unix signal to the process that caused the exception. The action to be taken is thus deferred until the process receives the signal; as a result, the kernel is able to process the exception quickly. This approach does not hold for interrupts , because they frequently arrive long after the process to which they are related (for instance, a process that requested a data transfer) has been suspended and a completely unrelated process is running. So it would make no sense to send a Unix signal to the current process . Interrupt handling depends on the type of interrupt. For our purposes, we'll distinguish three main classes of interrupts: I/O interrupts An I/O device requires attention; the corresponding interrupt handler must query the device to determine the proper course of action. We cover this type of interrupt in the later section \"I/O Interrupt Handling.\" Timer interrupts Some timer, either a local APIC timer or an external timer , has issued an interrupt; this kind of interrupt tells the kernel that a fixed-time interval has elapsed. These interrupts are handled mostly as I/O interrupts; we discuss the peculiar characteristics of timer interrupts in Chapter 6. Interprocessor interrupts A CPU issued an interrupt to another CPU of a multiprocessor system. We cover such interrupts in the later section \"Interprocessor Interrupt Handling.\" 4.6.1. I/O Interrupt Handling In general, an I/O interrupt handler must be flexible enough to service several devices at the same time. In the PCI bus architecture, for instance, several devices may share the same IRQ line . This means that the interrupt vector alone does not tell the whole story. In the example shown in Table 4-3, the same vector 43 is assigned to the USB port and to the sound card. However, some hardware devices found in older PC architectures (such as ISA) do not reliably operate if their IRQ line is shared with other devices. Interrupt handler flexibility is achieved in two distinct ways, as discussed in the following list. 4.6.1.1. Interrupt vectors 4.6.1.2. IRQ data structures 4.6.1.3. IRQ distribution in multiprocessor systems 4.6.1.4. Multiple Kernel Mode stacks As mentioned in the section \"Identifying a Process\" in Chapter 3, the thread_info descriptor of each process is coupled with a Kernel Mode stack in a thread_union data structure composed by one or two page frames, according to an option selected when the kernel has been compiled. If the size of the thread_union structure is 8 KB, the Kernel Mode stack of the current process is used for every type of kernel control path : exceptions , interrupts , and deferrable functions (see the later section \"Softirqs and Tasklets\"). Conversely, if the size of the thread_union structure is 4 KB, the kernel makes use of three types of Kernel Mode stacks: The exception stack is used when handling exceptions (including system calls). This is the stack contained in the per-process thread_union data structure, thus the kernel makes use of a different exception stack for each process in the system. The hard IRQ stack is used when handling interrupts. There is one hard IRQ stack for each CPU in the system, and each stack is contained in a single page frame. The soft IRQ stack is used when handling deferrable functions (softirqs or tasklets; see the later section \"Softirqs and Tasklets\"). There is one soft IRQ stack for each CPU in the system, and each stack is contained in a single page frame. All hard IRQ stacks are contained in the hardirq_stack array, while all soft IRQ stacks are contained in the softirq_stack array. Each array element is a union of type irq_ctx that span a single page. At the bottom of this page is stored a thread_info structure, while the spare memory locations are used for the stack; remember that each stack grows towards lower addresses. Thus, hard IRQ stacks and soft IRQ stacks are very similar to the exception stacks described in the section \"Identifying a Process\" in Chapter 3; the only difference is that the tHRead_info structure coupled with each stack is associated with a CPU rather than a process. The hardirq_ctx and softirq_ctx arrays allow the kernel to quickly determine the hard IRQ stack and soft IRQ stack of a given CPU, respectively: they contain pointers to the corresponding irq_ctx elements. 4.6.1.5. Saving the registers for the interrupt handler When a CPU receives an interrupt, it starts executing the code at the address found in the corresponding gate of the IDT (see the earlier section \"Hardware Handling of Interrupts and Exceptions\"). As with other context switches, the need to save registers leaves the kernel developer with a somewhat messy coding job, because the registers have to be saved and restored using assembly language code. However, within those operations, the processor is expected to call and return from a C function. In this section, we describe the assembly language task of handling registers; in the next, we show some of the acrobatics\uff08\u6280\u5de7\uff09 required in the C function that is subsequently invoked. Saving registers is the first task of the interrupt handler . As already mentioned, the address of the interrupt handler for IRQ n is initially stored in the interrupt[n] entry and then copied into the interrupt gate included in the proper IDT entry. The interrupt array is built through a few assembly language instructions in the arch/i386/kernel/entry.S file. The array includes NR_IRQS elements, where the NR_IRQS macro yields either the number 224 if the kernel supports a recent I/O APIC chip, [ * ] or the number 16 if the kernel uses the older 8259A PIC chips. The element at index n in the array stores the address of the following two assembly language instructions: [ * ] 256 vectors is an architectural limit for the 80x86 architecture. 32 of them are used or reserved for the CPU, so the usable vector space consists of 224 vectors. pushl $n-256 jmp common_interrupt The result is to save on the stack the IRQ number associated with the interrupt minus 256. The kernel represents all IRQs through negative numbers, because it reserves positive interrupt numbers to identify system calls (see Chapter 10). The same code for all interrupt handlers can then be executed while referring to this number. The common code starts at label common_interrupt and consists of the following assembly language macros and instructions: common_interrupt: SAVE_ALL movl %esp,%eax call do_IRQ jmp ret_from_intr The SAVE_ALL macro expands to the following fragment: cld push %es push %ds pushl %eax pushl %ebp pushl %edi pushl %esi pushl %edx pushl %ecx pushl %ebx movl $ _ _USER_DS,%edx movl %edx,%ds movl %edx,%es SAVE_ALL saves all the CPU registers that may be used by the interrupt handler on the stack, except for eflags , cs , eip , ss , and esp , which are already saved automatically by the control unit (see the earlier section \"Hardware Handling of Interrupts and Exceptions\"). The macro then loads the selector of the user data segment into ds and es . After saving the registers, the address of the current top stack location is saved in the eax register; then, the interrupt handler invokes the do_IRQ( ) function. When the ret instruction of do_IRQ( ) is executed (when that function terminates) control is transferred to ret_from_intr( ) (see the later section \"Returning from Interrupts and Exceptions\"). 4.6.1.6. The do_IRQ( ) function 4.6.1.7. The __do_IRQ( ) function 4.6.1.8. Reviving a lost interrupt 4.6.1.9. Interrupt service routines 4.6.1.10. Dynamic allocation of IRQ lines","title":"4.6-Interrupt-Handling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#46#interrupt#handling","text":"As we explained earlier, most exceptions are handled simply by sending a Unix signal to the process that caused the exception. The action to be taken is thus deferred until the process receives the signal; as a result, the kernel is able to process the exception quickly. This approach does not hold for interrupts , because they frequently arrive long after the process to which they are related (for instance, a process that requested a data transfer) has been suspended and a completely unrelated process is running. So it would make no sense to send a Unix signal to the current process . Interrupt handling depends on the type of interrupt. For our purposes, we'll distinguish three main classes of interrupts: I/O interrupts An I/O device requires attention; the corresponding interrupt handler must query the device to determine the proper course of action. We cover this type of interrupt in the later section \"I/O Interrupt Handling.\" Timer interrupts Some timer, either a local APIC timer or an external timer , has issued an interrupt; this kind of interrupt tells the kernel that a fixed-time interval has elapsed. These interrupts are handled mostly as I/O interrupts; we discuss the peculiar characteristics of timer interrupts in Chapter 6. Interprocessor interrupts A CPU issued an interrupt to another CPU of a multiprocessor system. We cover such interrupts in the later section \"Interprocessor Interrupt Handling.\"","title":"4.6. Interrupt Handling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#461#io#interrupt#handling","text":"In general, an I/O interrupt handler must be flexible enough to service several devices at the same time. In the PCI bus architecture, for instance, several devices may share the same IRQ line . This means that the interrupt vector alone does not tell the whole story. In the example shown in Table 4-3, the same vector 43 is assigned to the USB port and to the sound card. However, some hardware devices found in older PC architectures (such as ISA) do not reliably operate if their IRQ line is shared with other devices. Interrupt handler flexibility is achieved in two distinct ways, as discussed in the following list.","title":"4.6.1. I/O Interrupt Handling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#4611#interrupt#vectors","text":"","title":"4.6.1.1. Interrupt vectors"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#4612#irq#data#structures","text":"","title":"4.6.1.2. IRQ data structures"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#4613#irq#distribution#in#multiprocessor#systems","text":"","title":"4.6.1.3. IRQ distribution in multiprocessor systems"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#4614#multiple#kernel#mode#stacks","text":"As mentioned in the section \"Identifying a Process\" in Chapter 3, the thread_info descriptor of each process is coupled with a Kernel Mode stack in a thread_union data structure composed by one or two page frames, according to an option selected when the kernel has been compiled. If the size of the thread_union structure is 8 KB, the Kernel Mode stack of the current process is used for every type of kernel control path : exceptions , interrupts , and deferrable functions (see the later section \"Softirqs and Tasklets\"). Conversely, if the size of the thread_union structure is 4 KB, the kernel makes use of three types of Kernel Mode stacks: The exception stack is used when handling exceptions (including system calls). This is the stack contained in the per-process thread_union data structure, thus the kernel makes use of a different exception stack for each process in the system. The hard IRQ stack is used when handling interrupts. There is one hard IRQ stack for each CPU in the system, and each stack is contained in a single page frame. The soft IRQ stack is used when handling deferrable functions (softirqs or tasklets; see the later section \"Softirqs and Tasklets\"). There is one soft IRQ stack for each CPU in the system, and each stack is contained in a single page frame. All hard IRQ stacks are contained in the hardirq_stack array, while all soft IRQ stacks are contained in the softirq_stack array. Each array element is a union of type irq_ctx that span a single page. At the bottom of this page is stored a thread_info structure, while the spare memory locations are used for the stack; remember that each stack grows towards lower addresses. Thus, hard IRQ stacks and soft IRQ stacks are very similar to the exception stacks described in the section \"Identifying a Process\" in Chapter 3; the only difference is that the tHRead_info structure coupled with each stack is associated with a CPU rather than a process. The hardirq_ctx and softirq_ctx arrays allow the kernel to quickly determine the hard IRQ stack and soft IRQ stack of a given CPU, respectively: they contain pointers to the corresponding irq_ctx elements.","title":"4.6.1.4. Multiple Kernel Mode stacks"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#4615#saving#the#registers#for#the#interrupt#handler","text":"When a CPU receives an interrupt, it starts executing the code at the address found in the corresponding gate of the IDT (see the earlier section \"Hardware Handling of Interrupts and Exceptions\"). As with other context switches, the need to save registers leaves the kernel developer with a somewhat messy coding job, because the registers have to be saved and restored using assembly language code. However, within those operations, the processor is expected to call and return from a C function. In this section, we describe the assembly language task of handling registers; in the next, we show some of the acrobatics\uff08\u6280\u5de7\uff09 required in the C function that is subsequently invoked. Saving registers is the first task of the interrupt handler . As already mentioned, the address of the interrupt handler for IRQ n is initially stored in the interrupt[n] entry and then copied into the interrupt gate included in the proper IDT entry. The interrupt array is built through a few assembly language instructions in the arch/i386/kernel/entry.S file. The array includes NR_IRQS elements, where the NR_IRQS macro yields either the number 224 if the kernel supports a recent I/O APIC chip, [ * ] or the number 16 if the kernel uses the older 8259A PIC chips. The element at index n in the array stores the address of the following two assembly language instructions: [ * ] 256 vectors is an architectural limit for the 80x86 architecture. 32 of them are used or reserved for the CPU, so the usable vector space consists of 224 vectors. pushl $n-256 jmp common_interrupt The result is to save on the stack the IRQ number associated with the interrupt minus 256. The kernel represents all IRQs through negative numbers, because it reserves positive interrupt numbers to identify system calls (see Chapter 10). The same code for all interrupt handlers can then be executed while referring to this number. The common code starts at label common_interrupt and consists of the following assembly language macros and instructions: common_interrupt: SAVE_ALL movl %esp,%eax call do_IRQ jmp ret_from_intr The SAVE_ALL macro expands to the following fragment: cld push %es push %ds pushl %eax pushl %ebp pushl %edi pushl %esi pushl %edx pushl %ecx pushl %ebx movl $ _ _USER_DS,%edx movl %edx,%ds movl %edx,%es SAVE_ALL saves all the CPU registers that may be used by the interrupt handler on the stack, except for eflags , cs , eip , ss , and esp , which are already saved automatically by the control unit (see the earlier section \"Hardware Handling of Interrupts and Exceptions\"). The macro then loads the selector of the user data segment into ds and es . After saving the registers, the address of the current top stack location is saved in the eax register; then, the interrupt handler invokes the do_IRQ( ) function. When the ret instruction of do_IRQ( ) is executed (when that function terminates) control is transferred to ret_from_intr( ) (see the later section \"Returning from Interrupts and Exceptions\").","title":"4.6.1.5. Saving the registers for the interrupt handler"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#4616#the#do_irq#function","text":"","title":"4.6.1.6. The do_IRQ( ) function"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#4617#the#__do_irq#function","text":"","title":"4.6.1.7. The __do_IRQ( ) function"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#4618#reviving#a#lost#interrupt","text":"","title":"4.6.1.8. Reviving a lost interrupt"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#4619#interrupt#service#routines","text":"","title":"4.6.1.9. Interrupt service routines"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/4.6-Interrupt-Handling/#46110#dynamic#allocation#of#irq#lines","text":"","title":"4.6.1.10. Dynamic allocation of IRQ lines"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/Chapter-4-Interrupts-and-Exceptions/","text":"Chapter 4. Interrupts and Exceptions An interrupt is usually defined as an event that alters the sequence of instructions executed by a processor. Such events correspond to electrical signals generated by hardware circuits both inside and outside the CPU chip. Interrupts are often divided into synchronous and asynchronous interrupts : Synchronous interrupts are produced by the CPU control unit while executing instructions and are called synchronous because the control unit issues them only after terminating the execution of an instruction. Asynchronous interrupts are generated by other hardware devices at arbitrary times with respect to the CPU clock signals. NOTE : \u4e24\u8005\u7684\u6765\u6e90\u4e0d\u540c\uff0c\u4e00\u4e2a\u662f\u6e90\u81eaCPU\uff0c\u4e00\u4e2a\u662f\u6e90\u81ea\u5176\u4ed6\u7684**hardware devices** Intel microprocessor manuals designate synchronous and asynchronous interrupts as exceptions and interrupts , respectively. We'll adopt this classification, although we'll occasionally use the term \" interrupt signal \" to designate both types together (synchronous as well as asynchronous). \u82f1\u7279\u5c14\u5fae\u5904\u7406\u5668\u624b\u518c\u5206\u522b\u5c06\u540c\u6b65\u548c\u5f02\u6b65\u4e2d\u65ad\u6307\u5b9a\u4e3a\u5f02\u5e38\u548c\u4e2d\u65ad\u3002 \u6211\u4eec\u5c06\u91c7\u7528\u8fd9\u79cd\u5206\u7c7b\uff0c\u5c3d\u7ba1\u6211\u4eec\u5076\u5c14\u4f1a\u4f7f\u7528\u672f\u8bed\u201c\u4e2d\u65ad\u4fe1\u53f7\u201d\u6765\u6307\u5b9a\u4e24\u79cd\u7c7b\u578b\uff08\u540c\u6b65\u548c\u5f02\u6b65\uff09\u3002 Interrupts are issued by interval timers and I/O devices ; for instance, the arrival of a keystroke from a user sets off an interrupt. Exceptions , on the other hand, are caused either by programming errors or by anomalous\uff08\u5f02\u5e38\u7684\uff09 conditions that must be handled by the kernel. In the first case, the kernel handles the exception by delivering to the current process one of the signals familiar to every Unix programmer . In the second case, the kernel performs all the steps needed to recover from the anomalous condition , such as a Page Fault or a request via an assembly language instruction such as int or sysenter for a kernel service. We start by describing in the next section the motivation for introducing such signals. We then show how the well-known IRQs (Interrupt Requests) issued by I/O devices give rise to interrupts, and we detail how 80x86 processors handle interrupts and exceptions at the hardware level . Then we illustrate, in the section \"Initializing the Interrupt Descriptor Table,\" how Linux initializes all the data structures required by the 80x86 interrupt architecture. The remaining three sections describe how Linux handles interrupt signals at the software level . NOTE: \u601d\u8003Unix signal\u548cexceptions\u548cinterrupts\u4e4b\u95f4\u7684\u5173\u7cfb\u3002Unix signal\u90fd\u5bf9\u5e94\u7684\u662fexceptions\uff1f\u5173\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u53c2\u52a0\u300adocs/Programming/Signal/Signal.md\u300b","title":"Chapter-4-Interrupts-and-Exceptions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/Chapter-4-Interrupts-and-Exceptions/#chapter#4#interrupts#and#exceptions","text":"An interrupt is usually defined as an event that alters the sequence of instructions executed by a processor. Such events correspond to electrical signals generated by hardware circuits both inside and outside the CPU chip. Interrupts are often divided into synchronous and asynchronous interrupts : Synchronous interrupts are produced by the CPU control unit while executing instructions and are called synchronous because the control unit issues them only after terminating the execution of an instruction. Asynchronous interrupts are generated by other hardware devices at arbitrary times with respect to the CPU clock signals. NOTE : \u4e24\u8005\u7684\u6765\u6e90\u4e0d\u540c\uff0c\u4e00\u4e2a\u662f\u6e90\u81eaCPU\uff0c\u4e00\u4e2a\u662f\u6e90\u81ea\u5176\u4ed6\u7684**hardware devices** Intel microprocessor manuals designate synchronous and asynchronous interrupts as exceptions and interrupts , respectively. We'll adopt this classification, although we'll occasionally use the term \" interrupt signal \" to designate both types together (synchronous as well as asynchronous). \u82f1\u7279\u5c14\u5fae\u5904\u7406\u5668\u624b\u518c\u5206\u522b\u5c06\u540c\u6b65\u548c\u5f02\u6b65\u4e2d\u65ad\u6307\u5b9a\u4e3a\u5f02\u5e38\u548c\u4e2d\u65ad\u3002 \u6211\u4eec\u5c06\u91c7\u7528\u8fd9\u79cd\u5206\u7c7b\uff0c\u5c3d\u7ba1\u6211\u4eec\u5076\u5c14\u4f1a\u4f7f\u7528\u672f\u8bed\u201c\u4e2d\u65ad\u4fe1\u53f7\u201d\u6765\u6307\u5b9a\u4e24\u79cd\u7c7b\u578b\uff08\u540c\u6b65\u548c\u5f02\u6b65\uff09\u3002 Interrupts are issued by interval timers and I/O devices ; for instance, the arrival of a keystroke from a user sets off an interrupt. Exceptions , on the other hand, are caused either by programming errors or by anomalous\uff08\u5f02\u5e38\u7684\uff09 conditions that must be handled by the kernel. In the first case, the kernel handles the exception by delivering to the current process one of the signals familiar to every Unix programmer . In the second case, the kernel performs all the steps needed to recover from the anomalous condition , such as a Page Fault or a request via an assembly language instruction such as int or sysenter for a kernel service. We start by describing in the next section the motivation for introducing such signals. We then show how the well-known IRQs (Interrupt Requests) issued by I/O devices give rise to interrupts, and we detail how 80x86 processors handle interrupts and exceptions at the hardware level . Then we illustrate, in the section \"Initializing the Interrupt Descriptor Table,\" how Linux initializes all the data structures required by the 80x86 interrupt architecture. The remaining three sections describe how Linux handles interrupt signals at the software level . NOTE: \u601d\u8003Unix signal\u548cexceptions\u548cinterrupts\u4e4b\u95f4\u7684\u5173\u7cfb\u3002Unix signal\u90fd\u5bf9\u5e94\u7684\u662fexceptions\uff1f\u5173\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u53c2\u52a0\u300adocs/Programming/Signal/Signal.md\u300b","title":"Chapter 4. Interrupts and Exceptions"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-4-Interrupts-and-Exceptions/Trap/","text":"","title":"Trap"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/6.1-Clock-and-Timer-Circuits/","text":"6.1. Clock and Timer Circuits On the 80x86 architecture, the kernel must explicitly interact with several kinds of clocks and timer circuits. The clock circuits are used both to keep track of the current time of day and to make precise time measurements. The timer circuits are programmed by the kernel, so that they issue interrupts at a fixed, predefined frequency; such periodic interrupts are crucial for implementing the software timers used by the kernel and the user programs. We'll now briefly describe the clock and hardware circuits that can be found in IBM-compatible PCs.","title":"6.1-Clock-and-Timer-Circuits"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/6.1-Clock-and-Timer-Circuits/#61#clock#and#timer#circuits","text":"On the 80x86 architecture, the kernel must explicitly interact with several kinds of clocks and timer circuits. The clock circuits are used both to keep track of the current time of day and to make precise time measurements. The timer circuits are programmed by the kernel, so that they issue interrupts at a fixed, predefined frequency; such periodic interrupts are crucial for implementing the software timers used by the kernel and the user programs. We'll now briefly describe the clock and hardware circuits that can be found in IBM-compatible PCs.","title":"6.1. Clock and Timer Circuits"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/6.2-The-Linux-Timekeeping-Architecture/","text":"6.2. The Linux Timekeeping Architecture Linux must carry on several time-related activities. For instance, the kernel periodically: Updates the time elapsed since system startup. Updates the time and date. Determines, for every CPU, how long the current process has been running, and preempts it if it has exceeded the time allocated to it. The allocation of time slots (also called \"quanta\") is discussed in Chapter 7 . Updates resource usage statistics. Checks whether the interval of time associated with each software timer (see the later section \"Software Timers and Delay Functions\") has elapsed. Linux's timekeeping architecture is the set of kernel data structures and functions related to the flow of time. Actually, 80 x 86-based multiprocessor machines have a timekeeping architecture that is slightly different from the timekeeping architecture of uniprocessor machines: In a uniprocessor system, all time-keeping activities are triggered by interrupts raised by the global timer (either the Programmable Interval Timer or the High Precision Event Timer). In a multiprocessor system, all general activities (such as handling of software timers) are triggered by the interrupts raised by the global timer , while CPU-specific activities (such as monitoring the execution time of the currently running process) are triggered by the interrupts raised by the local APIC timer. Unfortunately, the distinction between the two cases is somewhat blurred. For instance, some early SMP systems based on Intel 80486 processors didn't have local APICs. Even nowadays, there are SMP motherboards so buggy that local timer interrupts are not usable at all. In these cases, the SMP kernel must resort to the UP timekeeping architecture. On the other hand, recent uniprocessor systems feature one local APIC, so the UP kernel often makes use of the SMP timekeeping architecture. However, to simplify our description, we won't discuss these hybrid cases and will stick to the two \"pure\" timekeeping architectures. Linux's timekeeping architecture depends also on the availability of the Time Stamp Counter (TSC), of the ACPI Power Management Timer, and of the High Precision Event Timer (HPET). The kernel uses two basic timekeeping functions: one to keep the current time up-to-date and another to count the number of nanoseconds that have elapsed within the current second. There are different ways to get the last value. Some methods are more precise and are available if the CPU has a Time Stamp Counter or a HPET; a less-precise method is used in the opposite case (see the later section \"The time( ) and gettimeofday( ) System Calls\").","title":"6.2-The-Linux-Timekeeping-Architecture"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/6.2-The-Linux-Timekeeping-Architecture/#62#the#linux#timekeeping#architecture","text":"Linux must carry on several time-related activities. For instance, the kernel periodically: Updates the time elapsed since system startup. Updates the time and date. Determines, for every CPU, how long the current process has been running, and preempts it if it has exceeded the time allocated to it. The allocation of time slots (also called \"quanta\") is discussed in Chapter 7 . Updates resource usage statistics. Checks whether the interval of time associated with each software timer (see the later section \"Software Timers and Delay Functions\") has elapsed. Linux's timekeeping architecture is the set of kernel data structures and functions related to the flow of time. Actually, 80 x 86-based multiprocessor machines have a timekeeping architecture that is slightly different from the timekeeping architecture of uniprocessor machines: In a uniprocessor system, all time-keeping activities are triggered by interrupts raised by the global timer (either the Programmable Interval Timer or the High Precision Event Timer). In a multiprocessor system, all general activities (such as handling of software timers) are triggered by the interrupts raised by the global timer , while CPU-specific activities (such as monitoring the execution time of the currently running process) are triggered by the interrupts raised by the local APIC timer. Unfortunately, the distinction between the two cases is somewhat blurred. For instance, some early SMP systems based on Intel 80486 processors didn't have local APICs. Even nowadays, there are SMP motherboards so buggy that local timer interrupts are not usable at all. In these cases, the SMP kernel must resort to the UP timekeeping architecture. On the other hand, recent uniprocessor systems feature one local APIC, so the UP kernel often makes use of the SMP timekeeping architecture. However, to simplify our description, we won't discuss these hybrid cases and will stick to the two \"pure\" timekeeping architectures. Linux's timekeeping architecture depends also on the availability of the Time Stamp Counter (TSC), of the ACPI Power Management Timer, and of the High Precision Event Timer (HPET). The kernel uses two basic timekeeping functions: one to keep the current time up-to-date and another to count the number of nanoseconds that have elapsed within the current second. There are different ways to get the last value. Some methods are more precise and are available if the CPU has a Time Stamp Counter or a HPET; a less-precise method is used in the opposite case (see the later section \"The time( ) and gettimeofday( ) System Calls\").","title":"6.2. The Linux Timekeeping Architecture"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/6.4-Updating-System-Statistics/","text":"6.4. Updating System Statistics The kernel, among the other time-related duties, must periodically collect various data used for: Checking the CPU resource limit of the running processes Updating statistics about the local CPU workload Computing the average system load Profiling the kernel code NOTE: \u5728 Shell-and-tools\\Tools\\Performance \u7ae0\u8282\u4e2d\uff0c\u4ecb\u7ecd\u4e86\u5f88\u591a\u7528\u4e8e\u76d1\u63a7Linux OS\u7684\u5de5\u5177\uff0c\u663e\u7136\u8fd9\u4e9b\u5de5\u5177\u7684\u5b9e\u73b0\u662f\u4f9d\u8d56\u4e8e\u672c\u7ae0\u4ecb\u7ecd\u7684kernel\u7684\u8fd9\u4e2a\u7279\u6027\u7684\u3002 6.4.1. Updating Local CPU Statistics We have mentioned that the update_process_times( ) function is invoked either by the global timer interrupt handler on uniprocessor systems or by the local timer interrupt handler in multiprocessor systems to update some kernel statistics. This function performs the following steps: 1 Checks how long the current process has been running. Depending on whether the current process was running in User Mode or in Kernel Mode when the timer interrupt occurred, invokes either account_user_time( ) or account_system_time( ) . Each of these functions performs essentially the following steps: a. Updates either the utime field (ticks spent in User Mode ) or the stime field (ticks spent in Kernel Mode ) of the current process descriptor . Two additional fields called cutime and cstime are provided in the process descriptor to count the number of CPU ticks spent by the process children in User Mode and Kernel Mode, respectively. For reasons of efficiency, these fields are not updated by update_process_times( ) , but rather when the parent process queries the state of one of its children (see the section \"Destroying Processes\" in Chapter 3). b. Checks whether the total CPU time limit has been reached; if so, sends SIGXCPU and SIGKILL signals to current . The section \"Process Resource Limits\" in Chapter 3 describes how the limit is controlled by the signal->rlim[RLIMIT_CPU].rlim_cur field of each process descriptor. c. Invokes account_it_virt( ) and account_it_prof( ) to check the process timers (see the section \"The setitimer( ) and alarm( ) System Calls\" later in this chapter). d. Updates some kernel statistics stored in the kstat per-CPU variable. 2 Invokes raise_softirq( ) to activate the TIMER_SOFTIRQ tasklet on the local CPU (see the section \"Software Timers and Delay Functions\" later in this chapter). NOTE: tasklet\u57284.7. Softirqs and Tasklets\u4e2d\u6709\u4ecb\u7ecd\uff0c\u53e6\u5916\u53c2\u89c1\uff1a Deferrable functions, kernel tasklets, and work queues Multitasking in the Linux Kernel. Interrupts and Tasklets 3 If some old version of an RCU-protected data structure has to be reclaimed, checks whether the local CPU has gone through a quiescent state and invokes tasklet_schedule( ) to activate the rcu_tasklet tasklet of the local CPU (see the section \"Read-Copy Update (RCU)\" in Chapter 5). 4 Invokes the scheduler_tick( ) function, which decreases the time slice counter of the current process, and checks whether its quantum is exhausted. We'll discuss in depth these operations in the section \"The scheduler_tick( ) Function\" in Chapter 7. NOTE: **quantum**\u57287.1. Scheduling Policy\u4e2d\u5b9a\u4e49\uff1b 6.4.2. Keeping Track of System Load Every Unix kernel keeps track of how much CPU activity is being carried on by the system. These statistics are used by various administration utilities such as top . A user who enters the uptime command sees the statistics as the \"load average\" relative to the last minute, the last 5 minutes, and the last 15 minutes. On a uniprocessor system, a value of 0 means that there are no active processes (besides the swapper process 0 ) to run, while a value of 1 means that the CPU is 100 percent busy with a single process, and values greater than 1 mean that the CPU is shared among several active processes. [ * ] [ * ] Linux includes in the load average all processes that are in the TASK_RUNNING and TASK_UNINTERRUPTIBLE states. However, under normal conditions, there are few TASK_UNINTERRUPTIBLE processes, so a high load usually means that the CPU is busy. At every tick, update_times( ) invokes the calc_load( ) function, which counts the number of processes in the TASK_RUNNING or TASK_UNINTERRUPTIBLE state and uses this number to update the average system load. 6.4.3. Profiling the Kernel Code Linux includes a minimalist\uff08\u7b80\u5355\u7684\uff09 code profiler called readprofile used by Linux developers to discover where the kernel spends its time in Kernel Mode . The profiler identifies the hot spots of the kernel the most frequently executed fragments of kernel code. Identifying the kernel hot spots is very important, because they may point out kernel functions that should be further optimized. The profiler is based on a simple Monte Carlo algorithm : at every timer interrupt occurrence, the kernel determines whether the interrupt occurred in Kernel Mode; if so, the kernel fetches the value of the eip register before the interruption from the stack and uses it to discover what the kernel was doing before the interrupt. In the long run, the samples accumulate on the hot spots. NOTE : \u5173\u4e8e\u4e3a\u4ec0\u4e48\u4f7f\u7528 eip register\uff0c\u53ef\u4ee5\u53c2\u89c1\uff1a 4. EIP Instruction Pointer Register What does EIP stand for? The profile_tick( ) function collects the data for the code profiler. It is invoked either by the do_timer_interrupt( ) function in uniprocessor systems (by the global timer interrupt handler) or by the smp_local_timer_interrupt( ) function in multiprocessor systems (by the local timer interrupt handler). To enable the code profiler, the Linux kernel must be booted by passing as a parameter the string profile=N , where 2^N 2^N denotes the size of the code fragments to be profiled. The collected data can be read from the /proc/profile file. The counters are reset by writing in the same file; in multiprocessor systems, writing into the file can also change the sample frequency (see the earlier section \"Timekeeping Architecture in Multiprocessor Systems\"). However, kernel developers do not usually access /proc/profile directly; instead, they use the readprofile system command. The Linux 2.6 kernel includes yet another profiler called oprofile . Besides being more flexible and customizable than readprofile , oprofile can be used to discover hot spots in kernel code, User Mode applications, and system libraries. When oprofile is being used, profile_tick( ) invokes the timer_notify( ) function to collect the data used by this new profiler. 6.4.4. Checking the NMI Watchdogs In multiprocessor systems, Linux offers yet another feature to kernel developers: a watchdog system, which might be quite useful to detect kernel bugs that cause a system freeze. To activate such a watchdog, the kernel must be booted with the nmi_watchdog parameter. The watchdog is based on a clever hardware feature of local and I/O APICs: they can generate periodic NMI interrupts on every CPU. Because NMI interrupts are not masked by the cli assembly language instruction, the watchdog can detect deadlocks even when interrupts are disabled.","title":"6.4-Updating-System-Statistics"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/6.4-Updating-System-Statistics/#64#updating#system#statistics","text":"The kernel, among the other time-related duties, must periodically collect various data used for: Checking the CPU resource limit of the running processes Updating statistics about the local CPU workload Computing the average system load Profiling the kernel code NOTE: \u5728 Shell-and-tools\\Tools\\Performance \u7ae0\u8282\u4e2d\uff0c\u4ecb\u7ecd\u4e86\u5f88\u591a\u7528\u4e8e\u76d1\u63a7Linux OS\u7684\u5de5\u5177\uff0c\u663e\u7136\u8fd9\u4e9b\u5de5\u5177\u7684\u5b9e\u73b0\u662f\u4f9d\u8d56\u4e8e\u672c\u7ae0\u4ecb\u7ecd\u7684kernel\u7684\u8fd9\u4e2a\u7279\u6027\u7684\u3002","title":"6.4. Updating System Statistics"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/6.4-Updating-System-Statistics/#641#updating#local#cpu#statistics","text":"We have mentioned that the update_process_times( ) function is invoked either by the global timer interrupt handler on uniprocessor systems or by the local timer interrupt handler in multiprocessor systems to update some kernel statistics. This function performs the following steps: 1 Checks how long the current process has been running. Depending on whether the current process was running in User Mode or in Kernel Mode when the timer interrupt occurred, invokes either account_user_time( ) or account_system_time( ) . Each of these functions performs essentially the following steps: a. Updates either the utime field (ticks spent in User Mode ) or the stime field (ticks spent in Kernel Mode ) of the current process descriptor . Two additional fields called cutime and cstime are provided in the process descriptor to count the number of CPU ticks spent by the process children in User Mode and Kernel Mode, respectively. For reasons of efficiency, these fields are not updated by update_process_times( ) , but rather when the parent process queries the state of one of its children (see the section \"Destroying Processes\" in Chapter 3). b. Checks whether the total CPU time limit has been reached; if so, sends SIGXCPU and SIGKILL signals to current . The section \"Process Resource Limits\" in Chapter 3 describes how the limit is controlled by the signal->rlim[RLIMIT_CPU].rlim_cur field of each process descriptor. c. Invokes account_it_virt( ) and account_it_prof( ) to check the process timers (see the section \"The setitimer( ) and alarm( ) System Calls\" later in this chapter). d. Updates some kernel statistics stored in the kstat per-CPU variable. 2 Invokes raise_softirq( ) to activate the TIMER_SOFTIRQ tasklet on the local CPU (see the section \"Software Timers and Delay Functions\" later in this chapter). NOTE: tasklet\u57284.7. Softirqs and Tasklets\u4e2d\u6709\u4ecb\u7ecd\uff0c\u53e6\u5916\u53c2\u89c1\uff1a Deferrable functions, kernel tasklets, and work queues Multitasking in the Linux Kernel. Interrupts and Tasklets 3 If some old version of an RCU-protected data structure has to be reclaimed, checks whether the local CPU has gone through a quiescent state and invokes tasklet_schedule( ) to activate the rcu_tasklet tasklet of the local CPU (see the section \"Read-Copy Update (RCU)\" in Chapter 5). 4 Invokes the scheduler_tick( ) function, which decreases the time slice counter of the current process, and checks whether its quantum is exhausted. We'll discuss in depth these operations in the section \"The scheduler_tick( ) Function\" in Chapter 7. NOTE: **quantum**\u57287.1. Scheduling Policy\u4e2d\u5b9a\u4e49\uff1b","title":"6.4.1. Updating Local CPU Statistics"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/6.4-Updating-System-Statistics/#642#keeping#track#of#system#load","text":"Every Unix kernel keeps track of how much CPU activity is being carried on by the system. These statistics are used by various administration utilities such as top . A user who enters the uptime command sees the statistics as the \"load average\" relative to the last minute, the last 5 minutes, and the last 15 minutes. On a uniprocessor system, a value of 0 means that there are no active processes (besides the swapper process 0 ) to run, while a value of 1 means that the CPU is 100 percent busy with a single process, and values greater than 1 mean that the CPU is shared among several active processes. [ * ] [ * ] Linux includes in the load average all processes that are in the TASK_RUNNING and TASK_UNINTERRUPTIBLE states. However, under normal conditions, there are few TASK_UNINTERRUPTIBLE processes, so a high load usually means that the CPU is busy. At every tick, update_times( ) invokes the calc_load( ) function, which counts the number of processes in the TASK_RUNNING or TASK_UNINTERRUPTIBLE state and uses this number to update the average system load.","title":"6.4.2. Keeping Track of System Load"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/6.4-Updating-System-Statistics/#643#profiling#the#kernel#code","text":"Linux includes a minimalist\uff08\u7b80\u5355\u7684\uff09 code profiler called readprofile used by Linux developers to discover where the kernel spends its time in Kernel Mode . The profiler identifies the hot spots of the kernel the most frequently executed fragments of kernel code. Identifying the kernel hot spots is very important, because they may point out kernel functions that should be further optimized. The profiler is based on a simple Monte Carlo algorithm : at every timer interrupt occurrence, the kernel determines whether the interrupt occurred in Kernel Mode; if so, the kernel fetches the value of the eip register before the interruption from the stack and uses it to discover what the kernel was doing before the interrupt. In the long run, the samples accumulate on the hot spots. NOTE : \u5173\u4e8e\u4e3a\u4ec0\u4e48\u4f7f\u7528 eip register\uff0c\u53ef\u4ee5\u53c2\u89c1\uff1a 4. EIP Instruction Pointer Register What does EIP stand for? The profile_tick( ) function collects the data for the code profiler. It is invoked either by the do_timer_interrupt( ) function in uniprocessor systems (by the global timer interrupt handler) or by the smp_local_timer_interrupt( ) function in multiprocessor systems (by the local timer interrupt handler). To enable the code profiler, the Linux kernel must be booted by passing as a parameter the string profile=N , where 2^N 2^N denotes the size of the code fragments to be profiled. The collected data can be read from the /proc/profile file. The counters are reset by writing in the same file; in multiprocessor systems, writing into the file can also change the sample frequency (see the earlier section \"Timekeeping Architecture in Multiprocessor Systems\"). However, kernel developers do not usually access /proc/profile directly; instead, they use the readprofile system command. The Linux 2.6 kernel includes yet another profiler called oprofile . Besides being more flexible and customizable than readprofile , oprofile can be used to discover hot spots in kernel code, User Mode applications, and system libraries. When oprofile is being used, profile_tick( ) invokes the timer_notify( ) function to collect the data used by this new profiler.","title":"6.4.3. Profiling the Kernel Code"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/6.4-Updating-System-Statistics/#644#checking#the#nmi#watchdogs","text":"In multiprocessor systems, Linux offers yet another feature to kernel developers: a watchdog system, which might be quite useful to detect kernel bugs that cause a system freeze. To activate such a watchdog, the kernel must be booted with the nmi_watchdog parameter. The watchdog is based on a clever hardware feature of local and I/O APICs: they can generate periodic NMI interrupts on every CPU. Because NMI interrupts are not masked by the cli assembly language instruction, the watchdog can detect deadlocks even when interrupts are disabled.","title":"6.4.4. Checking the NMI Watchdogs"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/Chapter-6-Timing-Measurements/","text":"Chapter 6. Timing Measurements Chapter 6. Timing Measurements Countless computerized activities are driven by timing measurements , often behind the user's back. For instance, if the screen is automatically switched off after you have stopped using the computer's console, it is due to a timer that allows the kernel to keep track of how much time has elapsed since you pushed a key or moved the mouse. If you receive a warning from the system asking you to remove a set of unused files, it is the outcome of a program that identifies all user files that have not been accessed for a long time. To do these things, programs must be able to retrieve a timestamp identifying its last access time from each file. Such a timestamp must be automatically written by the kernel . More significantly, timing drives process switches along with even more visible kernel activities such as checking for time-outs. SUMMARY : CPU\u7684\u63a7\u5236\u5668\u4e5f\u662f\u53d7\u65f6\u949f\u63a7\u5236\u7684\uff1aclock generator\uff1b We can distinguish two main kinds of timing measurement that must be performed by the Linux kernel: Keeping the current time and date so they can be returned to user programs through the time() , ftime( ) , and gettimeofday( ) APIs (see the section \"The time( ) and gettimeofday( ) System Calls\" later in this chapter) and used by the kernel itself as timestamps for files and network packets Maintaining timers mechanisms that are able to notify the kernel (see the later section \"Software Timers and Delay Functions\") or a user program (see the later sections \"The setitimer( ) and alarm( ) System Calls\" and \"System Calls for POSIX Timers\") that a certain interval of time has elapsed Timing measurements are performed by several hardware circuits based on fixed-frequency oscillators and counters. This chapter consists of four different parts. The first two sections describe the hardware devices that underly timing and give an overall picture of Linux timekeeping architecture . The following sections describe the main time-related duties of the kernel: implementing CPU time sharing , updating system time and resource usage statistics, and maintaining software timers . The last section discusses the system calls related to timing measurements and the corresponding service routines.","title":"Chapter-6-Timing-Measurements"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-6-Timing-Measurements/Chapter-6-Timing-Measurements/#chapter#6#timing#measurements","text":"Countless computerized activities are driven by timing measurements , often behind the user's back. For instance, if the screen is automatically switched off after you have stopped using the computer's console, it is due to a timer that allows the kernel to keep track of how much time has elapsed since you pushed a key or moved the mouse. If you receive a warning from the system asking you to remove a set of unused files, it is the outcome of a program that identifies all user files that have not been accessed for a long time. To do these things, programs must be able to retrieve a timestamp identifying its last access time from each file. Such a timestamp must be automatically written by the kernel . More significantly, timing drives process switches along with even more visible kernel activities such as checking for time-outs. SUMMARY : CPU\u7684\u63a7\u5236\u5668\u4e5f\u662f\u53d7\u65f6\u949f\u63a7\u5236\u7684\uff1aclock generator\uff1b We can distinguish two main kinds of timing measurement that must be performed by the Linux kernel: Keeping the current time and date so they can be returned to user programs through the time() , ftime( ) , and gettimeofday( ) APIs (see the section \"The time( ) and gettimeofday( ) System Calls\" later in this chapter) and used by the kernel itself as timestamps for files and network packets Maintaining timers mechanisms that are able to notify the kernel (see the later section \"Software Timers and Delay Functions\") or a user program (see the later sections \"The setitimer( ) and alarm( ) System Calls\" and \"System Calls for POSIX Timers\") that a certain interval of time has elapsed Timing measurements are performed by several hardware circuits based on fixed-frequency oscillators and counters. This chapter consists of four different parts. The first two sections describe the hardware devices that underly timing and give an overall picture of Linux timekeeping architecture . The following sections describe the main time-related duties of the kernel: implementing CPU time sharing , updating system time and resource usage statistics, and maintaining software timers . The last section discusses the system calls related to timing measurements and the corresponding service routines.","title":"Chapter 6. Timing Measurements"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-7-Process-Scheduling/Chapter-7-Process-Scheduling/","text":"Chapter 7. Process Scheduling Like every time sharing system, Linux achieves the magical effect of an apparent simultaneous execution of multiple processes by switching from one process to another in a very short time frame. Process switching itself was discussed in Chapter 3; this chapter deals with scheduling , which is concerned with when to switch and which process to choose. The chapter consists of three parts. The section \"Scheduling Policy\" introduces the choices made by Linux in the abstract to schedule processes. The section \"The Scheduling Algorithm\" discusses the data structures used to implement scheduling and the corresponding algorithm. Finally, the section \"System Calls Related to Scheduling\" describes the system calls that affect process scheduling. To simplify the description, we refer as usual to the 80 x 86 architecture; in particular, we assume that the system uses the Uniform Memory Access model, and that the system tick is set to 1 ms.","title":"Chapter-7-Process-Scheduling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-7-Process-Scheduling/Chapter-7-Process-Scheduling/#chapter#7#process#scheduling","text":"Like every time sharing system, Linux achieves the magical effect of an apparent simultaneous execution of multiple processes by switching from one process to another in a very short time frame. Process switching itself was discussed in Chapter 3; this chapter deals with scheduling , which is concerned with when to switch and which process to choose. The chapter consists of three parts. The section \"Scheduling Policy\" introduces the choices made by Linux in the abstract to schedule processes. The section \"The Scheduling Algorithm\" discusses the data structures used to implement scheduling and the corresponding algorithm. Finally, the section \"System Calls Related to Scheduling\" describes the system calls that affect process scheduling. To simplify the description, we refer as usual to the 80 x 86 architecture; in particular, we assume that the system uses the Uniform Memory Access model, and that the system tick is set to 1 ms.","title":"Chapter 7. Process Scheduling"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-8-Memory-Management/8.1-Page-Frame-Management/","text":"8.1. Page Frame Management We saw in the section \"Paging in Hardware\" in Chapter 2 how the Intel Pentium processor can use two different page frame sizes: 4 KB and 4 MB (or 2 MB if PAE is enabled see the section \"The Physical Address Extension (PAE) Paging Mechanism\" in Chapter 2). Linux adopts the smaller 4 KB page frame size as the standard memory allocation unit . This makes things simpler for two reasons: The Page Fault exceptions issued by the paging circuitry are easily interpreted. Either the page requested exists but the process is not allowed to address it, or the page does not exist. In the second case, the memory allocator must find a free 4 KB page frame and assign it to the process. Although both 4 KB and 4 MB are multiples of all disk block sizes, transfers of data between main memory and disks are in most cases more efficient when the smaller size is used. 8.1.1. Page Descriptors The kernel must keep track of the current status of each page frame . For instance, it must be able to distinguish the page frames that are used to contain pages that belong to processes from those that contain kernel code or kernel data structures. Similarly, it must be able to determine whether a page frame in dynamic memory is free. A page frame in dynamic memory is free if it does not contain any useful data. It is not free when the page frame contains data of a User Mode process, data of a software cache, dynamically allocated kernel data structures, buffered data of a device driver, code of a kernel module, and so on. State information of a page frame is kept in a page descriptor of type page , whose fields are shown in Table 8-1. All page descriptors are stored in the mem_map array. Because each descriptor is 32 bytes long, the space required by mem_map is slightly less than 1% of the whole RAM. The virt_to_page(addr) macro yields the address of the page descriptor associated with the linear address addr . The pfn_to_page(pfn) macro yields the address of the page descriptor associated with the page frame having number pfn . NOTE: \u6839\u636epage frame\u6765\u83b7\u5f97\u5176\u5bf9\u5e94\u7684page descriptor\u3002 Table 8-1. The fields of the page descriptor Type Name Description unsigned long flags Array of flags (see Table 8-2). Also encodes the zone number to which the page frame belongs. atomic_t _count Page frame's reference counter. atomic_t _mapcount Number of Page Table entries that refer to the page frame ( - 1 if none). unsigned long private Available to the kernel component that is using the page (for instance, it is a buffer head pointer in case of buffer page; see \"Block Buffers and Buffer Heads\" in Chapter 15). If the page is free, this field is used by the buddy system (see later in this chapter). struct address_space * mapping Used when the page is inserted into the page cache (see the section \"The Page Cache\" in Chapter 15), or when it belongs to an anonymous region (see the section \"Reverse Mapping for Anonymous Pages\" in Chapter 17). unsigned long index Used by several kernel components with different meanings. For instance, it identifies the position of the data stored in the page frame within the page's disk image or within an anonymous region (Chapter 15), or it stores a swapped-out page identifier (Chapter 17). struct list_head lru Contains pointers to the least recently used doubly linked list of pages. You don't have to fully understand the role of all fields in the page descriptor right now. In the following chapters, we often come back to the fields of the page descriptor. Moreover, several fields have different meaning, according to whether the page frame is free or what kernel component is using the page frame.","title":"8.1-Page-Frame-Management"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-8-Memory-Management/8.1-Page-Frame-Management/#81#page#frame#management","text":"We saw in the section \"Paging in Hardware\" in Chapter 2 how the Intel Pentium processor can use two different page frame sizes: 4 KB and 4 MB (or 2 MB if PAE is enabled see the section \"The Physical Address Extension (PAE) Paging Mechanism\" in Chapter 2). Linux adopts the smaller 4 KB page frame size as the standard memory allocation unit . This makes things simpler for two reasons: The Page Fault exceptions issued by the paging circuitry are easily interpreted. Either the page requested exists but the process is not allowed to address it, or the page does not exist. In the second case, the memory allocator must find a free 4 KB page frame and assign it to the process. Although both 4 KB and 4 MB are multiples of all disk block sizes, transfers of data between main memory and disks are in most cases more efficient when the smaller size is used.","title":"8.1. Page Frame Management"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-8-Memory-Management/8.1-Page-Frame-Management/#811#page#descriptors","text":"The kernel must keep track of the current status of each page frame . For instance, it must be able to distinguish the page frames that are used to contain pages that belong to processes from those that contain kernel code or kernel data structures. Similarly, it must be able to determine whether a page frame in dynamic memory is free. A page frame in dynamic memory is free if it does not contain any useful data. It is not free when the page frame contains data of a User Mode process, data of a software cache, dynamically allocated kernel data structures, buffered data of a device driver, code of a kernel module, and so on. State information of a page frame is kept in a page descriptor of type page , whose fields are shown in Table 8-1. All page descriptors are stored in the mem_map array. Because each descriptor is 32 bytes long, the space required by mem_map is slightly less than 1% of the whole RAM. The virt_to_page(addr) macro yields the address of the page descriptor associated with the linear address addr . The pfn_to_page(pfn) macro yields the address of the page descriptor associated with the page frame having number pfn . NOTE: \u6839\u636epage frame\u6765\u83b7\u5f97\u5176\u5bf9\u5e94\u7684page descriptor\u3002 Table 8-1. The fields of the page descriptor Type Name Description unsigned long flags Array of flags (see Table 8-2). Also encodes the zone number to which the page frame belongs. atomic_t _count Page frame's reference counter. atomic_t _mapcount Number of Page Table entries that refer to the page frame ( - 1 if none). unsigned long private Available to the kernel component that is using the page (for instance, it is a buffer head pointer in case of buffer page; see \"Block Buffers and Buffer Heads\" in Chapter 15). If the page is free, this field is used by the buddy system (see later in this chapter). struct address_space * mapping Used when the page is inserted into the page cache (see the section \"The Page Cache\" in Chapter 15), or when it belongs to an anonymous region (see the section \"Reverse Mapping for Anonymous Pages\" in Chapter 17). unsigned long index Used by several kernel components with different meanings. For instance, it identifies the position of the data stored in the page frame within the page's disk image or within an anonymous region (Chapter 15), or it stores a swapped-out page identifier (Chapter 17). struct list_head lru Contains pointers to the least recently used doubly linked list of pages. You don't have to fully understand the role of all fields in the page descriptor right now. In the following chapters, we often come back to the fields of the page descriptor. Moreover, several fields have different meaning, according to whether the page frame is free or what kernel component is using the page frame.","title":"8.1.1. Page Descriptors"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-8-Memory-Management/Chapter-8-Memory-Management/","text":"Chapter 8. Memory Management We saw in Chapter 2 how Linux takes advantage of 80 x 86's segmentation and paging circuits to translate logical addresses into physical ones. We also mentioned that some portion of RAM is permanently assigned to the kernel and used to store both the kernel code and the static kernel data structures. NOTE: \u73b0\u4ee3\u5927\u591a\u6570\u90fd\u662f\u91c7\u7528\u7684\u57fa\u4e8epage\u7684memory management\u3002 The remaining part of the RAM is called dynamic memory . It is a valuable resource, needed not only by the processes but also by the kernel itself. In fact, the performance of the entire system depends on how efficiently dynamic memory is managed. Therefore, all current multitasking operating systems try to optimize the use of dynamic memory , assigning it only when it is needed and freeing it as soon as possible. Figure 8-1 shows schematically the page frames used as dynamic memory ; see the section \"Physical Memory Layout\" in Chapter 2 for details. This chapter, which consists of three main sections, describes how the kernel allocates dynamic memory for its own use. The sections \"Page Frame Management\" and \"Memory Area Management\" illustrate two different techniques for handling physically contiguous memory areas, while the section \"Noncontiguous Memory Area Management\" illustrates a third technique that handles noncontiguous memory areas. In these sections we'll cover topics such as memory zones, kernel mappings, the buddy system, the slab cache, and memory pools.","title":"Chapter-8-Memory-Management"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-8-Memory-Management/Chapter-8-Memory-Management/#chapter#8#memory#management","text":"We saw in Chapter 2 how Linux takes advantage of 80 x 86's segmentation and paging circuits to translate logical addresses into physical ones. We also mentioned that some portion of RAM is permanently assigned to the kernel and used to store both the kernel code and the static kernel data structures. NOTE: \u73b0\u4ee3\u5927\u591a\u6570\u90fd\u662f\u91c7\u7528\u7684\u57fa\u4e8epage\u7684memory management\u3002 The remaining part of the RAM is called dynamic memory . It is a valuable resource, needed not only by the processes but also by the kernel itself. In fact, the performance of the entire system depends on how efficiently dynamic memory is managed. Therefore, all current multitasking operating systems try to optimize the use of dynamic memory , assigning it only when it is needed and freeing it as soon as possible. Figure 8-1 shows schematically the page frames used as dynamic memory ; see the section \"Physical Memory Layout\" in Chapter 2 for details. This chapter, which consists of three main sections, describes how the kernel allocates dynamic memory for its own use. The sections \"Page Frame Management\" and \"Memory Area Management\" illustrate two different techniques for handling physically contiguous memory areas, while the section \"Noncontiguous Memory Area Management\" illustrates a third technique that handles noncontiguous memory areas. In these sections we'll cover topics such as memory zones, kernel mappings, the buddy system, the slab cache, and memory pools.","title":"Chapter 8. Memory Management"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-9-Process-Address-Space/9.1-The-Process%27s-Address-Space/","text":"9.1. The Process's Address Space The address space of a process consists of all linear addresses that the process is allowed to use. Each process sees a different set of linear addresses ; the address used by one process bears no relation to the address used by another. As we will see later, the kernel may dynamically modify a process address space by adding or removing intervals of linear addresses . The kernel represents intervals of linear addresses by means of resources called memory regions, which are characterized by an initial linear address , a length , and some access rights . For reasons of efficiency, both the initial address and the length of a memory region must be multiples of 4,096, so that the data identified by each memory region completely fills up the page frames allocated to it. Following are some typical situations in which a process gets new memory regions : When the user types a command at the console, the shell process creates a new process to execute the command. As a result, a fresh address space, and thus a set of memory regions , is assigned to the new process (see the section \"Creating and Deleting a Process Address Space\" later in this chapter; also, see Chapter 20). A running process may decide to load an entirely different program. In this case, the process ID remains unchanged, but the memory regions used before loading the program are released and a new set of memory regions is assigned to the process (see the section \"The exec Functions\" in Chapter 20). A running process may perform a \"memory mapping\" on a file (or on a portion of it). In such cases, the kernel assigns a new memory region to the process to map the file (see the section \"Memory Mapping\" in Chapter 16). A process may keep adding data on its User Mode stack until all addresses in the memory region that map the stack have been used. In this case, the kernel may decide to expand the size of that memory region (see the section \"Page Fault Exception Handler\" later in this chapter). A process may create an IPC-shared memory region to share data with other cooperating processes. In this case, the kernel assigns a new memory region to the process to implement this construct (see the section \"IPC Shared Memory\" in Chapter 19). A process may expand its dynamic area (the heap) through a function such as malloc( ) . As a result, the kernel may decide to expand the size of the memory region assigned to the heap (see the section \"Managing the Heap\" later in this chapter). Table 9-1 illustrates some of the system calls related to the previously mentioned tasks. brk( ) is discussed at the end of this chapter, while the remaining system calls are described in other chapters. Table 9-1. System calls related to memory region creation and deletion System call Description brk( ) Changes the heap size of the process execve( ) Loads a new executable file, thus changing the process address space _exit( ) Terminates the current process and destroys its address space fork( ) Creates a new process, and thus a new address space mmap( ) , mmap2( ) Creates a memory mapping for a file, thus enlarging the process address space mremap( ) Expands or shrinks a memory region remap_file_pages() Creates a non-linear mapping for a file (see Chapter 16) munmap( ) Destroys a memory mapping for a file, thus contracting the process address space shmat( ) Attaches a shared memory region shmdt( ) Detaches a shared memory region As we'll see in the later section \"Page Fault Exception Handler,\" it is essential for the kernel to identify the memory regions currently owned by a process (the address space of a process), because that allows the Page Fault exception handler to efficiently distinguish between two types of invalid linear addresses that cause it to be invoked: Those caused by programming errors. Those caused by a missing page; even though the linear address belongs to the process's address space, the page frame corresponding to that address has yet to be allocated. The latter addresses are not invalid from the process's point of view; the induced Page Faults are exploited by the kernel to implement demand paging : the kernel provides the missing page frame and lets the process continue.","title":"9.1-The-Process's-Address-Space."},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-9-Process-Address-Space/9.1-The-Process%27s-Address-Space/#91#the#processs#address#space","text":"The address space of a process consists of all linear addresses that the process is allowed to use. Each process sees a different set of linear addresses ; the address used by one process bears no relation to the address used by another. As we will see later, the kernel may dynamically modify a process address space by adding or removing intervals of linear addresses . The kernel represents intervals of linear addresses by means of resources called memory regions, which are characterized by an initial linear address , a length , and some access rights . For reasons of efficiency, both the initial address and the length of a memory region must be multiples of 4,096, so that the data identified by each memory region completely fills up the page frames allocated to it. Following are some typical situations in which a process gets new memory regions : When the user types a command at the console, the shell process creates a new process to execute the command. As a result, a fresh address space, and thus a set of memory regions , is assigned to the new process (see the section \"Creating and Deleting a Process Address Space\" later in this chapter; also, see Chapter 20). A running process may decide to load an entirely different program. In this case, the process ID remains unchanged, but the memory regions used before loading the program are released and a new set of memory regions is assigned to the process (see the section \"The exec Functions\" in Chapter 20). A running process may perform a \"memory mapping\" on a file (or on a portion of it). In such cases, the kernel assigns a new memory region to the process to map the file (see the section \"Memory Mapping\" in Chapter 16). A process may keep adding data on its User Mode stack until all addresses in the memory region that map the stack have been used. In this case, the kernel may decide to expand the size of that memory region (see the section \"Page Fault Exception Handler\" later in this chapter). A process may create an IPC-shared memory region to share data with other cooperating processes. In this case, the kernel assigns a new memory region to the process to implement this construct (see the section \"IPC Shared Memory\" in Chapter 19). A process may expand its dynamic area (the heap) through a function such as malloc( ) . As a result, the kernel may decide to expand the size of the memory region assigned to the heap (see the section \"Managing the Heap\" later in this chapter). Table 9-1 illustrates some of the system calls related to the previously mentioned tasks. brk( ) is discussed at the end of this chapter, while the remaining system calls are described in other chapters. Table 9-1. System calls related to memory region creation and deletion System call Description brk( ) Changes the heap size of the process execve( ) Loads a new executable file, thus changing the process address space _exit( ) Terminates the current process and destroys its address space fork( ) Creates a new process, and thus a new address space mmap( ) , mmap2( ) Creates a memory mapping for a file, thus enlarging the process address space mremap( ) Expands or shrinks a memory region remap_file_pages() Creates a non-linear mapping for a file (see Chapter 16) munmap( ) Destroys a memory mapping for a file, thus contracting the process address space shmat( ) Attaches a shared memory region shmdt( ) Detaches a shared memory region As we'll see in the later section \"Page Fault Exception Handler,\" it is essential for the kernel to identify the memory regions currently owned by a process (the address space of a process), because that allows the Page Fault exception handler to efficiently distinguish between two types of invalid linear addresses that cause it to be invoked: Those caused by programming errors. Those caused by a missing page; even though the linear address belongs to the process's address space, the page frame corresponding to that address has yet to be allocated. The latter addresses are not invalid from the process's point of view; the induced Page Faults are exploited by the kernel to implement demand paging : the kernel provides the missing page frame and lets the process continue.","title":"9.1. The Process's Address Space"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-9-Process-Address-Space/9.2-The-Memory-Descriptor/","text":"9.2. The Memory Descriptor All information related to the process address space is included in an object called the memory descriptor of type mm_struct . This object is referenced by the mm field of the process descriptor . The fields of a memory descriptor are listed in Table 9-2. Table 9-2. The fields of the memory descriptor Type Field Description \u6ce8\u91ca struct vm_area_struct * mmap Pointer to the head of the list of memory region objects \u53c2\u89c1chapter 9.3. Memory Regions struct rb_root mm_rb Pointer to the root of the red-black tree of memory region objects struct vm_area_struct * mmap_cache Pointer to the last referenced memory region object unsigned long (*)( ) get_unmapped_area Method that searches an available linear address interval in the process address space void (*)( ) unmap_area Method invoked when releasing a linear address interval unsigned long mmap_base Identifies the linear address of the first allocated anonymous memory region or file memory mapping (see the section \"Program Segments and Process Memory Regions\" in Chapter 20) unsigned long free_area_cache Address from which the kernel will look for a free interval of linear addresses in the process address space pgd_t * pgd Pointer to the Page Global Directory \u5173\u4e8ePage Global Directory\uff0c\u53c2\u89c1Section 2.4. Paging in Hardware\u3001Section 2.5. Paging in Linux atomic_t mm_users Secondary usage counter atomic_t mm_count Main usage counter All memory descriptors are stored in a doubly linked list. Each descriptor stores the address of the adjacent list items in the mmlist field. The first element of the list is the mmlist field of init_mm , the memory descriptor used by process 0 in the initialization phase. The list is protected against concurrent accesses in multiprocessor systems by the mmlist_lock spin lock. The mm_users field stores the number of lightweight processes that share the mm_struct data structure (see the section \"The clone( ) , fork( ) , and vfork( ) System Calls\" in Chapter 3). The mm_count field is the main usage counter of the memory descriptor; all \"users\" in mm_users count as one unit in mm_count . Every time the mm_count field is decreased, the kernel checks whether it becomes zero; if so, the memory descriptor is deallocated because it is no longer in use.","title":"9.2-The-Memory-Descriptor"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-9-Process-Address-Space/9.2-The-Memory-Descriptor/#92#the#memory#descriptor","text":"All information related to the process address space is included in an object called the memory descriptor of type mm_struct . This object is referenced by the mm field of the process descriptor . The fields of a memory descriptor are listed in Table 9-2. Table 9-2. The fields of the memory descriptor Type Field Description \u6ce8\u91ca struct vm_area_struct * mmap Pointer to the head of the list of memory region objects \u53c2\u89c1chapter 9.3. Memory Regions struct rb_root mm_rb Pointer to the root of the red-black tree of memory region objects struct vm_area_struct * mmap_cache Pointer to the last referenced memory region object unsigned long (*)( ) get_unmapped_area Method that searches an available linear address interval in the process address space void (*)( ) unmap_area Method invoked when releasing a linear address interval unsigned long mmap_base Identifies the linear address of the first allocated anonymous memory region or file memory mapping (see the section \"Program Segments and Process Memory Regions\" in Chapter 20) unsigned long free_area_cache Address from which the kernel will look for a free interval of linear addresses in the process address space pgd_t * pgd Pointer to the Page Global Directory \u5173\u4e8ePage Global Directory\uff0c\u53c2\u89c1Section 2.4. Paging in Hardware\u3001Section 2.5. Paging in Linux atomic_t mm_users Secondary usage counter atomic_t mm_count Main usage counter All memory descriptors are stored in a doubly linked list. Each descriptor stores the address of the adjacent list items in the mmlist field. The first element of the list is the mmlist field of init_mm , the memory descriptor used by process 0 in the initialization phase. The list is protected against concurrent accesses in multiprocessor systems by the mmlist_lock spin lock. The mm_users field stores the number of lightweight processes that share the mm_struct data structure (see the section \"The clone( ) , fork( ) , and vfork( ) System Calls\" in Chapter 3). The mm_count field is the main usage counter of the memory descriptor; all \"users\" in mm_users count as one unit in mm_count . Every time the mm_count field is decreased, the kernel checks whether it becomes zero; if so, the memory descriptor is deallocated because it is no longer in use.","title":"9.2. The Memory Descriptor"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-9-Process-Address-Space/Chapter-9-Process-Address-Space/","text":"Chapter 9. Process Address Space As seen in the previous chapter, a kernel function gets dynamic memory in a fairly straightforward manner by invoking one of a variety of functions: __get_free_pages( ) or alloc_pages( ) to get pages from the zoned page frame allocator, kmem_cache_alloc( ) or kmalloc( ) to use the slab allocator for specialized or general-purpose objects, and vmalloc( ) or vmalloc_32( ) to get a noncontiguous memory area. If the request can be satisfied, each of these functions returns a page descriptor address or a linear address identifying the beginning of the allocated dynamic memory area. NOTE: \u666e\u901a\u7684process\u662f\u4e0d\u4f1a\u63a5\u89e6\u5230page descriptor\u7684 These simple approaches work for two reasons: The kernel is the highest-priority component of the operating system. If a kernel function makes a request for dynamic memory , it must have a valid reason to issue that request, and there is no point in trying to defer it. The kernel trusts itself. All kernel functions are assumed to be error-free, so the kernel does not need to insert any protection against programming errors. When allocating memory to User Mode processes, the situation is entirely different: Process requests for dynamic memory are considered non-urgent. When a process's executable file is loaded, for instance, it is unlikely that the process will address all the pages of code in the near future. Similarly, when a process invokes malloc( ) to get additional dynamic memory, it doesn't mean the process will soon access all the additional memory obtained. Thus, as a general rule, the kernel tries to defer allocating dynamic memory to User Mode processes. Because user programs cannot be trusted, the kernel must be prepared to catch all addressing errors caused by processes in User Mode. As this chapter describes, the kernel succeeds in deferring the allocation of dynamic memory to processes by using a new kind of resource. When a User Mode process asks for dynamic memory , it doesn't get additional page frames ; instead, it gets the right to use a new range of linear addresses , which become part of its address space . This interval is called a \" memory region .\" In the next section, we discuss how the process views dynamic memory . We then describe the basic components of the process address space in the section \"Memory Regions.\" Next, we examine in detail the role played by the Page Fault exception handler in deferring the allocation of page frames to processes and illustrate how the kernel creates and deletes whole process address spaces . Last, we discuss the APIs and system calls related to address space management .","title":"Chapter-9-Process-Address-Space"},{"location":"Kernel/Book-Understanding-the-Linux-Kernel/Chapter-9-Process-Address-Space/Chapter-9-Process-Address-Space/#chapter#9#process#address#space","text":"As seen in the previous chapter, a kernel function gets dynamic memory in a fairly straightforward manner by invoking one of a variety of functions: __get_free_pages( ) or alloc_pages( ) to get pages from the zoned page frame allocator, kmem_cache_alloc( ) or kmalloc( ) to use the slab allocator for specialized or general-purpose objects, and vmalloc( ) or vmalloc_32( ) to get a noncontiguous memory area. If the request can be satisfied, each of these functions returns a page descriptor address or a linear address identifying the beginning of the allocated dynamic memory area. NOTE: \u666e\u901a\u7684process\u662f\u4e0d\u4f1a\u63a5\u89e6\u5230page descriptor\u7684 These simple approaches work for two reasons: The kernel is the highest-priority component of the operating system. If a kernel function makes a request for dynamic memory , it must have a valid reason to issue that request, and there is no point in trying to defer it. The kernel trusts itself. All kernel functions are assumed to be error-free, so the kernel does not need to insert any protection against programming errors. When allocating memory to User Mode processes, the situation is entirely different: Process requests for dynamic memory are considered non-urgent. When a process's executable file is loaded, for instance, it is unlikely that the process will address all the pages of code in the near future. Similarly, when a process invokes malloc( ) to get additional dynamic memory, it doesn't mean the process will soon access all the additional memory obtained. Thus, as a general rule, the kernel tries to defer allocating dynamic memory to User Mode processes. Because user programs cannot be trusted, the kernel must be prepared to catch all addressing errors caused by processes in User Mode. As this chapter describes, the kernel succeeds in deferring the allocation of dynamic memory to processes by using a new kind of resource. When a User Mode process asks for dynamic memory , it doesn't get additional page frames ; instead, it gets the right to use a new range of linear addresses , which become part of its address space . This interval is called a \" memory region .\" In the next section, we discuss how the process views dynamic memory . We then describe the basic components of the process address space in the section \"Memory Regions.\" Next, we examine in detail the role played by the Page Fault exception handler in deferring the allocation of page frames to processes and illustrate how the kernel creates and deletes whole process address spaces . Last, we discuss the APIs and system calls related to address space management .","title":"Chapter 9. Process Address Space"},{"location":"Kernel/Guide/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u7684\u5185\u5bb9\u662f\u6211\u57fa\u4e8e\u9605\u8bfb\u672c\u4e66\uff08\u90e8\u5206\u7ae0\u8282\uff09\u540e\u6240\u603b\u7ed3\u7684\uff0c\u5bf9\u4e00\u4e9b\u4e13\u9898\u8fdb\u884c\u4e86\u603b\u7ed3\uff0c\u68b3\u7406\u4e86\u8109\u7edc\u3002 \u5728\u6587\u7ae0 Architecture-of-computing-system \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u603b\u7ed3\u4e86OS\u7684\u4e24\u4e2aobjective\uff1a The operating system must fulfill two main objectives: Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform. Provide an execution environment to the applications that run on the computer system (the so-called user programs). \u8fd9\u4e24\u4e2aobjective\uff08\u5176\u5b9e\u5c31\u662fOS\u7684\u4f5c\u7528\u3001\u4f7f\u547d\uff09\u76f8\u5f53\u4e8e\u4e24\u6761\u7ebf\uff0c\u540e\u9762\u6211\u4eec\u5c06\u6cbf\u7740\u8fd9\u4e24\u6761\u7ebf\u6df1\u5165\u5bf9Linux OS\u7684\u5b66\u4e60\u3002 \u672c\u7ae0\u4f1a\u5bf9\u7b2c\u4e00\u6761\u7ebf\u201cInteract with the hardware components\u201d\u8fdb\u884c\u603b\u7ed3\u3002 \u672c\u7ae0\u4f1a\u5bf9Linux OS\u7684 multitasking \u8fdb\u884c\u603b\u7ed3\uff0c\u8fd9\u662f\u548c\u7b2c\u4e8c\u6761\u7ebf\u5bc6\u5207\u76f8\u5173\u7684\u3002 \u672c\u7ae0\u4f1a\u7ed9\u51fa\u9605\u8bfbLinux OS kernel\u6e90\u7801\u7684\u6307\u5bfc\uff0c\u5e76\u5bf9Linux OS kernel\u6e90\u7801\u4e2d\u7684\u4e00\u4e9b\u91cd\u8981\u7684data structure\u8fdb\u884c\u603b\u7ed3\u3002 \u9605\u8bfb\u672c\u4e66\uff0c\u9700\u8981\u4e00\u4e9bhardware\u7684\u57fa\u7840\u77e5\u8bc6\uff0c\u53c2\u89c1\u6211\u7684\u53e6\u5916\u4e00\u4e2a\u9879\u76ee Hardware \u3002 \u603b\u7684\u6765\u8bf4\uff0c\u672c\u7ae0\u65e8\u5728\u5e2e\u52a9\u81ea\u5df1\u548c\u8bfb\u8005\u66f4\u597d\u5730\u7406\u89e3\u672c\u4e66\u7684\u5185\u5bb9\u3002","title":"Introduction"},{"location":"Kernel/Guide/#_1","text":"\u672c\u7ae0\u7684\u5185\u5bb9\u662f\u6211\u57fa\u4e8e\u9605\u8bfb\u672c\u4e66\uff08\u90e8\u5206\u7ae0\u8282\uff09\u540e\u6240\u603b\u7ed3\u7684\uff0c\u5bf9\u4e00\u4e9b\u4e13\u9898\u8fdb\u884c\u4e86\u603b\u7ed3\uff0c\u68b3\u7406\u4e86\u8109\u7edc\u3002 \u5728\u6587\u7ae0 Architecture-of-computing-system \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u603b\u7ed3\u4e86OS\u7684\u4e24\u4e2aobjective\uff1a The operating system must fulfill two main objectives: Interact with the hardware components, servicing all low-level programmable elements included in the hardware platform. Provide an execution environment to the applications that run on the computer system (the so-called user programs). \u8fd9\u4e24\u4e2aobjective\uff08\u5176\u5b9e\u5c31\u662fOS\u7684\u4f5c\u7528\u3001\u4f7f\u547d\uff09\u76f8\u5f53\u4e8e\u4e24\u6761\u7ebf\uff0c\u540e\u9762\u6211\u4eec\u5c06\u6cbf\u7740\u8fd9\u4e24\u6761\u7ebf\u6df1\u5165\u5bf9Linux OS\u7684\u5b66\u4e60\u3002 \u672c\u7ae0\u4f1a\u5bf9\u7b2c\u4e00\u6761\u7ebf\u201cInteract with the hardware components\u201d\u8fdb\u884c\u603b\u7ed3\u3002 \u672c\u7ae0\u4f1a\u5bf9Linux OS\u7684 multitasking \u8fdb\u884c\u603b\u7ed3\uff0c\u8fd9\u662f\u548c\u7b2c\u4e8c\u6761\u7ebf\u5bc6\u5207\u76f8\u5173\u7684\u3002 \u672c\u7ae0\u4f1a\u7ed9\u51fa\u9605\u8bfbLinux OS kernel\u6e90\u7801\u7684\u6307\u5bfc\uff0c\u5e76\u5bf9Linux OS kernel\u6e90\u7801\u4e2d\u7684\u4e00\u4e9b\u91cd\u8981\u7684data structure\u8fdb\u884c\u603b\u7ed3\u3002 \u9605\u8bfb\u672c\u4e66\uff0c\u9700\u8981\u4e00\u4e9bhardware\u7684\u57fa\u7840\u77e5\u8bc6\uff0c\u53c2\u89c1\u6211\u7684\u53e6\u5916\u4e00\u4e2a\u9879\u76ee Hardware \u3002 \u603b\u7684\u6765\u8bf4\uff0c\u672c\u7ae0\u65e8\u5728\u5e2e\u52a9\u81ea\u5df1\u548c\u8bfb\u8005\u66f4\u597d\u5730\u7406\u89e3\u672c\u4e66\u7684\u5185\u5bb9\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Kernel/Guide/Debug/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u4ecb\u7ecdLinux kernel\u548cdebug\u76f8\u5173\u7684\u5185\u5bb9\u3002\u4e0e\u672c\u7ae0\u5185\u5bb9\u76f8\u5173\u7684\u6709: Shell-and-tools\\Tools\\Debug Programming\\Process\\Tools TOC \u672c\u7ae0\u4e3b\u8981\u4ee5wikipedia Linux kernel # Debugging \u4e3aTOC\u6765\u8fdb\u884c\u6574\u7406\u3002","title":"Introduction"},{"location":"Kernel/Guide/Debug/#_1","text":"\u672c\u7ae0\u4ecb\u7ecdLinux kernel\u548cdebug\u76f8\u5173\u7684\u5185\u5bb9\u3002\u4e0e\u672c\u7ae0\u5185\u5bb9\u76f8\u5173\u7684\u6709: Shell-and-tools\\Tools\\Debug Programming\\Process\\Tools","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Kernel/Guide/Debug/#toc","text":"\u672c\u7ae0\u4e3b\u8981\u4ee5wikipedia Linux kernel # Debugging \u4e3aTOC\u6765\u8fdb\u884c\u6574\u7406\u3002","title":"TOC"},{"location":"Kernel/Guide/Debug/oops/","text":"oops wikipedia Linux kernel oops NOTE: \u5176\u5b9e\u5c31\u662f\u5f02\u5e38\u884c\u4e3a","title":"oops"},{"location":"Kernel/Guide/Debug/oops/#oops","text":"","title":"oops"},{"location":"Kernel/Guide/Debug/oops/#wikipedia#linux#kernel#oops","text":"NOTE: \u5176\u5b9e\u5c31\u662f\u5f02\u5e38\u884c\u4e3a","title":"wikipedia Linux kernel oops"},{"location":"Kernel/Guide/Debug/System.map/","text":"System.map \u662f\u5728\u9605\u8bfbdocstore 21.7. Hanging Processes: Detection and Diagnostics \u65f6\uff0c\u5176\u4e2d\u63d0\u53ca\u4e86 kernel symbol table \u3001 wait channel \uff0c\u4ece\u800c\u8ba9\u6211\u53d1\u73b0\u4e86System.map\u7684\u3002 wikipedia System.map Filesystem location as /boot/System.map-$(uname -r) NOTE: \u4e0b\u9762\u662f\u6211\u7684\u7cfb\u7edf\u4e2d\uff0csystem.map\u6587\u4ef6\u7684\u4f4d\u7f6e\uff0c\u663e\u7136\u5b83\u662f\u7b26\u5408\u4e0a\u8ff0\u6a21\u5f0f\u7684\uff1a [ust@localhost ~]$ ls /boot/System.map-3.10.0-327.el7.x86_64 /boot/System.map-3.10.0-327.el7.x86_64 [ust@localhost ~]$ uname -r 3.10.0-327.el7.x86_64 [ust@localhost ~]$ kernelnewbies System.map \"System.map\". is a file (produced via nm) containing symbol names and addresses of the linux kernel binary, vmlinux. Its primary use is in debugging. Application: ksymoops If a kernel \"oops\" message appears, the utility ksymoops can be used to decode the message into something useful for developers. Application: WCHAN field of ps ps l uses System.map to determine the WCHAN field (you can specify a map file with the PS_SYSTEM_MAP environment variable). rlworkman The system.map File","title":"Introduction"},{"location":"Kernel/Guide/Debug/System.map/#systemmap","text":"\u662f\u5728\u9605\u8bfbdocstore 21.7. Hanging Processes: Detection and Diagnostics \u65f6\uff0c\u5176\u4e2d\u63d0\u53ca\u4e86 kernel symbol table \u3001 wait channel \uff0c\u4ece\u800c\u8ba9\u6211\u53d1\u73b0\u4e86System.map\u7684\u3002","title":"System.map"},{"location":"Kernel/Guide/Debug/System.map/#wikipedia#systemmap","text":"","title":"wikipedia System.map"},{"location":"Kernel/Guide/Debug/System.map/#filesystem#location","text":"as /boot/System.map-$(uname -r) NOTE: \u4e0b\u9762\u662f\u6211\u7684\u7cfb\u7edf\u4e2d\uff0csystem.map\u6587\u4ef6\u7684\u4f4d\u7f6e\uff0c\u663e\u7136\u5b83\u662f\u7b26\u5408\u4e0a\u8ff0\u6a21\u5f0f\u7684\uff1a [ust@localhost ~]$ ls /boot/System.map-3.10.0-327.el7.x86_64 /boot/System.map-3.10.0-327.el7.x86_64 [ust@localhost ~]$ uname -r 3.10.0-327.el7.x86_64 [ust@localhost ~]$","title":"Filesystem location"},{"location":"Kernel/Guide/Debug/System.map/#kernelnewbies#systemmap","text":"\"System.map\". is a file (produced via nm) containing symbol names and addresses of the linux kernel binary, vmlinux. Its primary use is in debugging.","title":"kernelnewbies System.map"},{"location":"Kernel/Guide/Debug/System.map/#application#ksymoops","text":"If a kernel \"oops\" message appears, the utility ksymoops can be used to decode the message into something useful for developers.","title":"Application: ksymoops"},{"location":"Kernel/Guide/Debug/System.map/#application#wchan#field#of#ps","text":"ps l uses System.map to determine the WCHAN field (you can specify a map file with the PS_SYSTEM_MAP environment variable).","title":"Application: WCHAN field of ps"},{"location":"Kernel/Guide/Debug/System.map/#rlworkman#the#systemmap#file","text":"","title":"rlworkman The system.map File"},{"location":"Kernel/Guide/Interaction-with-hardware/Kernel-control-path-and-reentrant-kernel/","text":"Kernel control path and reentrant kernel \u672c\u8282\u7684\u5185\u5bb9\u4e3b\u8981\u6e90\u81eachapter 1.6.3. Reentrant Kernels \u5728\u524d\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u5efa\u7acb\u8d77\u6765\u4e86Linux OS kernel\u7684\u8fd0\u884c\u6a21\u578b\u4e86\uff0c\u5373OS kernel\u662fevent-driven\u7684\uff0c\u90a3\u73b0\u5728\u8ba9\u6211\u4eec\u7ad9\u5728\u5185\u6838\u8bbe\u8ba1\u8005\u7684\u89d2\u5ea6\u6765\u601d\u8003\u5982\u4f55\u6765\u5b9e\u73b0\uff1f \u5185\u6838\u7684\u8bbe\u8ba1\u8005\u4f1a\u8ffd\u6c42\u7cfb\u7edf\u80fd\u591f\u5feb\u901f\u5730\u54cd\u5e94\u7528\u6237\u7684\u8bf7\u6c42\uff0c\u7cfb\u7edf\u80fd\u591f\u9ad8\u6548\u5730\u8fd0\u884c\uff0c\u7cfb\u7edf\u9700\u8981\u5c3d\u53ef\u80fd\u7684\u538b\u7f29CPU\u7684\u7a7a\u95f2\u65f6\u95f4\uff0c\u8ba9CPU\u66f4\u591a\u5730\u8fdb\u884c\u8fd0\u8f6c\u3002\u6240\u4ee5\uff0c\u5b83\u5c31\u9700\u8981\u5728\u67d0\u4e2asystem call\u6682\u65f6\u65e0\u6cd5\u5b8c\u6210\u7684\u60c5\u51b5\u4e0b\uff0c\u5c06\u5b83\u6302\u8d77\u5e76\u8f6c\u5411\u53e6\u5916\u4e00\u4e2asystem call\uff1b\u5f53\u8be5system call\u7684\u6267\u884c\u6761\u4ef6\u6ee1\u8db3\u7684\u65f6\u5019\u518d\u5c06\u5b83\u91cd\u542f\uff1b\u53e6\u5916\uff0ckernel\u8fd8\u9700\u8981\u5904\u7406\u65e0\u6cd5\u9884\u6d4b\u4f55\u65f6\u4f1a\u51fa\u73b0\u7684\u5404\u79cdinterrupt\u548cexception\uff0c\u4e00\u65e6\u51fa\u73b0\uff0c\u5219\u9700\u8981\u8f6c\u53bb\u6267\u884c\u76f8\u5e94\u7684interrupt handler\uff0c\u5f53\u8fd9\u4e2ainterrupt handler\u6267\u884c\u5b8c\u6210\u540e\uff0c\u518d\u91cd\u542f\u4e4b\u524d\u88ab\u4e2d\u65ad\u7684\u6d41\u7a0b\uff08\u662f\u5426\u4f1a\u91cd\u542f\u5176\u5b9e\u662f\u4e00\u4e2a\u6bd4\u8f83\u590d\u6742\u7684\u95ee\u9898\uff0c\u540e\u9762\u4f1a\u5bf9\u6b64\u8fdb\u884c\u4e13\u95e8\u5206\u6790\uff09\u3002\u8fd9\u79cd\u80fd\u529b\u5c31\u662fchapter 1.6.3. Reentrant Kernels\u6240\u8ff0\u7684***reentrant***\u3002\u663e\u7136\u8fd9\u79cd\u8bbe\u8ba1\u80fd\u591f\u6700\u5927\u7a0b\u5ea6\u5730\u4fdd\u8bc1\u7cfb\u7edf\u7684\u9ad8\u6548\u3002 Kernel control path \u4e3a\u4e86\u4fbf\u4e8e\u63cf\u8ff0reentrant kernel\u7684\u5b9e\u73b0\u601d\u8def\uff0c\u5728chapter 1.6.3. Reentrant Kernels\u4e2d\u4f5c\u8005\u63d0\u51fa\u4e86*kernel control path*\u7684\u6982\u5ff5\uff0c\u5b83\u8868\u793a\u4e86kernel\u6240\u6709\u7684\u53ef\u80fd\u7684activity\uff0c\u5728 Linux-OS-kernel-is-event-driven \u4e2d\u6211\u4eec\u5df2\u7ecf\u603b\u7ed3\u4e86\uff0ckernel\u7684activity\u53ef\u80fd\u6709\u5982\u4e0b\u51e0\u79cd\u60c5\u51b5\u89e6\u53d1\uff1a system call interrupt and exception(\u5728Chapter 4. Interrupts and Exceptions\u533a\u5206\u8fd9\u4e24\u8005) \u4e5f\u5c31\u662f\u8bf4\uff1a \u5f53process\u5411kernel\u8bf7\u6c42\u4e00\u4e2asystem call\uff0c\u6b64\u65f6kernel\u4e2d\u5c31\u6267\u884c\u6b64system call\uff0c\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u7406\u89e3\u7684\u8bdd\uff0c\u5219\u662fkernel\u521b\u5efa\u4e86\u4e00\u4e2a\u6267\u884c\u8fd9\u4e2asystem call\u7684kernel control path\uff1b \u5f53\u4ea7\u751finterrupt\u6216exception\uff0c\u6b64\u65f6kernel\u8f6c\u53bb\u6267\u884c\u5b83\u4eec\u5bf9\u5e94\u7684handler\uff0c\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u7406\u89e3\u7684\u8bdd\uff0c\u53ef\u4ee5\u8ba4\u4e3akernel\u521b\u5efa\u4e86\u4e00\u4e2a\u6267\u884c\u8fd9\u4e2ahandler\u7684kernel control path\uff1b \u4e3a\u4ec0\u4e48\u8981\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u63cf\u8ff0\u5462\uff1f\u56e0\u4e3a\u6211\u4eec\u77e5\u9053\uff0coperating system\u7684kernel\u7684\u6267\u884c\u60c5\u51b5\u662f\u975e\u5e38\u590d\u6742\u7684\uff0c\u5b83\u9700\u8981\u540c\u65f6\u5904\u7406\u975e\u5e38\u591a\u7684\u4e8b\u60c5\uff0c\u6bd4\u5982process\u8bf7\u6c42\u7684system call\uff0c\u5728\u6b64\u8fc7\u7a0b\u4e2d\u662f\u4f1a\u4f34\u968f\u4e2d\u968f\u65f6\u53ef\u80fd\u53d1\u751f\u7684interrupt\u548cexception\u7684\u3002\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u94fa\u57ab\u4e86\uff0ckernel\u4e3a\u4e86\u4fdd\u6301\u9ad8\u6548\uff0c\u53ef\u80fd\u9700\u8981\u6302\u8d77\u6b63\u5728\u6267\u884c\u7684\u6d41\u7a0b\u8f6c\u53bb\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u6d41\u7a0b\uff0c\u800c\u540e\u5728\u91cd\u542f\u4e4b\u524d\u6302\u8d77\u7684\u6d41\u7a0b\u3002\u6b64\u5904\u6240\u8c13\u7684\u6d41\u7a0b\uff0c\u6211\u4eec\u4f7f\u7528\u66f4\u52a0\u4e13\u4e1a\u7684\u672f\u8bed\u5c31\u662fkernel control path\u3002\u663e\u7136\u4e0efunction\u76f8\u6bd4\uff0ckernel control path\u8574\u542b\u7740\u66f4\u52a0\u4e30\u5bcc\u7684\uff0c\u66f4\u52a0\u7b26\u5408kernel\u8c03\u5ea6\u60c5\u51b5\u7684\u5185\u6db5\uff0c\u6bd4\u5982\u5b83\u80fd\u591f\u8868\u793akernel\u7684suspend\uff08\u6302\u8d77\uff09\uff0cresume\uff08\u91cd\u542f\uff09\uff0c\u80fd\u591f\u8868\u793a\u591a\u4e2acontrol path\u7684interleave\uff08\u4ea4\u9519\u8fd0\u884c\uff09\u3002\u8fd9\u79cd\u901a\u8fc7\u521b\u9020\u65b0\u7684\u6982\u5ff5\u6765\u4f7f\u8868\u8ff0\u66f4\u52a0\u4fbf\u5229\u7684\u505a\u6cd5\u662f\u5728\u5404\u79cd\u5b66\u79d1\u975e\u5e38\u666e\u904d\u7684\u3002 \u8fd9\u79cd\u8bbe\u8ba1\u4e5f\u4e0d\u53ef\u907f\u514d\u5730\u5bfc\u81f4\u7cfb\u7edf\u7684\u590d\u6742\uff0c\u6b63\u5982\u5728chapter 1.6.3. Reentrant Kernels\u540e\u9762\u6240\u8ff0\u7684\uff0c \u7cfb\u7edf\u662f\u5728\u591a\u4e2a*kernel control path*\u4e2d\u4ea4\u9519\u8fd0\u884c\u7684\u3002\u8fd9\u79cd\u8bbe\u8ba1\u4f1a\u6d3e\u751f\u51fa\u4e00\u7cfb\u5217\u7684\u95ee\u9898\uff0c\u6bd4\u5982\u5c06\u57281.6.5. Synchronization and Critical Regions\u4e2d\u4ecb\u7ecd\u7684race condition\uff0c\u6240\u4ee5\u5b83\u5bf9kernel\u7684\u5b9e\u73b0\u63d0\u51fa\u4e86\u66f4\u9ad8\u7684\u8981\u6c42\u3002\u5f53\u7136\u53ef\u4ee5\u9884\u671f\u7684\u662f\uff0c\u7cfb\u7edf\u662f\u5728\u8fd9\u6837\u7684\u4ea4\u9519\u4e2d\u4e0d\u65ad\u5411\u524d\u8fdb\u7684\u3002 \u5982\u4f55\u6765\u5b9e\u73b0reentrant kernel\u5462\uff1f\u8fd9\u662f\u4e00\u4e2a\u9700\u8981\u7cfb\u7edf\u5730\u8fdb\u884c\u8bbe\u8ba1\u624d\u80fd\u591f\u89e3\u51b3\u7684\u95ee\u9898\uff0c\u4e0b\u9762\u603b\u7ed3\u4e86\u548c\u8fd9\u4e2a\u95ee\u9898\u76f8\u5173\u7684\u4e00\u4e9b\u7ae0\u8282\uff1a 1.6.4. Process Address Space Kernel control path refers to its own private kernel stack. 1.6.5. Synchronization and Critical Regions \u63cf\u8ff0\u4e86kernel control path\u7684Synchronization See also Kernel Control Path Definition","title":"Kernel-control-path-and-reentrant-kernel"},{"location":"Kernel/Guide/Interaction-with-hardware/Kernel-control-path-and-reentrant-kernel/#kernel#control#path#and#reentrant#kernel","text":"\u672c\u8282\u7684\u5185\u5bb9\u4e3b\u8981\u6e90\u81eachapter 1.6.3. Reentrant Kernels \u5728\u524d\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u5efa\u7acb\u8d77\u6765\u4e86Linux OS kernel\u7684\u8fd0\u884c\u6a21\u578b\u4e86\uff0c\u5373OS kernel\u662fevent-driven\u7684\uff0c\u90a3\u73b0\u5728\u8ba9\u6211\u4eec\u7ad9\u5728\u5185\u6838\u8bbe\u8ba1\u8005\u7684\u89d2\u5ea6\u6765\u601d\u8003\u5982\u4f55\u6765\u5b9e\u73b0\uff1f \u5185\u6838\u7684\u8bbe\u8ba1\u8005\u4f1a\u8ffd\u6c42\u7cfb\u7edf\u80fd\u591f\u5feb\u901f\u5730\u54cd\u5e94\u7528\u6237\u7684\u8bf7\u6c42\uff0c\u7cfb\u7edf\u80fd\u591f\u9ad8\u6548\u5730\u8fd0\u884c\uff0c\u7cfb\u7edf\u9700\u8981\u5c3d\u53ef\u80fd\u7684\u538b\u7f29CPU\u7684\u7a7a\u95f2\u65f6\u95f4\uff0c\u8ba9CPU\u66f4\u591a\u5730\u8fdb\u884c\u8fd0\u8f6c\u3002\u6240\u4ee5\uff0c\u5b83\u5c31\u9700\u8981\u5728\u67d0\u4e2asystem call\u6682\u65f6\u65e0\u6cd5\u5b8c\u6210\u7684\u60c5\u51b5\u4e0b\uff0c\u5c06\u5b83\u6302\u8d77\u5e76\u8f6c\u5411\u53e6\u5916\u4e00\u4e2asystem call\uff1b\u5f53\u8be5system call\u7684\u6267\u884c\u6761\u4ef6\u6ee1\u8db3\u7684\u65f6\u5019\u518d\u5c06\u5b83\u91cd\u542f\uff1b\u53e6\u5916\uff0ckernel\u8fd8\u9700\u8981\u5904\u7406\u65e0\u6cd5\u9884\u6d4b\u4f55\u65f6\u4f1a\u51fa\u73b0\u7684\u5404\u79cdinterrupt\u548cexception\uff0c\u4e00\u65e6\u51fa\u73b0\uff0c\u5219\u9700\u8981\u8f6c\u53bb\u6267\u884c\u76f8\u5e94\u7684interrupt handler\uff0c\u5f53\u8fd9\u4e2ainterrupt handler\u6267\u884c\u5b8c\u6210\u540e\uff0c\u518d\u91cd\u542f\u4e4b\u524d\u88ab\u4e2d\u65ad\u7684\u6d41\u7a0b\uff08\u662f\u5426\u4f1a\u91cd\u542f\u5176\u5b9e\u662f\u4e00\u4e2a\u6bd4\u8f83\u590d\u6742\u7684\u95ee\u9898\uff0c\u540e\u9762\u4f1a\u5bf9\u6b64\u8fdb\u884c\u4e13\u95e8\u5206\u6790\uff09\u3002\u8fd9\u79cd\u80fd\u529b\u5c31\u662fchapter 1.6.3. Reentrant Kernels\u6240\u8ff0\u7684***reentrant***\u3002\u663e\u7136\u8fd9\u79cd\u8bbe\u8ba1\u80fd\u591f\u6700\u5927\u7a0b\u5ea6\u5730\u4fdd\u8bc1\u7cfb\u7edf\u7684\u9ad8\u6548\u3002","title":"Kernel control path and reentrant kernel"},{"location":"Kernel/Guide/Interaction-with-hardware/Kernel-control-path-and-reentrant-kernel/#kernel#control#path","text":"\u4e3a\u4e86\u4fbf\u4e8e\u63cf\u8ff0reentrant kernel\u7684\u5b9e\u73b0\u601d\u8def\uff0c\u5728chapter 1.6.3. Reentrant Kernels\u4e2d\u4f5c\u8005\u63d0\u51fa\u4e86*kernel control path*\u7684\u6982\u5ff5\uff0c\u5b83\u8868\u793a\u4e86kernel\u6240\u6709\u7684\u53ef\u80fd\u7684activity\uff0c\u5728 Linux-OS-kernel-is-event-driven \u4e2d\u6211\u4eec\u5df2\u7ecf\u603b\u7ed3\u4e86\uff0ckernel\u7684activity\u53ef\u80fd\u6709\u5982\u4e0b\u51e0\u79cd\u60c5\u51b5\u89e6\u53d1\uff1a system call interrupt and exception(\u5728Chapter 4. Interrupts and Exceptions\u533a\u5206\u8fd9\u4e24\u8005) \u4e5f\u5c31\u662f\u8bf4\uff1a \u5f53process\u5411kernel\u8bf7\u6c42\u4e00\u4e2asystem call\uff0c\u6b64\u65f6kernel\u4e2d\u5c31\u6267\u884c\u6b64system call\uff0c\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u7406\u89e3\u7684\u8bdd\uff0c\u5219\u662fkernel\u521b\u5efa\u4e86\u4e00\u4e2a\u6267\u884c\u8fd9\u4e2asystem call\u7684kernel control path\uff1b \u5f53\u4ea7\u751finterrupt\u6216exception\uff0c\u6b64\u65f6kernel\u8f6c\u53bb\u6267\u884c\u5b83\u4eec\u5bf9\u5e94\u7684handler\uff0c\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u7406\u89e3\u7684\u8bdd\uff0c\u53ef\u4ee5\u8ba4\u4e3akernel\u521b\u5efa\u4e86\u4e00\u4e2a\u6267\u884c\u8fd9\u4e2ahandler\u7684kernel control path\uff1b \u4e3a\u4ec0\u4e48\u8981\u4f7f\u7528*kernel control path*\u6982\u5ff5\u6765\u8fdb\u884c\u63cf\u8ff0\u5462\uff1f\u56e0\u4e3a\u6211\u4eec\u77e5\u9053\uff0coperating system\u7684kernel\u7684\u6267\u884c\u60c5\u51b5\u662f\u975e\u5e38\u590d\u6742\u7684\uff0c\u5b83\u9700\u8981\u540c\u65f6\u5904\u7406\u975e\u5e38\u591a\u7684\u4e8b\u60c5\uff0c\u6bd4\u5982process\u8bf7\u6c42\u7684system call\uff0c\u5728\u6b64\u8fc7\u7a0b\u4e2d\u662f\u4f1a\u4f34\u968f\u4e2d\u968f\u65f6\u53ef\u80fd\u53d1\u751f\u7684interrupt\u548cexception\u7684\u3002\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u94fa\u57ab\u4e86\uff0ckernel\u4e3a\u4e86\u4fdd\u6301\u9ad8\u6548\uff0c\u53ef\u80fd\u9700\u8981\u6302\u8d77\u6b63\u5728\u6267\u884c\u7684\u6d41\u7a0b\u8f6c\u53bb\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u6d41\u7a0b\uff0c\u800c\u540e\u5728\u91cd\u542f\u4e4b\u524d\u6302\u8d77\u7684\u6d41\u7a0b\u3002\u6b64\u5904\u6240\u8c13\u7684\u6d41\u7a0b\uff0c\u6211\u4eec\u4f7f\u7528\u66f4\u52a0\u4e13\u4e1a\u7684\u672f\u8bed\u5c31\u662fkernel control path\u3002\u663e\u7136\u4e0efunction\u76f8\u6bd4\uff0ckernel control path\u8574\u542b\u7740\u66f4\u52a0\u4e30\u5bcc\u7684\uff0c\u66f4\u52a0\u7b26\u5408kernel\u8c03\u5ea6\u60c5\u51b5\u7684\u5185\u6db5\uff0c\u6bd4\u5982\u5b83\u80fd\u591f\u8868\u793akernel\u7684suspend\uff08\u6302\u8d77\uff09\uff0cresume\uff08\u91cd\u542f\uff09\uff0c\u80fd\u591f\u8868\u793a\u591a\u4e2acontrol path\u7684interleave\uff08\u4ea4\u9519\u8fd0\u884c\uff09\u3002\u8fd9\u79cd\u901a\u8fc7\u521b\u9020\u65b0\u7684\u6982\u5ff5\u6765\u4f7f\u8868\u8ff0\u66f4\u52a0\u4fbf\u5229\u7684\u505a\u6cd5\u662f\u5728\u5404\u79cd\u5b66\u79d1\u975e\u5e38\u666e\u904d\u7684\u3002 \u8fd9\u79cd\u8bbe\u8ba1\u4e5f\u4e0d\u53ef\u907f\u514d\u5730\u5bfc\u81f4\u7cfb\u7edf\u7684\u590d\u6742\uff0c\u6b63\u5982\u5728chapter 1.6.3. Reentrant Kernels\u540e\u9762\u6240\u8ff0\u7684\uff0c \u7cfb\u7edf\u662f\u5728\u591a\u4e2a*kernel control path*\u4e2d\u4ea4\u9519\u8fd0\u884c\u7684\u3002\u8fd9\u79cd\u8bbe\u8ba1\u4f1a\u6d3e\u751f\u51fa\u4e00\u7cfb\u5217\u7684\u95ee\u9898\uff0c\u6bd4\u5982\u5c06\u57281.6.5. Synchronization and Critical Regions\u4e2d\u4ecb\u7ecd\u7684race condition\uff0c\u6240\u4ee5\u5b83\u5bf9kernel\u7684\u5b9e\u73b0\u63d0\u51fa\u4e86\u66f4\u9ad8\u7684\u8981\u6c42\u3002\u5f53\u7136\u53ef\u4ee5\u9884\u671f\u7684\u662f\uff0c\u7cfb\u7edf\u662f\u5728\u8fd9\u6837\u7684\u4ea4\u9519\u4e2d\u4e0d\u65ad\u5411\u524d\u8fdb\u7684\u3002 \u5982\u4f55\u6765\u5b9e\u73b0reentrant kernel\u5462\uff1f\u8fd9\u662f\u4e00\u4e2a\u9700\u8981\u7cfb\u7edf\u5730\u8fdb\u884c\u8bbe\u8ba1\u624d\u80fd\u591f\u89e3\u51b3\u7684\u95ee\u9898\uff0c\u4e0b\u9762\u603b\u7ed3\u4e86\u548c\u8fd9\u4e2a\u95ee\u9898\u76f8\u5173\u7684\u4e00\u4e9b\u7ae0\u8282\uff1a 1.6.4. Process Address Space Kernel control path refers to its own private kernel stack. 1.6.5. Synchronization and Critical Regions \u63cf\u8ff0\u4e86kernel control path\u7684Synchronization","title":"Kernel control path"},{"location":"Kernel/Guide/Interaction-with-hardware/Kernel-control-path-and-reentrant-kernel/#see#also","text":"Kernel Control Path Definition","title":"See also"},{"location":"Kernel/Guide/Interaction-with-hardware/Linux-OS-interrupt-and-interrupte-handler/","text":"Linux OS interrupt and interrupt handler \u672c\u4e66\u4e2d\u96c6\u4e2d\u8bb2\u8ff0\u548cinterrupt\u7684\u7ae0\u8282\u5982\u4e0b\uff1a \u7ae0\u8282 \u4e3b\u8981\u5185\u5bb9 Chapter 4. Interrupts and Exceptions \u8bb2\u8ff0interrupt\u7684\u57fa\u7840\u77e5\u8bc6\uff0c\u662f\u540e\u7eed\u76f8\u5173\u7ae0\u8282\u7684\u57fa\u7840\u3002\u5185\u5bb9\u504f\u786c\u4ef6\u3002 Chapter 6. Timing Measurements \u8bb2\u8ff0hardware devices that underly timing\u3001time-related duties of the kernel Chapter 13. I/O Architecture and Device Drivers \u8bb2\u8ff0I/O devices \u672c\u6587\u7684\u5185\u5bb9\u662f\u5bf9\u8fd9\u4e9b\u7ae0\u8282\u7684\u5185\u5bb9\u7684\u68b3\u7406\u3002 Hardware\u901a\u8fc7interrupt\u6765\u901a\u77e5linux kernel\u3002\u5728Chapter 4. Interrupts and Exceptions\u4e2d\u5bf9interrupt\u8fdb\u884c\u4e86\u5206\u7c7b\uff1a \u6765\u6e90 Intel microprocessor manuals CPU control unit Synchronous interrupt exceptions Other hardware devices at arbitrary times with respect to the CPU clock signals, such as interval timers and I/O devices Asynchronous interrupt interrupts \u5bf9\u4e8ehardware\u7684\u77e5\u8bc6\uff0c\u6211\u4eec\u4e0d\u505a\u6df1\u5165\u5206\u6790\uff0c\u6211\u4eec\u91cd\u70b9\u5173\u6ce8software\u90e8\u5206\uff0c\u5373\u7531interrupt\u6240\u89e6\u53d1\u7684kernel control path\uff08\u662fOS\u5c42\u7684interrupt handler\uff09\uff0c\u6211\u4eec\u5bf9\u4e00\u4e9b\u4e3b\u8981\u7684interrupt\u548c\u5176kernel control path\u8fdb\u884c\u603b\u7ed3\u3002","title":"Linux-OS-interrupt-and-interrupte-handler"},{"location":"Kernel/Guide/Interaction-with-hardware/Linux-OS-interrupt-and-interrupte-handler/#linux#os#interrupt#and#interrupt#handler","text":"\u672c\u4e66\u4e2d\u96c6\u4e2d\u8bb2\u8ff0\u548cinterrupt\u7684\u7ae0\u8282\u5982\u4e0b\uff1a \u7ae0\u8282 \u4e3b\u8981\u5185\u5bb9 Chapter 4. Interrupts and Exceptions \u8bb2\u8ff0interrupt\u7684\u57fa\u7840\u77e5\u8bc6\uff0c\u662f\u540e\u7eed\u76f8\u5173\u7ae0\u8282\u7684\u57fa\u7840\u3002\u5185\u5bb9\u504f\u786c\u4ef6\u3002 Chapter 6. Timing Measurements \u8bb2\u8ff0hardware devices that underly timing\u3001time-related duties of the kernel Chapter 13. I/O Architecture and Device Drivers \u8bb2\u8ff0I/O devices \u672c\u6587\u7684\u5185\u5bb9\u662f\u5bf9\u8fd9\u4e9b\u7ae0\u8282\u7684\u5185\u5bb9\u7684\u68b3\u7406\u3002 Hardware\u901a\u8fc7interrupt\u6765\u901a\u77e5linux kernel\u3002\u5728Chapter 4. Interrupts and Exceptions\u4e2d\u5bf9interrupt\u8fdb\u884c\u4e86\u5206\u7c7b\uff1a \u6765\u6e90 Intel microprocessor manuals CPU control unit Synchronous interrupt exceptions Other hardware devices at arbitrary times with respect to the CPU clock signals, such as interval timers and I/O devices Asynchronous interrupt interrupts \u5bf9\u4e8ehardware\u7684\u77e5\u8bc6\uff0c\u6211\u4eec\u4e0d\u505a\u6df1\u5165\u5206\u6790\uff0c\u6211\u4eec\u91cd\u70b9\u5173\u6ce8software\u90e8\u5206\uff0c\u5373\u7531interrupt\u6240\u89e6\u53d1\u7684kernel control path\uff08\u662fOS\u5c42\u7684interrupt handler\uff09\uff0c\u6211\u4eec\u5bf9\u4e00\u4e9b\u4e3b\u8981\u7684interrupt\u548c\u5176kernel control path\u8fdb\u884c\u603b\u7ed3\u3002","title":"Linux OS interrupt and interrupt handler"},{"location":"Kernel/Guide/Interaction-with-hardware/Linux-OS-kernel-is-event-driven/","text":"Linux OS kernel is event-driven \u4e3a\u4e86\u66f4\u597d\u5730\u7406\u89e3\u672c\u4e66\uff0c\u6211\u89c9\u5f97\u6709\u5fc5\u8981\u5efa\u7acb\u8d77\u5bf9OS\u8fd0\u884c\u6982\u51b5\u7684\u9ad8\u5c4b\u5efa\u74f4\u7684\u3001\u6574\u4f53\u7684\u8ba4\u77e5\uff08big picture\uff09\uff0c\u8fd9\u6837\u624d\u80fd\u591f\u68b3\u7406\u6e05\u695a\u4e66\u4e2d\u5404\u4e2a\u7ae0\u8282\u4e4b\u95f4\u7684\u5173\u8054\u3002 \u4ece\u4e00\u4e2asoftware engineer\u7684\u89c6\u89d2\u6765\u770b\uff0c\u6211\u89c9\u5f97OS kernel\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2a**event-driven system**\uff0c\u5373\u6574\u4e2aOS kernel\u7684\u8fd0\u884c\u662f event \u9a71\u52a8\u7684\uff0clinux OS kernel\u7684\u5b9e\u73b0\u91c7\u7528\uff08\u90e8\u5206\uff09\u7684\u662f Event-driven architecture ( Event-driven programming )\u3002\u4e0b\u9762\u5bf9\u8fd9\u4e2a\u8bba\u65ad\u7684\u5206\u6790\uff1a \u5728\u672c\u4e66 chapter 1.4. Basic Operating System Concepts \u6240\u4ecb\u7ecd\u7684\uff1a The operating system interact with the hardware components, servicing all low-level programmable elements included in the hardware platform. A Unix-like operating system hides all low-level details concerning the physical organization of the computer from applications run by the user. \u663e\u7136\uff0cOS kernel\u76f4\u63a5\u548chardware\u6253\u4ea4\u9053\uff0c\u90a3\u6709\u54ea\u4e9bhardware\u5462\uff1f\u5982\u4e0b\uff1a I/O devices Chapter 13. I/O Architecture and Device Drivers \u8865\u5145\uff1a Operating System - I/O Hardware Clock and Timer Circuits Chapter 6. Timing Measurements \u76ee\u524d\uff0c\u57fa\u672c\u4e0a\u6240\u6709\u7684hardware\u90fd\u662f\u901a\u8fc7 interrupt \u6765\u901a\u77e5OS kernel\u7684\uff0c\u7136\u540e\u5176\u5bf9\u5e94\u7684 Interrupt handler \u4f1a\u88ab\u89e6\u53d1\u6267\u884c\uff0c\u4e5f\u5c31\u662fOS kernel\u662f interrupt-driven \u7684\u3002\u62e5\u6709\u8fd9\u6837\u7684\u8ba4\u77e5\u5bf9\u4e8e\u5b8c\u6574\u5730\u638c\u63e1\u672c\u4e66\u7684\u5185\u5bb9\u5341\u5206\u91cd\u8981\uff0c\u56e0\u4e3a\u5b83\u63cf\u8ff0\u4e86OS kernel\u8fd0\u884c\u7684\u6982\u51b5\u3002 \u672c\u4e66\u7684 Chapter 4. Interrupts and Exceptions \u4e13\u95e8\u63cf\u8ff0\u4e2d\u65ad\u76f8\u5173\u5185\u5bb9\uff0c\u5b83\u662f\u540e\u9762\u5f88\u591a\u7ae0\u8282\u7684\u57fa\u7840\uff0c\u56e0\u4e3aOS\u4e2d\u6709\u592a\u591a\u592a\u591a\u7684\u6d3b\u52a8\u90fd\u662finterrupt\u89e6\u53d1\u7684\uff0c\u6bd4\u5982\uff1a TODO: \u6b64\u5904\u6dfb\u52a0\u4e00\u4e9b\u4f8b\u5b50 \u672c\u4e66\u7684 Chapter 6. Timing Measurements \u4e3b\u8981\u63cf\u8ff0\u7684\u662ftiming measurements\u76f8\u5173\u7684hardware\uff08\u4e3b\u8981\u5305\u62ecClock and Timer Circuits\uff09\u4ee5\u53caOS kernel\u4e2d\u7531timing measurement\u9a71\u52a8\u7684\u91cd\u8981\u7684\u6d3b\u52a8\uff08\u4e0b\u9762\u4f1a\u6709\u4ecb\u7ecd\uff09\uff0c\u6b63\u5982\u672c\u7ae0\u5f00\u5934\u6240\u8ff0\uff1a Countless computerized activities are driven by timing measurements OS kernel\u7684\u4f17\u591a\u6838\u5fc3activity\u662fdriven by timing measurements\uff0c\u6b63\u5982 6.2. The Linux Timekeeping Architecture \u4e2d\u6240\u603b\u7ed3\u7684\uff1a Updates the time elapsed since system startup Updates the time and date Determines, for every CPU, how long the current process has been running, and preempts it if it has exceeded the time allocated to it. The allocation of time slots (also called \"quanta\") is discussed in Chapter 7. NOTE: \u8fd9\u4e2a\u6d3b\u52a8\u975e\u5e38\u91cd\u8981\uff0c\u5b83\u662fOS\u5b9e\u73b0 Time-sharing \uff0c\u8fdb\u800c\u5b9e\u73b0 multitasking \u7684\u5173\u952e\u6240\u5728\u3002\u5728linux kernel\u7684\u5b9e\u73b0\u4e2d\uff0c\u5b83\u7684\u5165\u53e3\u51fd\u6570\u662f scheduler_tick \uff0c\u641c\u7d22\u8fd9\u4e2a\u51fd\u6570\uff0c\u53ef\u4ee5\u67e5\u8be2\u5230\u975e\u5e38\u591a\u5173\u4e8e\u5b83\u7684\u5206\u6790\u3002 \u672c\u4e66\u4e2d\u5173\u4e8e\u8fd9\u4e2a\u51fd\u6570\u7684\u7ae0\u8282\uff1a 6.4. Updating System Statistics 7.4. Functions Used by the Scheduler Updates resource usage statistics. Checks whether the interval of time associated with each software timer (see the later section \"Software Timers and Delay Functions\") has elapsed. \u901a\u8fc7\u4e0a\u9762\u7684\u5185\u5bb9\u53ef\u4ee5\u770b\u5230\uff1atimer interrupt\u5bf9\u7cfb\u7edf\u975e\u5e38\u91cd\u8981\uff0c\u5b83\u5c31\u76f8\u5f53\u4e8e\u7cfb\u7edf\u7684heartbeat\uff0c\u5b83\u9a71\u52a8\u7740\u7cfb\u7edf\u7684\u8fd0\u8f6c\uff0c\u5b83\u5c31\u76f8\u5f53\u4e8e\u76f8\u540c\u7684\u7cfb\u7edf\u7684 Electric motor \uff08\u5185\u71c3\u673a\u8fd0\u8f6c\u5e26\u52a8\u6574\u4e2a\u7cfb\u7edf\u8fd0\u8f6c\u8d77\u6765\uff09\u3002 System call\u4e5f\u76f8\u5f53\u4e8einterrupt \u4e0a\u9762\u4f7f\u7528\u7684\u662f\u201c\u76f8\u5f53\u4e8e\u201d\uff0c\u800c\u4e0d\u662f\u201c\u662f\u201d\uff0c\u8fd9\u662f\u56e0\u4e3a\u968f\u7740\u6280\u672f\u7684\u66f4\u65b0\u8fed\u4ee3\uff0c\u5b9e\u73b0system call\u7684assembly instruction\u4e5f\u5728\u8fdb\u884c\u66f4\u65b0\u8fed\u4ee3\uff0c\u53ef\u80fd\u539f\u6765\u4f7f\u7528\u7684\u4e2d\u65ad\u6307\u4ee4\uff08 int assembly instruction\uff09\u4f1a\u66ff\u6362\u4e3a\u66f4\u52a0\u9ad8\u6548\u7684assembly instruction\u3002\u572810.3. Entering and Exiting a System Call\u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u8be6\u7ec6\u7684\u8bf4\u660e\uff0c\u5982\u4e0b\uff1a Applications can invoke a system call in two different ways: By executing the int $0x80 assembly language instruction; in older versions of the Linux kernel, this was the only way to switch from User Mode to Kernel Mode. By executing the sysenter assembly language instruction, introduced in the Intel Pentium II microprocessors; this instruction is now supported by the Linux 2.6 kernel. \u4f7f\u7528 int $0x80 \u7684\u65b9\u5f0f\u662finterrupt\uff0c\u4f7f\u7528 sysenter \u7684\u65b9\u5f0f\u5219\u4e0d\u662finterrupt\uff0c\u4f46\u662f\u5b83\u7684\u4f5c\u7528\u5176\u5b9e\u548cinterrupt\u975e\u5e38\u7c7b\u4f3c\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5b83\u770b\u505a\u662finterrupt\u3002 \u5173\u4e8e sysenter \uff0c\u53c2\u52a0\uff1a https://wiki.osdev.org/Sysenter \u4e0a\u9762\u63cf\u8ff0\u7684interrupt\u4e3b\u8981\u6765\u81ea\u4e8ehardware\uff0c\u5176\u5b9esystem call\u7684\u5b9e\u73b0\u4e5f\u662f\u4f9d\u8d56\u4e8einterrupt\u3002 \u5728chapter 4.2. Interrupts and Exceptions\u7684\u201cProgrammed exceptions\u201d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a Such exceptions have two common uses: to implement system calls and to notify a debugger of a specific event (see Chapter 10). \u603b\u7ed3 \u901a\u8fc7\u4e0a\u8ff0\u5206\u6790\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230OS kernel\u7684\u6240\u6709activity\u5176\u5b9e\u90fd\u53ef\u4ee5\u8ba4\u4e3a\u662fevent-driven\u7684\uff1aOS kernel\u7ba1\u7406\u7740hardware\u3001process\uff0c\u5b83\u4f5c\u4e3a\u4e24\u8005\u4e4b\u95f4\u7684\u4e2d\u95f4\u5c42\uff0c\u53ef\u4ee5\u8ba4\u4e3aOS\u7684\u6240\u6709\u7684activity\u90fd\u662f\u7531\u5b83\u4eec\u89e6\u53d1\u7684\u3002 \u5efa\u7acb\u8fd9\u6837\u7684\u4e00\u4e2a\u7edf\u4e00\u6a21\u578b\u5bf9\u4e8e\u540e\u9762\u8ba8\u8bbaOS kernel\u7684\u5b9e\u73b0\u601d\u8def\u662f\u975e\u5e38\u91cd\u8981\u7684\u3002 \u6211\u4eec\u60ca\u559c\u7684\u53d1\u73b0\u7ad9\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u4e0d\u540c\u7684\u5c42\u6b21\u6765\u63cf\u8ff0\u672c\u8d28\u4e0a\u975e\u5e38\u7c7b\u4f3c\u7684\u4e8b\u52a1\u6709\u7740\u4e0d\u540c\u7684\u8bf4\u6cd5\uff0c\u4e0b\u9762\u5bf9\u6b64\u8fdb\u884c\u4e86\u5bf9\u6bd4\uff1a Hardware Software Interrupt-driven Event-driven architecture / Event-driven programming Interrupt Event (computing) Interrupt handler / Interrupt service routine Event handler / Callback function \u5404\u79cdinterrupt\u5c31\u662f\u6240\u8c13\u7684event\u3002","title":"Linux-OS-kernel-is-event-driven"},{"location":"Kernel/Guide/Interaction-with-hardware/Linux-OS-kernel-is-event-driven/#linux#os#kernel#is#event-driven","text":"\u4e3a\u4e86\u66f4\u597d\u5730\u7406\u89e3\u672c\u4e66\uff0c\u6211\u89c9\u5f97\u6709\u5fc5\u8981\u5efa\u7acb\u8d77\u5bf9OS\u8fd0\u884c\u6982\u51b5\u7684\u9ad8\u5c4b\u5efa\u74f4\u7684\u3001\u6574\u4f53\u7684\u8ba4\u77e5\uff08big picture\uff09\uff0c\u8fd9\u6837\u624d\u80fd\u591f\u68b3\u7406\u6e05\u695a\u4e66\u4e2d\u5404\u4e2a\u7ae0\u8282\u4e4b\u95f4\u7684\u5173\u8054\u3002 \u4ece\u4e00\u4e2asoftware engineer\u7684\u89c6\u89d2\u6765\u770b\uff0c\u6211\u89c9\u5f97OS kernel\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2a**event-driven system**\uff0c\u5373\u6574\u4e2aOS kernel\u7684\u8fd0\u884c\u662f event \u9a71\u52a8\u7684\uff0clinux OS kernel\u7684\u5b9e\u73b0\u91c7\u7528\uff08\u90e8\u5206\uff09\u7684\u662f Event-driven architecture ( Event-driven programming )\u3002\u4e0b\u9762\u5bf9\u8fd9\u4e2a\u8bba\u65ad\u7684\u5206\u6790\uff1a \u5728\u672c\u4e66 chapter 1.4. Basic Operating System Concepts \u6240\u4ecb\u7ecd\u7684\uff1a The operating system interact with the hardware components, servicing all low-level programmable elements included in the hardware platform. A Unix-like operating system hides all low-level details concerning the physical organization of the computer from applications run by the user. \u663e\u7136\uff0cOS kernel\u76f4\u63a5\u548chardware\u6253\u4ea4\u9053\uff0c\u90a3\u6709\u54ea\u4e9bhardware\u5462\uff1f\u5982\u4e0b\uff1a I/O devices Chapter 13. I/O Architecture and Device Drivers \u8865\u5145\uff1a Operating System - I/O Hardware Clock and Timer Circuits Chapter 6. Timing Measurements \u76ee\u524d\uff0c\u57fa\u672c\u4e0a\u6240\u6709\u7684hardware\u90fd\u662f\u901a\u8fc7 interrupt \u6765\u901a\u77e5OS kernel\u7684\uff0c\u7136\u540e\u5176\u5bf9\u5e94\u7684 Interrupt handler \u4f1a\u88ab\u89e6\u53d1\u6267\u884c\uff0c\u4e5f\u5c31\u662fOS kernel\u662f interrupt-driven \u7684\u3002\u62e5\u6709\u8fd9\u6837\u7684\u8ba4\u77e5\u5bf9\u4e8e\u5b8c\u6574\u5730\u638c\u63e1\u672c\u4e66\u7684\u5185\u5bb9\u5341\u5206\u91cd\u8981\uff0c\u56e0\u4e3a\u5b83\u63cf\u8ff0\u4e86OS kernel\u8fd0\u884c\u7684\u6982\u51b5\u3002 \u672c\u4e66\u7684 Chapter 4. Interrupts and Exceptions \u4e13\u95e8\u63cf\u8ff0\u4e2d\u65ad\u76f8\u5173\u5185\u5bb9\uff0c\u5b83\u662f\u540e\u9762\u5f88\u591a\u7ae0\u8282\u7684\u57fa\u7840\uff0c\u56e0\u4e3aOS\u4e2d\u6709\u592a\u591a\u592a\u591a\u7684\u6d3b\u52a8\u90fd\u662finterrupt\u89e6\u53d1\u7684\uff0c\u6bd4\u5982\uff1a TODO: \u6b64\u5904\u6dfb\u52a0\u4e00\u4e9b\u4f8b\u5b50 \u672c\u4e66\u7684 Chapter 6. Timing Measurements \u4e3b\u8981\u63cf\u8ff0\u7684\u662ftiming measurements\u76f8\u5173\u7684hardware\uff08\u4e3b\u8981\u5305\u62ecClock and Timer Circuits\uff09\u4ee5\u53caOS kernel\u4e2d\u7531timing measurement\u9a71\u52a8\u7684\u91cd\u8981\u7684\u6d3b\u52a8\uff08\u4e0b\u9762\u4f1a\u6709\u4ecb\u7ecd\uff09\uff0c\u6b63\u5982\u672c\u7ae0\u5f00\u5934\u6240\u8ff0\uff1a Countless computerized activities are driven by timing measurements OS kernel\u7684\u4f17\u591a\u6838\u5fc3activity\u662fdriven by timing measurements\uff0c\u6b63\u5982 6.2. The Linux Timekeeping Architecture \u4e2d\u6240\u603b\u7ed3\u7684\uff1a Updates the time elapsed since system startup Updates the time and date Determines, for every CPU, how long the current process has been running, and preempts it if it has exceeded the time allocated to it. The allocation of time slots (also called \"quanta\") is discussed in Chapter 7. NOTE: \u8fd9\u4e2a\u6d3b\u52a8\u975e\u5e38\u91cd\u8981\uff0c\u5b83\u662fOS\u5b9e\u73b0 Time-sharing \uff0c\u8fdb\u800c\u5b9e\u73b0 multitasking \u7684\u5173\u952e\u6240\u5728\u3002\u5728linux kernel\u7684\u5b9e\u73b0\u4e2d\uff0c\u5b83\u7684\u5165\u53e3\u51fd\u6570\u662f scheduler_tick \uff0c\u641c\u7d22\u8fd9\u4e2a\u51fd\u6570\uff0c\u53ef\u4ee5\u67e5\u8be2\u5230\u975e\u5e38\u591a\u5173\u4e8e\u5b83\u7684\u5206\u6790\u3002 \u672c\u4e66\u4e2d\u5173\u4e8e\u8fd9\u4e2a\u51fd\u6570\u7684\u7ae0\u8282\uff1a 6.4. Updating System Statistics 7.4. Functions Used by the Scheduler Updates resource usage statistics. Checks whether the interval of time associated with each software timer (see the later section \"Software Timers and Delay Functions\") has elapsed. \u901a\u8fc7\u4e0a\u9762\u7684\u5185\u5bb9\u53ef\u4ee5\u770b\u5230\uff1atimer interrupt\u5bf9\u7cfb\u7edf\u975e\u5e38\u91cd\u8981\uff0c\u5b83\u5c31\u76f8\u5f53\u4e8e\u7cfb\u7edf\u7684heartbeat\uff0c\u5b83\u9a71\u52a8\u7740\u7cfb\u7edf\u7684\u8fd0\u8f6c\uff0c\u5b83\u5c31\u76f8\u5f53\u4e8e\u76f8\u540c\u7684\u7cfb\u7edf\u7684 Electric motor \uff08\u5185\u71c3\u673a\u8fd0\u8f6c\u5e26\u52a8\u6574\u4e2a\u7cfb\u7edf\u8fd0\u8f6c\u8d77\u6765\uff09\u3002","title":"Linux OS kernel is event-driven"},{"location":"Kernel/Guide/Interaction-with-hardware/Linux-OS-kernel-is-event-driven/#system#callinterrupt","text":"\u4e0a\u9762\u4f7f\u7528\u7684\u662f\u201c\u76f8\u5f53\u4e8e\u201d\uff0c\u800c\u4e0d\u662f\u201c\u662f\u201d\uff0c\u8fd9\u662f\u56e0\u4e3a\u968f\u7740\u6280\u672f\u7684\u66f4\u65b0\u8fed\u4ee3\uff0c\u5b9e\u73b0system call\u7684assembly instruction\u4e5f\u5728\u8fdb\u884c\u66f4\u65b0\u8fed\u4ee3\uff0c\u53ef\u80fd\u539f\u6765\u4f7f\u7528\u7684\u4e2d\u65ad\u6307\u4ee4\uff08 int assembly instruction\uff09\u4f1a\u66ff\u6362\u4e3a\u66f4\u52a0\u9ad8\u6548\u7684assembly instruction\u3002\u572810.3. Entering and Exiting a System Call\u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u8be6\u7ec6\u7684\u8bf4\u660e\uff0c\u5982\u4e0b\uff1a Applications can invoke a system call in two different ways: By executing the int $0x80 assembly language instruction; in older versions of the Linux kernel, this was the only way to switch from User Mode to Kernel Mode. By executing the sysenter assembly language instruction, introduced in the Intel Pentium II microprocessors; this instruction is now supported by the Linux 2.6 kernel. \u4f7f\u7528 int $0x80 \u7684\u65b9\u5f0f\u662finterrupt\uff0c\u4f7f\u7528 sysenter \u7684\u65b9\u5f0f\u5219\u4e0d\u662finterrupt\uff0c\u4f46\u662f\u5b83\u7684\u4f5c\u7528\u5176\u5b9e\u548cinterrupt\u975e\u5e38\u7c7b\u4f3c\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5b83\u770b\u505a\u662finterrupt\u3002 \u5173\u4e8e sysenter \uff0c\u53c2\u52a0\uff1a https://wiki.osdev.org/Sysenter \u4e0a\u9762\u63cf\u8ff0\u7684interrupt\u4e3b\u8981\u6765\u81ea\u4e8ehardware\uff0c\u5176\u5b9esystem call\u7684\u5b9e\u73b0\u4e5f\u662f\u4f9d\u8d56\u4e8einterrupt\u3002 \u5728chapter 4.2. Interrupts and Exceptions\u7684\u201cProgrammed exceptions\u201d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a Such exceptions have two common uses: to implement system calls and to notify a debugger of a specific event (see Chapter 10).","title":"System call\u4e5f\u76f8\u5f53\u4e8einterrupt"},{"location":"Kernel/Guide/Interaction-with-hardware/Linux-OS-kernel-is-event-driven/#_1","text":"\u901a\u8fc7\u4e0a\u8ff0\u5206\u6790\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230OS kernel\u7684\u6240\u6709activity\u5176\u5b9e\u90fd\u53ef\u4ee5\u8ba4\u4e3a\u662fevent-driven\u7684\uff1aOS kernel\u7ba1\u7406\u7740hardware\u3001process\uff0c\u5b83\u4f5c\u4e3a\u4e24\u8005\u4e4b\u95f4\u7684\u4e2d\u95f4\u5c42\uff0c\u53ef\u4ee5\u8ba4\u4e3aOS\u7684\u6240\u6709\u7684activity\u90fd\u662f\u7531\u5b83\u4eec\u89e6\u53d1\u7684\u3002 \u5efa\u7acb\u8fd9\u6837\u7684\u4e00\u4e2a\u7edf\u4e00\u6a21\u578b\u5bf9\u4e8e\u540e\u9762\u8ba8\u8bbaOS kernel\u7684\u5b9e\u73b0\u601d\u8def\u662f\u975e\u5e38\u91cd\u8981\u7684\u3002 \u6211\u4eec\u60ca\u559c\u7684\u53d1\u73b0\u7ad9\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u4e0d\u540c\u7684\u5c42\u6b21\u6765\u63cf\u8ff0\u672c\u8d28\u4e0a\u975e\u5e38\u7c7b\u4f3c\u7684\u4e8b\u52a1\u6709\u7740\u4e0d\u540c\u7684\u8bf4\u6cd5\uff0c\u4e0b\u9762\u5bf9\u6b64\u8fdb\u884c\u4e86\u5bf9\u6bd4\uff1a Hardware Software Interrupt-driven Event-driven architecture / Event-driven programming Interrupt Event (computing) Interrupt handler / Interrupt service routine Event handler / Callback function \u5404\u79cdinterrupt\u5c31\u662f\u6240\u8c13\u7684event\u3002","title":"\u603b\u7ed3"},{"location":"Kernel/Guide/Kernel-Task-model/Control-path-%26-Context-%26-Context-switch/","text":"Control path NOTE: \u4f7f\u7528task model\u6765\u8fdb\u884c\u63cf\u8ff0 Control path\u8fd9\u4e2a\u6982\u5ff5\u662f\u6211\u7531kernel control path\u542f\u53d1\u800c\u521b\u5efa\u7684\uff0cControl path\u8868\u793aOS\u4e2d\u6240\u6709\u53ef\u80fd\u7684\u6d3b\u52a8/\u6267\u884c\u6d41\u7a0b\uff0c\u4e4b\u6240\u4ee5\u521b\u5efa\u8fd9\u4e2a\u6982\u5ff5\uff0c\u662f\u56e0\u4e3a\u5b83\u53ef\u4ee5\u65b9\u4fbf\u6211\u4eec\u6765\u7edf\u4e00\u5730\u3001\u6982\u62ec\u5730\u63cf\u8ff0\u4e00\u4e9b\u95ee\u9898\uff08\u4e00\u4e2a\u62bd\u8c61\u8fc7\u7a0b\uff09\u3002\u4e0e\u5b83\u6bd4\u8f83\u63a5\u8fd1\u7684\u4e00\u4e2a\u6982\u5ff5\u662f Control flow \u3002 Linux OS\u4e2d\u6709\u5982\u4e0bcontrol path\uff1a kernel control path kernel thread task\uff08process/thread\uff0c\u73b0\u4ee3OS\u9700\u8981\u652f\u6301 multitasking \uff09 \u5728\u672c\u4e66\u7684\u6709\u4e9b\u7ae0\u8282\u4f1a\u4f7f\u7528\u201cexecution context\u201d\u3001\u201cexecution flow\u201d\u7b49\u8bcd\u8bed\uff0c\u5176\u5b9e\u5b83\u4eec\u548c\u672c\u6587\u6240\u5b9a\u4e49\u7684control path\u8868\u793a\u7684\u662f\u76f8\u540c\u7684\u610f\u601d\u3002 Control path\u7684\u5178\u578b\u7279\u5f81\u662f\u201creentrant\u201d\uff0c\u5373\u5b83\u7684\u6267\u884c\u53ef\u80fd\u4f1a\u88absuspend\u800c\u540e\u88abresume\u3002\u4e0b\u9762\u679a\u4e3e\u4e86\u4e24\u4e2a\u4f8b\u5b50\u6765\u8bf4\u660e\u201creentrant\u201d\u7684\u542b\u4e49\uff1a \u4e00\u65e6\u53d1\u751f\u4e86hardware interrupt\uff0cOS kernel\u4f1a\u7acb\u5373\u53bb\u54cd\u5e94\uff0c\u4ece\u800cinterrupt\uff08suspend\uff09\u5f53\u524d\u6267\u884c\u7684kernel control path\uff0c\u8f6c\u53bb\u6267\u884c\u65b0\u7684kernel control path\uff0c\u5373\u539fkernel control path\u4f1a\u88abinterrupted\u3002 task\u662f\u73b0\u4ee3OS\u4e3a\u652f\u6301 multitasking \u800c\u521b\u5efa\u7684\uff0c\u5b83\u7531 scheduler \u8fdb\u884c\u8c03\u5ea6\u6267\u884c\u7684\uff0c\u76ee\u524dlinux\u91c7\u53d6\u7684\u8c03\u5ea6\u7b56\u7565\u662f Preemptive multitasking \uff0c\u8fd9\u79cd\u7b56\u7565\u7684\u672c\u8d28\u662f\uff1a It is normally carried out by a privileged task or part of the system known as a preemptive scheduler , which has the power to preempt , or interrupt, and later resume, other tasks in the system. \u5373\u5b83\u53ef\u80fd\u4f1apreempt\uff08suspend\uff09\u6b63\u5728\u6267\u884c\u7684task\uff0c\u7136\u540e\u8f6c\u53bb\u6267\u884c\u53e6\u5916\u4e00\u4e2atask\u3002 \u5982\u4f55\u5b9e\u73b0Reentrant\uff1f \u663e\u7136\u8fd9\u662fOS\u4e3a\u4e86\u9ad8\u6548\uff0c\u8ba9\u591a\u4e2acontrol path interleave\uff08\u4ea4\u9519\u8fd0\u884c\uff09\uff0c\u4e3a\u4e86\u5b9e\u73b0 Reentrancy \uff0c\u6bcf\u4e2acontrol path\u90fd\u8981\u6709\u81ea\u5df1private\u7684context\u3001address space\uff08\u8fd9\u5176\u5b9e\u662f\u4e00\u4e2aseparation\u673a\u5236\uff09\uff0c\u5b83\u80fd\u591f\u4fdd\u8bc1\u4e00\u4e2acontrol path\u5728\u88absuspend\u540e\uff0c\u8fc7\u540e\u80fd\u591f\u88abresume\u3002 \u663e\u7136context\u5305\u62ec\u6bcf\u4e2acontrol path\u7684private\u6570\u636e\uff0c\u5982\u4e0b\uff1a hardware context\uff1a Program counter \u6bcf\u5f53\u4e00\u4e2a\u6b63\u5728\u6267\u884c\u7684control path\u8981\u88absuspend\u4e4b\u524d\uff0c\u9700\u8981\u5c06\u5b83\u7684context\u7f6e\u4e8e\u5b83\u7684\u5f53\u524d\u6267\u884c\u5b83\u7684process\uff08linux \u7684lightweight process\uff0c\u800c\u4e0d\u662f\u6807\u51c6\u7684process\uff09\u7684 call stack \uff08\u53ef\u80fd\u662fKernel Mode process stack\uff0c\u4e5f\u53ef\u80fd\u662fUser Mode process stack\uff09\uff0c\u5728\u5b83\u88abrestart\u7684\u65f6\u5019\uff0c\u518d\u5c06\u4fdd\u5b58\u5728 call stack \u4e0a\u7684context\u6062\u590d\uff0c\u8fd9\u5c31\u6240\u8c13\u7684context switch\uff0c\u540e\u9762\u4f1a\u8fdb\u884c\u4e13\u95e8\u4ecb\u7ecd\u3002 \u5173\u4e8e\u8fd9\u4e00\u70b9\uff0c\u8bc1\u636e\u6765\u6e90\u4e8e\uff1a chapter 4.1. The Role of Interrupt Signals \u9f99\u4e667.2.2 Activation Records Context switch \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u672c\u8282\u6240\u8ff0\u7684context switch\u662f\u5e7f\u4e49\u7684\uff0c\u800c\u4e0d\u662f Computer multitasking \u4e2d\u4e13\u6307task\uff08process/thread\uff09\u7684 context switch \u3002 \u53d1\u751fcontext switch\u7684\u573a\u666f\uff1a Scheduler\u89e6\u53d1Process Switch 3.3. Process Switch kernel substitutes one process for another process Interrupt Signals\u89e6\u53d1Switch 4.1. The Role of Interrupt Signals the code executed by an interrupt or by an exception handler is not a process. Rather, it is a kernel control path that runs at the expense of the same process that was running when the interrupt occurred As a kernel control path, the interrupt handler is lighter than a process (it has less context and requires less time to set up or tear down). 4.3. Nested Execution of Exception and Interrupt Handlers \u601d\u8003\uff1acontext switch\u7684\u6210\u672c \u4e0d\u540c\u7684control path\u8fdb\u884ccontext switch\u7684\u6210\u672c\u662f\u4e0d\u540c\u7684\uff0c \u8f6f\u4ef6\u5de5\u7a0b\u5e08\u7ecf\u5e38\u542c\u8bf4\u7684\u5c31\u662fthread\u7684context switch\u6bd4process\u7684context switch\u8981\u5feb\uff0c\u5c31\u662f\u8bf4\u7684\u8fd9\u4e2a\u9053\u7406\u3002 Control path context switch VS function call control path\u7684context switch\u548cfunction call\u4e2d\u5c06 return state \u4fdd\u5b58\u5230 call stack \u5f85\u88ab\u8c03\u51fd\u6570\u8fd4\u56de\u540e\u518d\u8fdb\u884c\u6062\u590d\u7684\u505a\u6cd5\u662f\u975e\u5e38\u7c7b\u4f3c\u7684\u3002 How kernel control path execute? kernel control path \uff08\u6ce8\u610f\u4e0d\u662fcontrol path\uff09\u7684\u6267\u884c\u7ec6\u8282\u6bd4\u8f83\u590d\u6742\uff0c\u540e\u7eed\u9700\u8981\u8fdb\u884c\u8865\u5145\u3002 Kernel control path\u548cprocess\u4e4b\u95f4\u7684\u5173\u8054\u662f\u672c\u4e66\u4e2d\u4f1a\u4e00\u76f4\u5f3a\u8c03\u7684\u5185\u5bb9\uff0c\u9700\u8981\u8fdb\u884c\u4e00\u4e0b\u603b\u7ed3\uff0c\u5176\u4e2d\u6700\u6700\u5178\u578b\u7684\u5c31\u662f\"kernel control path runs on behalf of process\"\u3002\u4e3a\u4e86\u4eca\u540e\u4fbf\u4e8e\u5feb\u901f\u5730\u68c0\u7d22\u5230\u8fd9\u4e9b\u5185\u5bb9\uff0c\u73b0\u5c06\u672c\u4e66\u4e2d\u6240\u6709\u7684\u4e0e\u6b64\u76f8\u5173\u5185\u5bb9\u7684\u4f4d\u7f6e\u5168\u90e8\u90fd\u6574\u7406\u5230\u8fd9\u91cc\uff1a chapter 1.6.3. Reentrant Kernels \u672c\u8282\u7684\u540e\u534a\u90e8\u5206\u5bf9kernel control path\u7684\u4e00\u4e9b\u53ef\u80fd\u60c5\u51b5\u8fdb\u884c\u4e86\u679a\u4e3e\uff0c\u5e76\u63cf\u8ff0\u4e86\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0ckernel control path\u548cprocess\u4e4b\u95f4\u7684\u5173\u7cfb Chapter 4. Interrupts and Exceptions \u4e3b\u8981\u63cf\u8ff0\u4e86Interrupts and Exceptions\u89e6\u53d1\u7684kernel control path\u7684\u6267\u884c\u60c5\u51b5\u3002\u5e76\u4e14\u5176\u4e2d\u8fd8\u5bf9\u6bd4\u4e86interrupt \u89e6\u53d1\u7684kernel control path\u548csystem call\u89e6\u53d1\u7684kernel control path\u4e4b\u95f4\u7684\u5dee\u5f02\u7b49\u5185\u5bb9\u3002 SUMMARY : \u6267\u884csystem call\u4e5f\u662fkernel control path\uff0c\u90a3\u4e48\u662f\u5426system call\u7684\u6267\u884c\u6b65\u9aa4\u548c\u4e0a\u9762\u63cf\u8ff0\u7684\u7c7b\u4f3c\uff1f\u5728\u8fd9\u7bc7\u6587\u7ae0\u4e2d\uff0c\u6709\u5982\u4e0b\u7684\u63d0\u95ee\uff1a Is the Unix process scheduler itself a process? Is the Unix process scheduler itself a process, or does it piggyback on other processes in the same way a system call does (running kernel code in the user process with the kernel bit set)? \u6309\u7167\u4e0a\u9762\u8fd9\u4e00\u6bb5\u7684\u63cf\u8ff0\u6765\u770b\uff0cinterrupt\u7684\u6267\u884c\u662fpiggyback on processes \uff1b\u6309\u71671.6.3. Reentrant Kernels\u4e2d\u6240\u5b9a\u4e49\u7684kernel control path\uff0c\u5b83\u652f\u6301A kernel control path denotes the sequence of instructions executed by the kernel to handle a system call, an exception, or an interrupt.\u663e\u7136\uff0csystem call\u548cexception handler\u90fd\u662fkernel control path\uff1b\u4e0a\u9762\u6240\u63cf\u8ff0\u7684exception handler\u7684\u6267\u884c\u65b9\u5f0f\u662f\u5426\u4e5f\u9002\u7528\u4e8esystem call\uff1b Unix\u8fdb\u7a0b\u8c03\u5ea6\u7a0b\u5e8f\u672c\u8eab\u662f\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u8fd8\u662f\u4ee5\u4e0e\u7cfb\u7edf\u8c03\u7528\u76f8\u540c\u7684\u65b9\u5f0f\u642d\u8f7d\u5728\u5176\u4ed6\u8fdb\u7a0b\u4e0a\uff08\u5728\u5185\u6838\u4f4d\u8bbe\u7f6e\u7684\u7528\u6237\u8fdb\u7a0b\u4e2d\u8fd0\u884c\u5185\u6838\u4ee3\u7801\uff09\uff1f 4.3. Nested Execution of Exception and Interrupt Handlers: the first instructions of the corresponding kernel control path are those that save the contents of the CPU registers in the Kernel Mode stack, while the last are those that restore the contents of the registers. \u603b\u7ed3 \u901a\u8fc7control path\u6a21\u578b\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0cOS\u5728\u8fd0\u884c\u548c\u63a7\u5236\u5b83\u4eec\u7684\u65f6\u5019\u4f1a\u9762\u4e34\u4e2d\u7c7b\u4f3c\u7684\u95ee\u9898\u3002","title":"Control-path-&-Context-&-Context-switch"},{"location":"Kernel/Guide/Kernel-Task-model/Control-path-%26-Context-%26-Context-switch/#control#path","text":"NOTE: \u4f7f\u7528task model\u6765\u8fdb\u884c\u63cf\u8ff0 Control path\u8fd9\u4e2a\u6982\u5ff5\u662f\u6211\u7531kernel control path\u542f\u53d1\u800c\u521b\u5efa\u7684\uff0cControl path\u8868\u793aOS\u4e2d\u6240\u6709\u53ef\u80fd\u7684\u6d3b\u52a8/\u6267\u884c\u6d41\u7a0b\uff0c\u4e4b\u6240\u4ee5\u521b\u5efa\u8fd9\u4e2a\u6982\u5ff5\uff0c\u662f\u56e0\u4e3a\u5b83\u53ef\u4ee5\u65b9\u4fbf\u6211\u4eec\u6765\u7edf\u4e00\u5730\u3001\u6982\u62ec\u5730\u63cf\u8ff0\u4e00\u4e9b\u95ee\u9898\uff08\u4e00\u4e2a\u62bd\u8c61\u8fc7\u7a0b\uff09\u3002\u4e0e\u5b83\u6bd4\u8f83\u63a5\u8fd1\u7684\u4e00\u4e2a\u6982\u5ff5\u662f Control flow \u3002 Linux OS\u4e2d\u6709\u5982\u4e0bcontrol path\uff1a kernel control path kernel thread task\uff08process/thread\uff0c\u73b0\u4ee3OS\u9700\u8981\u652f\u6301 multitasking \uff09 \u5728\u672c\u4e66\u7684\u6709\u4e9b\u7ae0\u8282\u4f1a\u4f7f\u7528\u201cexecution context\u201d\u3001\u201cexecution flow\u201d\u7b49\u8bcd\u8bed\uff0c\u5176\u5b9e\u5b83\u4eec\u548c\u672c\u6587\u6240\u5b9a\u4e49\u7684control path\u8868\u793a\u7684\u662f\u76f8\u540c\u7684\u610f\u601d\u3002 Control path\u7684\u5178\u578b\u7279\u5f81\u662f\u201creentrant\u201d\uff0c\u5373\u5b83\u7684\u6267\u884c\u53ef\u80fd\u4f1a\u88absuspend\u800c\u540e\u88abresume\u3002\u4e0b\u9762\u679a\u4e3e\u4e86\u4e24\u4e2a\u4f8b\u5b50\u6765\u8bf4\u660e\u201creentrant\u201d\u7684\u542b\u4e49\uff1a \u4e00\u65e6\u53d1\u751f\u4e86hardware interrupt\uff0cOS kernel\u4f1a\u7acb\u5373\u53bb\u54cd\u5e94\uff0c\u4ece\u800cinterrupt\uff08suspend\uff09\u5f53\u524d\u6267\u884c\u7684kernel control path\uff0c\u8f6c\u53bb\u6267\u884c\u65b0\u7684kernel control path\uff0c\u5373\u539fkernel control path\u4f1a\u88abinterrupted\u3002 task\u662f\u73b0\u4ee3OS\u4e3a\u652f\u6301 multitasking \u800c\u521b\u5efa\u7684\uff0c\u5b83\u7531 scheduler \u8fdb\u884c\u8c03\u5ea6\u6267\u884c\u7684\uff0c\u76ee\u524dlinux\u91c7\u53d6\u7684\u8c03\u5ea6\u7b56\u7565\u662f Preemptive multitasking \uff0c\u8fd9\u79cd\u7b56\u7565\u7684\u672c\u8d28\u662f\uff1a It is normally carried out by a privileged task or part of the system known as a preemptive scheduler , which has the power to preempt , or interrupt, and later resume, other tasks in the system. \u5373\u5b83\u53ef\u80fd\u4f1apreempt\uff08suspend\uff09\u6b63\u5728\u6267\u884c\u7684task\uff0c\u7136\u540e\u8f6c\u53bb\u6267\u884c\u53e6\u5916\u4e00\u4e2atask\u3002","title":"Control path"},{"location":"Kernel/Guide/Kernel-Task-model/Control-path-%26-Context-%26-Context-switch/#reentrant","text":"\u663e\u7136\u8fd9\u662fOS\u4e3a\u4e86\u9ad8\u6548\uff0c\u8ba9\u591a\u4e2acontrol path interleave\uff08\u4ea4\u9519\u8fd0\u884c\uff09\uff0c\u4e3a\u4e86\u5b9e\u73b0 Reentrancy \uff0c\u6bcf\u4e2acontrol path\u90fd\u8981\u6709\u81ea\u5df1private\u7684context\u3001address space\uff08\u8fd9\u5176\u5b9e\u662f\u4e00\u4e2aseparation\u673a\u5236\uff09\uff0c\u5b83\u80fd\u591f\u4fdd\u8bc1\u4e00\u4e2acontrol path\u5728\u88absuspend\u540e\uff0c\u8fc7\u540e\u80fd\u591f\u88abresume\u3002 \u663e\u7136context\u5305\u62ec\u6bcf\u4e2acontrol path\u7684private\u6570\u636e\uff0c\u5982\u4e0b\uff1a hardware context\uff1a Program counter \u6bcf\u5f53\u4e00\u4e2a\u6b63\u5728\u6267\u884c\u7684control path\u8981\u88absuspend\u4e4b\u524d\uff0c\u9700\u8981\u5c06\u5b83\u7684context\u7f6e\u4e8e\u5b83\u7684\u5f53\u524d\u6267\u884c\u5b83\u7684process\uff08linux \u7684lightweight process\uff0c\u800c\u4e0d\u662f\u6807\u51c6\u7684process\uff09\u7684 call stack \uff08\u53ef\u80fd\u662fKernel Mode process stack\uff0c\u4e5f\u53ef\u80fd\u662fUser Mode process stack\uff09\uff0c\u5728\u5b83\u88abrestart\u7684\u65f6\u5019\uff0c\u518d\u5c06\u4fdd\u5b58\u5728 call stack \u4e0a\u7684context\u6062\u590d\uff0c\u8fd9\u5c31\u6240\u8c13\u7684context switch\uff0c\u540e\u9762\u4f1a\u8fdb\u884c\u4e13\u95e8\u4ecb\u7ecd\u3002 \u5173\u4e8e\u8fd9\u4e00\u70b9\uff0c\u8bc1\u636e\u6765\u6e90\u4e8e\uff1a chapter 4.1. The Role of Interrupt Signals \u9f99\u4e667.2.2 Activation Records","title":"\u5982\u4f55\u5b9e\u73b0Reentrant\uff1f"},{"location":"Kernel/Guide/Kernel-Task-model/Control-path-%26-Context-%26-Context-switch/#context#switch","text":"\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u672c\u8282\u6240\u8ff0\u7684context switch\u662f\u5e7f\u4e49\u7684\uff0c\u800c\u4e0d\u662f Computer multitasking \u4e2d\u4e13\u6307task\uff08process/thread\uff09\u7684 context switch \u3002 \u53d1\u751fcontext switch\u7684\u573a\u666f\uff1a","title":"Context switch"},{"location":"Kernel/Guide/Kernel-Task-model/Control-path-%26-Context-%26-Context-switch/#schedulerprocess#switch","text":"3.3. Process Switch kernel substitutes one process for another process","title":"Scheduler\u89e6\u53d1Process Switch"},{"location":"Kernel/Guide/Kernel-Task-model/Control-path-%26-Context-%26-Context-switch/#interrupt#signalsswitch","text":"4.1. The Role of Interrupt Signals the code executed by an interrupt or by an exception handler is not a process. Rather, it is a kernel control path that runs at the expense of the same process that was running when the interrupt occurred As a kernel control path, the interrupt handler is lighter than a process (it has less context and requires less time to set up or tear down). 4.3. Nested Execution of Exception and Interrupt Handlers","title":"Interrupt Signals\u89e6\u53d1Switch"},{"location":"Kernel/Guide/Kernel-Task-model/Control-path-%26-Context-%26-Context-switch/#context#switch_1","text":"\u4e0d\u540c\u7684control path\u8fdb\u884ccontext switch\u7684\u6210\u672c\u662f\u4e0d\u540c\u7684\uff0c \u8f6f\u4ef6\u5de5\u7a0b\u5e08\u7ecf\u5e38\u542c\u8bf4\u7684\u5c31\u662fthread\u7684context switch\u6bd4process\u7684context switch\u8981\u5feb\uff0c\u5c31\u662f\u8bf4\u7684\u8fd9\u4e2a\u9053\u7406\u3002","title":"\u601d\u8003\uff1acontext switch\u7684\u6210\u672c"},{"location":"Kernel/Guide/Kernel-Task-model/Control-path-%26-Context-%26-Context-switch/#control#path#context#switch#vs#function#call","text":"control path\u7684context switch\u548cfunction call\u4e2d\u5c06 return state \u4fdd\u5b58\u5230 call stack \u5f85\u88ab\u8c03\u51fd\u6570\u8fd4\u56de\u540e\u518d\u8fdb\u884c\u6062\u590d\u7684\u505a\u6cd5\u662f\u975e\u5e38\u7c7b\u4f3c\u7684\u3002","title":"Control path context switch VS function call"},{"location":"Kernel/Guide/Kernel-Task-model/Control-path-%26-Context-%26-Context-switch/#how#kernel#control#path#execute","text":"kernel control path \uff08\u6ce8\u610f\u4e0d\u662fcontrol path\uff09\u7684\u6267\u884c\u7ec6\u8282\u6bd4\u8f83\u590d\u6742\uff0c\u540e\u7eed\u9700\u8981\u8fdb\u884c\u8865\u5145\u3002 Kernel control path\u548cprocess\u4e4b\u95f4\u7684\u5173\u8054\u662f\u672c\u4e66\u4e2d\u4f1a\u4e00\u76f4\u5f3a\u8c03\u7684\u5185\u5bb9\uff0c\u9700\u8981\u8fdb\u884c\u4e00\u4e0b\u603b\u7ed3\uff0c\u5176\u4e2d\u6700\u6700\u5178\u578b\u7684\u5c31\u662f\"kernel control path runs on behalf of process\"\u3002\u4e3a\u4e86\u4eca\u540e\u4fbf\u4e8e\u5feb\u901f\u5730\u68c0\u7d22\u5230\u8fd9\u4e9b\u5185\u5bb9\uff0c\u73b0\u5c06\u672c\u4e66\u4e2d\u6240\u6709\u7684\u4e0e\u6b64\u76f8\u5173\u5185\u5bb9\u7684\u4f4d\u7f6e\u5168\u90e8\u90fd\u6574\u7406\u5230\u8fd9\u91cc\uff1a chapter 1.6.3. Reentrant Kernels \u672c\u8282\u7684\u540e\u534a\u90e8\u5206\u5bf9kernel control path\u7684\u4e00\u4e9b\u53ef\u80fd\u60c5\u51b5\u8fdb\u884c\u4e86\u679a\u4e3e\uff0c\u5e76\u63cf\u8ff0\u4e86\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0ckernel control path\u548cprocess\u4e4b\u95f4\u7684\u5173\u7cfb Chapter 4. Interrupts and Exceptions \u4e3b\u8981\u63cf\u8ff0\u4e86Interrupts and Exceptions\u89e6\u53d1\u7684kernel control path\u7684\u6267\u884c\u60c5\u51b5\u3002\u5e76\u4e14\u5176\u4e2d\u8fd8\u5bf9\u6bd4\u4e86interrupt \u89e6\u53d1\u7684kernel control path\u548csystem call\u89e6\u53d1\u7684kernel control path\u4e4b\u95f4\u7684\u5dee\u5f02\u7b49\u5185\u5bb9\u3002 SUMMARY : \u6267\u884csystem call\u4e5f\u662fkernel control path\uff0c\u90a3\u4e48\u662f\u5426system call\u7684\u6267\u884c\u6b65\u9aa4\u548c\u4e0a\u9762\u63cf\u8ff0\u7684\u7c7b\u4f3c\uff1f\u5728\u8fd9\u7bc7\u6587\u7ae0\u4e2d\uff0c\u6709\u5982\u4e0b\u7684\u63d0\u95ee\uff1a Is the Unix process scheduler itself a process? Is the Unix process scheduler itself a process, or does it piggyback on other processes in the same way a system call does (running kernel code in the user process with the kernel bit set)? \u6309\u7167\u4e0a\u9762\u8fd9\u4e00\u6bb5\u7684\u63cf\u8ff0\u6765\u770b\uff0cinterrupt\u7684\u6267\u884c\u662fpiggyback on processes \uff1b\u6309\u71671.6.3. Reentrant Kernels\u4e2d\u6240\u5b9a\u4e49\u7684kernel control path\uff0c\u5b83\u652f\u6301A kernel control path denotes the sequence of instructions executed by the kernel to handle a system call, an exception, or an interrupt.\u663e\u7136\uff0csystem call\u548cexception handler\u90fd\u662fkernel control path\uff1b\u4e0a\u9762\u6240\u63cf\u8ff0\u7684exception handler\u7684\u6267\u884c\u65b9\u5f0f\u662f\u5426\u4e5f\u9002\u7528\u4e8esystem call\uff1b Unix\u8fdb\u7a0b\u8c03\u5ea6\u7a0b\u5e8f\u672c\u8eab\u662f\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u8fd8\u662f\u4ee5\u4e0e\u7cfb\u7edf\u8c03\u7528\u76f8\u540c\u7684\u65b9\u5f0f\u642d\u8f7d\u5728\u5176\u4ed6\u8fdb\u7a0b\u4e0a\uff08\u5728\u5185\u6838\u4f4d\u8bbe\u7f6e\u7684\u7528\u6237\u8fdb\u7a0b\u4e2d\u8fd0\u884c\u5185\u6838\u4ee3\u7801\uff09\uff1f 4.3. Nested Execution of Exception and Interrupt Handlers: the first instructions of the corresponding kernel control path are those that save the contents of the CPU registers in the Kernel Mode stack, while the last are those that restore the contents of the registers.","title":"How kernel control path execute?"},{"location":"Kernel/Guide/Kernel-Task-model/Control-path-%26-Context-%26-Context-switch/#_1","text":"\u901a\u8fc7control path\u6a21\u578b\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0cOS\u5728\u8fd0\u884c\u548c\u63a7\u5236\u5b83\u4eec\u7684\u65f6\u5019\u4f1a\u9762\u4e34\u4e2d\u7c7b\u4f3c\u7684\u95ee\u9898\u3002","title":"\u603b\u7ed3"},{"location":"Kernel/Guide/Kernel-data-structure/","text":"Kernel data structure TODO: \u5404\u79cd\u5404\u6837\u7684table kernel\u7ba1\u7406\u7740OS\u7684\u4e00\u5207\u8d44\u6e90\uff0c\u56e0\u6b64\uff0c\u5b83\u4e00\u822c\u4f7f\u7528table\u6765\u8fdb\u884c\u7ba1\u7406\uff0c\u6bd4\u5982\uff1a table \u7b80\u4ecb \u53c2\u8003 \u8fdb\u7a0b\u8868 \u8bb0\u5f55OS\u4e2d\u7684\u6240\u6709\u7684process \u6587\u4ef6\u8868 \u8bb0\u5f55OS\u4e2d\u6240\u6709\u7684\u6253\u5f00\u7684\u6587\u4ef6 APUE socket table \u8bb0\u5f55OS\u4e2d\u7684\u6240\u6709\u7684socket - ss(8) - Linux man page - wikipedia TCP# Resource usage Routing table \u8bb0\u5f55\u8def\u7531\u89c4\u5219 wikipedia Routing table \u5e95\u5c42\u91c7\u7528\u4f55\u79cddata structure\u6765\u8fdb\u884c\u5b9e\u73b0\uff0c\u9700\u8981\u8003\u8651\u591a\u91cd\u56e0\u7d20\uff1a \u67e5\u627e\u7684\u65f6\u95f4\u590d\u6742\u5ea6 \u7a7a\u95f4\u590d\u6742\u5ea6 TODO: Entry of table \u524d\u9762\u4ecb\u7ecd\u4e86table\uff0c\u73b0\u5728\u4ecb\u7ecdentry of table\uff0c\u4e00\u822centry of table\u88ab\u79f0\u4e3a: ****** control block ****** descriptor \u6bd4\u5982: table entry \u53c2\u89c1 socket table Transmission Control Block or TCB - wikipedia TCP# Resource usage \u5404\u79cd\u5404\u6837\u7684descriptor \u5404\u79cd\u5404\u6837\u7684descriptor\uff0c\u4ee5\u53ca\u5176\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784 Descriptor Chapter Struct Source Code Process Descriptor 3.2. Process Descriptor task_struct - https://github.com/torvalds/linux/blob/master/include/linux/sched.h - https://elixir.bootlin.com/linux/latest/ident/task_struct Memory Descriptor 9.2. The Memory Descriptor mm_struct - https://elixir.bootlin.com/linux/latest/ident/mm_struct - https://github.com/torvalds/linux/blob/master/include/linux/mm_types.h Page Descriptor 8.1.1. Page Descriptors page - https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h#L68 Task State Segment Descriptor 3.3. Process Switch Global Descriptor Table memory descriptor signal descriptor file descriptors Interrupt Descriptor Table","title":"Introduction"},{"location":"Kernel/Guide/Kernel-data-structure/#kernel#data#structure","text":"","title":"Kernel data structure"},{"location":"Kernel/Guide/Kernel-data-structure/#todo#table","text":"kernel\u7ba1\u7406\u7740OS\u7684\u4e00\u5207\u8d44\u6e90\uff0c\u56e0\u6b64\uff0c\u5b83\u4e00\u822c\u4f7f\u7528table\u6765\u8fdb\u884c\u7ba1\u7406\uff0c\u6bd4\u5982\uff1a table \u7b80\u4ecb \u53c2\u8003 \u8fdb\u7a0b\u8868 \u8bb0\u5f55OS\u4e2d\u7684\u6240\u6709\u7684process \u6587\u4ef6\u8868 \u8bb0\u5f55OS\u4e2d\u6240\u6709\u7684\u6253\u5f00\u7684\u6587\u4ef6 APUE socket table \u8bb0\u5f55OS\u4e2d\u7684\u6240\u6709\u7684socket - ss(8) - Linux man page - wikipedia TCP# Resource usage Routing table \u8bb0\u5f55\u8def\u7531\u89c4\u5219 wikipedia Routing table \u5e95\u5c42\u91c7\u7528\u4f55\u79cddata structure\u6765\u8fdb\u884c\u5b9e\u73b0\uff0c\u9700\u8981\u8003\u8651\u591a\u91cd\u56e0\u7d20\uff1a \u67e5\u627e\u7684\u65f6\u95f4\u590d\u6742\u5ea6 \u7a7a\u95f4\u590d\u6742\u5ea6","title":"TODO: \u5404\u79cd\u5404\u6837\u7684table"},{"location":"Kernel/Guide/Kernel-data-structure/#todo#entry#of#table","text":"\u524d\u9762\u4ecb\u7ecd\u4e86table\uff0c\u73b0\u5728\u4ecb\u7ecdentry of table\uff0c\u4e00\u822centry of table\u88ab\u79f0\u4e3a: ****** control block ****** descriptor \u6bd4\u5982: table entry \u53c2\u89c1 socket table Transmission Control Block or TCB - wikipedia TCP# Resource usage","title":"TODO: Entry of table"},{"location":"Kernel/Guide/Kernel-data-structure/#descriptor","text":"\u5404\u79cd\u5404\u6837\u7684descriptor\uff0c\u4ee5\u53ca\u5176\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784 Descriptor Chapter Struct Source Code Process Descriptor 3.2. Process Descriptor task_struct - https://github.com/torvalds/linux/blob/master/include/linux/sched.h - https://elixir.bootlin.com/linux/latest/ident/task_struct Memory Descriptor 9.2. The Memory Descriptor mm_struct - https://elixir.bootlin.com/linux/latest/ident/mm_struct - https://github.com/torvalds/linux/blob/master/include/linux/mm_types.h Page Descriptor 8.1.1. Page Descriptors page - https://elixir.bootlin.com/linux/latest/source/include/linux/mm_types.h#L68 Task State Segment Descriptor 3.3. Process Switch Global Descriptor Table memory descriptor signal descriptor file descriptors Interrupt Descriptor Table","title":"\u5404\u79cd\u5404\u6837\u7684descriptor"},{"location":"Kernel/Guide/Kernel-lifetime/Entry-point-of-kernel/","text":"Dose kernel have main function Linux Kernel And Its Functions Does the kernel have a main() function? closed Does kernel have main function?","title":"Entry-point-of-kernel"},{"location":"Kernel/Guide/Kernel-lifetime/Entry-point-of-kernel/#dose#kernel#have#main#function","text":"Linux Kernel And Its Functions Does the kernel have a main() function? closed Does kernel have main function?","title":"Dose kernel have main function"},{"location":"Kernel/Guide/Limit/","text":"\u5173\u4e8e\u672c\u7ae0 \u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\u4e00\u4e2aprocess\u53ef\u4ee5\u5360\u6709\u7684resource\uff0c\u7531\u4e8elinux OS\u662fmultitasking\u7684\uff0c\u6240\u4ee5OS\u4e2d\u540c\u65f6\u8fd0\u884c\u7740\u975e\u5e38\u591a\u7684process\uff0cOS\u9700\u8981\u80fd\u591f\u5bf9\u6bcf\u4e2aprocess\u7684resource\u8fdb\u884c**\u63a7\u5236**\uff0c\u4e00\u79cd\u6700\u6700\u5e38\u89c1\u7684\u63a7\u5236\u65b9\u5f0f\u5c31\u662f\u8fdb\u884climit\u3002limit\u5305\u542b\u4e86\u5bf9process\u6240\u80fd\u591f\u5360\u7528\u7684resource\u8fdb\u884c\u9650\u5236\u3001\u5bf9process\u80fd\u591f\u6267\u884c\u7684operation\u8fdb\u884c\u9650\u5236\uff0clinux\u4e2d\u4f7f\u7528 capabilities \u6765\u63cf\u8ff0process\u80fd\u591f\u6267\u884c\u7684\u64cd\u4f5c\uff0c\u663e\u7136\u5bf9process\u80fd\u591f\u6267\u884c\u7684operation\u7684\u9650\u5236\u662f\u901a\u8fc7\u9650\u5236 capabilities \u6765\u5b9e\u73b0\u7684\u3002 \u7531\u4e8elinux\u662fmulti-user system\uff0c\u597d\u5305\u62ec\u5bf9user\u8fdb\u884c\u9650\u5236\u3002 \u672c\u7ae0\u8ba8\u8bba\u5982\u4f55\u5bf9process\u7684resource\u8fdb\u884c\u9650\u5236\uff0c\u4e3b\u8981\u5305\u542b\uff1a \u63d0\u4f9b\u7cfb\u7edf\u914d\u7f6e\u6587\u4ef6\u8fdb\u884c\u663e\u5f0f \u901a\u8fc7system call\u8fdb\u884c\u9650\u5236","title":"Introduction"},{"location":"Kernel/Guide/Limit/#_1","text":"\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\u4e00\u4e2aprocess\u53ef\u4ee5\u5360\u6709\u7684resource\uff0c\u7531\u4e8elinux OS\u662fmultitasking\u7684\uff0c\u6240\u4ee5OS\u4e2d\u540c\u65f6\u8fd0\u884c\u7740\u975e\u5e38\u591a\u7684process\uff0cOS\u9700\u8981\u80fd\u591f\u5bf9\u6bcf\u4e2aprocess\u7684resource\u8fdb\u884c**\u63a7\u5236**\uff0c\u4e00\u79cd\u6700\u6700\u5e38\u89c1\u7684\u63a7\u5236\u65b9\u5f0f\u5c31\u662f\u8fdb\u884climit\u3002limit\u5305\u542b\u4e86\u5bf9process\u6240\u80fd\u591f\u5360\u7528\u7684resource\u8fdb\u884c\u9650\u5236\u3001\u5bf9process\u80fd\u591f\u6267\u884c\u7684operation\u8fdb\u884c\u9650\u5236\uff0clinux\u4e2d\u4f7f\u7528 capabilities \u6765\u63cf\u8ff0process\u80fd\u591f\u6267\u884c\u7684\u64cd\u4f5c\uff0c\u663e\u7136\u5bf9process\u80fd\u591f\u6267\u884c\u7684operation\u7684\u9650\u5236\u662f\u901a\u8fc7\u9650\u5236 capabilities \u6765\u5b9e\u73b0\u7684\u3002 \u7531\u4e8elinux\u662fmulti-user system\uff0c\u597d\u5305\u62ec\u5bf9user\u8fdb\u884c\u9650\u5236\u3002 \u672c\u7ae0\u8ba8\u8bba\u5982\u4f55\u5bf9process\u7684resource\u8fdb\u884c\u9650\u5236\uff0c\u4e3b\u8981\u5305\u542b\uff1a \u63d0\u4f9b\u7cfb\u7edf\u914d\u7f6e\u6587\u4ef6\u8fdb\u884c\u663e\u5f0f \u901a\u8fc7system call\u8fdb\u884c\u9650\u5236","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Kernel/Guide/Limit/Limit-via-configuration/","text":"LIMITS.CONF(5) LIMITS.CONF(5) \u6bd4\u5982\uff0c\u5728\u6309\u7167\u4e00\u4e9b\u4e3b\u8981\u8f6f\u4ef6\u7684\u65f6\u5019\uff0c\u4e00\u822c\u4ee5root\u7528\u6237\u8fd0\u884c vi /etc/security/limits.conf \uff0c\u589e\u52a0\u5982\u4e0b\u914d\u7f6e\uff1a * soft nproc 16384 * hard nproc 16384 * soft nofile 65536 * hard nofile 65536 \u4fee\u6539\u5b8c\u6bd5\u4ee5\u540e\uff0c\u9700\u91cd\u65b0\u767b\u5f55\uff0c\u4ee5\u4fbf\u751f\u6548\u3002 core dump unlimited username - core unlimited","title":"Limit-via-configuration"},{"location":"Kernel/Guide/Limit/Limit-via-configuration/#limitsconf5","text":"LIMITS.CONF(5) \u6bd4\u5982\uff0c\u5728\u6309\u7167\u4e00\u4e9b\u4e3b\u8981\u8f6f\u4ef6\u7684\u65f6\u5019\uff0c\u4e00\u822c\u4ee5root\u7528\u6237\u8fd0\u884c vi /etc/security/limits.conf \uff0c\u589e\u52a0\u5982\u4e0b\u914d\u7f6e\uff1a * soft nproc 16384 * hard nproc 16384 * soft nofile 65536 * hard nofile 65536 \u4fee\u6539\u5b8c\u6bd5\u4ee5\u540e\uff0c\u9700\u91cd\u65b0\u767b\u5f55\uff0c\u4ee5\u4fbf\u751f\u6548\u3002","title":"LIMITS.CONF(5)"},{"location":"Kernel/Guide/Limit/Limit-via-configuration/#core#dump#unlimited","text":"username - core unlimited","title":"core dump unlimited"},{"location":"Kernel/Guide/Limit/Limit-via-system-call/","text":"Limit via system call \u5728APUE\u76843.2.5-Process-Resource-Limits\u4e2d\u5bf9\u6b64\u6709\u4e13\u95e8\u4ecb\u7ecd\u3002","title":"Limit-via-system-call"},{"location":"Kernel/Guide/Limit/Limit-via-system-call/#limit#via#system#call","text":"\u5728APUE\u76843.2.5-Process-Resource-Limits\u4e2d\u5bf9\u6b64\u6709\u4e13\u95e8\u4ecb\u7ecd\u3002","title":"Limit via system call"},{"location":"Kernel/Guide/Limit/Process-resource-limits-under-the-hood/","text":"Process resource limits under the hood","title":"Process-resource-limits-under-the-hood"},{"location":"Kernel/Guide/Limit/Process-resource-limits-under-the-hood/#process#resource#limits#under#the#hood","text":"","title":"Process resource limits under the hood"},{"location":"Kernel/Guide/Limit/Ulimit/","text":"Ulimit ULIMIT(3) ulimit(1) ulimit -c unlimited \u5982\u679c\u4f60\u662f\u4e00\u4e2alinux OS\u7684\u5f00\u53d1\u8005\uff0c\u5efa\u8bae\u4f60\u5728\u4f60\u7684 .bash_profile \u4e2d\u6dfb\u52a0\u4e0a\u4e0a\u8ff0\u8bed\u53e5\uff0c\u5b83\u544a\u8bc9OS\uff0c\u4e0d\u9650\u5236core dump file\u7684\u5927\u5c0f\uff0c\u8fd9\u6837\u5f53\u4f60\u7684process\u6267\u884c\u4e86\u9519\u8bef\u7684\u64cd\u4f5c\u800c\u88abOS\u7ec8\u6b62\u7684\u65f6\u5019\uff0c\u4e00\u6765\uff0c\u4f60\u53ef\u4ee5\u53ca\u65f6\u7684\u83b7\u77e5\u8fd9\u79cd\u60c5\u51b5\u7684\u53d1\u9001\uff0c\u800c\u6765\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7 gdb \u6765\u8fdb\u884c\u5206\u6790\u3002 ulimit: core file size: cannot modify limit: Operation not permitted \u6709\u7684\u65f6\u5019\uff0c\u6267\u884c ulimit -c unlimited \u4f1a\u62a5\u8fd9\u79cd\u9519\u8bef\uff0c\u4fee\u6539\u65b9\u6848\u53c2\u89c1\u8fd9\u4e2a \u94fe\u63a5 ulimit is a shell builtin, and thus only affects the current shell, and processes started by that shell: $ type ulimit ulimit is a shell builtin From man ulimit : The ulimit utility shall set or report the file-size writing limit imposed on files written by the shell and its child processes (files of any size may be read). Only a process with appropriate privileges can increase the limit. So, yes, child processes are affected. To set limits permanently or for all processes, edit /etc/security/limits.conf and reboot. The examples in the manpage are fairly good. You just need to add something like: username - core unlimited","title":"Ulimit"},{"location":"Kernel/Guide/Limit/Ulimit/#ulimit","text":"","title":"Ulimit"},{"location":"Kernel/Guide/Limit/Ulimit/#ulimit3","text":"","title":"ULIMIT(3)"},{"location":"Kernel/Guide/Limit/Ulimit/#ulimit1","text":"","title":"ulimit(1)"},{"location":"Kernel/Guide/Limit/Ulimit/#ulimit#-c#unlimited","text":"\u5982\u679c\u4f60\u662f\u4e00\u4e2alinux OS\u7684\u5f00\u53d1\u8005\uff0c\u5efa\u8bae\u4f60\u5728\u4f60\u7684 .bash_profile \u4e2d\u6dfb\u52a0\u4e0a\u4e0a\u8ff0\u8bed\u53e5\uff0c\u5b83\u544a\u8bc9OS\uff0c\u4e0d\u9650\u5236core dump file\u7684\u5927\u5c0f\uff0c\u8fd9\u6837\u5f53\u4f60\u7684process\u6267\u884c\u4e86\u9519\u8bef\u7684\u64cd\u4f5c\u800c\u88abOS\u7ec8\u6b62\u7684\u65f6\u5019\uff0c\u4e00\u6765\uff0c\u4f60\u53ef\u4ee5\u53ca\u65f6\u7684\u83b7\u77e5\u8fd9\u79cd\u60c5\u51b5\u7684\u53d1\u9001\uff0c\u800c\u6765\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7 gdb \u6765\u8fdb\u884c\u5206\u6790\u3002","title":"ulimit -c unlimited"},{"location":"Kernel/Guide/Limit/Ulimit/#ulimit#core#file#size#cannot#modify#limit#operation#not#permitted","text":"\u6709\u7684\u65f6\u5019\uff0c\u6267\u884c ulimit -c unlimited \u4f1a\u62a5\u8fd9\u79cd\u9519\u8bef\uff0c\u4fee\u6539\u65b9\u6848\u53c2\u89c1\u8fd9\u4e2a \u94fe\u63a5 ulimit is a shell builtin, and thus only affects the current shell, and processes started by that shell: $ type ulimit ulimit is a shell builtin From man ulimit : The ulimit utility shall set or report the file-size writing limit imposed on files written by the shell and its child processes (files of any size may be read). Only a process with appropriate privileges can increase the limit. So, yes, child processes are affected. To set limits permanently or for all processes, edit /etc/security/limits.conf and reboot. The examples in the manpage are fairly good. You just need to add something like: username - core unlimited","title":"ulimit: core file size: cannot modify limit: Operation not permitted"},{"location":"Kernel/Guide/Linux-startup-process/","text":"Linux startup process 1\u3001\u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662f: \"LinuxOS\u7684\u542f\u52a8\u8fc7\u7a0b\"\u3002 2\u3001\u5bf9\u8fd9\u4e2a\u8fc7\u7a0b\u6709\u4e00\u4e2a\u5927\u81f4\u7684\u4e86\u89e3\u662f\u7531\u5fc5\u8981\u7684 wikipedia Linux startup process Linux startup process is the multi-stage initialization process performed during booting a Linux installation. It is in many ways similar to the BSD and other Unix -style boot processes, from which it derives. Booting a Linux installation involves multiple stages and software components, including firmware initialization, execution of a boot loader , loading and startup of a Linux kernel image, and execution of various startup scripts and daemons . For each of these stages and components there are different variations and approaches; for example, GRUB , LILO , SYSLINUX or Loadlin can be used as boot loaders, while the startup scripts can be either traditional init -style, or the system configuration can be performed through modern alternatives such as systemd or Upstart . NOTE: 1\u3001\u5f53\u4eca\u7684Linux\u7684boot loader\u3001init process\u90fd\u662f\u6709\u591a\u79cd\u53ef\u9009\u7684\uff0c\u4f5c\u4e3aprogrammer\uff0c\u6211\u4eec\u9700\u8981\u5bf9init process\u7684\u4e3b\u6d41\u7684\u65b9\u6848\u6709\u4e00\u4e2a\u5927\u81f4\u7684\u4e86\u89e3 Overview NOTE: 1\u3001\u4e0b\u9762\u7684\u5185\u5bb9\u57fa\u672c\u4e0a\u5305\u542b\u4e86programmer\u9700\u8981\u4e86\u89e3\u7684\u5185\u5bb9 Early stages of the Linux startup process depend very much on the computer architecture. IBM PC compatible hardware is one architecture Linux is commonly used on; on these systems, the BIOS plays an important role, which might not have exact analogs on other systems. In the following example, IBM PC compatible hardware is assumed: 1\u3001The BIOS performs startup tasks specific to the actual hardware platform. Once the hardware is enumerated and the hardware which is necessary for boot is initialized correctly, the BIOS loads and executes the boot code from the configured boot device . 2\u3001The boot loader often presents the user with a menu of possible boot options and has a default option, which is selected after some time passes. Once the selection is made, the boot loader loads the kernel into memory , supplies it with some parameters and gives it control. 3\u3001The kernel , if compressed, will decompress itself. It then sets up system functions such as essential hardware and memory paging, and calls start_kernel() which performs the majority of system setup (interrupts, the rest of memory management, device and driver initialization, etc.). It then starts up, separately, the idle process , scheduler, and the init process , which is executed in user space . NOTE: 1\u3001init process\u662f\u8fd0\u884c\u5728user space\u7684\uff0c\u4ee5root\u6743\u9650\u8fd0\u884c\uff0c\u8fd9\u975e\u5e38\u91cd\u8981 2\u3001\u4e0b\u9762\u5bf9init process\u7684\u4ecb\u7ecd\u662f\u9700\u8981programmer\u4e86\u89e3\u7684 4\u3001The init either consists of scripts that are executed by the shell (sysv, bsd, runit) or configuration files that are executed by the binary components (systemd, upstart). Init has specific levels (sysv, bsd) or targets (systemd), each of which consists of specific set of services (daemons). These provide various non-operating system services and structures and form the user environment. A typical server environment starts a web server, database services, and networking. 5\u3001The typical desktop environment begins with a daemon, called the display manager, that starts a graphic environment which consists of a graphical server that provides a basic underlying graphical stack and a login manager that provides the ability to enter credentials and select a session. After the user has entered the correct credentials, the session manager starts a session. A session is a set of programs such as UI elements (panels, desktops, applets, etc.) which, together, can form a complete desktop environment. Shutdown NOTE: 1\u3001\u4e0b\u9762\u8fd8\u4ecb\u7ecd\u4e86shutdown\u8fc7\u7a0b On shutdown, init is called to close down all user space functionality in a controlled manner. Once all the other processes have terminated, init makes a system call to the kernel instructing it to shut the system down. Boot loader phase NOTE: 1\u3001programmer\u53ef\u4ee5\u4e0d\u4e86\u89e3 Kernel phase NOTE: 1\u3001\u6709\u5fc5\u8981\u4e86\u89e3 The kernel in Linux handles all operating system processes, such as memory management , task scheduling , I/O , interprocess communication , and overall system control. This is loaded in two stages \u2013 in the first stage, the kernel (as a compressed image file) is loaded into memory and decompressed, and a few fundamental functions such as basic memory management are set up. Control is then switched one final time to the main kernel start process. Once the kernel is fully operational \u2013 and as part of its startup, upon being loaded and executing \u2013 the kernel looks for an init process to run, which (separately) sets up a user space and the processes needed for a user environment and ultimate login. The kernel itself is then allowed to go idle, subject to calls from other processes. For some platforms (like ARM 64-bit), kernel decompression has to be performed by the boot loader instead. Kernel loading stage The kernel is typically loaded as an image file, compressed into either zImage or bzImage formats with zlib . A routine at the head of it does a minimal amount of hardware setup, decompresses the image fully into high memory , and takes note of any RAM disk if configured.[ 3] It then executes kernel startup via ./arch/i386/boot/head and the startup_32 () (for x86 based processors) process. Kernel startup stage The startup function for the kernel (also called the swapper or process 0) establishes memory management (paging tables and memory paging), detects the type of CPU and any additional functionality such as floating point capabilities, and then switches to non-architecture specific Linux kernel functionality via a call to start_kernel() .[ 4] Early user space Main article: initramfs initramfs , also known as early user space , has been available since version 2.5.46 of the Linux kernel,[ 6] with the intent to replace as many functions as possible that previously the kernel would have performed during the start-up process. Typical uses of early user space are to detect what device drivers are needed to load the main user space file system and load them from a temporary filesystem . Init process NOTE: 1\u3001\u8fd9\u662f\u9700\u8981programmer\u638c\u63e1\u7684\uff0c\u5728 Operating-system-service-management \u7ae0\u8282\u5bf9\u5176\u8fdb\u884c\u4ecb\u7ecd 2\u3001\u8fd9\u662fLinux startup process\u6267\u884c\u7684\uff0c\u4e0d\u662f\u7531user\u6267\u884c\u7684 3\u3001\u6211\u4eec\u5e38\u8bf4\u7684\"\u5f00\u673a\u81ea\u542f\u52a8\"\u5c31\u662f\u5728\u8fd9\u4e2a\u73af\u8282 Once the kernel has started, it starts the init process. Historically this was the \"SysV init\", which was just called \"init\". More recent Linux distributions are likely to use one of the more modern alternatives such as \"systemd\". Basically, these are grouped as operating system service-management .","title":"Introduction"},{"location":"Kernel/Guide/Linux-startup-process/#linux#startup#process","text":"1\u3001\u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662f: \"LinuxOS\u7684\u542f\u52a8\u8fc7\u7a0b\"\u3002 2\u3001\u5bf9\u8fd9\u4e2a\u8fc7\u7a0b\u6709\u4e00\u4e2a\u5927\u81f4\u7684\u4e86\u89e3\u662f\u7531\u5fc5\u8981\u7684","title":"Linux startup process"},{"location":"Kernel/Guide/Linux-startup-process/#wikipedia#linux#startup#process","text":"Linux startup process is the multi-stage initialization process performed during booting a Linux installation. It is in many ways similar to the BSD and other Unix -style boot processes, from which it derives. Booting a Linux installation involves multiple stages and software components, including firmware initialization, execution of a boot loader , loading and startup of a Linux kernel image, and execution of various startup scripts and daemons . For each of these stages and components there are different variations and approaches; for example, GRUB , LILO , SYSLINUX or Loadlin can be used as boot loaders, while the startup scripts can be either traditional init -style, or the system configuration can be performed through modern alternatives such as systemd or Upstart . NOTE: 1\u3001\u5f53\u4eca\u7684Linux\u7684boot loader\u3001init process\u90fd\u662f\u6709\u591a\u79cd\u53ef\u9009\u7684\uff0c\u4f5c\u4e3aprogrammer\uff0c\u6211\u4eec\u9700\u8981\u5bf9init process\u7684\u4e3b\u6d41\u7684\u65b9\u6848\u6709\u4e00\u4e2a\u5927\u81f4\u7684\u4e86\u89e3","title":"wikipedia Linux startup process"},{"location":"Kernel/Guide/Linux-startup-process/#overview","text":"NOTE: 1\u3001\u4e0b\u9762\u7684\u5185\u5bb9\u57fa\u672c\u4e0a\u5305\u542b\u4e86programmer\u9700\u8981\u4e86\u89e3\u7684\u5185\u5bb9 Early stages of the Linux startup process depend very much on the computer architecture. IBM PC compatible hardware is one architecture Linux is commonly used on; on these systems, the BIOS plays an important role, which might not have exact analogs on other systems. In the following example, IBM PC compatible hardware is assumed: 1\u3001The BIOS performs startup tasks specific to the actual hardware platform. Once the hardware is enumerated and the hardware which is necessary for boot is initialized correctly, the BIOS loads and executes the boot code from the configured boot device . 2\u3001The boot loader often presents the user with a menu of possible boot options and has a default option, which is selected after some time passes. Once the selection is made, the boot loader loads the kernel into memory , supplies it with some parameters and gives it control. 3\u3001The kernel , if compressed, will decompress itself. It then sets up system functions such as essential hardware and memory paging, and calls start_kernel() which performs the majority of system setup (interrupts, the rest of memory management, device and driver initialization, etc.). It then starts up, separately, the idle process , scheduler, and the init process , which is executed in user space . NOTE: 1\u3001init process\u662f\u8fd0\u884c\u5728user space\u7684\uff0c\u4ee5root\u6743\u9650\u8fd0\u884c\uff0c\u8fd9\u975e\u5e38\u91cd\u8981 2\u3001\u4e0b\u9762\u5bf9init process\u7684\u4ecb\u7ecd\u662f\u9700\u8981programmer\u4e86\u89e3\u7684 4\u3001The init either consists of scripts that are executed by the shell (sysv, bsd, runit) or configuration files that are executed by the binary components (systemd, upstart). Init has specific levels (sysv, bsd) or targets (systemd), each of which consists of specific set of services (daemons). These provide various non-operating system services and structures and form the user environment. A typical server environment starts a web server, database services, and networking. 5\u3001The typical desktop environment begins with a daemon, called the display manager, that starts a graphic environment which consists of a graphical server that provides a basic underlying graphical stack and a login manager that provides the ability to enter credentials and select a session. After the user has entered the correct credentials, the session manager starts a session. A session is a set of programs such as UI elements (panels, desktops, applets, etc.) which, together, can form a complete desktop environment.","title":"Overview"},{"location":"Kernel/Guide/Linux-startup-process/#shutdown","text":"NOTE: 1\u3001\u4e0b\u9762\u8fd8\u4ecb\u7ecd\u4e86shutdown\u8fc7\u7a0b On shutdown, init is called to close down all user space functionality in a controlled manner. Once all the other processes have terminated, init makes a system call to the kernel instructing it to shut the system down.","title":"Shutdown"},{"location":"Kernel/Guide/Linux-startup-process/#boot#loader#phase","text":"NOTE: 1\u3001programmer\u53ef\u4ee5\u4e0d\u4e86\u89e3","title":"Boot loader phase"},{"location":"Kernel/Guide/Linux-startup-process/#kernel#phase","text":"NOTE: 1\u3001\u6709\u5fc5\u8981\u4e86\u89e3 The kernel in Linux handles all operating system processes, such as memory management , task scheduling , I/O , interprocess communication , and overall system control. This is loaded in two stages \u2013 in the first stage, the kernel (as a compressed image file) is loaded into memory and decompressed, and a few fundamental functions such as basic memory management are set up. Control is then switched one final time to the main kernel start process. Once the kernel is fully operational \u2013 and as part of its startup, upon being loaded and executing \u2013 the kernel looks for an init process to run, which (separately) sets up a user space and the processes needed for a user environment and ultimate login. The kernel itself is then allowed to go idle, subject to calls from other processes. For some platforms (like ARM 64-bit), kernel decompression has to be performed by the boot loader instead.","title":"Kernel phase"},{"location":"Kernel/Guide/Linux-startup-process/#kernel#loading#stage","text":"The kernel is typically loaded as an image file, compressed into either zImage or bzImage formats with zlib . A routine at the head of it does a minimal amount of hardware setup, decompresses the image fully into high memory , and takes note of any RAM disk if configured.[ 3] It then executes kernel startup via ./arch/i386/boot/head and the startup_32 () (for x86 based processors) process.","title":"Kernel loading stage"},{"location":"Kernel/Guide/Linux-startup-process/#kernel#startup#stage","text":"The startup function for the kernel (also called the swapper or process 0) establishes memory management (paging tables and memory paging), detects the type of CPU and any additional functionality such as floating point capabilities, and then switches to non-architecture specific Linux kernel functionality via a call to start_kernel() .[ 4]","title":"Kernel startup stage"},{"location":"Kernel/Guide/Linux-startup-process/#early#user#space","text":"Main article: initramfs initramfs , also known as early user space , has been available since version 2.5.46 of the Linux kernel,[ 6] with the intent to replace as many functions as possible that previously the kernel would have performed during the start-up process. Typical uses of early user space are to detect what device drivers are needed to load the main user space file system and load them from a temporary filesystem .","title":"Early user space"},{"location":"Kernel/Guide/Linux-startup-process/#init#process","text":"NOTE: 1\u3001\u8fd9\u662f\u9700\u8981programmer\u638c\u63e1\u7684\uff0c\u5728 Operating-system-service-management \u7ae0\u8282\u5bf9\u5176\u8fdb\u884c\u4ecb\u7ecd 2\u3001\u8fd9\u662fLinux startup process\u6267\u884c\u7684\uff0c\u4e0d\u662f\u7531user\u6267\u884c\u7684 3\u3001\u6211\u4eec\u5e38\u8bf4\u7684\"\u5f00\u673a\u81ea\u542f\u52a8\"\u5c31\u662f\u5728\u8fd9\u4e2a\u73af\u8282 Once the kernel has started, it starts the init process. Historically this was the \"SysV init\", which was just called \"init\". More recent Linux distributions are likely to use one of the more modern alternatives such as \"systemd\". Basically, these are grouped as operating system service-management .","title":"Init process"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/","text":"Operating-system service management \u5bf9OS\u7684service\u8fdb\u884c\u7ba1\u7406\uff0c\u8fd9\u662f\u6bcf\u4e2aOS\u90fd\u9700\u8981\u505a\u7684\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u5de5\u4f5c\u3002 wikipedia Operating system service management In computing , mechanisms and techniques for managing services often differ by operating system . Apple macOS launchd Many Linux distributions systemd","title":"Introduction"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/#operating-system#service#management","text":"\u5bf9OS\u7684service\u8fdb\u884c\u7ba1\u7406\uff0c\u8fd9\u662f\u6bcf\u4e2aOS\u90fd\u9700\u8981\u505a\u7684\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u5de5\u4f5c\u3002","title":"Operating-system service management"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/#wikipedia#operating#system#service#management","text":"In computing , mechanisms and techniques for managing services often differ by operating system .","title":"wikipedia Operating system service management"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/#apple#macos","text":"launchd","title":"Apple macOS"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/#many#linux#distributions","text":"systemd","title":"Many Linux distributions"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/","text":"systemd \u76ee\u524dcentos\u4f7f\u7528\u7684\u5c31\u662f systemd \u3002 wikipedia systemd systemd is a software suite that provides an array of system components for Linux operating systems. NOTE: 1\u3001\u5b83\u662f\u4e00\u5957\u8f6f\u4ef6 freedesktop systemd System and Service Manager TODO 1\u3001where dose systemd log\uff1f","title":"systemd"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/#systemd","text":"\u76ee\u524dcentos\u4f7f\u7528\u7684\u5c31\u662f systemd \u3002","title":"systemd"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/#wikipedia#systemd","text":"systemd is a software suite that provides an array of system components for Linux operating systems. NOTE: 1\u3001\u5b83\u662f\u4e00\u5957\u8f6f\u4ef6","title":"wikipedia systemd"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/#freedesktop#systemd#system#and#service#manager","text":"","title":"freedesktop systemd System and Service Manager"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/#todo","text":"1\u3001where dose systemd log\uff1f","title":"TODO"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/systemd-service/","text":"systemd.service freedesktop systemd.service Description \u00b6 A unit configuration file whose name ends in \" .service \" encodes information about a process controlled and supervised(\u76d1\u7763) by systemd . This man page lists the configuration options specific to this unit type. See systemd.unit(5) for the common options of all unit configuration files. The common configuration items are configured in the generic \" [Unit] \" and \" [Install] \" sections. The service specific configuration options are configured in the \" [Service] \" section. \u603b\u7ed3\uff1a\u7279\u5b9a\u7684\u7684\u914d\u7f6e\u9879\u548c\u901a\u7528\u7684\u914d\u7f6e\u9879\u3002 Additional options are listed in systemd.exec(5) , which define the execution environment the commands are executed in\uff08\u6267\u884c\u73af\u8282\uff09, and in systemd.kill(5) , which define the way the processes of the service are terminated(\u7ec8\u6b62\u6d41\u7a0b), and in systemd.resource-control(5) , which configure resource control settings for the processes of the service. If a service is requested under a certain name but no unit configuration file is found, systemd looks for a SysV init script by the same name (with the .service suffix removed) and dynamically creates a service unit from that script. This is useful for compatibility with SysV . Note that this compatibility is quite comprehensive but not 100%. For details about the incompatibilities, see the Incompatibilities with SysV document. Service Templates \u00b6 It is possible for systemd services to take a single argument via the \" service@argument.service \" syntax. Such services are called \"instantiated\" services, while the unit definition without the argument parameter is called a \"template\". An example could be a dhcpcd@.service service template which takes a network interface as a parameter to form an instantiated service. Within the service file, this parameter or \"instance name\" can be accessed with %-specifiers. See systemd.unit(5) for details. \u601d\u8003\uff1a\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5e76\u6ca1\u6709\u641e\u6e05\u695a Options \u00b6 Service files must include a \" [Service] \" section, which carries information about the service and the process it supervises\uff08\u76d1\u7ba1\uff09. A number of options that may be used in this section are shared with other unit types. These options are documented in systemd.exec(5) , systemd.kill(5) and systemd.resource-control(5) . The options specific to the \" [Service] \" section of service units are the following: how to run a program as a service in systemd system https://superuser.com/questions/1236961/running-an-executable-as-a-service-under-debian-8 https://www.tecmint.com/create-new-service-units-in-systemd/","title":"systemd.service"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/systemd-service/#systemdservice","text":"","title":"systemd.service"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/systemd-service/#freedesktop#systemdservice","text":"","title":"freedesktop systemd.service"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/systemd-service/#description","text":"A unit configuration file whose name ends in \" .service \" encodes information about a process controlled and supervised(\u76d1\u7763) by systemd . This man page lists the configuration options specific to this unit type. See systemd.unit(5) for the common options of all unit configuration files. The common configuration items are configured in the generic \" [Unit] \" and \" [Install] \" sections. The service specific configuration options are configured in the \" [Service] \" section. \u603b\u7ed3\uff1a\u7279\u5b9a\u7684\u7684\u914d\u7f6e\u9879\u548c\u901a\u7528\u7684\u914d\u7f6e\u9879\u3002 Additional options are listed in systemd.exec(5) , which define the execution environment the commands are executed in\uff08\u6267\u884c\u73af\u8282\uff09, and in systemd.kill(5) , which define the way the processes of the service are terminated(\u7ec8\u6b62\u6d41\u7a0b), and in systemd.resource-control(5) , which configure resource control settings for the processes of the service. If a service is requested under a certain name but no unit configuration file is found, systemd looks for a SysV init script by the same name (with the .service suffix removed) and dynamically creates a service unit from that script. This is useful for compatibility with SysV . Note that this compatibility is quite comprehensive but not 100%. For details about the incompatibilities, see the Incompatibilities with SysV document.","title":"Description\u00b6"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/systemd-service/#service#templates","text":"It is possible for systemd services to take a single argument via the \" service@argument.service \" syntax. Such services are called \"instantiated\" services, while the unit definition without the argument parameter is called a \"template\". An example could be a dhcpcd@.service service template which takes a network interface as a parameter to form an instantiated service. Within the service file, this parameter or \"instance name\" can be accessed with %-specifiers. See systemd.unit(5) for details. \u601d\u8003\uff1a\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5e76\u6ca1\u6709\u641e\u6e05\u695a","title":"Service Templates\u00b6"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/systemd-service/#options","text":"Service files must include a \" [Service] \" section, which carries information about the service and the process it supervises\uff08\u76d1\u7ba1\uff09. A number of options that may be used in this section are shared with other unit types. These options are documented in systemd.exec(5) , systemd.kill(5) and systemd.resource-control(5) . The options specific to the \" [Service] \" section of service units are the following:","title":"Options\u00b6"},{"location":"Kernel/Guide/Linux-startup-process/Operating-system-service-management/systemd/systemd-service/#how#to#run#a#program#as#a#service#in#systemd#system","text":"https://superuser.com/questions/1236961/running-an-executable-as-a-service-under-debian-8 https://www.tecmint.com/create-new-service-units-in-systemd/","title":"how to run a program as a service in systemd system"},{"location":"Kernel/Guide/Linux-startup-process/init-process/","text":"","title":"Introduction"},{"location":"Kernel/Guide/Memory-management/","text":"Memory management \u672c\u7ae0\u4e3b\u8981\u63cf\u8ff0\u73b0\u4ee3Linux OS kernel\u7684Memory management\uff0c\u800c\u975eprocess\u7684memory management\uff0c\u7ef4\u57fa\u767e\u79d1 Memory management \u6ca1\u6709\u5c06\u4e24\u8005\u533a\u5206\u5f00\u6765\uff0c\u56e0\u4e3a\u8fd9\u4e24\u8005\u662f\u6709\u7740\u5bc6\u5207\u5173\u8054\u7684\uff0c\u5b83\u4e3b\u8981\u8ba8\u8bba\u7684\u662fprocess\u7684memory management\uff0c\u6240\u4ee5\u672c\u7ae0\u4e0d\u5f15\u7528\u8fd9\u7bc7\u6587\u7ae0\uff0c\u4f46\u662f\u7ef4\u57fa\u767e\u79d1\u5bf9memory management\u7684\u76f8\u5173\u7684\u5185\u5bb9\u603b\u7ed3\u8fd8\u662f\u975e\u5e38\u597d\u7684\u3002OS kernel\u7684memory management\u6280\u672f\u5c42\u51fa\u4e0d\u7a77\uff0c\u672c\u7ae0\u6240\u5173\u6ce8\u7684\u662f\u73b0\u4ee3OS\u666e\u904d\u4f7f\u7528\u7684 Paged virtual memory \u6280\u672f\uff08 Memory segmentation \u88ab\u89c6\u4e3alegacy \u4e86\uff09\u3002","title":"Introduction"},{"location":"Kernel/Guide/Memory-management/#memory#management","text":"\u672c\u7ae0\u4e3b\u8981\u63cf\u8ff0\u73b0\u4ee3Linux OS kernel\u7684Memory management\uff0c\u800c\u975eprocess\u7684memory management\uff0c\u7ef4\u57fa\u767e\u79d1 Memory management \u6ca1\u6709\u5c06\u4e24\u8005\u533a\u5206\u5f00\u6765\uff0c\u56e0\u4e3a\u8fd9\u4e24\u8005\u662f\u6709\u7740\u5bc6\u5207\u5173\u8054\u7684\uff0c\u5b83\u4e3b\u8981\u8ba8\u8bba\u7684\u662fprocess\u7684memory management\uff0c\u6240\u4ee5\u672c\u7ae0\u4e0d\u5f15\u7528\u8fd9\u7bc7\u6587\u7ae0\uff0c\u4f46\u662f\u7ef4\u57fa\u767e\u79d1\u5bf9memory management\u7684\u76f8\u5173\u7684\u5185\u5bb9\u603b\u7ed3\u8fd8\u662f\u975e\u5e38\u597d\u7684\u3002OS kernel\u7684memory management\u6280\u672f\u5c42\u51fa\u4e0d\u7a77\uff0c\u672c\u7ae0\u6240\u5173\u6ce8\u7684\u662f\u73b0\u4ee3OS\u666e\u904d\u4f7f\u7528\u7684 Paged virtual memory \u6280\u672f\uff08 Memory segmentation \u88ab\u89c6\u4e3alegacy \u4e86\uff09\u3002","title":"Memory management"},{"location":"Kernel/Guide/Memory-management/Difference-Between-Paging-and-Segmentation-in-OS/","text":"Difference Between Paging and Segmentation in OS The memory management in the operating system is an essential functionality, which allows the allocation of memory to the processes for execution and deallocates the memory when the process is no longer needed. In this article, we will discuss two memory management schemes paging and segmentation . The basic difference between paging and segmentation is that, \u201cpage\u201d is a fixed-sized block whereas, a \u201csegment\u201d is a variable-sized block. NOTE : \u5176\u5b9e\uff0c\u8fd9\u4e2a\u5dee\u522b\u5c31\u51b3\u5b9a\u4e86segment\u662f\u9700\u8981\u8bb0\u5f55\u4e0b\u5b83\u7684\u6bcf\u4e2ablock\u7684size\u7684\uff0c\u800cpage\u663e\u7136\u4e0d\u9700\u8981 We will discuss some more differences between Paging and Segmentation with the help of comparison chart shown below. Content: Paging Vs Segmentation Comparison Chart Definition Key Differences Conclusion Comparison Chart BASIS FOR COMPARISON PAGING SEGMENTATION Basic A page is of fixed block size. A segment is of variable size. Fragmentation\uff08\u788e\u7247\uff09 Paging may lead to internal fragmentation . Segmentation may lead to external fragmentation . Address The user specified address is divided by CPU into a page number and offset . The user specifies each address by two quantities a segment number and the offset (Segment limit). Size The hardware decides the page size . The segment size is specified by the user. Table Paging involves a page table that contains base address of each page. Segmentation involves the segment table that contains segment number and offset (segment length). Definition of Paging Paging is a memory management scheme . Paging allows a process to be stored in a memory in a non-contiguous manner. Storing process in a non-contiguous manner solves the problem of external fragmentation . For implementing paging the physical and logical memory spaces are divided into the same fixed-sized blocks. These fixed-sized blocks of physical memory are called frames , and the fixed-sized blocks of logical memory are called pages . SUMMARY :\u6ce8\u610f**pages**\u548c**frames**\u7684\u542b\u4e49\u662f\u4e0d\u540c\u7684\uff1b When a process needs to be executed the process pages from logical memory space are loaded into the frames of physical memory address space. Now the address generated by CPU for accessing the frame is divided into two parts i.e. page number and page offset . The page table uses page number as an index; each process has its separate page table that maps logical address to the physical address . The page table contains base address of the page stored in the frame of physical memory space. The base address defined by page table is combined with the page offset to define the frame number in physical memory where the page is stored. Definition of Segmentation Like Paging, Segmentation is also a memory management scheme . It supports the user\u2019s view of the memory. The process is divided into the variable size segments and loaded to the logical memory address space . The logical address space is the collection of variable size segments. Each segment has its name and length . For the execution, the segments from logical memory space are loaded to the physical memory space . The address specified by the user contain two quantities the segment name and the Offset . The segments are numbered and referred by the segment number instead of segment name. This segment number is used as an index in the segment table , and offset value decides the length or limit of the segment. The segment number and the offset together combinely generates the address of the segment in the physical memory space. Key Differences Between Paging and Segmentation The basic difference between paging and segmentation is that a page is always of fixed block size whereas, a segment is of variable size . Paging may lead to internal fragmentation as the page is of fixed block size, but it may happen that the process does not acquire the entire block size which will generate the internal fragment in memory. The segmentation may lead to external fragmentation as the memory is filled with the variable sized blocks. In paging the user only provides a single integer as the address which is divided by the hardware into a page number and Offset . On the other hands, in segmentation the user specifies the address in two quantities i.e. segment number and offset . The size of the page is decided or specified by the hardware . On the other hands, the size of the segment is specified by the user . In paging, the page table maps the logical address to the physical address , and it contains base address of each page stored in the frames of physical memory space. However, in segmentation, the segment table maps the logical address to the physical address , and it contains segment number and offset (segment limit). Conclusion: Paging and segmentation both are the memory management schemes . Paging allows the memory to be divided into fixed sized block whereas the segmentation, divides the memory space into segments of the variable block size . Where the paging leads to internal fragmentation the segmentation leads to external fragmentation .","title":"Difference-Between-Paging-and-Segmentation-in-OS"},{"location":"Kernel/Guide/Memory-management/Difference-Between-Paging-and-Segmentation-in-OS/#difference#between#paging#and#segmentation#in#os","text":"The memory management in the operating system is an essential functionality, which allows the allocation of memory to the processes for execution and deallocates the memory when the process is no longer needed. In this article, we will discuss two memory management schemes paging and segmentation . The basic difference between paging and segmentation is that, \u201cpage\u201d is a fixed-sized block whereas, a \u201csegment\u201d is a variable-sized block. NOTE : \u5176\u5b9e\uff0c\u8fd9\u4e2a\u5dee\u522b\u5c31\u51b3\u5b9a\u4e86segment\u662f\u9700\u8981\u8bb0\u5f55\u4e0b\u5b83\u7684\u6bcf\u4e2ablock\u7684size\u7684\uff0c\u800cpage\u663e\u7136\u4e0d\u9700\u8981 We will discuss some more differences between Paging and Segmentation with the help of comparison chart shown below.","title":"Difference Between Paging and Segmentation in OS"},{"location":"Kernel/Guide/Memory-management/Difference-Between-Paging-and-Segmentation-in-OS/#content#paging#vs#segmentation","text":"Comparison Chart Definition Key Differences Conclusion","title":"Content: Paging Vs Segmentation"},{"location":"Kernel/Guide/Memory-management/Difference-Between-Paging-and-Segmentation-in-OS/#comparison#chart","text":"BASIS FOR COMPARISON PAGING SEGMENTATION Basic A page is of fixed block size. A segment is of variable size. Fragmentation\uff08\u788e\u7247\uff09 Paging may lead to internal fragmentation . Segmentation may lead to external fragmentation . Address The user specified address is divided by CPU into a page number and offset . The user specifies each address by two quantities a segment number and the offset (Segment limit). Size The hardware decides the page size . The segment size is specified by the user. Table Paging involves a page table that contains base address of each page. Segmentation involves the segment table that contains segment number and offset (segment length).","title":"Comparison Chart"},{"location":"Kernel/Guide/Memory-management/Difference-Between-Paging-and-Segmentation-in-OS/#definition#of#paging","text":"Paging is a memory management scheme . Paging allows a process to be stored in a memory in a non-contiguous manner. Storing process in a non-contiguous manner solves the problem of external fragmentation . For implementing paging the physical and logical memory spaces are divided into the same fixed-sized blocks. These fixed-sized blocks of physical memory are called frames , and the fixed-sized blocks of logical memory are called pages . SUMMARY :\u6ce8\u610f**pages**\u548c**frames**\u7684\u542b\u4e49\u662f\u4e0d\u540c\u7684\uff1b When a process needs to be executed the process pages from logical memory space are loaded into the frames of physical memory address space. Now the address generated by CPU for accessing the frame is divided into two parts i.e. page number and page offset . The page table uses page number as an index; each process has its separate page table that maps logical address to the physical address . The page table contains base address of the page stored in the frame of physical memory space. The base address defined by page table is combined with the page offset to define the frame number in physical memory where the page is stored.","title":"Definition of Paging"},{"location":"Kernel/Guide/Memory-management/Difference-Between-Paging-and-Segmentation-in-OS/#definition#of#segmentation","text":"Like Paging, Segmentation is also a memory management scheme . It supports the user\u2019s view of the memory. The process is divided into the variable size segments and loaded to the logical memory address space . The logical address space is the collection of variable size segments. Each segment has its name and length . For the execution, the segments from logical memory space are loaded to the physical memory space . The address specified by the user contain two quantities the segment name and the Offset . The segments are numbered and referred by the segment number instead of segment name. This segment number is used as an index in the segment table , and offset value decides the length or limit of the segment. The segment number and the offset together combinely generates the address of the segment in the physical memory space.","title":"Definition of Segmentation"},{"location":"Kernel/Guide/Memory-management/Difference-Between-Paging-and-Segmentation-in-OS/#key#differences#between#paging#and#segmentation","text":"The basic difference between paging and segmentation is that a page is always of fixed block size whereas, a segment is of variable size . Paging may lead to internal fragmentation as the page is of fixed block size, but it may happen that the process does not acquire the entire block size which will generate the internal fragment in memory. The segmentation may lead to external fragmentation as the memory is filled with the variable sized blocks. In paging the user only provides a single integer as the address which is divided by the hardware into a page number and Offset . On the other hands, in segmentation the user specifies the address in two quantities i.e. segment number and offset . The size of the page is decided or specified by the hardware . On the other hands, the size of the segment is specified by the user . In paging, the page table maps the logical address to the physical address , and it contains base address of each page stored in the frames of physical memory space. However, in segmentation, the segment table maps the logical address to the physical address , and it contains segment number and offset (segment limit).","title":"Key Differences Between Paging and Segmentation"},{"location":"Kernel/Guide/Memory-management/Difference-Between-Paging-and-Segmentation-in-OS/#conclusion","text":"Paging and segmentation both are the memory management schemes . Paging allows the memory to be divided into fixed sized block whereas the segmentation, divides the memory space into segments of the variable block size . Where the paging leads to internal fragmentation the segmentation leads to external fragmentation .","title":"Conclusion:"},{"location":"Kernel/Guide/Memory-management/Fragmentation/","text":"Fragmentation wikipedia Fragmentation (computing) Basic principle NOTE: \u7406\u89e3\u8fd9\u4e00\u6bb5\u7684\u6838\u5fc3\u662f\u7406\u89e3\"chunk\"\u8fd9\u4e2a\u8bcd\uff0c\u5b83\u8868\u793a\u7684\u662f\u8fde\u7eed\u7684\u5185\u5b58\u7a7a\u95f4 When a computer program requests blocks of memory from the computer system, the blocks are allocated in chunks. When the computer program is finished with a chunk, it can free it back to the system, making it available to later be allocated again to another or the same program. The size and the amount of time a chunk is held by a program varies. During its lifespan, a computer program can request and free many chunks of memory. When a program is started, the free memory areas are long and contiguous. Over time and with use, the long contiguous regions become fragmented into smaller and smaller contiguous areas. Eventually, it may become impossible for the program to obtain large contiguous chunks of memory. Types Internal fragmentation NOTE: \u4e8e\u6b64\u76f8\u5173\u7684\u662falignment\uff0c\u53c2\u89c1\u5de5\u7a0bhardware\u7684 CPU\\Memory-access\\Memory-alignment \u7ae0\u8282\u3002 \u663e\u7136\u8fd9\u79cdfragmentation\u662f\u7531computer\u7684internal\u673a\u5236\u6240\u51b3\u5b9a\u7684\uff0c\u53ef\u4ee5\u8bf4\u662f\u5b83\u5929\u751f\u7684 Due to the rules governing memory allocation , more computer memory is sometimes allocated than is needed. For example, memory can only be provided to programs in chunks (multiple of 4), and as a result if a program requests perhaps 29 bytes, it will actually get a chunk of 32 bytes. When this happens, the excess memory goes to waste. In this scenario, the unusable memory is contained within an allocated region. This arrangement, termed fixed partitions, suffers from inefficient memory use - any process, no matter how small, occupies an entire partition. This waste is called internal fragmentation .[ 1] [ 2] Unlike other types of fragmentation, internal fragmentation is difficult to reclaim; usually the best way to remove it is with a design change. For example, in dynamic memory allocation , memory pools drastically cut internal fragmentation by spreading the space overhead over a larger number of objects. External fragmentation External fragmentation arises when free memory is separated into small blocks and is interspersed by allocated memory. It is a weakness of certain storage allocation algorithms, when they fail to order memory used by programs efficiently. The result is that, although free storage is available, it is effectively unusable because it is divided into pieces that are too small individually to satisfy the demands of the application. The term \"external\" refers to the fact that the unusable storage is outside the allocated regions. Data fragmentation NOTE: TODO stackoverflow Memory fragmentation A As per ISO/IEC 9899:201x -> 7.22.3 The order and contiguity of storage allocated by successive calls to the aligned_alloc, calloc, malloc, and realloc functions is unspecified. A good memory manager will be able to tackle the issue to an extent. However, there are other aspects like data alignment [ 1] which causes internal fragmentation. What you could do if you rely on inbuilt memory management? Use a profiler - say valgrind - with memory check option to find the memory which is not freed after use. Example: valgrind -- leak - check = yes myprog arg1 arg2 Follow good practices. Example - In C++, if you intend others to inherit from your polymorphic class, you may declare its destructor virtual. Use smart pointers. Notes: Internal fragmentation . If you were to use your own memory management system, you may consider Boehm-Demers-Weiser garbage collector. Valgrind Instrumentation Framework. Memory not freed after use will contribute to fragmentation. Example 1) wikipedia Memory-mapped file : For small files, memory-mapped files can result in a waste of slack space [ 7] as memory maps are always aligned to the page size, which is mostly 4 KiB. Therefore, a 5 KiB file will allocate 8 KiB and thus 3 KiB are wasted.","title":"Introduction"},{"location":"Kernel/Guide/Memory-management/Fragmentation/#fragmentation","text":"","title":"Fragmentation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/#wikipedia#fragmentation#computing","text":"","title":"wikipedia Fragmentation (computing)"},{"location":"Kernel/Guide/Memory-management/Fragmentation/#basic#principle","text":"NOTE: \u7406\u89e3\u8fd9\u4e00\u6bb5\u7684\u6838\u5fc3\u662f\u7406\u89e3\"chunk\"\u8fd9\u4e2a\u8bcd\uff0c\u5b83\u8868\u793a\u7684\u662f\u8fde\u7eed\u7684\u5185\u5b58\u7a7a\u95f4 When a computer program requests blocks of memory from the computer system, the blocks are allocated in chunks. When the computer program is finished with a chunk, it can free it back to the system, making it available to later be allocated again to another or the same program. The size and the amount of time a chunk is held by a program varies. During its lifespan, a computer program can request and free many chunks of memory. When a program is started, the free memory areas are long and contiguous. Over time and with use, the long contiguous regions become fragmented into smaller and smaller contiguous areas. Eventually, it may become impossible for the program to obtain large contiguous chunks of memory.","title":"Basic principle"},{"location":"Kernel/Guide/Memory-management/Fragmentation/#types","text":"","title":"Types"},{"location":"Kernel/Guide/Memory-management/Fragmentation/#internal#fragmentation","text":"NOTE: \u4e8e\u6b64\u76f8\u5173\u7684\u662falignment\uff0c\u53c2\u89c1\u5de5\u7a0bhardware\u7684 CPU\\Memory-access\\Memory-alignment \u7ae0\u8282\u3002 \u663e\u7136\u8fd9\u79cdfragmentation\u662f\u7531computer\u7684internal\u673a\u5236\u6240\u51b3\u5b9a\u7684\uff0c\u53ef\u4ee5\u8bf4\u662f\u5b83\u5929\u751f\u7684 Due to the rules governing memory allocation , more computer memory is sometimes allocated than is needed. For example, memory can only be provided to programs in chunks (multiple of 4), and as a result if a program requests perhaps 29 bytes, it will actually get a chunk of 32 bytes. When this happens, the excess memory goes to waste. In this scenario, the unusable memory is contained within an allocated region. This arrangement, termed fixed partitions, suffers from inefficient memory use - any process, no matter how small, occupies an entire partition. This waste is called internal fragmentation .[ 1] [ 2] Unlike other types of fragmentation, internal fragmentation is difficult to reclaim; usually the best way to remove it is with a design change. For example, in dynamic memory allocation , memory pools drastically cut internal fragmentation by spreading the space overhead over a larger number of objects.","title":"Internal fragmentation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/#external#fragmentation","text":"External fragmentation arises when free memory is separated into small blocks and is interspersed by allocated memory. It is a weakness of certain storage allocation algorithms, when they fail to order memory used by programs efficiently. The result is that, although free storage is available, it is effectively unusable because it is divided into pieces that are too small individually to satisfy the demands of the application. The term \"external\" refers to the fact that the unusable storage is outside the allocated regions.","title":"External fragmentation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/#data#fragmentation","text":"NOTE: TODO","title":"Data fragmentation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/#stackoverflow#memory#fragmentation","text":"A As per ISO/IEC 9899:201x -> 7.22.3 The order and contiguity of storage allocated by successive calls to the aligned_alloc, calloc, malloc, and realloc functions is unspecified. A good memory manager will be able to tackle the issue to an extent. However, there are other aspects like data alignment [ 1] which causes internal fragmentation. What you could do if you rely on inbuilt memory management? Use a profiler - say valgrind - with memory check option to find the memory which is not freed after use. Example: valgrind -- leak - check = yes myprog arg1 arg2 Follow good practices. Example - In C++, if you intend others to inherit from your polymorphic class, you may declare its destructor virtual. Use smart pointers. Notes: Internal fragmentation . If you were to use your own memory management system, you may consider Boehm-Demers-Weiser garbage collector. Valgrind Instrumentation Framework. Memory not freed after use will contribute to fragmentation.","title":"stackoverflow Memory fragmentation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/#example","text":"","title":"Example"},{"location":"Kernel/Guide/Memory-management/Fragmentation/#1#wikipedia#memory-mapped#file","text":"For small files, memory-mapped files can result in a waste of slack space [ 7] as memory maps are always aligned to the page size, which is mostly 4 KiB. Therefore, a 5 KiB file will allocate 8 KiB and thus 3 KiB are wasted.","title":"1) wikipedia Memory-mapped file:"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Defragmentation/","text":"Defragmentation wikipedia Defragmentation","title":"Introduction"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Defragmentation/#defragmentation","text":"","title":"Defragmentation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Defragmentation/#wikipedia#defragmentation","text":"","title":"wikipedia Defragmentation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/","text":"Heap Fragmentation cpp4arduino What is Heap Fragmentation? NOTE: \u8fd9\u7bc7\u6587\u7ae0\u975e\u5e38\u597d\uff0c\u4e0d\u4ec5\u975e\u5e38\u5f62\u8c61\u7684\u63cf\u8ff0\u4e86heap fragmentation\u7684\u542b\u4e49\uff0c\u5e76\u4e14\u63cf\u8ff0\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u7684\u65b9\u6cd5\u3002 There is a lot of free memory, so why allocation fails? My program ran well for hours/days/months, why does it crash now? Why does my program run slower over time? Believe or not, the answers to these three questions are the same: you have a heap fragmentation problem. In this article, we\u2019ll see what it means and how to fix it. What is the heap? The \u201cheap\u201d is the area of the RAM where the dynamic memory allocation happens. Every time you call malloc() , you reserve a block of memory in the heap. Similarly, every time you call new , you reserve a block in the heap. Because new calls malloc() and delete calls free() , everything we\u2019ll see equally applies to new and delete . Very often, your program allocates heap memory without explicitly calling malloc() . For example, when you create a String object, the constructor allocates some space in the heap to store the characters. What is heap fragmentation? When you call free() to release a block, you create a hole of unused memory. After some time, the heap becomes a swiss cheese with many holes . NOTE: \" swiss cheese with many holes \"\u662f\u4e00\u4e2a\u975e\u5e38\u5f62\u8c61\u7684\u6bd4\u55bb Here is a simplified view with an imaginary heap of 30 bytes: The holes count as free memory, so there are 20 bytes available. However, we are unable to allocate 20 bytes because there is not a consecutive(\u8fde\u7eed\u7684) block of 20 free bytes. This phenomenon is what we call \u201cheap fragmentation.\u201d It\u2019s an inefficient utilization of the RAM that prevents a program from using the full capacity of the microcontroller(\u5fae\u63a7\u5236\u5668). NOTE: \u5728\u5d4c\u5165\u5f0f\u4e2d\uff0c\u4f7f\u7528\"microcontroller\"\u8fd9\u4e2a\u8bcd\u8bed When does fragmentation happen? Suppose you just released a block of memory and therefore created a hole in the heap. Is that always a problem? There are three possibilities. First possibility: you allocate another block of the same size. The new block takes the place left by the old one. No hole remains. Second possibility: you allocate a smaller block. The new block fits in the hole but doesn\u2019t fill it. A small hole remains. Third possibility: you allocate a larger block. The new block cannot fit in the hole, so it\u2019s allocated further in the heap. A big hole remains. As you see, only a program that allocates and releases blocks of different size increases the heap fragmentation . An example Now that we get the theory, let\u2019s see a concrete example. Consider a loop() function that downloads the weather forecasts from a web server. It first saves the response a big String ; then it extracts the date, the city, the temperature, the humidity(\u6e7f\u5ea6), and the weather description in five String s of various size. String serverResponse ; String date , city , temperature , humidity , description ; void loop () { serverResponse = downloadFromServer (); date = extractDate ( serverResponse ); city = extractCity ( serverResponse ); temperature = extractTemperature ( serverResponse ); description = extractDescription ( serverResponse ); } The first iteration of loop() is OK: it allocates the String s in the heap but doesn\u2019t release them, so no fragmentation happens. Then, each iteration creates new String s to replace the old ones. The new String s allocate new blocks and the old String s release the old blocks. Here is the problem: every time the server returns a different response, the sizes of the blocks change. As we saw, allocation of varying sizes creates holes in the heap, which increases the fragmentation. NOTE: varying size\u662f\u975e\u5e38\u5bb9\u6613\u9020\u6210heap fragmentation\u7684\uff0c\u56e0\u6b64\u4e00\u4e2a\u89e3\u51b3\u65b9\u6cd5\u662f\u4f7f\u7528 \"Strategy 3: Constant allocation\" Measuring the fragmentation There are several formal definitions for the fragmentation; in this article, I\u2019ll use this simple definition: Let\u2019s try some numbers in this formula. Suppose you have 1KB of free RAM. At 0% (no fragmentation), you can allocate 1KB in one shot. At 25%, you can allocate 750B in one shot. At 50%, you can only allocate 500B in one shot. At 75%, you can only allocate 250B in one shot. A value of 50% or more is considered high and can seriously impede(\u963b\u788d) your program, as we\u2019ll see. How fragmentation evolves over time Now that we have a formal definition, let\u2019s write a program that will show the evolution of the fragmentation over time. Computing the fragmentation To compute the fragmentation percentage, we apply the formula and multiply by 100: float getFragmentation () { return 100 - getLargestAvailableBlock () * 100.0 / getTotalAvailableMemory (); } As you can guess, getLargestAvailableBlock() returns the size of the largest allocable block, and getTotalAvailableMemory() returns the total free memory. Writing these two functions is the trickiest(\u68d8\u624b\u7684) part of this program because they are dependent on the platform. In the code samples , I implemented a version for AVR (Arduino UNO et al.) and another for ESP8266. Drilling(\u6f14\u7ec3) holes To produce fragmentation, we saw that we could use a few String s of various size and replace them repeatedly. The easiest way to do that is to have an array of String and to replace them with random values: String strings [ NUMBER_OF_STRINGS ]; for ( String & s : strings ) s = generateRandomString (); As the name suggests, generateRandomString() returns a String whose length varies from one call to the other: String generateRandomString () { String result ; int len = random ( SMALLEST_STRING , LARGEST_STRING ); while ( len -- ) result += '?' ; return result ; } This program roughly simulates the weather forecast example. The results I obtained the following graph with 20 strings whose length varied from 10 to 50 characters. The program ran on an Arduino UNO. As you see, when the program starts, the fragmentation is close to zero and then increases irregularly until it stabilizes at about 70%. I encourage you to tweak the settings to see the effect on the fragmentation. In particular, you\u2019ll see that when SMALLEST_STRING and LARGEST_STRING are equals, i.e., if the String s are all of the same sizes, no fragmentation occurs. Why is heap fragmentation bad? We saw how fragmentation increases, now let\u2019s talk about the consequences of a high fragmentation level. Consequence 1: Unreliable program By definition, a high fragmentation level means you have a lot of free memory, but you can only allocate small blocks. If your program needs a bigger block, it will not get it and will stop working. Consequence 2: Degraded performance A highly fragmented heap is slower because the memory allocator takes more time to find the best hole, the so-called \u201cbest-fit.\u201d If it\u2019s so huge, why nobody talks about it? Heap fragmentation is a solved problem for most programmers, but not for us Arduino programmers. Let\u2019s see how other platforms handle the problem. Solution 1: Virtual memory The programs running on our computers use Virtual Memory . The value of the pointer is not the physical location in the RAM; instead, the CPU translates the address on the fly. This decoupling allows defragmenting the RAM without moving anything but requires dedicated hardware that we do not have on our microcontrollers. Solution 2: Optimized allocators Either as part of the standard library or as a linked library, C++ programs running on a computer embeds a heap allocator that is much more efficient than what we have on our Arduinos. The most common optimization is to gather small blocks into bins: one bin for blocks of 4 bytes, one bin for 8 bytes, etc. Thanks to this technique the small objects don\u2019t contribute to and are not affected by the fragmentation. Solution 3: Short string optimization Even if the C++ standard doesn\u2019t mandate it, all implementations of std::string support the \u201cSmall String Optimization,\u201d or SSO. std::string stores short strings locally and only uses the heap for long strings. By reducing the number of small objects in the heap, the SSO reduces the fragmentation. Unfortunately, the String class doesn\u2019t perform SSO in Arduino. Solution 4: Heap compacting(\u7d27\u51d1) In languages with managed memory, the garbage collector moves the memory blocks to squash the holes. We cannot use this technique in C++ because moving a block would change its address, so all pointers to this block would be invalid. Solution 5: Memory pool Instead of allocating many small blocks, a program can allocate only one big block and divide it as it needs. Within this block, the program is free to use any allocation strategy. For example, ArduinoJson implements this technique with DynamicJsonBuffer . So what can I do to reduce heap fragmentation? None of these techniques applies to our Arduino programs, which means we have to code in a way that reduces the fragmentation. Strategy 1: Avoid heap (in particular, avoid String) In many cases, we can avoid dynamic allocation. Instead of allocating objects in the heap, we place them in the stack or in the globals. By design, these two areas are not fragmented. For example, we could replace all String objects with plain old char[] . Not only we would reduce the fragmentation, but we would also create a smaller and faster executable. Strategy 2: Short object lifetime Short-lived objects have a small impact on the heap fragmentation. They rapidly come and go, leaving the heap in the same state. Long-lived objects, however, have a substantial impact on the heap fragmentation. They book their room and stick here for a long time, leaving the heap with an unmovable block in the middle. So, if you still needed another reason to avoid global variables, there you have it. Strategy 3: Constant allocation As we saw, repeated allocations of the same size don\u2019t cause fragmentation; so, we could keep our objects in the heap but always use the same size. For example, if we have a string that can have between 10 and 100 characters, we could always reserve 100 characters: myString.reserve(100); As curious as it sounds, allocating more memory than strictly necessary allows more efficient utilization of the RAM. Conclusion This article was unusually long, I hoped you\u2019ve gone through it. Here is what you need to remember: Fragmentation is an inefficient utilization of the RAM. Arduino programs, more than others, are affected by fragmentation. It\u2019s our responsibility as programmers to fight against fragmentation. As usual, you\u2019ll find the source code of the examples on GitHub . I\u2019ll see you soon with another article!","title":"Introduction"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#heap#fragmentation","text":"","title":"Heap Fragmentation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#cpp4arduino#what#is#heap#fragmentation","text":"NOTE: \u8fd9\u7bc7\u6587\u7ae0\u975e\u5e38\u597d\uff0c\u4e0d\u4ec5\u975e\u5e38\u5f62\u8c61\u7684\u63cf\u8ff0\u4e86heap fragmentation\u7684\u542b\u4e49\uff0c\u5e76\u4e14\u63cf\u8ff0\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u7684\u65b9\u6cd5\u3002 There is a lot of free memory, so why allocation fails? My program ran well for hours/days/months, why does it crash now? Why does my program run slower over time? Believe or not, the answers to these three questions are the same: you have a heap fragmentation problem. In this article, we\u2019ll see what it means and how to fix it.","title":"cpp4arduino What is Heap Fragmentation?"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#what#is#the#heap","text":"The \u201cheap\u201d is the area of the RAM where the dynamic memory allocation happens. Every time you call malloc() , you reserve a block of memory in the heap. Similarly, every time you call new , you reserve a block in the heap. Because new calls malloc() and delete calls free() , everything we\u2019ll see equally applies to new and delete . Very often, your program allocates heap memory without explicitly calling malloc() . For example, when you create a String object, the constructor allocates some space in the heap to store the characters.","title":"What is the heap?"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#what#is#heap#fragmentation","text":"When you call free() to release a block, you create a hole of unused memory. After some time, the heap becomes a swiss cheese with many holes . NOTE: \" swiss cheese with many holes \"\u662f\u4e00\u4e2a\u975e\u5e38\u5f62\u8c61\u7684\u6bd4\u55bb Here is a simplified view with an imaginary heap of 30 bytes: The holes count as free memory, so there are 20 bytes available. However, we are unable to allocate 20 bytes because there is not a consecutive(\u8fde\u7eed\u7684) block of 20 free bytes. This phenomenon is what we call \u201cheap fragmentation.\u201d It\u2019s an inefficient utilization of the RAM that prevents a program from using the full capacity of the microcontroller(\u5fae\u63a7\u5236\u5668). NOTE: \u5728\u5d4c\u5165\u5f0f\u4e2d\uff0c\u4f7f\u7528\"microcontroller\"\u8fd9\u4e2a\u8bcd\u8bed","title":"What is heap fragmentation?"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#when#does#fragmentation#happen","text":"Suppose you just released a block of memory and therefore created a hole in the heap. Is that always a problem? There are three possibilities. First possibility: you allocate another block of the same size. The new block takes the place left by the old one. No hole remains. Second possibility: you allocate a smaller block. The new block fits in the hole but doesn\u2019t fill it. A small hole remains. Third possibility: you allocate a larger block. The new block cannot fit in the hole, so it\u2019s allocated further in the heap. A big hole remains. As you see, only a program that allocates and releases blocks of different size increases the heap fragmentation .","title":"When does fragmentation happen?"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#an#example","text":"Now that we get the theory, let\u2019s see a concrete example. Consider a loop() function that downloads the weather forecasts from a web server. It first saves the response a big String ; then it extracts the date, the city, the temperature, the humidity(\u6e7f\u5ea6), and the weather description in five String s of various size. String serverResponse ; String date , city , temperature , humidity , description ; void loop () { serverResponse = downloadFromServer (); date = extractDate ( serverResponse ); city = extractCity ( serverResponse ); temperature = extractTemperature ( serverResponse ); description = extractDescription ( serverResponse ); } The first iteration of loop() is OK: it allocates the String s in the heap but doesn\u2019t release them, so no fragmentation happens. Then, each iteration creates new String s to replace the old ones. The new String s allocate new blocks and the old String s release the old blocks. Here is the problem: every time the server returns a different response, the sizes of the blocks change. As we saw, allocation of varying sizes creates holes in the heap, which increases the fragmentation. NOTE: varying size\u662f\u975e\u5e38\u5bb9\u6613\u9020\u6210heap fragmentation\u7684\uff0c\u56e0\u6b64\u4e00\u4e2a\u89e3\u51b3\u65b9\u6cd5\u662f\u4f7f\u7528 \"Strategy 3: Constant allocation\"","title":"An example"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#measuring#the#fragmentation","text":"There are several formal definitions for the fragmentation; in this article, I\u2019ll use this simple definition: Let\u2019s try some numbers in this formula. Suppose you have 1KB of free RAM. At 0% (no fragmentation), you can allocate 1KB in one shot. At 25%, you can allocate 750B in one shot. At 50%, you can only allocate 500B in one shot. At 75%, you can only allocate 250B in one shot. A value of 50% or more is considered high and can seriously impede(\u963b\u788d) your program, as we\u2019ll see.","title":"Measuring the fragmentation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#how#fragmentation#evolves#over#time","text":"Now that we have a formal definition, let\u2019s write a program that will show the evolution of the fragmentation over time.","title":"How fragmentation evolves over time"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#computing#the#fragmentation","text":"To compute the fragmentation percentage, we apply the formula and multiply by 100: float getFragmentation () { return 100 - getLargestAvailableBlock () * 100.0 / getTotalAvailableMemory (); } As you can guess, getLargestAvailableBlock() returns the size of the largest allocable block, and getTotalAvailableMemory() returns the total free memory. Writing these two functions is the trickiest(\u68d8\u624b\u7684) part of this program because they are dependent on the platform. In the code samples , I implemented a version for AVR (Arduino UNO et al.) and another for ESP8266.","title":"Computing the fragmentation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#drilling#holes","text":"To produce fragmentation, we saw that we could use a few String s of various size and replace them repeatedly. The easiest way to do that is to have an array of String and to replace them with random values: String strings [ NUMBER_OF_STRINGS ]; for ( String & s : strings ) s = generateRandomString (); As the name suggests, generateRandomString() returns a String whose length varies from one call to the other: String generateRandomString () { String result ; int len = random ( SMALLEST_STRING , LARGEST_STRING ); while ( len -- ) result += '?' ; return result ; } This program roughly simulates the weather forecast example.","title":"Drilling(\u6f14\u7ec3) holes"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#the#results","text":"I obtained the following graph with 20 strings whose length varied from 10 to 50 characters. The program ran on an Arduino UNO. As you see, when the program starts, the fragmentation is close to zero and then increases irregularly until it stabilizes at about 70%. I encourage you to tweak the settings to see the effect on the fragmentation. In particular, you\u2019ll see that when SMALLEST_STRING and LARGEST_STRING are equals, i.e., if the String s are all of the same sizes, no fragmentation occurs.","title":"The results"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#why#is#heap#fragmentation#bad","text":"We saw how fragmentation increases, now let\u2019s talk about the consequences of a high fragmentation level.","title":"Why is heap fragmentation bad?"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#consequence#1#unreliable#program","text":"By definition, a high fragmentation level means you have a lot of free memory, but you can only allocate small blocks. If your program needs a bigger block, it will not get it and will stop working.","title":"Consequence 1: Unreliable program"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#consequence#2#degraded#performance","text":"A highly fragmented heap is slower because the memory allocator takes more time to find the best hole, the so-called \u201cbest-fit.\u201d","title":"Consequence 2: Degraded performance"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#if#its#so#huge#why#nobody#talks#about#it","text":"Heap fragmentation is a solved problem for most programmers, but not for us Arduino programmers. Let\u2019s see how other platforms handle the problem.","title":"If it\u2019s so huge, why nobody talks about it?"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#solution#1#virtual#memory","text":"The programs running on our computers use Virtual Memory . The value of the pointer is not the physical location in the RAM; instead, the CPU translates the address on the fly. This decoupling allows defragmenting the RAM without moving anything but requires dedicated hardware that we do not have on our microcontrollers.","title":"Solution 1: Virtual memory"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#solution#2#optimized#allocators","text":"Either as part of the standard library or as a linked library, C++ programs running on a computer embeds a heap allocator that is much more efficient than what we have on our Arduinos. The most common optimization is to gather small blocks into bins: one bin for blocks of 4 bytes, one bin for 8 bytes, etc. Thanks to this technique the small objects don\u2019t contribute to and are not affected by the fragmentation.","title":"Solution 2: Optimized allocators"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#solution#3#short#string#optimization","text":"Even if the C++ standard doesn\u2019t mandate it, all implementations of std::string support the \u201cSmall String Optimization,\u201d or SSO. std::string stores short strings locally and only uses the heap for long strings. By reducing the number of small objects in the heap, the SSO reduces the fragmentation. Unfortunately, the String class doesn\u2019t perform SSO in Arduino.","title":"Solution 3: Short string optimization"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#solution#4#heap#compacting","text":"In languages with managed memory, the garbage collector moves the memory blocks to squash the holes. We cannot use this technique in C++ because moving a block would change its address, so all pointers to this block would be invalid.","title":"Solution 4: Heap compacting(\u7d27\u51d1)"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#solution#5#memory#pool","text":"Instead of allocating many small blocks, a program can allocate only one big block and divide it as it needs. Within this block, the program is free to use any allocation strategy. For example, ArduinoJson implements this technique with DynamicJsonBuffer .","title":"Solution 5: Memory pool"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#so#what#can#i#do#to#reduce#heap#fragmentation","text":"None of these techniques applies to our Arduino programs, which means we have to code in a way that reduces the fragmentation.","title":"So what can I do to reduce heap fragmentation?"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#strategy#1#avoid#heap#in#particular#avoid#string","text":"In many cases, we can avoid dynamic allocation. Instead of allocating objects in the heap, we place them in the stack or in the globals. By design, these two areas are not fragmented. For example, we could replace all String objects with plain old char[] . Not only we would reduce the fragmentation, but we would also create a smaller and faster executable.","title":"Strategy 1: Avoid heap (in particular, avoid String)"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#strategy#2#short#object#lifetime","text":"Short-lived objects have a small impact on the heap fragmentation. They rapidly come and go, leaving the heap in the same state. Long-lived objects, however, have a substantial impact on the heap fragmentation. They book their room and stick here for a long time, leaving the heap with an unmovable block in the middle. So, if you still needed another reason to avoid global variables, there you have it.","title":"Strategy 2: Short object lifetime"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#strategy#3#constant#allocation","text":"As we saw, repeated allocations of the same size don\u2019t cause fragmentation; so, we could keep our objects in the heap but always use the same size. For example, if we have a string that can have between 10 and 100 characters, we could always reserve 100 characters: myString.reserve(100); As curious as it sounds, allocating more memory than strictly necessary allows more efficient utilization of the RAM.","title":"Strategy 3: Constant allocation"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/#conclusion","text":"This article was unusually long, I hoped you\u2019ve gone through it. Here is what you need to remember: Fragmentation is an inefficient utilization of the RAM. Arduino programs, more than others, are affected by fragmentation. It\u2019s our responsibility as programmers to fight against fragmentation. As usual, you\u2019ll find the source code of the examples on GitHub . I\u2019ll see you soon with another article!","title":"Conclusion"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/Dynamic-Memory-Allocation-and-Fragmentation-in-C-and-C%2B%2B/","text":"design-reuse Dynamic Memory Allocation and Fragmentation in C and C++","title":"design-reuse [Dynamic Memory Allocation and Fragmentation in C and C++](https://www.design-reuse.com/articles/25090/dynamic-memory-allocation-fragmentation-c.html)"},{"location":"Kernel/Guide/Memory-management/Fragmentation/Heap-fragmentation/Dynamic-Memory-Allocation-and-Fragmentation-in-C-and-C%2B%2B/#design-reuse#dynamic#memory#allocation#and#fragmentation#in#c#and#c","text":"","title":"design-reuse Dynamic Memory Allocation and Fragmentation in C and C++"},{"location":"Kernel/Guide/Memory-management/Memory-protection/","text":"Memory protection \u8ba9\u6211\u4eec\u518d\u6b21\u56de\u5fc6\u5728 Architecture-of-computing-system \u7684\u201c\u901a\u8fc7architecture\u6765\u5206\u6790OS\u7684\u4f5c\u7528\u201d\u6bb5\u4e2d\u603b\u7ed3\u7684OS\u7684\u4e24\u5927\u4f5c\u7528\uff0c\u7b80\u800c\u8a00\u4e4b\u5c31\u662f\u7ba1\u7406hardware\u548c\u4e3aprocess\u63d0\u4f9b execution environment \uff0c\u5bf9\u4e8e\u8fd0\u884c\u4e8e\u5b83\u4e4b\u4e2d\u7684process\uff0cOS kernel\u9700\u8981\u5bf9process\u7684\u6240\u6709\u884c\u4e3a\uff08\u5305\u62ecmemory access\uff09\u90fd\u4e86\u5982\u6307\u638c\uff0c\u5b83\u80fd\u591f\u53d1\u73b0process\u662f\u5426\u8fdb\u884c\u4e86\u9519\u8bef\u7684\u64cd\u4f5c\uff0c\u4e00\u65e6\u53d1\u73b0\u5b83\u5c31\u4f1a\u201c\u63d0\u9192\u201d\u8fd9\u4e2aprocess\uff0c\u672c\u6587\u6240\u63cf\u8ff0\u7684memory protection\u5c31\u5c5e\u4e8e\u6b64\uff0c\u5373OS kernel\u5bf9process\u7684memory access\u884c\u4e3a\u8fdb\u884c\u7ba1\u63a7\u3002 \u7ef4\u57fa\u767e\u79d1 Memory protection Memory protection is a way to control memory access rights on a computer, and is a part of most modern instruction set architectures and operating systems . The main purpose of memory protection is to prevent a process from accessing memory that has not been allocated to it. This prevents a bug or malware (\u6076\u610f\u8f6f\u4ef6) within a process from affecting other processes, or the operating system itself. Protection may encompass(\u73af\u7ed5) all accesses to a specified area of memory, write accesses, or attempts to execute the contents of the area. An attempt to access unowned memory results in a hardware fault , called a segmentation fault or storage violation exception, generally causing abnormal termination of the offending process. Memory protection for computer security includes additional techniques such as address space layout randomization and executable space protection . Methods Segmentation Segmentation NOTE: \u8fd9\u79cd\u65b9\u5f0f\u73b0\u4ee3OS\u4ee5\u53ca\u5f88\u5c11\u91c7\u7528\u4e86\u3002 Paged virtual memory Main article: Paged virtual memory NOTE: \u8fd9\u79cd\u65b9\u5f0f\u662f\u76ee\u524d\u91c7\u7528\u6700\u591a\u7684\u3002 SUMMARY \u672c\u6587\u4ec5\u4ec5\u8ba8\u8bba\u7684\u662fmemory protection\u7684\u6982\u5ff5\uff0cOS kernel\u5b9e\u9645\u7684\u5b9e\u73b0\u8fdc\u6bd4\u8fd9\u8981\u590d\u6742\u3002\u5173\u4e8e\u5177\u4f53\u7684\u5b9e\u73b0\u7ec6\u8282\uff0c\u53c2\u89c1Book-Understanding-the-Linux-Kernel\u7684 2.4-Paging-in-Hardware \u3002\u7531\u4e8eOS kernel\u6240\u91c7\u7528\u7684memory protection\uff0c\u5219\u4e00\u65e6process\u7684memory access\u8fdd\u6cd5\uff0c\u5219\u5b83\u80fd\u591f\u7acb\u5373\u53d1\u73b0\u5e76\u4e88\u4ee5\u901a\u77e5\u3002\u4e0e\u6b64\u76f8\u5173\u7684\u662f\u4e00\u7c7bprogramming error\uff0c\u53eb\u505amemory access error\uff0c\u5728 Memory-access-error \u4e2d\u8fdb\u884c\u4e86\u8be6\u7ec6\u63cf\u8ff0\u3002","title":"Introduction"},{"location":"Kernel/Guide/Memory-management/Memory-protection/#memory#protection","text":"\u8ba9\u6211\u4eec\u518d\u6b21\u56de\u5fc6\u5728 Architecture-of-computing-system \u7684\u201c\u901a\u8fc7architecture\u6765\u5206\u6790OS\u7684\u4f5c\u7528\u201d\u6bb5\u4e2d\u603b\u7ed3\u7684OS\u7684\u4e24\u5927\u4f5c\u7528\uff0c\u7b80\u800c\u8a00\u4e4b\u5c31\u662f\u7ba1\u7406hardware\u548c\u4e3aprocess\u63d0\u4f9b execution environment \uff0c\u5bf9\u4e8e\u8fd0\u884c\u4e8e\u5b83\u4e4b\u4e2d\u7684process\uff0cOS kernel\u9700\u8981\u5bf9process\u7684\u6240\u6709\u884c\u4e3a\uff08\u5305\u62ecmemory access\uff09\u90fd\u4e86\u5982\u6307\u638c\uff0c\u5b83\u80fd\u591f\u53d1\u73b0process\u662f\u5426\u8fdb\u884c\u4e86\u9519\u8bef\u7684\u64cd\u4f5c\uff0c\u4e00\u65e6\u53d1\u73b0\u5b83\u5c31\u4f1a\u201c\u63d0\u9192\u201d\u8fd9\u4e2aprocess\uff0c\u672c\u6587\u6240\u63cf\u8ff0\u7684memory protection\u5c31\u5c5e\u4e8e\u6b64\uff0c\u5373OS kernel\u5bf9process\u7684memory access\u884c\u4e3a\u8fdb\u884c\u7ba1\u63a7\u3002","title":"Memory protection"},{"location":"Kernel/Guide/Memory-management/Memory-protection/#memory#protection_1","text":"Memory protection is a way to control memory access rights on a computer, and is a part of most modern instruction set architectures and operating systems . The main purpose of memory protection is to prevent a process from accessing memory that has not been allocated to it. This prevents a bug or malware (\u6076\u610f\u8f6f\u4ef6) within a process from affecting other processes, or the operating system itself. Protection may encompass(\u73af\u7ed5) all accesses to a specified area of memory, write accesses, or attempts to execute the contents of the area. An attempt to access unowned memory results in a hardware fault , called a segmentation fault or storage violation exception, generally causing abnormal termination of the offending process. Memory protection for computer security includes additional techniques such as address space layout randomization and executable space protection .","title":"\u7ef4\u57fa\u767e\u79d1Memory protection"},{"location":"Kernel/Guide/Memory-management/Memory-protection/#methods","text":"","title":"Methods"},{"location":"Kernel/Guide/Memory-management/Memory-protection/#segmentation","text":"Segmentation NOTE: \u8fd9\u79cd\u65b9\u5f0f\u73b0\u4ee3OS\u4ee5\u53ca\u5f88\u5c11\u91c7\u7528\u4e86\u3002","title":"Segmentation"},{"location":"Kernel/Guide/Memory-management/Memory-protection/#paged#virtual#memory","text":"Main article: Paged virtual memory NOTE: \u8fd9\u79cd\u65b9\u5f0f\u662f\u76ee\u524d\u91c7\u7528\u6700\u591a\u7684\u3002","title":"Paged virtual memory"},{"location":"Kernel/Guide/Memory-management/Memory-protection/#summary","text":"\u672c\u6587\u4ec5\u4ec5\u8ba8\u8bba\u7684\u662fmemory protection\u7684\u6982\u5ff5\uff0cOS kernel\u5b9e\u9645\u7684\u5b9e\u73b0\u8fdc\u6bd4\u8fd9\u8981\u590d\u6742\u3002\u5173\u4e8e\u5177\u4f53\u7684\u5b9e\u73b0\u7ec6\u8282\uff0c\u53c2\u89c1Book-Understanding-the-Linux-Kernel\u7684 2.4-Paging-in-Hardware \u3002\u7531\u4e8eOS kernel\u6240\u91c7\u7528\u7684memory protection\uff0c\u5219\u4e00\u65e6process\u7684memory access\u8fdd\u6cd5\uff0c\u5219\u5b83\u80fd\u591f\u7acb\u5373\u53d1\u73b0\u5e76\u4e88\u4ee5\u901a\u77e5\u3002\u4e0e\u6b64\u76f8\u5173\u7684\u662f\u4e00\u7c7bprogramming error\uff0c\u53eb\u505amemory access error\uff0c\u5728 Memory-access-error \u4e2d\u8fdb\u884c\u4e86\u8be6\u7ec6\u63cf\u8ff0\u3002","title":"SUMMARY"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/","text":"Virtual memory Why use virtual memory? \u5728\u6587\u7ae0 Abstraction-and-virtual \u4e2d\uff0c\u6211\u4eec\u77e5\u9053 virtual\u4e5f\u662f\u4e00\u79cd\u62bd\u8c61\uff0c\u4e00\u79cd\u5206\u5c42\uff0c\u8fd9\u79cd\u5206\u5c42\u6240\u5e26\u6765\u7684\u4ef7\u503c\u5c31\u662f\u89e3\u8026\u3002 \u663e\u7136virtual memory\u662f\u7b26\u5408abstraction principle\u7684\u3002 \u4e0b\u9762\u8bf4\u660e\u4f7f\u7528virtual address\u7684\u89e3\u8026\uff1a process\u5728\u8fd0\u884c\u7684\u65f6\u5019\u4f7f\u7528virtual memory address\uff0c\u7531OS\u6839\u636epage table\u5c06virtual address\u7ffb\u8bd1\u4e3aphysical address\uff1b\u4e0eprocess\u76f4\u63a5\u4f7f\u7528physical address\u76f8\u6bd4\uff0c\u8fd9\u79cd\u8bbe\u8ba1\u591a\u6dfb\u52a0\u4e86\u4e00\u5c42\uff1a\u8f6c\u6362\u5c42\u3002\u8fd9\u79cd\u8bbe\u8ba1\u5e26\u6765\u7684\u4ef7\u503c\u662f\uff1a\u5b83\u89e3\u8026\u4e86process\u7684page\u548cpage\u7684\u5b58\u50a8\u4f4d\u7f6e\uff0c\u5177\u4f53\u6765\u8bb2\u5c31\u662f\u6309\u7167\u8fd9\u79cd\u8bbe\u8ba1\uff0cpage\u65e2\u53ef\u4ee5\u4f4d\u4e8eRAM\uff0c\u4e5f\u53ef\u4ee5\u4f4d\u4e8edisk\uff0c\u800c\u5982\u679c\u76f4\u63a5\u4f7f\u7528physical address\u7684\u8bdd\uff0c\u5219process\u7684page\u53ea\u80fd\u591f\u4f4d\u4e8eRAM\u4e2d\u3002\u6240\u4ee5\u53ef\u4ee5\u770b\u51fa\uff0cvirtual address\u89e3\u8026\u4e86process\u7684page\u548cpage\u7684\u5b58\u50a8\u4f4d\u7f6e\u3002 \u90a3\"\u89e3\u8026\"\u5e26\u6765\u4e86\u4ec0\u4e48\u4ef7\u503c\u5462\uff1f \u603b\u7684\u6765\u8bf4\u662ftransparency: hide\u7ec6\u8282\uff0c\u8ba9\u5f88\u591ahardware\u3001OS kernel\u5c42\u7684optimization\u79f0\u4e3a\u53ef\u80fd\uff0chardware\u3001OS kernel\u5c42\u7684optimization\u5bf9process\u5c42\u662f\u900f\u660e(transparency)\u7684\u3002 hardware\u3001OS kernel\u5c42\u7684optimization\u5305\u62ec: 1) wikipedia Virtual memory # Primary benefit \u4e2d\u63cf\u8ff0\u7684\u4e00\u4e9b\u4ef7\u503c\u5c31\u662f\u5b83\u6240\u5e26\u6765\u7684 2) wikipedia Virtual memory # Properties Virtual memory and fragmentation \u5728 Kernel\\Guide\\Memory-management\\Fragmentation \u4e2d\u8ba8\u8bba\u4e86fragmentation\uff0c\u5728 Kernel\\Guide\\Memory-management\\Fragmentation\\Heap-fragmentation \u4e2d\u6536\u5f55\u4e86cpp4arduino What is Heap Fragmentation? \u4e2d\u8ba8\u8bba\u4e86virtual memory \u548cfragmentation\u4e4b\u95f4\u7684\u5185\u5bb9: The programs running on our computers use Virtual Memory. The value of the pointer is not the physical location in the RAM; instead, the CPU translates the address on the fly. This decoupling allows defragmenting the RAM without moving anything but requires dedicated hardware that we do not have on our microcontrollers. wikipedia Virtual memory NOTE: Virtual memory \u6280\u672f\u7684\u76f8\u5173\u6982\u5ff5\u90fd\u4f1a\u5728\u540d\u79f0\u524d\u9762\u52a0\u4e0a\u201cvirtual\"\u4fee\u9970\u8bcd\uff0c\u6bd4\u5982\uff1a virtual addresses virtual address spaces In computing , virtual memory (also virtual storage ) is a memory management technique that provides an \"idealized abstraction of the storage resources that are actually available on a given machine\" which \"creates the illusion to users of a very large (main) memory.\" The computer's operating system , using a combination of hardware and software, maps memory addresses used by a program, called virtual addresses , into physical addresses in computer memory . NOTE: \u7531OS\u6765\u6267\u884c\u4e0a\u8ff0\u6620\u5c04\u3002 \u5728 \u8fd9\u7bc7\u6587\u7ae0 \u4e2d\uff0c\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a Virtual address When we say virtual address, that refers to a location in a process's address space. In other words, a pointer ! \u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u4e00\u76f4\u4f7f\u7528\u7684pointer\uff0c\u5b9e\u9645\u662fvirtual address\uff1b Main storage , as seen by a process or task, appears as a contiguous address space or collection of contiguous segments . The operating system manages virtual address spaces and the assignment of real memory to virtual memory . Address translation hardware in the CPU, often referred to as a memory management unit or MMU , automatically translates virtual addresses to physical addresses . Software within the operating system may extend these capabilities to provide a virtual address space that can exceed the capacity of real memory and thus reference more memory than is physically present in the computer. NOTE: \u53c2\u89c1\uff1a how is page size determined in virtual address space? Primary benefit The primary benefits of virtual memory include 1) freeing applications from having to manage a shared memory space, 2) increased security due to memory isolation , and 3) being able to conceptually use more memory than might be physically available, using the technique of paging . NOTE: memory isolation\u6307\u7684\u662f\u6bcf\u4e2aprocess\u6709\u4e00\u4e2a\u72ec\u7acb\u7684 virtual address space \u3002 Virtual memory combines active RAM and inactive memory on DASD \uff08Direct-access storage device\uff09 to form a large range of contiguous addresses. Properties Virtual memory makes application programming easier 1) by hiding fragmentation (\u788e\u7247\uff09 of physical memory; NOTE: \u5173\u4e8evirtual memory\u548cfragmentation\uff0c\u5728\u524d\u9762\u7684\"Why use virtual memory?\"\u4e2d\u8fdb\u884c\u4e86\u4e13\u95e8\u7684\u4ecb\u7ecd\u3002 2) by delegating to the kernel the burden\uff08\u8d23\u4efb\uff09 of managing the memory hierarchy (eliminating the need for the program to handle overlays explicitly); and, when each process is run in its own dedicated address space, 3) by obviating\uff08\u6d88\u9664\uff09 the need to relocate program code or to access memory with relative addressing . NOTE: \u6838\u5fc3\u89c2\u70b9\u662f: makes application programming easier Memory virtualization can be considered a generalization of the concept of virtual memory. Paged virtual memory Nearly all current implementations of virtual memory divide a virtual address space into pages , blocks of contiguous virtual memory addresses. Pages on contemporary systems are usually at least 4 kilobytes in size; systems with large virtual address ranges or amounts of real memory generally use larger page sizes. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u662f\u6307\u5c06 virtual address space \u6309\u7167 pages \u8fdb\u884c\u5212\u5206\uff1b Page tables Page tables are used to translate the virtual addresses seen by the application into physical addresses used by the hardware to process instructions; such hardware that handles this specific translation is often known as the memory management unit . Each entry in the page table holds a flag indicating whether the corresponding page is in real memory or not. If it is in real memory, the page table entry will contain the real memory address at which the page is stored. When a reference is made to a page by the hardware, if the page table entry for the page indicates that it is not currently in real memory, the hardware raises a page fault exception , invoking the paging supervisor component of the operating system . NOTE : \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u6709\u4e00\u53e5\u975e\u5e38\u91cd\u8981\u7684\uff1a virtual addresses seen by application while physical addresses use by hardware\uff1b\u5373process\u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6240\u4f7f\u7528\u7684\u662fvirtual address\u3002 Systems can have one page table for the whole system separate page tables for each application and segment a tree of page tables for large segments or some combination of these. If there is only one page table, different applications running at the same time use different parts of a single range of virtual addresses. If there are multiple page or segment tables, there are multiple virtual address spaces and concurrent applications with separate page tables redirect to different real addresses. Some earlier systems with smaller real memory sizes, such as the SDS 940 , used page registers instead of page tables in memory for address translation. Paging supervisor This part of the operating system creates and manages page tables . If the hardware raises a page fault exception , the paging supervisor accesses secondary storage, returns the page that has the virtual address that resulted in the page fault, updates the page tables to reflect the physical location of the virtual address and tells the translation mechanism to restart the request. When all physical memory is already in use, the paging supervisor must free a page in primary storage to hold the swapped-in page. The supervisor uses one of a variety of page replacement algorithms such as least recently used to determine which page to free. Pinned pages Operating systems have memory areas that are pinned (never swapped to secondary storage). Other terms used are locked , fixed , or wired pages. For example, interrupt mechanisms rely on an array of pointers to their handlers, such as I/O completion and page fault . If the pages containing these pointers or the code that they invoke were pageable, interrupt-handling would become far more complex and time-consuming, particularly in the case of page fault interruptions. Hence, some part of the page table structures is not pageable. Segmented virtual memory NOTE: \u8fd9\u79cd\u5e76\u975e\u4e3b\u6d41\u7684\uff0cpass\u6389\u3002 See also Page table Page (computer memory) Paging Virtual Addresses","title":"Introduction"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#virtual#memory","text":"","title":"Virtual memory"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#why#use#virtual#memory","text":"\u5728\u6587\u7ae0 Abstraction-and-virtual \u4e2d\uff0c\u6211\u4eec\u77e5\u9053 virtual\u4e5f\u662f\u4e00\u79cd\u62bd\u8c61\uff0c\u4e00\u79cd\u5206\u5c42\uff0c\u8fd9\u79cd\u5206\u5c42\u6240\u5e26\u6765\u7684\u4ef7\u503c\u5c31\u662f\u89e3\u8026\u3002 \u663e\u7136virtual memory\u662f\u7b26\u5408abstraction principle\u7684\u3002 \u4e0b\u9762\u8bf4\u660e\u4f7f\u7528virtual address\u7684\u89e3\u8026\uff1a process\u5728\u8fd0\u884c\u7684\u65f6\u5019\u4f7f\u7528virtual memory address\uff0c\u7531OS\u6839\u636epage table\u5c06virtual address\u7ffb\u8bd1\u4e3aphysical address\uff1b\u4e0eprocess\u76f4\u63a5\u4f7f\u7528physical address\u76f8\u6bd4\uff0c\u8fd9\u79cd\u8bbe\u8ba1\u591a\u6dfb\u52a0\u4e86\u4e00\u5c42\uff1a\u8f6c\u6362\u5c42\u3002\u8fd9\u79cd\u8bbe\u8ba1\u5e26\u6765\u7684\u4ef7\u503c\u662f\uff1a\u5b83\u89e3\u8026\u4e86process\u7684page\u548cpage\u7684\u5b58\u50a8\u4f4d\u7f6e\uff0c\u5177\u4f53\u6765\u8bb2\u5c31\u662f\u6309\u7167\u8fd9\u79cd\u8bbe\u8ba1\uff0cpage\u65e2\u53ef\u4ee5\u4f4d\u4e8eRAM\uff0c\u4e5f\u53ef\u4ee5\u4f4d\u4e8edisk\uff0c\u800c\u5982\u679c\u76f4\u63a5\u4f7f\u7528physical address\u7684\u8bdd\uff0c\u5219process\u7684page\u53ea\u80fd\u591f\u4f4d\u4e8eRAM\u4e2d\u3002\u6240\u4ee5\u53ef\u4ee5\u770b\u51fa\uff0cvirtual address\u89e3\u8026\u4e86process\u7684page\u548cpage\u7684\u5b58\u50a8\u4f4d\u7f6e\u3002 \u90a3\"\u89e3\u8026\"\u5e26\u6765\u4e86\u4ec0\u4e48\u4ef7\u503c\u5462\uff1f \u603b\u7684\u6765\u8bf4\u662ftransparency: hide\u7ec6\u8282\uff0c\u8ba9\u5f88\u591ahardware\u3001OS kernel\u5c42\u7684optimization\u79f0\u4e3a\u53ef\u80fd\uff0chardware\u3001OS kernel\u5c42\u7684optimization\u5bf9process\u5c42\u662f\u900f\u660e(transparency)\u7684\u3002 hardware\u3001OS kernel\u5c42\u7684optimization\u5305\u62ec: 1) wikipedia Virtual memory # Primary benefit \u4e2d\u63cf\u8ff0\u7684\u4e00\u4e9b\u4ef7\u503c\u5c31\u662f\u5b83\u6240\u5e26\u6765\u7684 2) wikipedia Virtual memory # Properties","title":"Why use virtual memory?"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#virtual#memory#and#fragmentation","text":"\u5728 Kernel\\Guide\\Memory-management\\Fragmentation \u4e2d\u8ba8\u8bba\u4e86fragmentation\uff0c\u5728 Kernel\\Guide\\Memory-management\\Fragmentation\\Heap-fragmentation \u4e2d\u6536\u5f55\u4e86cpp4arduino What is Heap Fragmentation? \u4e2d\u8ba8\u8bba\u4e86virtual memory \u548cfragmentation\u4e4b\u95f4\u7684\u5185\u5bb9: The programs running on our computers use Virtual Memory. The value of the pointer is not the physical location in the RAM; instead, the CPU translates the address on the fly. This decoupling allows defragmenting the RAM without moving anything but requires dedicated hardware that we do not have on our microcontrollers.","title":"Virtual memory and fragmentation"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#wikipedia#virtual#memory","text":"NOTE: Virtual memory \u6280\u672f\u7684\u76f8\u5173\u6982\u5ff5\u90fd\u4f1a\u5728\u540d\u79f0\u524d\u9762\u52a0\u4e0a\u201cvirtual\"\u4fee\u9970\u8bcd\uff0c\u6bd4\u5982\uff1a virtual addresses virtual address spaces In computing , virtual memory (also virtual storage ) is a memory management technique that provides an \"idealized abstraction of the storage resources that are actually available on a given machine\" which \"creates the illusion to users of a very large (main) memory.\" The computer's operating system , using a combination of hardware and software, maps memory addresses used by a program, called virtual addresses , into physical addresses in computer memory . NOTE: \u7531OS\u6765\u6267\u884c\u4e0a\u8ff0\u6620\u5c04\u3002 \u5728 \u8fd9\u7bc7\u6587\u7ae0 \u4e2d\uff0c\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a Virtual address When we say virtual address, that refers to a location in a process's address space. In other words, a pointer ! \u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u4e00\u76f4\u4f7f\u7528\u7684pointer\uff0c\u5b9e\u9645\u662fvirtual address\uff1b Main storage , as seen by a process or task, appears as a contiguous address space or collection of contiguous segments . The operating system manages virtual address spaces and the assignment of real memory to virtual memory . Address translation hardware in the CPU, often referred to as a memory management unit or MMU , automatically translates virtual addresses to physical addresses . Software within the operating system may extend these capabilities to provide a virtual address space that can exceed the capacity of real memory and thus reference more memory than is physically present in the computer. NOTE: \u53c2\u89c1\uff1a how is page size determined in virtual address space?","title":"wikipedia Virtual memory"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#primary#benefit","text":"The primary benefits of virtual memory include 1) freeing applications from having to manage a shared memory space, 2) increased security due to memory isolation , and 3) being able to conceptually use more memory than might be physically available, using the technique of paging . NOTE: memory isolation\u6307\u7684\u662f\u6bcf\u4e2aprocess\u6709\u4e00\u4e2a\u72ec\u7acb\u7684 virtual address space \u3002 Virtual memory combines active RAM and inactive memory on DASD \uff08Direct-access storage device\uff09 to form a large range of contiguous addresses.","title":"Primary benefit"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#properties","text":"Virtual memory makes application programming easier 1) by hiding fragmentation (\u788e\u7247\uff09 of physical memory; NOTE: \u5173\u4e8evirtual memory\u548cfragmentation\uff0c\u5728\u524d\u9762\u7684\"Why use virtual memory?\"\u4e2d\u8fdb\u884c\u4e86\u4e13\u95e8\u7684\u4ecb\u7ecd\u3002 2) by delegating to the kernel the burden\uff08\u8d23\u4efb\uff09 of managing the memory hierarchy (eliminating the need for the program to handle overlays explicitly); and, when each process is run in its own dedicated address space, 3) by obviating\uff08\u6d88\u9664\uff09 the need to relocate program code or to access memory with relative addressing . NOTE: \u6838\u5fc3\u89c2\u70b9\u662f: makes application programming easier Memory virtualization can be considered a generalization of the concept of virtual memory.","title":"Properties"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#paged#virtual#memory","text":"Nearly all current implementations of virtual memory divide a virtual address space into pages , blocks of contiguous virtual memory addresses. Pages on contemporary systems are usually at least 4 kilobytes in size; systems with large virtual address ranges or amounts of real memory generally use larger page sizes. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u662f\u6307\u5c06 virtual address space \u6309\u7167 pages \u8fdb\u884c\u5212\u5206\uff1b","title":"Paged virtual memory"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#page#tables","text":"Page tables are used to translate the virtual addresses seen by the application into physical addresses used by the hardware to process instructions; such hardware that handles this specific translation is often known as the memory management unit . Each entry in the page table holds a flag indicating whether the corresponding page is in real memory or not. If it is in real memory, the page table entry will contain the real memory address at which the page is stored. When a reference is made to a page by the hardware, if the page table entry for the page indicates that it is not currently in real memory, the hardware raises a page fault exception , invoking the paging supervisor component of the operating system . NOTE : \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u6709\u4e00\u53e5\u975e\u5e38\u91cd\u8981\u7684\uff1a virtual addresses seen by application while physical addresses use by hardware\uff1b\u5373process\u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6240\u4f7f\u7528\u7684\u662fvirtual address\u3002 Systems can have one page table for the whole system separate page tables for each application and segment a tree of page tables for large segments or some combination of these. If there is only one page table, different applications running at the same time use different parts of a single range of virtual addresses. If there are multiple page or segment tables, there are multiple virtual address spaces and concurrent applications with separate page tables redirect to different real addresses. Some earlier systems with smaller real memory sizes, such as the SDS 940 , used page registers instead of page tables in memory for address translation.","title":"Page tables"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#paging#supervisor","text":"This part of the operating system creates and manages page tables . If the hardware raises a page fault exception , the paging supervisor accesses secondary storage, returns the page that has the virtual address that resulted in the page fault, updates the page tables to reflect the physical location of the virtual address and tells the translation mechanism to restart the request. When all physical memory is already in use, the paging supervisor must free a page in primary storage to hold the swapped-in page. The supervisor uses one of a variety of page replacement algorithms such as least recently used to determine which page to free.","title":"Paging supervisor"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#pinned#pages","text":"Operating systems have memory areas that are pinned (never swapped to secondary storage). Other terms used are locked , fixed , or wired pages. For example, interrupt mechanisms rely on an array of pointers to their handlers, such as I/O completion and page fault . If the pages containing these pointers or the code that they invoke were pageable, interrupt-handling would become far more complex and time-consuming, particularly in the case of page fault interruptions. Hence, some part of the page table structures is not pageable.","title":"Pinned pages"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#segmented#virtual#memory","text":"NOTE: \u8fd9\u79cd\u5e76\u975e\u4e3b\u6d41\u7684\uff0cpass\u6389\u3002","title":"Segmented virtual memory"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/#see#also","text":"Page table Page (computer memory) Paging Virtual Addresses","title":"See also"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/","text":"Paging In computer operating systems , paging is a memory management scheme by which a computer stores and retrieves data from secondary storage for use in main memory . In this scheme, the operating system retrieves data from secondary storage in same-size blocks called pages . Paging is an important part of virtual memory implementations in modern operating systems, using secondary storage to let programs exceed the size of available physical memory . For simplicity, main memory is called \"RAM\" (an acronym of \" random-access memory \") and secondary storage is called \"disk\" (a shorthand for \" hard disk drive \"), but the concepts do not depend on whether these terms apply literally to a specific computer system. Page faults Main article: Page fault When a process tries to reference a page not currently present in RAM, the processor treats this invalid memory reference as a page fault and transfers control from the program to the operating system. The operating system must: Determine the location of the data on disk. Obtain an empty page frame in RAM to use as a container for the data. Load the requested data into the available page frame. Update the page table to refer to the new page frame. Return control to the program, transparently retrying the instruction that caused the page fault. When all page frames are in use, the operating system must select a page frame to reuse for the page the program now needs. If the evicted page frame was dynamically allocated by a program to hold data, or if a program modified it since it was read into RAM (in other words, if it has become \"dirty\"), it must be written out to disk before being freed. If a program later references the evicted page, another page fault occurs and the page must be read back into RAM. The method the operating system uses to select the page frame to reuse, which is its page replacement algorithm , is important to efficiency. The operating system predicts the page frame least likely to be needed soon, often through the least recently used (LRU) algorithm or an algorithm based on the program's working set . To further increase responsiveness, paging systems may predict which pages will be needed soon, preemptively loading them into RAM before a program references them. Page replacement techniques Main articles: Page replacement algorithm and Demand paging Sharing In multi-programming or in a multi-user environment, many users may execute the same program, written so that its code and data are in separate pages. To minimize RAM use, all users share a single copy of the program. Each process's page table is set up so that the pages that address code point to the single shared copy, while the pages that address data point to different physical pages for each process. Different programs might also use the same libraries. To save space, only one copy of the shared library is loaded into physical memory. Programs which use the same library have virtual addresses that map to the same pages (which contain the library's code and data). When programs want to modify the library's code, they use copy-on-write , so memory is only allocated when needed. Shared memory is an efficient way of communication between programs. Programs can share pages in memory, and then write and read to exchange data. Implementations Unix and Unix-like systems Unix systems, and other Unix-like operating systems, use the term \" swap \" to describe both the act of moving memory pages between RAM and disk, and the region of a disk the pages are stored on. In some of those systems, it is common to dedicate an entire partition of a hard disk to swapping. These partitions are called swap partitions \uff08\u4ea4\u6362\u533a\uff09. Many systems have an entire hard drive dedicated to swapping, separate from the data drive(s), containing only a swap partition. A hard drive dedicated to swapping is called a \"swap drive\" or a \"scratch drive\" or a \" scratch disk \". Some of those systems only support swapping to a swap partition; others also support swapping to files. NOTE: **swap**\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u6240\u8bf4\u7684\u4ea4\u6362\u533a Linux The Linux kernel supports a virtually unlimited number of swap backends (devices or files), and also supports assignment of backend priorities. When the kernel needs to swap pages out of physical memory, it uses the highest-priority backend with available free space. If multiple swap backends are assigned the same priority, they are used in a round-robin fashion (which is somewhat similar to RAID 0 storage layouts), providing improved performance as long as the underlying devices can be efficiently accessed in parallel.","title":"Introduction"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/#paging","text":"In computer operating systems , paging is a memory management scheme by which a computer stores and retrieves data from secondary storage for use in main memory . In this scheme, the operating system retrieves data from secondary storage in same-size blocks called pages . Paging is an important part of virtual memory implementations in modern operating systems, using secondary storage to let programs exceed the size of available physical memory . For simplicity, main memory is called \"RAM\" (an acronym of \" random-access memory \") and secondary storage is called \"disk\" (a shorthand for \" hard disk drive \"), but the concepts do not depend on whether these terms apply literally to a specific computer system.","title":"Paging"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/#page#faults","text":"Main article: Page fault When a process tries to reference a page not currently present in RAM, the processor treats this invalid memory reference as a page fault and transfers control from the program to the operating system. The operating system must: Determine the location of the data on disk. Obtain an empty page frame in RAM to use as a container for the data. Load the requested data into the available page frame. Update the page table to refer to the new page frame. Return control to the program, transparently retrying the instruction that caused the page fault. When all page frames are in use, the operating system must select a page frame to reuse for the page the program now needs. If the evicted page frame was dynamically allocated by a program to hold data, or if a program modified it since it was read into RAM (in other words, if it has become \"dirty\"), it must be written out to disk before being freed. If a program later references the evicted page, another page fault occurs and the page must be read back into RAM. The method the operating system uses to select the page frame to reuse, which is its page replacement algorithm , is important to efficiency. The operating system predicts the page frame least likely to be needed soon, often through the least recently used (LRU) algorithm or an algorithm based on the program's working set . To further increase responsiveness, paging systems may predict which pages will be needed soon, preemptively loading them into RAM before a program references them.","title":"Page faults"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/#page#replacement#techniques","text":"Main articles: Page replacement algorithm and Demand paging","title":"Page replacement techniques"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/#sharing","text":"In multi-programming or in a multi-user environment, many users may execute the same program, written so that its code and data are in separate pages. To minimize RAM use, all users share a single copy of the program. Each process's page table is set up so that the pages that address code point to the single shared copy, while the pages that address data point to different physical pages for each process. Different programs might also use the same libraries. To save space, only one copy of the shared library is loaded into physical memory. Programs which use the same library have virtual addresses that map to the same pages (which contain the library's code and data). When programs want to modify the library's code, they use copy-on-write , so memory is only allocated when needed. Shared memory is an efficient way of communication between programs. Programs can share pages in memory, and then write and read to exchange data.","title":"Sharing"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/#implementations","text":"","title":"Implementations"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/#unix#and#unix-like#systems","text":"Unix systems, and other Unix-like operating systems, use the term \" swap \" to describe both the act of moving memory pages between RAM and disk, and the region of a disk the pages are stored on. In some of those systems, it is common to dedicate an entire partition of a hard disk to swapping. These partitions are called swap partitions \uff08\u4ea4\u6362\u533a\uff09. Many systems have an entire hard drive dedicated to swapping, separate from the data drive(s), containing only a swap partition. A hard drive dedicated to swapping is called a \"swap drive\" or a \"scratch drive\" or a \" scratch disk \". Some of those systems only support swapping to a swap partition; others also support swapping to files. NOTE: **swap**\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u6240\u8bf4\u7684\u4ea4\u6362\u533a","title":"Unix and Unix-like systems"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/#linux","text":"The Linux kernel supports a virtually unlimited number of swap backends (devices or files), and also supports assignment of backend priorities. When the kernel needs to swap pages out of physical memory, it uses the highest-priority backend with available free space. If multiple swap backends are assigned the same priority, they are used in a round-robin fashion (which is somewhat similar to RAID 0 storage layouts), providing improved performance as long as the underlying devices can be efficiently accessed in parallel.","title":"Linux"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/Unix-system-page-size/","text":"how is page size determined in virtual address space? Linux uses a virtual memory system where all of the addresses are virtual addresses and not physical addresses . These virtual addresses are converted into physical addresses by the processor. To make this translation easier, virtual and physical memory are divided into pages . Each of these pages is given a unique number; the page frame number. Some page sizes can be 2 KB, 4 KB, etc. But how is this page size number determined? Is it influenced by the size of the architecture? For example, a 32-bit bus will have 4 GB address space. A You can find out a system's default page size by querying its configuration via the getconf command: $ getconf PAGE_SIZE 4096 or $ getconf PAGESIZE 4096 NOTE: The above units are typically in bytes, so the 4096 equates to 4096 bytes or 4kB. This is hardwired in the Linux kernel's source here: Example $ more / usr / src / kernels / 3.13.9-100.f c19 . x86_64 / include / asm - generic / page . h ... ... /* PAGE_SHIFT determines the page size */ #define PAGE_SHIFT 12 #ifdef __ASSEMBLY__ #define PAGE_SIZE (1 << PAGE_SHIFT) #else #define PAGE_SIZE (1UL << PAGE_SHIFT) #endif #define PAGE_MASK (~(PAGE_SIZE-1)) How does shifting give you 4096? When you shift bits, you're performing a binary multiplication by 2. So in effect a shifting of bits to the left ( 1 << PAGE_SHIFT ) is doing the multiplication of 2^12 = 4096. $ echo \"2^12\" | bc 4096","title":"Unix-system-page-size"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/Unix-system-page-size/#how#is#page#size#determined#in#virtual#address#space","text":"Linux uses a virtual memory system where all of the addresses are virtual addresses and not physical addresses . These virtual addresses are converted into physical addresses by the processor. To make this translation easier, virtual and physical memory are divided into pages . Each of these pages is given a unique number; the page frame number. Some page sizes can be 2 KB, 4 KB, etc. But how is this page size number determined? Is it influenced by the size of the architecture? For example, a 32-bit bus will have 4 GB address space.","title":"how is page size determined in virtual address space?"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/Unix-system-page-size/#a","text":"You can find out a system's default page size by querying its configuration via the getconf command: $ getconf PAGE_SIZE 4096 or $ getconf PAGESIZE 4096 NOTE: The above units are typically in bytes, so the 4096 equates to 4096 bytes or 4kB. This is hardwired in the Linux kernel's source here:","title":"A"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/Unix-system-page-size/#example","text":"$ more / usr / src / kernels / 3.13.9-100.f c19 . x86_64 / include / asm - generic / page . h ... ... /* PAGE_SHIFT determines the page size */ #define PAGE_SHIFT 12 #ifdef __ASSEMBLY__ #define PAGE_SIZE (1 << PAGE_SHIFT) #else #define PAGE_SIZE (1UL << PAGE_SHIFT) #endif #define PAGE_MASK (~(PAGE_SIZE-1))","title":"Example"},{"location":"Kernel/Guide/Memory-management/Virtual-memory/Paging/Unix-system-page-size/#how#does#shifting#give#you#4096","text":"When you shift bits, you're performing a binary multiplication by 2. So in effect a shifting of bits to the left ( 1 << PAGE_SHIFT ) is doing the multiplication of 2^12 = 4096. $ echo \"2^12\" | bc 4096","title":"How does shifting give you 4096?"},{"location":"Kernel/Guide/Multitasking/Multitask/","text":"Computer multitasking Multitasking\u5373\u591a\u4efb\u52a1\uff0c\u662f\u73b0\u4ee3OS\u7684\u5fc5\u5907feature\uff0c\u672c\u7ae0\u5c31\u5bf9\u6b64\u8fdb\u884c\u5206\u6790\u3002 \u5728\u6587\u7ae0 Abstraction and model \u7684 Task model \u7ae0\u8282\u603b\u7ed3\u4e86Task model\uff0c\u652f\u6301multitasking\u7684OS kernel\u662f\u53ef\u4ee5\u4f7f\u7528 task model \u6765\u8fdb\u884c\u63cf\u8ff0\u7684\u3002 wikipedia Computer multitasking \u7ef4\u57fa\u767e\u79d1 Computer multitasking \u5bf9multitasking\u603b\u7ed3\u5730\u975e\u5e38\u597d\uff0c\u4e0b\u9762\u662f\u6211\u7684\u9605\u8bfb\u7b14\u8bb0\uff1a \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6211\u4eec\u5e94\u8be5\u4ee5\u53d1\u5c55\u7684\u773c\u5149\u6765\u770b\u5f85multitask\u7684\u53d1\u5c55\uff0cmultitask\u662f\u4e00\u4e2a\u5f88\u65e9\u63d0\u51fa\u7684**\u6982\u5ff5**\uff1a In computing , multitasking is the concurrent execution of multiple tasks \u663e\u7136\u8fd9\u4e2a\u6982\u5ff5\u6240\u5f3a\u8c03\u7684\u662ftask\u7684concurrent\uff08\u5e76\u53d1\uff09\u6267\u884c\u3002\u81f3\u4e8etask\u6240\u6307\u4e3a\u4f55\uff1f\u662fprocess\uff08\u8fdb\u7a0b\uff09\u8fd8\u662fthread\uff08\u7ebf\u7a0b\uff09\uff1f\u4e0d\u540c\u7684\u5b9e\u73b0\u80af\u5b9a\u7b54\u6848\u5c31\u4e0d\u540c\u4e86\u3002\u5728\u65e9\u671f\uff0cthread\u8fd8\u6ca1\u6709\u51fa\u73b0\u7684\u65f6\u5019\uff0c\u663e\u7136task\u6240\u6307\u4e3aprocess\u3002\u4f46\u662f\u968f\u7740\u6280\u672f\u7684\u53d1\u5c55\uff0c\u63d0\u51fa\u4e86thread\u7684\u6982\u5ff5\uff0c\u5982\u679cOS\u7684\u5b9e\u73b0\u652f\u6301\u7684thread\u7684\u8bdd\uff0c\u90a3\u4e48task\u5c31\u53ef\u80fd\u662f\u6307thread\u4e86\uff08\u663e\u7136task\u662f\u4e00\u79cd\u62bd\u8c61\u7684\u63cf\u8ff0\uff0c\u7c7b\u4f3c\u4e8e kernel control path \uff09\u3002 \u5728\u672c\u6587\u7684 Multithreading \u7ae0\u8282\u5c31\u8bf4\u660e\u4e86\u8fd9\u79cd\u6f14\u8fdb\uff1a\u4eceprocess\u5230thread\u3002\u8fd9\u4e00\u6bb5\u7684\u8bba\u8ff0\u662f\u6bd4\u8f83\u597d\u7684\uff0c\u5b83\u8bf4\u660e\u4e86thread\u7684\u4ef7\u503c\u6240\u5728\u3002\u5728\u672c\u6587\u7684\u5f00\u5934\u4e5f\u5bf9\u6b64\u8fdb\u884c\u4e86\u8bf4\u660e\uff1a Depending on the operating system, a task might be as large as an entire application program, or might be made up of smaller threads that carry out portions of the overall program. \u53e6\u5916\u4e00\u4e2a\u5173\u4e8emultitask\u9700\u8981\u8fdb\u884c\u5f3a\u8c03\u7684\u662f\uff1amultitask\u662foperating system\u5c42\u7684\u6982\u5ff5\uff0c\u5728hardware\u5c42\u6ca1\u6709multitask\u7684\u6982\u5ff5\uff0c\u6240\u4ee5multitask\u7531OS\u5382\u5546\u5b9e\u73b0\uff0c\u5728hardware\u5c42\u6bd4\u5982CPU\u538b\u6839\u5c31\u6ca1\u6709\u8fd9\u6837\u7684\u6982\u5ff5\u3002\u4e0d\u8fc7CPU\u5382\u5546\u80af\u5b9a\u4f1a\u4e3aOS\u63d0\u4f9b\u4fbf\u4e8e\u5b9e\u73b0multitask\u7684\u786c\u4ef6\u652f\u6301\uff0c\u6bd4\u5982\u63d0\u4f9b\u4e00\u4e9b\u4e13\u95e8\u7684\u6307\u4ee4\u7b49\u3002 \u5982\u4f55\u5b9e\u73b0multitask\uff1f \u90a3\u5982\u4f55\u5b9e\u73b0multitask\u5462\uff1f\u8fd9\u662f\u672c\u7ae0\u8981\u91cd\u70b9\u8ba8\u8bba\u7684\u95ee\u9898\uff0c\u672c\u7ae0\u5c06\u5206\u591a\u7bc7\u5bf9multitask\u7684\u5b9e\u73b0\u8fdb\u884c\u68b3\u7406\u3002 \u5173\u4e8e multitasking \u5b9e\u73b0\u7684\u4e00\u4e9b\u601d\u8003 OS\u4e3a\u4e86\u652f\u6301 multitasking \u90fd\u4f1a\u884d\u751f\u51fa\u4e00\u4e9b\u5217\u7684\u95ee\u9898\uff0c\u5e76\u4e14\u5b9e\u73b0 multitasking \u5f80\u5f80\u9700\u8981hardware\u548cOS\u540c\u65f6\u652f\u6301\uff1a \u95ee\u9898\u4e00\uff1a\u6b63\u5982 multitasking \u7684\u5b9a\u4e49\u6240\u652f\u6301\uff0cOS\u4e2d\u4f1a\u5b58\u5728\u591a\u4e2atask\uff0c\u90a3\u5982\u4f55\u4fdd\u8bc1task\u4e4b\u95f4\u5f7c\u6b64\u7684\u9694\u79bb\u3001\u4e92\u4e0d\u4fb5\u72af\uff1f \u8fd9\u4e2a\u95ee\u9898\u5728\u672c\u6587\u7684 Memory protection \u8fdb\u884c\u4e86\u8bf4\u660e\uff0c\u5176\u5b9e\u6700\u6839\u672c\u7684\u63aa\u65bd\u662f\u6bcf\u4e2aprocess\u90fd\u6709\u81ea\u5df1\u7684 address space \u3002 \u95ee\u9898\u4e8c\uff1aoperating system's scheduler \u5982\u4f55\u5b9e\u73b0\u6765\u652f\u6301 multitasking \uff1f scheduler \u7684\u5b9e\u73b0\u662f\u4e00\u4e2a\u975e\u5e38\u5b8f\u5927\u7684\u4e3b\u9898\uff0c\u5728\u6b64\u6211\u4eec\u4ec5\u4ec5\u8ba8\u8bba scheduler \u7684\u8c03\u5ea6\u7b56\u7565\uff0c\u6839\u636e scheduler \u7684\u8c03\u5ea6\u7b56\u7565\uff0c\u53ef\u4ee5\u5c06 multitasking \u5206\u4e3a\u5982\u4e0b\u4e24\u79cd\uff1a pre-emptive multitasking cooperative multitasking \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u4e24\u79cd\u65b9\u5f0f\u662f\u666e\u904d\u5b58\u5728\u7684\uff0c\u4e24\u8005\u5404\u6709\u5343\u79cb\uff0cOS\u7684\u5b9e\u73b0\u53ef\u4ee5\u6839\u636e\u9700\u6c42\u9009\u62e9\u5176\u4e2d\u4efb\u610f\u4e00\u79cd\u3002 \u65e0\u8bba\u54ea\u79cd multitasking \uff0c\u5728\u8fdb\u884c\u8c03\u5ea6\u7684\u65f6\u5019\uff0c\u90fd\u6d89\u53ca context switch \u3002 Task\u662fcontrol path \u5728 Control-path-&-Context-&-Context-switch \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u5c06task\u5f52\u5165\u4e86control path\u7684\u8303\u8f74\uff0c\u5728\u4e0b\u4e00\u7ae0\u4e2d\uff0c\u5c06\u5bf9\u5b83\u8fdb\u884c\u8be6\u7ec6\u5206\u6790\u3002 Linux OS\u7684\u5b9e\u73b0 \u5728\u672c\u4e66\u4e2d\uff0c\u5176\u5b9e\u5e76\u6ca1\u6709\u4e13\u95e8\u7684\u7ae0\u8282\u6765\u63cf\u8ff0linux OS\u4e2dmultitask\u7684\u5b9e\u73b0\uff0c\u800c\u662f\u5206\u6563\u5728\u591a\u4e2a\u7ae0\u8282\u3002\u6240\u4ee5\u5728\u6b64\u5bf9linux OS\u7684multitask\u7684\u5b9e\u73b0\u8fdb\u884c\u7efc\u8ff0\u3002","title":"Multitask"},{"location":"Kernel/Guide/Multitasking/Multitask/#computer#multitasking","text":"Multitasking\u5373\u591a\u4efb\u52a1\uff0c\u662f\u73b0\u4ee3OS\u7684\u5fc5\u5907feature\uff0c\u672c\u7ae0\u5c31\u5bf9\u6b64\u8fdb\u884c\u5206\u6790\u3002 \u5728\u6587\u7ae0 Abstraction and model \u7684 Task model \u7ae0\u8282\u603b\u7ed3\u4e86Task model\uff0c\u652f\u6301multitasking\u7684OS kernel\u662f\u53ef\u4ee5\u4f7f\u7528 task model \u6765\u8fdb\u884c\u63cf\u8ff0\u7684\u3002","title":"Computer multitasking"},{"location":"Kernel/Guide/Multitasking/Multitask/#wikipedia#computer#multitasking","text":"\u7ef4\u57fa\u767e\u79d1 Computer multitasking \u5bf9multitasking\u603b\u7ed3\u5730\u975e\u5e38\u597d\uff0c\u4e0b\u9762\u662f\u6211\u7684\u9605\u8bfb\u7b14\u8bb0\uff1a \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6211\u4eec\u5e94\u8be5\u4ee5\u53d1\u5c55\u7684\u773c\u5149\u6765\u770b\u5f85multitask\u7684\u53d1\u5c55\uff0cmultitask\u662f\u4e00\u4e2a\u5f88\u65e9\u63d0\u51fa\u7684**\u6982\u5ff5**\uff1a In computing , multitasking is the concurrent execution of multiple tasks \u663e\u7136\u8fd9\u4e2a\u6982\u5ff5\u6240\u5f3a\u8c03\u7684\u662ftask\u7684concurrent\uff08\u5e76\u53d1\uff09\u6267\u884c\u3002\u81f3\u4e8etask\u6240\u6307\u4e3a\u4f55\uff1f\u662fprocess\uff08\u8fdb\u7a0b\uff09\u8fd8\u662fthread\uff08\u7ebf\u7a0b\uff09\uff1f\u4e0d\u540c\u7684\u5b9e\u73b0\u80af\u5b9a\u7b54\u6848\u5c31\u4e0d\u540c\u4e86\u3002\u5728\u65e9\u671f\uff0cthread\u8fd8\u6ca1\u6709\u51fa\u73b0\u7684\u65f6\u5019\uff0c\u663e\u7136task\u6240\u6307\u4e3aprocess\u3002\u4f46\u662f\u968f\u7740\u6280\u672f\u7684\u53d1\u5c55\uff0c\u63d0\u51fa\u4e86thread\u7684\u6982\u5ff5\uff0c\u5982\u679cOS\u7684\u5b9e\u73b0\u652f\u6301\u7684thread\u7684\u8bdd\uff0c\u90a3\u4e48task\u5c31\u53ef\u80fd\u662f\u6307thread\u4e86\uff08\u663e\u7136task\u662f\u4e00\u79cd\u62bd\u8c61\u7684\u63cf\u8ff0\uff0c\u7c7b\u4f3c\u4e8e kernel control path \uff09\u3002 \u5728\u672c\u6587\u7684 Multithreading \u7ae0\u8282\u5c31\u8bf4\u660e\u4e86\u8fd9\u79cd\u6f14\u8fdb\uff1a\u4eceprocess\u5230thread\u3002\u8fd9\u4e00\u6bb5\u7684\u8bba\u8ff0\u662f\u6bd4\u8f83\u597d\u7684\uff0c\u5b83\u8bf4\u660e\u4e86thread\u7684\u4ef7\u503c\u6240\u5728\u3002\u5728\u672c\u6587\u7684\u5f00\u5934\u4e5f\u5bf9\u6b64\u8fdb\u884c\u4e86\u8bf4\u660e\uff1a Depending on the operating system, a task might be as large as an entire application program, or might be made up of smaller threads that carry out portions of the overall program. \u53e6\u5916\u4e00\u4e2a\u5173\u4e8emultitask\u9700\u8981\u8fdb\u884c\u5f3a\u8c03\u7684\u662f\uff1amultitask\u662foperating system\u5c42\u7684\u6982\u5ff5\uff0c\u5728hardware\u5c42\u6ca1\u6709multitask\u7684\u6982\u5ff5\uff0c\u6240\u4ee5multitask\u7531OS\u5382\u5546\u5b9e\u73b0\uff0c\u5728hardware\u5c42\u6bd4\u5982CPU\u538b\u6839\u5c31\u6ca1\u6709\u8fd9\u6837\u7684\u6982\u5ff5\u3002\u4e0d\u8fc7CPU\u5382\u5546\u80af\u5b9a\u4f1a\u4e3aOS\u63d0\u4f9b\u4fbf\u4e8e\u5b9e\u73b0multitask\u7684\u786c\u4ef6\u652f\u6301\uff0c\u6bd4\u5982\u63d0\u4f9b\u4e00\u4e9b\u4e13\u95e8\u7684\u6307\u4ee4\u7b49\u3002","title":"wikipedia Computer multitasking"},{"location":"Kernel/Guide/Multitasking/Multitask/#multitask","text":"\u90a3\u5982\u4f55\u5b9e\u73b0multitask\u5462\uff1f\u8fd9\u662f\u672c\u7ae0\u8981\u91cd\u70b9\u8ba8\u8bba\u7684\u95ee\u9898\uff0c\u672c\u7ae0\u5c06\u5206\u591a\u7bc7\u5bf9multitask\u7684\u5b9e\u73b0\u8fdb\u884c\u68b3\u7406\u3002","title":"\u5982\u4f55\u5b9e\u73b0multitask\uff1f"},{"location":"Kernel/Guide/Multitasking/Multitask/#multitasking","text":"OS\u4e3a\u4e86\u652f\u6301 multitasking \u90fd\u4f1a\u884d\u751f\u51fa\u4e00\u4e9b\u5217\u7684\u95ee\u9898\uff0c\u5e76\u4e14\u5b9e\u73b0 multitasking \u5f80\u5f80\u9700\u8981hardware\u548cOS\u540c\u65f6\u652f\u6301\uff1a \u95ee\u9898\u4e00\uff1a\u6b63\u5982 multitasking \u7684\u5b9a\u4e49\u6240\u652f\u6301\uff0cOS\u4e2d\u4f1a\u5b58\u5728\u591a\u4e2atask\uff0c\u90a3\u5982\u4f55\u4fdd\u8bc1task\u4e4b\u95f4\u5f7c\u6b64\u7684\u9694\u79bb\u3001\u4e92\u4e0d\u4fb5\u72af\uff1f \u8fd9\u4e2a\u95ee\u9898\u5728\u672c\u6587\u7684 Memory protection \u8fdb\u884c\u4e86\u8bf4\u660e\uff0c\u5176\u5b9e\u6700\u6839\u672c\u7684\u63aa\u65bd\u662f\u6bcf\u4e2aprocess\u90fd\u6709\u81ea\u5df1\u7684 address space \u3002 \u95ee\u9898\u4e8c\uff1aoperating system's scheduler \u5982\u4f55\u5b9e\u73b0\u6765\u652f\u6301 multitasking \uff1f scheduler \u7684\u5b9e\u73b0\u662f\u4e00\u4e2a\u975e\u5e38\u5b8f\u5927\u7684\u4e3b\u9898\uff0c\u5728\u6b64\u6211\u4eec\u4ec5\u4ec5\u8ba8\u8bba scheduler \u7684\u8c03\u5ea6\u7b56\u7565\uff0c\u6839\u636e scheduler \u7684\u8c03\u5ea6\u7b56\u7565\uff0c\u53ef\u4ee5\u5c06 multitasking \u5206\u4e3a\u5982\u4e0b\u4e24\u79cd\uff1a pre-emptive multitasking cooperative multitasking \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u4e24\u79cd\u65b9\u5f0f\u662f\u666e\u904d\u5b58\u5728\u7684\uff0c\u4e24\u8005\u5404\u6709\u5343\u79cb\uff0cOS\u7684\u5b9e\u73b0\u53ef\u4ee5\u6839\u636e\u9700\u6c42\u9009\u62e9\u5176\u4e2d\u4efb\u610f\u4e00\u79cd\u3002 \u65e0\u8bba\u54ea\u79cd multitasking \uff0c\u5728\u8fdb\u884c\u8c03\u5ea6\u7684\u65f6\u5019\uff0c\u90fd\u6d89\u53ca context switch \u3002","title":"\u5173\u4e8emultitasking\u5b9e\u73b0\u7684\u4e00\u4e9b\u601d\u8003"},{"location":"Kernel/Guide/Multitasking/Multitask/#taskcontrol#path","text":"\u5728 Control-path-&-Context-&-Context-switch \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u5c06task\u5f52\u5165\u4e86control path\u7684\u8303\u8f74\uff0c\u5728\u4e0b\u4e00\u7ae0\u4e2d\uff0c\u5c06\u5bf9\u5b83\u8fdb\u884c\u8be6\u7ec6\u5206\u6790\u3002","title":"Task\u662fcontrol path"},{"location":"Kernel/Guide/Multitasking/Multitask/#linux#os","text":"\u5728\u672c\u4e66\u4e2d\uff0c\u5176\u5b9e\u5e76\u6ca1\u6709\u4e13\u95e8\u7684\u7ae0\u8282\u6765\u63cf\u8ff0linux OS\u4e2dmultitask\u7684\u5b9e\u73b0\uff0c\u800c\u662f\u5206\u6563\u5728\u591a\u4e2a\u7ae0\u8282\u3002\u6240\u4ee5\u5728\u6b64\u5bf9linux OS\u7684multitask\u7684\u5b9e\u73b0\u8fdb\u884c\u7efc\u8ff0\u3002","title":"Linux OS\u7684\u5b9e\u73b0"},{"location":"Kernel/Guide/Multitasking/Process-model/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u63cf\u8ff0process model\uff0c\u6d89\u53ca\u7684\u5185\u5bb9\u5982\u4e0b: 1\u3001Process \u4ecb\u7ecdprocess\u3001thread\u7684\u6982\u5ff5 2\u3001Process-execution-model \u63cf\u8ff0process\u7684execution 3\u3001Process-resource \u63cf\u8ff0process\u7684resource 4\u3001Process-lifetime \u63cf\u8ff0process\u7684lifetime 5\u3001Linux-implementation \u63cf\u8ff0Linux implementation","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/#_1","text":"\u672c\u7ae0\u63cf\u8ff0process model\uff0c\u6d89\u53ca\u7684\u5185\u5bb9\u5982\u4e0b: 1\u3001Process \u4ecb\u7ecdprocess\u3001thread\u7684\u6982\u5ff5 2\u3001Process-execution-model \u63cf\u8ff0process\u7684execution 3\u3001Process-resource \u63cf\u8ff0process\u7684resource 4\u3001Process-lifetime \u63cf\u8ff0process\u7684lifetime 5\u3001Linux-implementation \u63cf\u8ff0Linux implementation","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Kernel/Guide/Multitasking/Process-model/Linux-implementation/Linux-OS-implementation-of-process-model/","text":"Linux OS implementation of process model \u5728\u672c\u4e66\u7684chapter 1.1. Linux Versus Other Unix-Like Kernels\u5bf9linux OS\u4e2dprocess model\u7684\u5b9e\u73b0\u601d\u8def\u8fdb\u884c\u4e86\u6982\u62ec\uff1a Most modern operating systems have some kind of support for multithreaded applications that is, user programs that are designed in terms of many relatively independent execution flows that share a large portion of the application data structures. A multithreaded user application could be composed of many lightweight processes (LWP), which are processes that can operate on a common address space, common physical memory pages, common opened files, and so on. Linux defines its own version of lightweight processes , which is different from the types used on other systems such as SVR4 and Solaris. While all the commercial Unix variants of LWP are based on kernel threads , Linux regards lightweight processes as the basic execution context and handles them via the nonstandard clone(2) system call. Process\u548cThread\u7684\u6982\u5ff5\u5728\u524d\u9762\u7684\u7ae0\u8282\u5df2\u7ecf\u63cf\u8ff0\u4e86\uff0c\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5f15\u5165\u4e86\u4e00\u4e2a\u65b0\u7684\u6982\u5ff5\uff1a lightweight processes (LWP)\uff0c lightweight processes \u662f\u4e00\u4e2a\u5b9e\u73b0\u5c42\u9762\u7684\u6982\u5ff5\uff0c\u800cProcess\u548cThread\u662f\u6807\u51c6\u5b9a\u4e49\u7684\u6982\u5ff5\u3002 \u7ed3\u5408\u524d\u9762\u7ae0\u8282\u5173\u4e8eprocess model\u7684\u63cf\u8ff0\u548c\u4e0a\u9762\u8fd9\u6bb5\u5173\u4e8elinux OS\u4e2dprocess model\u5b9e\u73b0\u6982\u8ff0\uff0c\u53ef\u4ee5\u603b\u7ed3\uff1a Linux OS\u7684kernel scheduling entity\u662f**lightweight processes** linux OS\u901a\u8fc7\u5b83\u7684**lightweight processes**\u6765\u5b9e\u73b0process model\u7684\uff1blinux OS\u4e2d\uff0clight weight process\u5bf9\u5e94\u7684\u662f\u6807\u51c6\u7684thread\uff0clinux OS\u4e2d\uff0c\u4e00\u4e2aprocess\u7531n\uff08n>=1\uff09\u4e2alight weight process\u7ec4\u6210\uff08\u663e\u7136\uff0c\u5f53n\u4e3a1\u65f6\uff0c\u4e00\u4e2aprocess\u53ea\u6709\u4e00\u4e2alightweight process\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u901a\u5e38\u6240\u8bf4\u7684single-thread process\uff09\u3002 \u5728\u672c\u4e66chapter 3.1. Processes, Lightweight Processes, and Threads\u4e2d\u5b9a\u4e49\u4e86*thread group*\u7684\u6982\u5ff5\uff0c*thread group*\u76f8\u5f53\u4e8eprocess\u3002 \u5728\u672c\u4e66chapter 3.1. Processes, Lightweight Processes, and Threads\u4e2d\u63d0\u51fa\uff1a\u5bf9\u4e8e\u9762\u5411process\u7684system call\uff0cthread group\u8981\u201cact as a whole\u201d\u5373\u8868\u793a\u4e3a\u4e00\u4e2a\u6574\u4f53\uff0c\u8fd9\u4e9bsystem call\u5305\u62ec\uff1a getpid \u3001 kill \u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5728\u672c\u4e66\u4e2d\u6709\u65f6\u5019\u4f1a\u5c06lightweight process\u7b80\u79f0\u4e3aprocess\uff0c\u6bd4\u5982\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u8fd9\u53e5\uff1a A multithreaded user application could be composed of many lightweight processes (LWP), which are processes that can operate on a common address space, common physical memory pages, common opened files, and so on. \u6240\u4ee5\u5728\u672c\u4e66\u4e2d\uff0cprocess\u4e0d\u4e00\u5b9a\u6307\u7684\u662f\u6807\u51c6\u7684process\uff0c\u6709\u7684\u65f6\u5019\u6307\u7684\u662flightweight process\uff1b\u5728\u672c\u4e66\u4e2d\uff0c\u4f7f\u7528**thread group**\u6765\u8868\u793a\u6807\u51c6\u7684process\u3002\u8bb0\u4f4f\u8fd9\u4e00\u70b9\uff0c\u5426\u5219\u672c\u4e66\u4e2d\u7684\u5f88\u591a\u5730\u65b9\u90fd\u4f1a\u641e\u6df7\u6dc6\u3002 \u5173\u4e8elightweight process\uff0c\u53c2\u89c1\uff1a Light-weight process \u66f4\u52a0\u6df1\u5165\u7684\u5206\u6790 \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u544a\u8bc9\u4e86\u6211\u4eec\uff0clightweight process\u662f\u7531nonstandard clone(2) system call\u521b\u5efa\u3002\u6807\u51c6\u7ed9\u51fa\u7684\u521b\u5efaprocess\u7684api\u662f fork(2) \uff0cPOSIX\u6807\u51c6\u6240\u5b9a\u4e49\u7684\u521b\u5efathread\u7684api\u662f pthread_create(3) \uff0c\u4e0b\u9762\u901a\u8fc7linux\u7684man\u6765\u63a2\u7d22\u5b83\u4eec\u7684\u5b9e\u73b0\u7ec6\u8282\uff1a \u5728 PTHREADS(7) \u7684Linux implementations of POSIX threads\u7ae0\u8282\u7ed9\u51fa\u4e86linux\u4e2dPOSIX threads\u7684\u5b9e\u73b0\u65b9\u5f0f\u7684\u8be6\u7ec6\u4fe1\u606f Over time, two threading implementations have been provided by the GNU C library on Linux: LinuxThreads \u200b This is the original Pthreads implementation. Since glibc 2.4, this implementation is no longer supported. NPTL (Native POSIX Threads Library) \u200b This is the modern Pthreads implementation. By comparison with LinuxThreads, NPTL provides closer conformance to the requirements of the POSIX.1 specification and better performance when creating large numbers of threads. NPTL is available since glibc 2.3.2, and requires features that are present in the Linux 2.6 kernel. Both of these are so-called 1:1 implementations, meaning that each thread maps to a kernel scheduling entity. Both threading implementations employ the Linux clone(2 ) system call. In NPTL, thread synchronization primitives (mutexes, thread joining, and so on) are implemented using the Linux futex(2) system call. \u53ef\u4ee5\u770b\u5230\u65e0\u8bba\u91c7\u7528\u54ea\u79cd\u65b9\u5f0f\uff0c\u6700\u7ec8\u90fd\u662f\u4f9d\u8d56 clone(2) \u3002 \u5728 fork(2) \u7684 NOTES \u7ae0\u8282\u63cf\u8ff0\u4e86 fork \u7684\u5b9e\u73b0\u7ec6\u8282\uff1a Since version 2.3.3, rather than invoking the kernel's fork() system call, the glibc fork() wrapper that is provided as part of the NPTL threading implementation invokes clone(2) with flags that provide the same effect as the traditional system call. (A call to fork() is equivalent to a call to clone(2) specifying flags as just SIGCHLD.) The glibc wrapper invokes any fork handlers that have been established using pthread_atfork(3) . \u663e\u7136\uff0c fork(2) \u7684\u5b9e\u73b0\u4e5f\u662f\u4f9d\u8d56 clone(2) \u3002 linux kernel\u5982\u4f55\u5b9e\u73b0process\u4e0ethread \u53c2\u89c13.1. Processes, Lightweight Processes, and Threads \u6211\u89c9\u5f97\u8981\u60f3\u89e3\u91ca\u597d\u8fd9\u4e2a\u95ee\u9898\uff0c\u9700\u8981\u68b3\u7406\u4e00\u4e0blinux\u7684fork\uff0cclone\u4e4b\u95f4\u7684\u5173\u7cfb\u3002\u5728 Fork (system call) \u8fd9\u7bc7\u6587\u7ae0\u4e2d\u68b3\u7406\u5730\u975e\u5e38\u597d\u3002\u57283.4. Creating Processes\u4e2d\u4e5f\u6709\u76f8\u5173\u7684\u63cf\u8ff0\u3002 per-process kernel data structures \u57283.4. Creating Processes\u4e2d\u63d0\u51fa\u4e86\u8fd9\u4e2a\u8bf4\u6cd5\uff0c\u5b83\u8ba9\u6211\u60f3\u8d77\u4e86\u4e24\u4ef6\u4e8b\u60c5\uff1a process\u4f5c\u4e3asystem resource\u5206\u914d\u5355\u4f4d\uff0c\u5b83\u6709\u54ea\u4e9bresource\u5462\uff1f\u663e\u7136\uff0c\u5b83\u7684\u6240\u6709\u7684resource\u90fd\u9700\u8981\u4f7f\u7528\u4e00\u4e2a kernel data structures\u6765\u8fdb\u884c\u63cf\u8ff0\u3002\u6709\u5fc5\u8981\u603b\u7ed3per-process\u7684resource\u4ee5\u53ca\u5bf9\u5e94\u7684kernel data structures\u3002\u4e0e\u6b64\u76f8\u5173\u7684\u4e00\u4e2a\u95ee\u9898\u5c31\u662f\uff0c\u8fd9\u4e9bresource\u54ea\u4e9b\u662fchild process\u53ef\u4ee5\u7ee7\u627f\u7684\uff0c\u54ea\u4e9b\u662f\u65e0\u6cd5\u7ee7\u627f\u7684\u3002 \u663e\u7136\uff0c\u591a\u4e2alightweight process\u662f\u53ef\u4ee5\u5171\u4eabper-process kernel data structure\u7684\uff08\u8fd9\u662f\u6807\u51c6\u89c4\u5b9a\u7684\uff09\uff0c\u8fd9\u79cd\u5171\u4eab\uff0c\u6211\u89c9\u5f97\u5b9e\u73b0\u4e0a\u5e94\u8be5\u4e5f\u662f\u975e\u5e38\u7b80\u5355\u7684\uff0c\u65e0\u975e\u5c31\u662f\u4f20\u5165\u4e00\u4e2a\u6307\u9488\u3002 LWP VS thread VS kernel thread? \u5173\u4e8e\u672c\u6bb5\uff0c\u6709\u7591\u95ee\uff1aLWP VS thread VS kernel thread? \u4e0a\u4e00\u6bb5\u4e2d\u6240\u63cf\u8ff0\u7684\uff1aLinux kernel threads do not represent the basic execution context abstraction. \u672c\u6bb5\u4e2d\u6240\u63cf\u8ff0\u7684\uff1aLinux regards lightweight processes as the basic execution context and handles them via the nonstandard clone( ) system call. \u663e\u7136\uff0ckernel thread\u4e0d\u662flinux\u7684lightweight process\u3002 \u663e\u7136linux\u7684lightweight process\u662f\u9700\u8981\u7531linux\u7684scheduler\u6765\u8fdb\u884c\u8c03\u5ea6\u7684\uff0c\u90a3kernel thread\u662f\u7531\u8c01\u6765\u8fdb\u884c\u8c03\u5ea6\u5462\uff1f\u4e0b\u9762\u662f\u4e00\u4e9b\u6709\u4ef7\u503c\u7684\u5185\u5bb9\uff1a Are kernel threads processes and daemons? Difference between user-level and kernel-supported threads? Kernel threads made easy Linux OS lightweigh thread\u6240\u5171\u4eab\u7684 \u6807\u51c6process ID See also \u53c2\u89c1\u7ae0\u8282\uff1a 1.6.2. Process Implementation 1.6.4. Process Address Space Linux OS process model\u7684\u5b9e\u73b0 \u4e4b\u524d\u6211\u4e00\u76f4\u6709\u4e00\u4e2a\u7591\u95ee\u5c31\u662f\uff1a\u4e00\u4e2aprocess\u7684\u6240\u6709\u7684thread\u90fd\u5171\u4eab\u8be5process\u7684address space\uff0c\u800c\u6bcf\u4e2athread\u6709\u4e00\u4e2a\u81ea\u5df1\u7684 call stack \uff0c\u5e76\u4e14call stack\u662f\u5411\u4e0b\u751f\u957f\u7684\uff0c\u5f53\u65f6\u6211\u5c31\u975e\u5e38\u7591\u60d1\uff0c\u8fd9\u8981\u5982\u4f55\u5b9e\u73b0\u5440\uff1f\u4eca\u5929\u5728\u9605\u8bfb Call stack \u3001 Stack register \u7684\u65f6\u5019\uff0c\u6211\u6709\u4e86\u5982\u4e0b\u7684\u8ba4\u77e5\uff1a \u51fd\u6570\u8c03\u7528\u6240\u4f7f\u7528\u7684\u662fJMP\u6307\u4ee4 x86\u6709segment register\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u6307\u5b9acall stack \u5176\u5b9ecall stack\u5c31\u662f\u4e00\u7247\u5185\u5b58\u533a\u57df\u800c\u5df2\uff0c\u53ea\u8981\u6307\u5b9a\u4e00\u7247\u5185\u5b58\u533a\u57df\u4f5c\u4e3acall stack\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528calling convention\u6765\u5b9e\u73b0\u51fd\u6570\u8c03\u7528\u4e86\u3002\u5b9e\u73b0\u51fd\u6570\u8c03\u7528\u3001\u6267\u884c\u7684\u6307\u4ee4\u662f\u4e0e\u8fd9\u7247\u5185\u5b58\u533a\u57df\u5728\u4f55\u5904\u65e0\u5173\u7684\uff0c\u6240\u4ee5\u7528\u6237\u662f\u53ef\u4ee5\u6307\u5b9a\u4efb\u610f\u7684\u3001\u5408\u6cd5\u7684\u5185\u5b58\u533a\u57df\u6765\u4f5c\u4e3acall stack\u7684\u3002 \u6240\u4ee5\u6211\u5c31\u53bb\u770b\u4e86 pthread_create \u7684\u6587\u6863\uff0c\u5176\u4e2d\u662f\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\u7684\uff1a On Linux/x86-32, the default stack size for a new thread is 2 megabytes. Under the NPTL threading implementation, if the RLIMIT_STACK soft resource limit at the time the program started has any value other than \"unlimited\", then it determines the default stack size of new threads. Using pthread_attr_setstacksize (3), the stack size attribute can be explicitly set in the attr argument used to create a thread, in order to obtain a stack size other than the default. \u5373\u65b0\u521b\u5efa\u7684thread\u7684\u9ed8\u8ba4\u7684call stack\u7684\u5927\u5c0f\u9ed8\u8ba4\u662f2M\uff0c\u8fd9\u8bf4\u660e\u662f\u53ef\u4ee5\u7531\u7528\u6237\u4e86\u6765\u6307\u5b9a\u65b0\u521b\u5efa\u7684thread\u7684call stack\u7684\uff0c\u6211\u4eec\u77e5\u9053\uff0c pthread_create \u6700\u7ec8\u662f\u901a\u8fc7\u8c03\u7528 clone(2) \uff0c\u8be5\u51fd\u6570\u7684\u7b2c\u4e8c\u4e2a\u5165\u53c2\u5c31\u662f\u7531\u7528\u6237\u6765\u6307\u5b9a\u8be5lightweight process\u7684call stack\u7684\u3002 \u770b\u5230\u4e86\u4e0a\u9762\u7684\u63cf\u8ff0\uff0c \u5176\u5b9e\u6211\u53c8\u60f3\u5230\u4e86\u4e00\u4e2a\u95ee\u9898\uff1a\u4e00\u4e2a\u51fd\u6570\uff0c\u5982\u679c\u58f0\u660e\u7684\u81ea\u52a8\u53d8\u91cf\u5927\u5c0f\u8d85\u8fc7\u4e86call stack\u7684\u5927\u5c0f\uff0c\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u4f1a\u53d1\u751f Stack overflow \uff0c\u5173\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u53c2\u89c1\uff1a https://www.cnblogs.com/zmlctt/p/3987181.html https://blog.csdn.net/zDavid_2018/article/details/89255630 \u7ef4\u57fa\u767e\u79d1\u7684 Stack overflow \u603b\u7ed3\u7684\u975e\u5e38\u597d\u3002 Process VS thread VS lightweight-process \u4e0b\u9762\u662f\u4e00\u4e9b\u6211\u89c9\u5f97\u6bd4\u8f83\u597d\u7684\u5173\u4e8e\u8fd9\u4e2a\u95ee\u9898\u7684\u8ba8\u8bba\uff1a What the difference between lightweight process and thread? What is the difference between LWP and threads? What are the relations between processes, kernel threads, lightweight processes and user threads in Unix? [closed] What are Linux Processes, Threads, Light Weight Processes, and Process State","title":"Linux-OS-implementation-of-process-model"},{"location":"Kernel/Guide/Multitasking/Process-model/Linux-implementation/Linux-OS-implementation-of-process-model/#linux#os#implementation#of#process#model","text":"\u5728\u672c\u4e66\u7684chapter 1.1. Linux Versus Other Unix-Like Kernels\u5bf9linux OS\u4e2dprocess model\u7684\u5b9e\u73b0\u601d\u8def\u8fdb\u884c\u4e86\u6982\u62ec\uff1a Most modern operating systems have some kind of support for multithreaded applications that is, user programs that are designed in terms of many relatively independent execution flows that share a large portion of the application data structures. A multithreaded user application could be composed of many lightweight processes (LWP), which are processes that can operate on a common address space, common physical memory pages, common opened files, and so on. Linux defines its own version of lightweight processes , which is different from the types used on other systems such as SVR4 and Solaris. While all the commercial Unix variants of LWP are based on kernel threads , Linux regards lightweight processes as the basic execution context and handles them via the nonstandard clone(2) system call. Process\u548cThread\u7684\u6982\u5ff5\u5728\u524d\u9762\u7684\u7ae0\u8282\u5df2\u7ecf\u63cf\u8ff0\u4e86\uff0c\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5f15\u5165\u4e86\u4e00\u4e2a\u65b0\u7684\u6982\u5ff5\uff1a lightweight processes (LWP)\uff0c lightweight processes \u662f\u4e00\u4e2a\u5b9e\u73b0\u5c42\u9762\u7684\u6982\u5ff5\uff0c\u800cProcess\u548cThread\u662f\u6807\u51c6\u5b9a\u4e49\u7684\u6982\u5ff5\u3002 \u7ed3\u5408\u524d\u9762\u7ae0\u8282\u5173\u4e8eprocess model\u7684\u63cf\u8ff0\u548c\u4e0a\u9762\u8fd9\u6bb5\u5173\u4e8elinux OS\u4e2dprocess model\u5b9e\u73b0\u6982\u8ff0\uff0c\u53ef\u4ee5\u603b\u7ed3\uff1a Linux OS\u7684kernel scheduling entity\u662f**lightweight processes** linux OS\u901a\u8fc7\u5b83\u7684**lightweight processes**\u6765\u5b9e\u73b0process model\u7684\uff1blinux OS\u4e2d\uff0clight weight process\u5bf9\u5e94\u7684\u662f\u6807\u51c6\u7684thread\uff0clinux OS\u4e2d\uff0c\u4e00\u4e2aprocess\u7531n\uff08n>=1\uff09\u4e2alight weight process\u7ec4\u6210\uff08\u663e\u7136\uff0c\u5f53n\u4e3a1\u65f6\uff0c\u4e00\u4e2aprocess\u53ea\u6709\u4e00\u4e2alightweight process\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u901a\u5e38\u6240\u8bf4\u7684single-thread process\uff09\u3002 \u5728\u672c\u4e66chapter 3.1. Processes, Lightweight Processes, and Threads\u4e2d\u5b9a\u4e49\u4e86*thread group*\u7684\u6982\u5ff5\uff0c*thread group*\u76f8\u5f53\u4e8eprocess\u3002 \u5728\u672c\u4e66chapter 3.1. Processes, Lightweight Processes, and Threads\u4e2d\u63d0\u51fa\uff1a\u5bf9\u4e8e\u9762\u5411process\u7684system call\uff0cthread group\u8981\u201cact as a whole\u201d\u5373\u8868\u793a\u4e3a\u4e00\u4e2a\u6574\u4f53\uff0c\u8fd9\u4e9bsystem call\u5305\u62ec\uff1a getpid \u3001 kill \u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5728\u672c\u4e66\u4e2d\u6709\u65f6\u5019\u4f1a\u5c06lightweight process\u7b80\u79f0\u4e3aprocess\uff0c\u6bd4\u5982\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u8fd9\u53e5\uff1a A multithreaded user application could be composed of many lightweight processes (LWP), which are processes that can operate on a common address space, common physical memory pages, common opened files, and so on. \u6240\u4ee5\u5728\u672c\u4e66\u4e2d\uff0cprocess\u4e0d\u4e00\u5b9a\u6307\u7684\u662f\u6807\u51c6\u7684process\uff0c\u6709\u7684\u65f6\u5019\u6307\u7684\u662flightweight process\uff1b\u5728\u672c\u4e66\u4e2d\uff0c\u4f7f\u7528**thread group**\u6765\u8868\u793a\u6807\u51c6\u7684process\u3002\u8bb0\u4f4f\u8fd9\u4e00\u70b9\uff0c\u5426\u5219\u672c\u4e66\u4e2d\u7684\u5f88\u591a\u5730\u65b9\u90fd\u4f1a\u641e\u6df7\u6dc6\u3002 \u5173\u4e8elightweight process\uff0c\u53c2\u89c1\uff1a Light-weight process","title":"Linux OS implementation of process model"},{"location":"Kernel/Guide/Multitasking/Process-model/Linux-implementation/Linux-OS-implementation-of-process-model/#_1","text":"\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u544a\u8bc9\u4e86\u6211\u4eec\uff0clightweight process\u662f\u7531nonstandard clone(2) system call\u521b\u5efa\u3002\u6807\u51c6\u7ed9\u51fa\u7684\u521b\u5efaprocess\u7684api\u662f fork(2) \uff0cPOSIX\u6807\u51c6\u6240\u5b9a\u4e49\u7684\u521b\u5efathread\u7684api\u662f pthread_create(3) \uff0c\u4e0b\u9762\u901a\u8fc7linux\u7684man\u6765\u63a2\u7d22\u5b83\u4eec\u7684\u5b9e\u73b0\u7ec6\u8282\uff1a \u5728 PTHREADS(7) \u7684Linux implementations of POSIX threads\u7ae0\u8282\u7ed9\u51fa\u4e86linux\u4e2dPOSIX threads\u7684\u5b9e\u73b0\u65b9\u5f0f\u7684\u8be6\u7ec6\u4fe1\u606f Over time, two threading implementations have been provided by the GNU C library on Linux: LinuxThreads \u200b This is the original Pthreads implementation. Since glibc 2.4, this implementation is no longer supported. NPTL (Native POSIX Threads Library) \u200b This is the modern Pthreads implementation. By comparison with LinuxThreads, NPTL provides closer conformance to the requirements of the POSIX.1 specification and better performance when creating large numbers of threads. NPTL is available since glibc 2.3.2, and requires features that are present in the Linux 2.6 kernel. Both of these are so-called 1:1 implementations, meaning that each thread maps to a kernel scheduling entity. Both threading implementations employ the Linux clone(2 ) system call. In NPTL, thread synchronization primitives (mutexes, thread joining, and so on) are implemented using the Linux futex(2) system call. \u53ef\u4ee5\u770b\u5230\u65e0\u8bba\u91c7\u7528\u54ea\u79cd\u65b9\u5f0f\uff0c\u6700\u7ec8\u90fd\u662f\u4f9d\u8d56 clone(2) \u3002 \u5728 fork(2) \u7684 NOTES \u7ae0\u8282\u63cf\u8ff0\u4e86 fork \u7684\u5b9e\u73b0\u7ec6\u8282\uff1a Since version 2.3.3, rather than invoking the kernel's fork() system call, the glibc fork() wrapper that is provided as part of the NPTL threading implementation invokes clone(2) with flags that provide the same effect as the traditional system call. (A call to fork() is equivalent to a call to clone(2) specifying flags as just SIGCHLD.) The glibc wrapper invokes any fork handlers that have been established using pthread_atfork(3) . \u663e\u7136\uff0c fork(2) \u7684\u5b9e\u73b0\u4e5f\u662f\u4f9d\u8d56 clone(2) \u3002","title":"\u66f4\u52a0\u6df1\u5165\u7684\u5206\u6790"},{"location":"Kernel/Guide/Multitasking/Process-model/Linux-implementation/Linux-OS-implementation-of-process-model/#linux#kernelprocessthread","text":"\u53c2\u89c13.1. Processes, Lightweight Processes, and Threads \u6211\u89c9\u5f97\u8981\u60f3\u89e3\u91ca\u597d\u8fd9\u4e2a\u95ee\u9898\uff0c\u9700\u8981\u68b3\u7406\u4e00\u4e0blinux\u7684fork\uff0cclone\u4e4b\u95f4\u7684\u5173\u7cfb\u3002\u5728 Fork (system call) \u8fd9\u7bc7\u6587\u7ae0\u4e2d\u68b3\u7406\u5730\u975e\u5e38\u597d\u3002\u57283.4. Creating Processes\u4e2d\u4e5f\u6709\u76f8\u5173\u7684\u63cf\u8ff0\u3002","title":"linux kernel\u5982\u4f55\u5b9e\u73b0process\u4e0ethread"},{"location":"Kernel/Guide/Multitasking/Process-model/Linux-implementation/Linux-OS-implementation-of-process-model/#per-process#kernel#data#structures","text":"\u57283.4. Creating Processes\u4e2d\u63d0\u51fa\u4e86\u8fd9\u4e2a\u8bf4\u6cd5\uff0c\u5b83\u8ba9\u6211\u60f3\u8d77\u4e86\u4e24\u4ef6\u4e8b\u60c5\uff1a process\u4f5c\u4e3asystem resource\u5206\u914d\u5355\u4f4d\uff0c\u5b83\u6709\u54ea\u4e9bresource\u5462\uff1f\u663e\u7136\uff0c\u5b83\u7684\u6240\u6709\u7684resource\u90fd\u9700\u8981\u4f7f\u7528\u4e00\u4e2a kernel data structures\u6765\u8fdb\u884c\u63cf\u8ff0\u3002\u6709\u5fc5\u8981\u603b\u7ed3per-process\u7684resource\u4ee5\u53ca\u5bf9\u5e94\u7684kernel data structures\u3002\u4e0e\u6b64\u76f8\u5173\u7684\u4e00\u4e2a\u95ee\u9898\u5c31\u662f\uff0c\u8fd9\u4e9bresource\u54ea\u4e9b\u662fchild process\u53ef\u4ee5\u7ee7\u627f\u7684\uff0c\u54ea\u4e9b\u662f\u65e0\u6cd5\u7ee7\u627f\u7684\u3002 \u663e\u7136\uff0c\u591a\u4e2alightweight process\u662f\u53ef\u4ee5\u5171\u4eabper-process kernel data structure\u7684\uff08\u8fd9\u662f\u6807\u51c6\u89c4\u5b9a\u7684\uff09\uff0c\u8fd9\u79cd\u5171\u4eab\uff0c\u6211\u89c9\u5f97\u5b9e\u73b0\u4e0a\u5e94\u8be5\u4e5f\u662f\u975e\u5e38\u7b80\u5355\u7684\uff0c\u65e0\u975e\u5c31\u662f\u4f20\u5165\u4e00\u4e2a\u6307\u9488\u3002","title":"per-process kernel data structures"},{"location":"Kernel/Guide/Multitasking/Process-model/Linux-implementation/Linux-OS-implementation-of-process-model/#lwp#vs#thread#vs#kernel#thread","text":"\u5173\u4e8e\u672c\u6bb5\uff0c\u6709\u7591\u95ee\uff1aLWP VS thread VS kernel thread? \u4e0a\u4e00\u6bb5\u4e2d\u6240\u63cf\u8ff0\u7684\uff1aLinux kernel threads do not represent the basic execution context abstraction. \u672c\u6bb5\u4e2d\u6240\u63cf\u8ff0\u7684\uff1aLinux regards lightweight processes as the basic execution context and handles them via the nonstandard clone( ) system call. \u663e\u7136\uff0ckernel thread\u4e0d\u662flinux\u7684lightweight process\u3002 \u663e\u7136linux\u7684lightweight process\u662f\u9700\u8981\u7531linux\u7684scheduler\u6765\u8fdb\u884c\u8c03\u5ea6\u7684\uff0c\u90a3kernel thread\u662f\u7531\u8c01\u6765\u8fdb\u884c\u8c03\u5ea6\u5462\uff1f\u4e0b\u9762\u662f\u4e00\u4e9b\u6709\u4ef7\u503c\u7684\u5185\u5bb9\uff1a Are kernel threads processes and daemons? Difference between user-level and kernel-supported threads? Kernel threads made easy","title":"LWP VS thread VS kernel thread?"},{"location":"Kernel/Guide/Multitasking/Process-model/Linux-implementation/Linux-OS-implementation-of-process-model/#linux#os#lightweigh#thread","text":"\u6807\u51c6process ID","title":"Linux OS lightweigh thread\u6240\u5171\u4eab\u7684"},{"location":"Kernel/Guide/Multitasking/Process-model/Linux-implementation/Linux-OS-implementation-of-process-model/#see#also","text":"\u53c2\u89c1\u7ae0\u8282\uff1a 1.6.2. Process Implementation 1.6.4. Process Address Space","title":"See also"},{"location":"Kernel/Guide/Multitasking/Process-model/Linux-implementation/Linux-OS-implementation-of-process-model/#linux#os#process#model","text":"\u4e4b\u524d\u6211\u4e00\u76f4\u6709\u4e00\u4e2a\u7591\u95ee\u5c31\u662f\uff1a\u4e00\u4e2aprocess\u7684\u6240\u6709\u7684thread\u90fd\u5171\u4eab\u8be5process\u7684address space\uff0c\u800c\u6bcf\u4e2athread\u6709\u4e00\u4e2a\u81ea\u5df1\u7684 call stack \uff0c\u5e76\u4e14call stack\u662f\u5411\u4e0b\u751f\u957f\u7684\uff0c\u5f53\u65f6\u6211\u5c31\u975e\u5e38\u7591\u60d1\uff0c\u8fd9\u8981\u5982\u4f55\u5b9e\u73b0\u5440\uff1f\u4eca\u5929\u5728\u9605\u8bfb Call stack \u3001 Stack register \u7684\u65f6\u5019\uff0c\u6211\u6709\u4e86\u5982\u4e0b\u7684\u8ba4\u77e5\uff1a \u51fd\u6570\u8c03\u7528\u6240\u4f7f\u7528\u7684\u662fJMP\u6307\u4ee4 x86\u6709segment register\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u6307\u5b9acall stack \u5176\u5b9ecall stack\u5c31\u662f\u4e00\u7247\u5185\u5b58\u533a\u57df\u800c\u5df2\uff0c\u53ea\u8981\u6307\u5b9a\u4e00\u7247\u5185\u5b58\u533a\u57df\u4f5c\u4e3acall stack\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528calling convention\u6765\u5b9e\u73b0\u51fd\u6570\u8c03\u7528\u4e86\u3002\u5b9e\u73b0\u51fd\u6570\u8c03\u7528\u3001\u6267\u884c\u7684\u6307\u4ee4\u662f\u4e0e\u8fd9\u7247\u5185\u5b58\u533a\u57df\u5728\u4f55\u5904\u65e0\u5173\u7684\uff0c\u6240\u4ee5\u7528\u6237\u662f\u53ef\u4ee5\u6307\u5b9a\u4efb\u610f\u7684\u3001\u5408\u6cd5\u7684\u5185\u5b58\u533a\u57df\u6765\u4f5c\u4e3acall stack\u7684\u3002 \u6240\u4ee5\u6211\u5c31\u53bb\u770b\u4e86 pthread_create \u7684\u6587\u6863\uff0c\u5176\u4e2d\u662f\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\u7684\uff1a On Linux/x86-32, the default stack size for a new thread is 2 megabytes. Under the NPTL threading implementation, if the RLIMIT_STACK soft resource limit at the time the program started has any value other than \"unlimited\", then it determines the default stack size of new threads. Using pthread_attr_setstacksize (3), the stack size attribute can be explicitly set in the attr argument used to create a thread, in order to obtain a stack size other than the default. \u5373\u65b0\u521b\u5efa\u7684thread\u7684\u9ed8\u8ba4\u7684call stack\u7684\u5927\u5c0f\u9ed8\u8ba4\u662f2M\uff0c\u8fd9\u8bf4\u660e\u662f\u53ef\u4ee5\u7531\u7528\u6237\u4e86\u6765\u6307\u5b9a\u65b0\u521b\u5efa\u7684thread\u7684call stack\u7684\uff0c\u6211\u4eec\u77e5\u9053\uff0c pthread_create \u6700\u7ec8\u662f\u901a\u8fc7\u8c03\u7528 clone(2) \uff0c\u8be5\u51fd\u6570\u7684\u7b2c\u4e8c\u4e2a\u5165\u53c2\u5c31\u662f\u7531\u7528\u6237\u6765\u6307\u5b9a\u8be5lightweight process\u7684call stack\u7684\u3002 \u770b\u5230\u4e86\u4e0a\u9762\u7684\u63cf\u8ff0\uff0c \u5176\u5b9e\u6211\u53c8\u60f3\u5230\u4e86\u4e00\u4e2a\u95ee\u9898\uff1a\u4e00\u4e2a\u51fd\u6570\uff0c\u5982\u679c\u58f0\u660e\u7684\u81ea\u52a8\u53d8\u91cf\u5927\u5c0f\u8d85\u8fc7\u4e86call stack\u7684\u5927\u5c0f\uff0c\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u4f1a\u53d1\u751f Stack overflow \uff0c\u5173\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u53c2\u89c1\uff1a https://www.cnblogs.com/zmlctt/p/3987181.html https://blog.csdn.net/zDavid_2018/article/details/89255630 \u7ef4\u57fa\u767e\u79d1\u7684 Stack overflow \u603b\u7ed3\u7684\u975e\u5e38\u597d\u3002","title":"Linux OS process model\u7684\u5b9e\u73b0"},{"location":"Kernel/Guide/Multitasking/Process-model/Linux-implementation/Linux-OS-implementation-of-process-model/#process#vs#thread#vs#lightweight-process","text":"\u4e0b\u9762\u662f\u4e00\u4e9b\u6211\u89c9\u5f97\u6bd4\u8f83\u597d\u7684\u5173\u4e8e\u8fd9\u4e2a\u95ee\u9898\u7684\u8ba8\u8bba\uff1a What the difference between lightweight process and thread? What is the difference between LWP and threads? What are the relations between processes, kernel threads, lightweight processes and user threads in Unix? [closed] What are Linux Processes, Threads, Light Weight Processes, and Process State","title":"Process VS thread VS lightweight-process"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/","text":"Process model Thread \u548c Process \u662f\u73b0\u4ee3OS\u5b9e\u73b0 multitasking \u7684\u5173\u952e\u6240\u5728\u3002\u5efa\u7acb\u8d77\u5b8c\u6574\u3001\u6b63\u786e\u7684process model\u5bf9\u4e8e\u5728linux OS\u4e0b\u8fdb\u884c\u5f00\u53d1\u3001\u7406\u89e3linux kernel\u7684\u5b9e\u73b0\u81f3\u5173\u91cd\u8981\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c \u672c\u6587\u6240\u8ff0\u7684process model\u662f\u4e00\u4e2a Conceptual model \uff0c\u4e5f\u53ef\u4ee5\u8bf4\u672c\u6587\u6240\u63cf\u8ff0\u7684process model\u662f\u6807\u51c6\u6240\u5b9a\u4e49\u7684\u3002\u4e0d\u540c\u7684OS\u5bf9process model\u7684\u5b9e\u73b0\u65b9\u5f0f\u662f\u4e0d\u540c\u7684\u3002 Process model\u56fe\u793a\u5982\u4e0b\uff1a Process \u4e3b\u8981\u53c2\u8003\u6587\u7ae0\uff1a Process In computing, a process is the instance of a computer program that is being executed by one or many threads. It contains the program code and its activity. Depending on the operating system (OS), a process may be made up of multiple threads of execution that execute instructions concurrently . \u663e\u7136thread\u662fprocess\u7684\u201c\u6210\u5206\u201d\uff0c\u4e0b\u9762\u770b\u770bthread\u3002 Thread \u4e3b\u8981\u53c2\u8003\u6587\u7ae0\uff1a Thread (computing) In computer science , a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler . Multiple threads can exist within one process, executing concurrently and sharing resources \u6982\u62ecprocess model \u7efc\u5408\u4e0a\u9762\u63cf\u8ff0\uff0c\u4ee5\u4e0b\u6211\u6240\u6982\u62ecProcess model\uff1a \u201cOS\u662f\u57fa\u4e8eprocess\u7684resource\u5206\u914d\uff0c\u57fa\u4e8e thread \u7684\u8c03\u5ea6\u3002\u4e00\u4e2a process \u53ef\u80fd\u7531\u591a\u4e2a thread \u7ec4\u6210\uff0c thread \u5171\u4eabprocess\u7684resource\uff0c \u5e76\u53d1 \u6267\u884c \u3002\u201d \u6ce8\u610f\uff1a\u4e0a\u8ff0\u6982\u62ec\u7684\u662f\u73b0\u4ee3\u5927\u591a\u6570OS\u7684process model\uff0c\u5e76\u975e\u6240\u6709OS\u7684process model\u90fd\u662f\u5982\u6b64\uff0c\u5b9e\u73b0\u4e0a\u662f\u5b58\u5728\u5dee\u5f02\u7684\u3002 \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u867d\u7136\u7b80\u77ed\uff0c\u4f46\u662f\u8574\u542b\u7740\u4e30\u5bcc\u7684\u5185\u6db5\uff0c\u9700\u8981\u8fdb\u884c\u8be6\u7ec6\u5206\u6790\uff1a \u201cOS\u662f\u57fa\u4e8eprocess\u7684resource\u5206\u914d\u201d \u8fd9\u6bb5\u8bdd\u610f\u5473\u7740\uff1aprocess\u662fOS\u7684\u8fdb\u884cresource\u5206\u914d\u7684\u5355\u4f4d\uff0cprocess\u4e4b\u95f4\u662f\u5f7c\u6b64\u9694\u79bb\u7684\u3002 \u6ce8\u610f: \u5bf9\u4e8e\u4e00\u4e9b\u7279\u6b8a\u7684\u60c5\u51b5\uff0c\u5982process\u4e4b\u95f4\u5171\u4eabmemory\u7684\u60c5\u51b5\u9664\u5916\u3002 OS\u4e2d\u6709\u54ea\u4e9bresource\uff1fProcess\u9700\u8981\u54ea\u4e9bresource\uff1f \u53c2\u89c1 Process mode: resource Process\u5982\u4f55\u5b9e\u73b0\u9694\u79bb\uff1f TODO \u201c\u57fa\u4e8e thread \u7684\u8c03\u5ea6\u201d \u8fd9\u6bb5\u8bdd\u610f\u5473\u7740thread\u662fOS\u7684\u8c03\u5ea6\u5355\u4f4d\u3002\u663e\u7136\u6bcf\u4e2athread\u53ef\u4ee5\u72ec\u7acb\u6267\u884c\uff0c\u5219\u6bcf\u4e2athread\u90fd\u6709\u6267\u884c\u7684\u5fc5\u5907\u6761\u4ef6\uff1a call stack \u5728\u7ef4\u57fa\u767e\u79d1 Threads vs. processes \u4e2d\u6709\u5982\u4e0b\u63cf\u8ff0\uff1a \u663e\u7136operating system\u4e3a\u4e86\u652f\u6301multiple thread\uff0c\u5c31\u5fc5\u987b\u8981\u8ba9\u6bcf\u4e2athread\u6709\u4e00\u4e2a\u81ea\u5df1\u7684 call stack \uff1b\u5728Wikipedia\u7684 Thread control block \u4e2d\u5c31\u8c08\u53ca\u6bcf\u4e2athread\u90fd\u6709\u4e00\u4e2a Stack pointer \uff0c\u800c Process control block \u4e2d\uff0c\u53ef\u80fd\u5c31\u4e0d\u9700\u8981 Stack pointer \u4e86\uff1b Process model\u7684\u6f14\u8fdb\u5386\u53f2 \u5728 stanford CS 140: Operating Systems (Spring 2014) \u7684lecture\u4e2d\u603b\u7ed3\u4e86Evolution of operating system process model : Early operating systems supported a single process with a single thread at a time ( single tasking ). They ran batch jobs (one user at a time). Some early personal computer operating systems used single-tasking (e.g. MS-DOS), but these systems are almost unheard of today. By late 1970's most operating systems were multitasking systems: they supported multiple processes , but each process had only a single thread. In the 1990's most systems converted to multithreading : multiple threads within each process. \u663e\u7136\uff0c\u65e9\u671f\u7684\u65f6\u5019\uff0c\u5e76\u6ca1\u6709*multithreading*: multiple threads within each process\uff0c\u6240\u4ee5\u65e9\u671f\u7684\u65f6\u5019multitasking\u7684task\u6240\u6307**processes**\u3002\u800c\u968f\u7740\u6280\u672f\u7684\u53d1\u5c55\uff0c\u540e\u6765\u624d\u51fa\u73b0\u4e86*multithreading*: multiple threads within each process\u3002 multithreading VS Multiprocessing \u4e0d\u7981\u8981\u95ee\uff1a multithreading \u76f8\u8f83\u4e8e Multiprocessing \u4f18\u52bf\u662f\u4ec0\u4e48\uff1f \u8fd9\u4e2a\u95ee\u9898\uff0c\u5728\u7ef4\u57fa\u767e\u79d1 Computer multitasking \u7684 Multithreading \u7ae0\u8282\u7ed9\u51fa\u4e86\u7b54\u6848\u89e3\u7b54\u3002 \u6211\u89c9\u5f97\u53e6\u5916\u4e00\u4e2a\u4f18\u52bf\u662f\uff1athread\u4f7fconcurrency\u7f16\u7a0b\u66f4\u52a0\u5bb9\u6613\u5b9e\u73b0\u3002\u6211\u4eec\u5e38\u5e38\u9700\u8981\u4f7f\u7528\u7b2c\u4e09\u65b9\u5e93\uff0c\u5982\u679c\u60f3\u8981\u5145\u5206\u5b9e\u73b0concurrency\uff0c\u5982\u679c\u4e0d\u652f\u6301thread\uff0c\u5219\u5e93\u4e2d\u53ea\u80fd\u591f\u4f7f\u7528process\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5c31\u6d89\u53ca\u548c\u7b2c\u4e09\u65b9\u5e93\u4e2d\u7684process\u4e2d\u7684IPC\uff0c\u663e\u7136\u8fd9\u4f1a\u5bfc\u81f4\u548c\u7b2c\u4e09\u5e93\u7684\u4ea4\u4e92\u4f1a\u53d8\u5f97\u975e\u5e38\u56f0\u96be\uff1b\u800c\u5982\u679c\u4f7f\u7528thread\uff0c\u5219\u5e93\u7684\u4f7f\u7528\u8fd9\u548c\u5e93\u5904\u4e8e\u540c\u4e00\u4e2aprocess space\uff0c\u4e24\u8005\u4e4b\u95f4\u7684\u4ea4\u4e92\u662f\u975e\u5e38\u4efb\u610f\u7684\uff0c\u663e\u7136\u8fd9\u79cd\u6d89\u53ca\u80fd\u591f\u5145\u5206\u53d1\u6325concurrency\u7684\u4f18\u52bf\u3002 \u603b\u7ed3 process\u662fOS\u7684\u6982\u5ff5\uff0c\u5728instruction\u5c42\u7ea7\u5e76\u6ca1\u6709process\u7684\u6982\u5ff5\uff08 \u5206\u5c42\u601d\u60f3 \uff09\u3002OS\u4f7f\u7528process\u7684\u76ee\u7684\u662f\u4e3a\u4e86\u5b9e\u73b0 multitasking \uff0c\u4e3a\u4e86\u5145\u5206\u5229\u7528hardware\uff08one-to-many model\uff0c\u5728\u5de5\u7a0b discrete math \u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u63cf\u8ff0\uff09\u3002process\u662fprogram\u7684\u6267\u884c\uff0c\u5b83\u662fOS\u8fdb\u884cresource\u5206\u914d\u7684\u5355\u4f4d\uff0c\u4e0d\u540cprocess\u4e4b\u95f4\u7684\u8d44\u6e90\u9700\u8981\u5b8c\u5168\u9694\u79bb\uff08\u7279\u6b8a\u60c5\u51b5\u9664\u5916\uff09\uff0cOS\u4e2d\u7684\u6240\u6709process\u5171\u4eabOS\u6240\u7ba1\u7406\u7684hardware\u8d44\u6e90\u3002OS\u9700\u8981\u6e05\u695a\u5730\u77e5\u9053process\u548c\u8d44\u6e90\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u5373\u4e00\u4e2aprocess\u62e5\u6709\u54ea\u4e9bresource\uff08\u6240\u4ee5\uff0c\u6bcf\u4e2aprocess\u9700\u8981\u6709\u81ea\u5df1\u72ec\u7acb\u7684address space\u3001file table\u7b49\uff09\u3002","title":"Process"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#process#model","text":"Thread \u548c Process \u662f\u73b0\u4ee3OS\u5b9e\u73b0 multitasking \u7684\u5173\u952e\u6240\u5728\u3002\u5efa\u7acb\u8d77\u5b8c\u6574\u3001\u6b63\u786e\u7684process model\u5bf9\u4e8e\u5728linux OS\u4e0b\u8fdb\u884c\u5f00\u53d1\u3001\u7406\u89e3linux kernel\u7684\u5b9e\u73b0\u81f3\u5173\u91cd\u8981\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c \u672c\u6587\u6240\u8ff0\u7684process model\u662f\u4e00\u4e2a Conceptual model \uff0c\u4e5f\u53ef\u4ee5\u8bf4\u672c\u6587\u6240\u63cf\u8ff0\u7684process model\u662f\u6807\u51c6\u6240\u5b9a\u4e49\u7684\u3002\u4e0d\u540c\u7684OS\u5bf9process model\u7684\u5b9e\u73b0\u65b9\u5f0f\u662f\u4e0d\u540c\u7684\u3002 Process model\u56fe\u793a\u5982\u4e0b\uff1a","title":"Process model"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#process","text":"\u4e3b\u8981\u53c2\u8003\u6587\u7ae0\uff1a Process In computing, a process is the instance of a computer program that is being executed by one or many threads. It contains the program code and its activity. Depending on the operating system (OS), a process may be made up of multiple threads of execution that execute instructions concurrently . \u663e\u7136thread\u662fprocess\u7684\u201c\u6210\u5206\u201d\uff0c\u4e0b\u9762\u770b\u770bthread\u3002","title":"Process"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#thread","text":"\u4e3b\u8981\u53c2\u8003\u6587\u7ae0\uff1a Thread (computing) In computer science , a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler . Multiple threads can exist within one process, executing concurrently and sharing resources","title":"Thread"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#process#model_1","text":"\u7efc\u5408\u4e0a\u9762\u63cf\u8ff0\uff0c\u4ee5\u4e0b\u6211\u6240\u6982\u62ecProcess model\uff1a \u201cOS\u662f\u57fa\u4e8eprocess\u7684resource\u5206\u914d\uff0c\u57fa\u4e8e thread \u7684\u8c03\u5ea6\u3002\u4e00\u4e2a process \u53ef\u80fd\u7531\u591a\u4e2a thread \u7ec4\u6210\uff0c thread \u5171\u4eabprocess\u7684resource\uff0c \u5e76\u53d1 \u6267\u884c \u3002\u201d \u6ce8\u610f\uff1a\u4e0a\u8ff0\u6982\u62ec\u7684\u662f\u73b0\u4ee3\u5927\u591a\u6570OS\u7684process model\uff0c\u5e76\u975e\u6240\u6709OS\u7684process model\u90fd\u662f\u5982\u6b64\uff0c\u5b9e\u73b0\u4e0a\u662f\u5b58\u5728\u5dee\u5f02\u7684\u3002 \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u867d\u7136\u7b80\u77ed\uff0c\u4f46\u662f\u8574\u542b\u7740\u4e30\u5bcc\u7684\u5185\u6db5\uff0c\u9700\u8981\u8fdb\u884c\u8be6\u7ec6\u5206\u6790\uff1a","title":"\u6982\u62ecprocess model"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#osprocessresource","text":"\u8fd9\u6bb5\u8bdd\u610f\u5473\u7740\uff1aprocess\u662fOS\u7684\u8fdb\u884cresource\u5206\u914d\u7684\u5355\u4f4d\uff0cprocess\u4e4b\u95f4\u662f\u5f7c\u6b64\u9694\u79bb\u7684\u3002 \u6ce8\u610f: \u5bf9\u4e8e\u4e00\u4e9b\u7279\u6b8a\u7684\u60c5\u51b5\uff0c\u5982process\u4e4b\u95f4\u5171\u4eabmemory\u7684\u60c5\u51b5\u9664\u5916\u3002","title":"\u201cOS\u662f\u57fa\u4e8eprocess\u7684resource\u5206\u914d\u201d"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#osresourceprocessresource","text":"\u53c2\u89c1 Process mode: resource","title":"OS\u4e2d\u6709\u54ea\u4e9bresource\uff1fProcess\u9700\u8981\u54ea\u4e9bresource\uff1f"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#process_1","text":"TODO","title":"Process\u5982\u4f55\u5b9e\u73b0\u9694\u79bb\uff1f"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#thread_1","text":"\u8fd9\u6bb5\u8bdd\u610f\u5473\u7740thread\u662fOS\u7684\u8c03\u5ea6\u5355\u4f4d\u3002\u663e\u7136\u6bcf\u4e2athread\u53ef\u4ee5\u72ec\u7acb\u6267\u884c\uff0c\u5219\u6bcf\u4e2athread\u90fd\u6709\u6267\u884c\u7684\u5fc5\u5907\u6761\u4ef6\uff1a call stack \u5728\u7ef4\u57fa\u767e\u79d1 Threads vs. processes \u4e2d\u6709\u5982\u4e0b\u63cf\u8ff0\uff1a \u663e\u7136operating system\u4e3a\u4e86\u652f\u6301multiple thread\uff0c\u5c31\u5fc5\u987b\u8981\u8ba9\u6bcf\u4e2athread\u6709\u4e00\u4e2a\u81ea\u5df1\u7684 call stack \uff1b\u5728Wikipedia\u7684 Thread control block \u4e2d\u5c31\u8c08\u53ca\u6bcf\u4e2athread\u90fd\u6709\u4e00\u4e2a Stack pointer \uff0c\u800c Process control block \u4e2d\uff0c\u53ef\u80fd\u5c31\u4e0d\u9700\u8981 Stack pointer \u4e86\uff1b","title":"\u201c\u57fa\u4e8ethread\u7684\u8c03\u5ea6\u201d"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#process#model_2","text":"\u5728 stanford CS 140: Operating Systems (Spring 2014) \u7684lecture\u4e2d\u603b\u7ed3\u4e86Evolution of operating system process model : Early operating systems supported a single process with a single thread at a time ( single tasking ). They ran batch jobs (one user at a time). Some early personal computer operating systems used single-tasking (e.g. MS-DOS), but these systems are almost unheard of today. By late 1970's most operating systems were multitasking systems: they supported multiple processes , but each process had only a single thread. In the 1990's most systems converted to multithreading : multiple threads within each process. \u663e\u7136\uff0c\u65e9\u671f\u7684\u65f6\u5019\uff0c\u5e76\u6ca1\u6709*multithreading*: multiple threads within each process\uff0c\u6240\u4ee5\u65e9\u671f\u7684\u65f6\u5019multitasking\u7684task\u6240\u6307**processes**\u3002\u800c\u968f\u7740\u6280\u672f\u7684\u53d1\u5c55\uff0c\u540e\u6765\u624d\u51fa\u73b0\u4e86*multithreading*: multiple threads within each process\u3002","title":"Process model\u7684\u6f14\u8fdb\u5386\u53f2"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#multithreading#vs#multiprocessing","text":"\u4e0d\u7981\u8981\u95ee\uff1a multithreading \u76f8\u8f83\u4e8e Multiprocessing \u4f18\u52bf\u662f\u4ec0\u4e48\uff1f \u8fd9\u4e2a\u95ee\u9898\uff0c\u5728\u7ef4\u57fa\u767e\u79d1 Computer multitasking \u7684 Multithreading \u7ae0\u8282\u7ed9\u51fa\u4e86\u7b54\u6848\u89e3\u7b54\u3002 \u6211\u89c9\u5f97\u53e6\u5916\u4e00\u4e2a\u4f18\u52bf\u662f\uff1athread\u4f7fconcurrency\u7f16\u7a0b\u66f4\u52a0\u5bb9\u6613\u5b9e\u73b0\u3002\u6211\u4eec\u5e38\u5e38\u9700\u8981\u4f7f\u7528\u7b2c\u4e09\u65b9\u5e93\uff0c\u5982\u679c\u60f3\u8981\u5145\u5206\u5b9e\u73b0concurrency\uff0c\u5982\u679c\u4e0d\u652f\u6301thread\uff0c\u5219\u5e93\u4e2d\u53ea\u80fd\u591f\u4f7f\u7528process\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5c31\u6d89\u53ca\u548c\u7b2c\u4e09\u65b9\u5e93\u4e2d\u7684process\u4e2d\u7684IPC\uff0c\u663e\u7136\u8fd9\u4f1a\u5bfc\u81f4\u548c\u7b2c\u4e09\u5e93\u7684\u4ea4\u4e92\u4f1a\u53d8\u5f97\u975e\u5e38\u56f0\u96be\uff1b\u800c\u5982\u679c\u4f7f\u7528thread\uff0c\u5219\u5e93\u7684\u4f7f\u7528\u8fd9\u548c\u5e93\u5904\u4e8e\u540c\u4e00\u4e2aprocess space\uff0c\u4e24\u8005\u4e4b\u95f4\u7684\u4ea4\u4e92\u662f\u975e\u5e38\u4efb\u610f\u7684\uff0c\u663e\u7136\u8fd9\u79cd\u6d89\u53ca\u80fd\u591f\u5145\u5206\u53d1\u6325concurrency\u7684\u4f18\u52bf\u3002","title":"multithreading VS Multiprocessing"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Process/#_1","text":"process\u662fOS\u7684\u6982\u5ff5\uff0c\u5728instruction\u5c42\u7ea7\u5e76\u6ca1\u6709process\u7684\u6982\u5ff5\uff08 \u5206\u5c42\u601d\u60f3 \uff09\u3002OS\u4f7f\u7528process\u7684\u76ee\u7684\u662f\u4e3a\u4e86\u5b9e\u73b0 multitasking \uff0c\u4e3a\u4e86\u5145\u5206\u5229\u7528hardware\uff08one-to-many model\uff0c\u5728\u5de5\u7a0b discrete math \u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u63cf\u8ff0\uff09\u3002process\u662fprogram\u7684\u6267\u884c\uff0c\u5b83\u662fOS\u8fdb\u884cresource\u5206\u914d\u7684\u5355\u4f4d\uff0c\u4e0d\u540cprocess\u4e4b\u95f4\u7684\u8d44\u6e90\u9700\u8981\u5b8c\u5168\u9694\u79bb\uff08\u7279\u6b8a\u60c5\u51b5\u9664\u5916\uff09\uff0cOS\u4e2d\u7684\u6240\u6709process\u5171\u4eabOS\u6240\u7ba1\u7406\u7684hardware\u8d44\u6e90\u3002OS\u9700\u8981\u6e05\u695a\u5730\u77e5\u9053process\u548c\u8d44\u6e90\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u5373\u4e00\u4e2aprocess\u62e5\u6709\u54ea\u4e9bresource\uff08\u6240\u4ee5\uff0c\u6bcf\u4e2aprocess\u9700\u8981\u6709\u81ea\u5df1\u72ec\u7acb\u7684address space\u3001file table\u7b49\uff09\u3002","title":"\u603b\u7ed3"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Thread/","text":"Thread wikipedia Thread (computing) Thoughts \u4e0d\u540c\u7684OS\u6709\u7740\u4e0d\u540c\u7684\u5b9e\u73b0\uff0c\u4f46\u662f\u5b83\u4eec\u80af\u5b9a\u90fd\u4f1a\u7b26\u5408\u6807\u51c6\u3002 \u6309\u7167\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u53d1\u5c55\u6d41\u7a0b\u6765\u770b\uff0c\u5e94\u8be5\u662f\u9996\u5148\u6709\u8ba1\u7b97\u673a\u7406\u8bba\u5b66\u5bb6\u63d0\u51fa\u4e86\u8fd9\u4e9b\u6982\u5ff5/\u6807\u51c6\uff0c\u7136\u540e\u64cd\u4f5c\u7cfb\u7edf\u5382\u5546\u518d\u5b9e\u73b0\u8fd9\u4e9b\u6982\u5ff5/\u6807\u51c6\u3002\u6240\u4ee5\u4ece\u6807\u51c6\u7684\u51fa\u73b0\u5230\u64cd\u4f5c\u7cfb\u7edf\u5382\u5546\u5b9e\u73b0\u8fd9\u4e9b\u6807\u51c6\uff0c\u4e24\u8005\u4e4b\u95f4\u662f\u6709\u4e00\u4e2a\u65f6\u95f4\u95f4\u9694\u7684\u3002\u4e0d\u540c\u5382\u5546\u7684\u5bf9\u540c\u4e00\u6982\u5ff5/\u6807\u51c6\u7684\u5b9e\u73b0\u65b9\u5f0f\u4e5f\u4f1a\u6709\u6240\u4e0d\u540c\uff0c\u5e76\u4e14\u5b83\u4eec\u7684\u5b9e\u73b0\u65b9\u5f0f\u4e5f\u4f1a\u4e0d\u65ad\u5730\u6f14\u8fdb\u3002\u6240\u4ee5\u5728\u5f00\u59cb\u8fdb\u5165\u5230\u672c\u4e66\u7684\u5185\u5bb9\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u9996\u5148\u5efa\u7acb\u5982\u4e0b\u89c2\u5ff5\uff1a \u6807\u51c6\u4e0e\u5b9e\u73b0\u4e4b\u95f4\u7684\u5173\u7cfb \u4ee5\u53d1\u5c55\u7684\u773c\u5149\u6765\u770b\u5f85\u8f6f\u4ef6\u7684\u6f14\u8fdb \u4e0b\u9762\u4ee5operating system\u5982\u4f55\u6765\u5b9e\u73b0 Thread (computing) \u4e3a\u4f8b\u6765\u8fdb\u884c\u8bf4\u660e\uff0c\u76ee\u524d\u5b58\u5728\u7740\u4e24\u79cd\u5b9e\u73b0\u65b9\u5f0f\uff1a user level thread\uff0c\u5e38\u79f0\u4e3auser thread kernel level thread \u4e24\u8005\u4e4b\u95f4\u7684\u5dee\u5f02\u53ef\u4ee5\u53c2\u89c1\u5982\u4e0b\u6587\u7ae0\uff1a https://www.geeksforgeeks.org/difference-between-user-level-thread-and-kernel-level-thread/ What is a user thread and a kernel thread? \u663e\u7136\uff0c\u5bf9\u4e8e\u6807\u51c6\u6240\u63d0\u51fa\u7684 Thread (computing) \uff0c\u53ef\u4ee5\u6709\u591a\u79cd\u5b9e\u73b0\u65b9\u5f0f\u3002\u5173\u4e8e\u6b64\uff0c\u7ef4\u57fa\u767e\u79d1\u7684 Thread (computing) \u6709\u7740\u975e\u5e38\u597d\u7684\u603b\u7ed3\u3002","title":"Thread"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Thread/#thread","text":"","title":"Thread"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Thread/#wikipedia#thread#computing","text":"","title":"wikipedia Thread (computing)"},{"location":"Kernel/Guide/Multitasking/Process-model/Process/Thread/#thoughts","text":"\u4e0d\u540c\u7684OS\u6709\u7740\u4e0d\u540c\u7684\u5b9e\u73b0\uff0c\u4f46\u662f\u5b83\u4eec\u80af\u5b9a\u90fd\u4f1a\u7b26\u5408\u6807\u51c6\u3002 \u6309\u7167\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u53d1\u5c55\u6d41\u7a0b\u6765\u770b\uff0c\u5e94\u8be5\u662f\u9996\u5148\u6709\u8ba1\u7b97\u673a\u7406\u8bba\u5b66\u5bb6\u63d0\u51fa\u4e86\u8fd9\u4e9b\u6982\u5ff5/\u6807\u51c6\uff0c\u7136\u540e\u64cd\u4f5c\u7cfb\u7edf\u5382\u5546\u518d\u5b9e\u73b0\u8fd9\u4e9b\u6982\u5ff5/\u6807\u51c6\u3002\u6240\u4ee5\u4ece\u6807\u51c6\u7684\u51fa\u73b0\u5230\u64cd\u4f5c\u7cfb\u7edf\u5382\u5546\u5b9e\u73b0\u8fd9\u4e9b\u6807\u51c6\uff0c\u4e24\u8005\u4e4b\u95f4\u662f\u6709\u4e00\u4e2a\u65f6\u95f4\u95f4\u9694\u7684\u3002\u4e0d\u540c\u5382\u5546\u7684\u5bf9\u540c\u4e00\u6982\u5ff5/\u6807\u51c6\u7684\u5b9e\u73b0\u65b9\u5f0f\u4e5f\u4f1a\u6709\u6240\u4e0d\u540c\uff0c\u5e76\u4e14\u5b83\u4eec\u7684\u5b9e\u73b0\u65b9\u5f0f\u4e5f\u4f1a\u4e0d\u65ad\u5730\u6f14\u8fdb\u3002\u6240\u4ee5\u5728\u5f00\u59cb\u8fdb\u5165\u5230\u672c\u4e66\u7684\u5185\u5bb9\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u9996\u5148\u5efa\u7acb\u5982\u4e0b\u89c2\u5ff5\uff1a \u6807\u51c6\u4e0e\u5b9e\u73b0\u4e4b\u95f4\u7684\u5173\u7cfb \u4ee5\u53d1\u5c55\u7684\u773c\u5149\u6765\u770b\u5f85\u8f6f\u4ef6\u7684\u6f14\u8fdb \u4e0b\u9762\u4ee5operating system\u5982\u4f55\u6765\u5b9e\u73b0 Thread (computing) \u4e3a\u4f8b\u6765\u8fdb\u884c\u8bf4\u660e\uff0c\u76ee\u524d\u5b58\u5728\u7740\u4e24\u79cd\u5b9e\u73b0\u65b9\u5f0f\uff1a user level thread\uff0c\u5e38\u79f0\u4e3auser thread kernel level thread \u4e24\u8005\u4e4b\u95f4\u7684\u5dee\u5f02\u53ef\u4ee5\u53c2\u89c1\u5982\u4e0b\u6587\u7ae0\uff1a https://www.geeksforgeeks.org/difference-between-user-level-thread-and-kernel-level-thread/ What is a user thread and a kernel thread? \u663e\u7136\uff0c\u5bf9\u4e8e\u6807\u51c6\u6240\u63d0\u51fa\u7684 Thread (computing) \uff0c\u53ef\u4ee5\u6709\u591a\u79cd\u5b9e\u73b0\u65b9\u5f0f\u3002\u5173\u4e8e\u6b64\uff0c\u7ef4\u57fa\u767e\u79d1\u7684 Thread (computing) \u6709\u7740\u975e\u5e38\u597d\u7684\u603b\u7ed3\u3002","title":"Thoughts"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-execution-model/","text":"Process run model \u672c\u6587\u7684\u5185\u5bb9\u57fa\u4e8e\uff1a ../Process \u9f99\u4e66 Chapter 7 Run-Time Environments \u7ef4\u57fa\u767e\u79d1ABI \u672c\u6587\u5c06\u5bf9process\u7684run-time\u8fdb\u884c\u5206\u6790\uff0c\u4ee5\u5bf9process model\u8fdb\u884c\u66f4\u52a0\u6df1\u5165\u7684\u5206\u6790\u3002 \u672c\u6587\u7684\u6807\u9898\u662f\u53c2\u8003\u81ea\u9f99\u4e66 Chapter 7 Run-Time Environments \uff0c\u672c\u6587\u7684\u5185\u5bb9\u4e3b\u8981\u662f\u57fa\u4e8e\u9f99\u4e66 Chapter 7 Run-Time Environments \u7684\u5185\u5bb9\uff0c\u5728\u5b83\u7684\u57fa\u7840\u4e0a\u8fdb\u884c\u4e86\u6269\u5145\u3002\u9f99\u4e66\u6b63\u5982\u5176\u540d\uff08\u539f\u6587\u539f\u540d\uff09\uff0c\u5b83\u6240\u8ff0\u7684\u662f\u539f\u7406\uff0c\u5b83\u6240\u8bb2\u8ff0\u7684\u662f \u6982\u5ff5\u6a21\u578b \uff08\u662f\u4e00\u4e2a\u7b80\u5316\u7684\u6a21\u578b\uff0c\u6ca1\u6709\u8003\u8651multi-thread\u7b49\uff09\uff0c\u5b9e\u9645\u7684\u5b9e\u73b0\u80af\u5b9a\u662f\u57fa\u4e8e\u8be5\u6982\u5ff5\u6a21\u578b\u7684\uff0c\u9700\u8981\u8003\u8651\u7684\u5f88\u591a\u5176\u4ed6\u5143\u7d20\uff0c\u5982\uff1a multi-thread ......\uff08TODO:\u8fd8\u8981\u4e00\u4e9b\u5176\u4ed6\u7684\u56e0\u7d20\uff09 \u672c\u6587\u6240\u6269\u5145\u7684\u662f\uff1a \u4e00\u4e9b\u5b9e\u73b0\u76f8\u5173\u7684\u7ec6\u8282\uff0c\u5982ABI\u7b49 \u6dfb\u52a0multi-thread\u76f8\u5173\u7684\u5185\u5bb9 \u603b\u7684\u6765\u8bf4\uff0c\u672c\u6587\u7684\u76ee\u6807\u662f\u5bf9process\u7684runtime\u8fdb\u884c\u5206\u6790\uff0c\u6784\u5efa\u8d77\u66f4\u52a0\u5b8c\u6574\u7684process model\u3002 Thread run model \u5728\u4e0a\u4e00\u7bc7\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\uff1athread\u662fOS kernel\u8c03\u5ea6\u5355\u4f4d\uff08\u7ebf\u7a0b\u7684\u6267\u884c\u53ef\u80fd\u88ab preempt \uff09\uff0c\u5373\u6bcf\u4e2athread\u90fd\u80fd\u591f\u72ec\u7acb\u6267\u884c\uff1b\u5728\u6587\u7ae0 Unit \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86thread\u7684unit of user-defined action**\u662f**subroutine \uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u6240\u8bf4\u7684**\u7ebf\u7a0b\u6267\u884c\u51fd\u6570**\u3002\uff08\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u4e9b\u90fd\u662fcomputer science\u4e2d\u7684\u89c4\u5b9a\u3001\u4e8b\u5b9e\uff0c\u5b83\u4eec\u662f\u65e0\u6570\u7684\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u4eec\u7ecf\u8fc7\u7cbe\u5fc3\u8bbe\u8ba1\u800c\u6784\u5efa\u51fa\u6765\u7684\uff0c\u4f5c\u4e3a\u5de5\u7a0b\u5e08\uff0c\u6211\u4eec\u65e0\u9700\u53bb\u8bc1\u660e\u4e3a\u4ec0\u4e48\u662f\u8fd9\u6837\u7684\uff0c\u6211\u4eec\u9700\u8981\u7684\u662f\u77e5\u9053\u8fd9\u4e2a\u4e8b\u5b9e\uff0c\u6211\u4eec\u53ef\u4ee5\u53bb\u601d\u8003\u8fd9\u6837\u8bbe\u8ba1\u7684\u4f18\u52bf\u6709\u54ea\u4e9b\uff09 \u7efc\u5408\u4e0a\u9762\u7684\u5185\u5bb9\uff1a\u201cthread\u7684unit of user-defined **action**\u662fsubroutine\uff0cthread\u662fOS kernel\u8c03\u5ea6\u5355\u4f4d\u201d\u3002 \u90a3thread\u662f\u5982\u4f55\u8fd0\u884c\u7684\u5462\uff1f\u5728\u9f99\u4e66\u7684chapter 7.2 Stack Allocation of Space \u4e2d\u6709\u5bf9\u6b64\u7684\u63cf\u8ff0\uff1a Languages that use procedures, functions, or methods as units of user-defined actions manage at least part of their run-time memory as a stack . Each time a procedure is called, space for its local variables is pushed onto a stack, and when the procedure terminates, that space is popped off the stack. As we shall see, this arrangement not only allows space to be shared by procedure calls whose durations do not overlap in time, but it allows us to compile code for a procedure in such a way that the relative addresses of its nonlocal variables are always the same, regardless of the sequence of procedure calls. \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684**stack**\uff0c\u6240\u6307\u4e3a**call stack**\uff08\u5728\u540e\u9762\u4f1a\u5bf9\u6b64\u8fdb\u884c\u5c55\u5f00\uff09\u3002 \u8ba9\u6211\u4eec\u7ad9\u5728OS kernel\u7684\u8bbe\u8ba1\u8005\u7684\u89d2\u8272\u6765\u601d\u8003\u5982\u4f55\u5b9e\u73b0\u8fd9\u79cd\u8bbe\u8ba1\uff1f\u663e\u7136\uff0cOS kernel\u9700\u8981\u4e3a\u6bcf\u4e2athread\u90fd\u63d0\u4f9b\u4e00\u5957\u201c \u57fa\u7840\u8bbe\u65bd \u201d\u548c\u4e00\u79cd\u201c \u8c03\u5ea6\u673a\u5236 \u201d\u6765\u5b9e\u73b0\u8fd9\u79cd\u8bbe\u8ba1\uff0c\u4e0b\u9762\u5bf9\u6b64\u8fdb\u884c\u5206\u6790\uff1a \u201cthread\u7684unit of user-defined action\u662fsubroutine/function\u201d \u8981\u6c42OS\u81f3\u5c11\u8981\u4e3athread\u914d\u5907subroutine/function\u7684\u6267\u884c\u6240\u9700\u8981\u7684\" \u57fa\u7840\u8bbe\u65bd \"\uff0c\u8bf8\u5982\uff1a 1\u3001 Call stack \u6bcf\u4e2athread\u90fd\u6709\u4e00\u4e2a\u81ea\u5df1\u72ec\u7acb\u7684call stack\uff0cfunction\u7684\u8fd0\u884c\u90fd\u662f\u53d1\u751f\u5728call stack\u4e0a\uff0c\u6bcf\u6b21\u8c03\u7528function\uff0c\u5219\u5165\u6808\uff0c \u51fd\u6570\u8fd0\u884c\u7ed3\u675f\uff0c\u5219\u51fa\u6808\uff0c\u8fd9\u5c31\u662fthread\u7684**\u8fd0\u884c\u6a21\u578b**\u3002 Call stack \u53c8\u79f0\u4e3a control stack\uff0c\u6240\u4ee5\u5b83\u4e5f\u4f53\u73b0\u4e86\u5b83\u4e0e**program counter**\uff0c flow of control \u4e4b\u95f4\u7684\u5173\u7cfb\u3002 \u201cthread\u662fOS kernel\u8c03\u5ea6\u5355\u4f4d\" OS\u4e2d\u7684\u6240\u6709\u7684thread\u5171\u4eabCPU\uff0c\u201c \u8c03\u5ea6\u673a\u5236 \u201d\u662f\u7531OS kernel scheduler\uff08\u540e\u9762\u7b80\u79f0scheduler\uff09\u6765\u5b8c\u6210\uff0cscheduler\u80fd\u591fsuspend\u3001restart\u4e00\u4e2athread\uff0c\u5728suspend\u4e00\u4e2athread\u4e4b\u524d\u9700\u8981\u4fdd\u5b58thread\u8fd0\u884c\u7684**context**\uff0c\u5728restart\u4e00\u4e2athread\u7684\u65f6\u5019\uff0c\u9700\u8981\u6062\u590d\u4e4b\u524d\u4fdd\u5b58\u7684**context**\uff0ccontext\u7684\u5185\u5bb9\u5982\u4e0b\uff1a Program counter Stack pointer ...... \u8fd9\u5c31\u662f\u201c \u8c03\u5ea6\u673a\u5236 \u201d\u4e2d\u975e\u5e38\u91cd\u8981\u7684**context switch**\u6b65\u9aa4\u3002 \u6bcf\u4e2athread\u90fd\u6709\u81ea\u5df1\u7684\u72ec\u7acb\u7684\u4e00\u4efd\u201c \u57fa\u7840\u8bbe\u65bd \u201d\uff0c\u201c \u57fa\u7840\u8bbe\u65bd \u201d\u5305\u62ec\uff1a thread\u7684 thread control block call stack Subroutine\uff08\u51fd\u6570\uff09 \u53c2\u89c1\u5de5\u7a0b programming-language \u7684 Theory\\Programming-language-construct\\Subroutine \u7ae0\u8282\u3002 Call stack \u53c2\u89c1\u5de5\u7a0b programming-language \u7684 Theory\\Programming-language-construct\\Subroutine \u7ae0\u8282\u3002 Call convention \u524d\u9762\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u4e86\uff0c\u6bcf\u4e2athread\u90fd\u914d\u5907\u4e86\u81ea\u5df1\u7684call stack\u6765\u4f5c\u4e3asubroutine\u8fd0\u884c\u573a\u6240\uff0c\u7531\u6b64\u5c31\u5f15\u51fa\u4e86\u4e00\u4e9b\u5217\u7684\u95ee\u9898\uff1a\u51fd\u6570\u4f20\u53c2\u5982\u4f55\u5b9e\u73b0\u3001\u5728\u8fdb\u5165\u51fd\u6570\u4e4b\u524d\uff0c\u5982\u4f55\u5f97\u77e5\u8981\u7533\u8bf7\u591a\u5c11\u6808\u7a7a\u95f4\uff1f\u5e94\u8be5\u4e0d\u662f\u63d0\u524d\u4e00\u6b21\u6027\u7533\u8bf7\u8be5\u51fd\u6570\u6240\u9700\u8981\u7684\u6240\u6709\u7684\u6808\u7a7a\u95f4\uff0c\u800c\u662f\u8fd0\u884c\u5230\u8be5\u6307\u4ee4\u7684\u65f6\u5019\uff0c\u624d\u5728\u6808\u4e0a\u5206\u914d\u7a7a\u95f4\u3002\u8fd9\u4e9b\u5185\u5bb9\u90fd\u5c06\u5728\u5de5\u7a0b programming-language \u7684 ABI \u7ae0\u8282\u7684Call-convention\u4e2d\u8fdb\u884c\u8bb2\u89e3\u3002 Stack unwinding \u5728function termination\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884cstack unwinding\uff0c\u5f88\u591aprogramming language\u501f\u7528\u8fd9\u4e2a\u673a\u5236\u5efa\u7acb\u8d77\u4e86\u4e00\u4e9b\u975e\u5e38\u4fbf\u5229\u7684feature\u3002 Process run model \u6709\u4e86\u524d\u9762\u7684thread run model\uff0c\u90a3\u4e48process\u7684run model\u5c31\u76f8\u5bf9\u6bd4\u8f83\u597d\u5206\u6790\u4e86, \u663e\u7136: \u4e00\u4e2aprocess\u6709\u591a\u4e2athread\u7ec4\u6210\uff0cthread\u72ec\u7acb\u8fdb\u884c\u8fd0\u884c\uff0c\u5171\u4eabprocess\u7684resource","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-execution-model/#process#run#model","text":"\u672c\u6587\u7684\u5185\u5bb9\u57fa\u4e8e\uff1a ../Process \u9f99\u4e66 Chapter 7 Run-Time Environments \u7ef4\u57fa\u767e\u79d1ABI \u672c\u6587\u5c06\u5bf9process\u7684run-time\u8fdb\u884c\u5206\u6790\uff0c\u4ee5\u5bf9process model\u8fdb\u884c\u66f4\u52a0\u6df1\u5165\u7684\u5206\u6790\u3002 \u672c\u6587\u7684\u6807\u9898\u662f\u53c2\u8003\u81ea\u9f99\u4e66 Chapter 7 Run-Time Environments \uff0c\u672c\u6587\u7684\u5185\u5bb9\u4e3b\u8981\u662f\u57fa\u4e8e\u9f99\u4e66 Chapter 7 Run-Time Environments \u7684\u5185\u5bb9\uff0c\u5728\u5b83\u7684\u57fa\u7840\u4e0a\u8fdb\u884c\u4e86\u6269\u5145\u3002\u9f99\u4e66\u6b63\u5982\u5176\u540d\uff08\u539f\u6587\u539f\u540d\uff09\uff0c\u5b83\u6240\u8ff0\u7684\u662f\u539f\u7406\uff0c\u5b83\u6240\u8bb2\u8ff0\u7684\u662f \u6982\u5ff5\u6a21\u578b \uff08\u662f\u4e00\u4e2a\u7b80\u5316\u7684\u6a21\u578b\uff0c\u6ca1\u6709\u8003\u8651multi-thread\u7b49\uff09\uff0c\u5b9e\u9645\u7684\u5b9e\u73b0\u80af\u5b9a\u662f\u57fa\u4e8e\u8be5\u6982\u5ff5\u6a21\u578b\u7684\uff0c\u9700\u8981\u8003\u8651\u7684\u5f88\u591a\u5176\u4ed6\u5143\u7d20\uff0c\u5982\uff1a multi-thread ......\uff08TODO:\u8fd8\u8981\u4e00\u4e9b\u5176\u4ed6\u7684\u56e0\u7d20\uff09 \u672c\u6587\u6240\u6269\u5145\u7684\u662f\uff1a \u4e00\u4e9b\u5b9e\u73b0\u76f8\u5173\u7684\u7ec6\u8282\uff0c\u5982ABI\u7b49 \u6dfb\u52a0multi-thread\u76f8\u5173\u7684\u5185\u5bb9 \u603b\u7684\u6765\u8bf4\uff0c\u672c\u6587\u7684\u76ee\u6807\u662f\u5bf9process\u7684runtime\u8fdb\u884c\u5206\u6790\uff0c\u6784\u5efa\u8d77\u66f4\u52a0\u5b8c\u6574\u7684process model\u3002","title":"Process run model"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-execution-model/#thread#run#model","text":"\u5728\u4e0a\u4e00\u7bc7\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\uff1athread\u662fOS kernel\u8c03\u5ea6\u5355\u4f4d\uff08\u7ebf\u7a0b\u7684\u6267\u884c\u53ef\u80fd\u88ab preempt \uff09\uff0c\u5373\u6bcf\u4e2athread\u90fd\u80fd\u591f\u72ec\u7acb\u6267\u884c\uff1b\u5728\u6587\u7ae0 Unit \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86thread\u7684unit of user-defined action**\u662f**subroutine \uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u6240\u8bf4\u7684**\u7ebf\u7a0b\u6267\u884c\u51fd\u6570**\u3002\uff08\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u4e9b\u90fd\u662fcomputer science\u4e2d\u7684\u89c4\u5b9a\u3001\u4e8b\u5b9e\uff0c\u5b83\u4eec\u662f\u65e0\u6570\u7684\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u4eec\u7ecf\u8fc7\u7cbe\u5fc3\u8bbe\u8ba1\u800c\u6784\u5efa\u51fa\u6765\u7684\uff0c\u4f5c\u4e3a\u5de5\u7a0b\u5e08\uff0c\u6211\u4eec\u65e0\u9700\u53bb\u8bc1\u660e\u4e3a\u4ec0\u4e48\u662f\u8fd9\u6837\u7684\uff0c\u6211\u4eec\u9700\u8981\u7684\u662f\u77e5\u9053\u8fd9\u4e2a\u4e8b\u5b9e\uff0c\u6211\u4eec\u53ef\u4ee5\u53bb\u601d\u8003\u8fd9\u6837\u8bbe\u8ba1\u7684\u4f18\u52bf\u6709\u54ea\u4e9b\uff09 \u7efc\u5408\u4e0a\u9762\u7684\u5185\u5bb9\uff1a\u201cthread\u7684unit of user-defined **action**\u662fsubroutine\uff0cthread\u662fOS kernel\u8c03\u5ea6\u5355\u4f4d\u201d\u3002 \u90a3thread\u662f\u5982\u4f55\u8fd0\u884c\u7684\u5462\uff1f\u5728\u9f99\u4e66\u7684chapter 7.2 Stack Allocation of Space \u4e2d\u6709\u5bf9\u6b64\u7684\u63cf\u8ff0\uff1a Languages that use procedures, functions, or methods as units of user-defined actions manage at least part of their run-time memory as a stack . Each time a procedure is called, space for its local variables is pushed onto a stack, and when the procedure terminates, that space is popped off the stack. As we shall see, this arrangement not only allows space to be shared by procedure calls whose durations do not overlap in time, but it allows us to compile code for a procedure in such a way that the relative addresses of its nonlocal variables are always the same, regardless of the sequence of procedure calls. \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684**stack**\uff0c\u6240\u6307\u4e3a**call stack**\uff08\u5728\u540e\u9762\u4f1a\u5bf9\u6b64\u8fdb\u884c\u5c55\u5f00\uff09\u3002 \u8ba9\u6211\u4eec\u7ad9\u5728OS kernel\u7684\u8bbe\u8ba1\u8005\u7684\u89d2\u8272\u6765\u601d\u8003\u5982\u4f55\u5b9e\u73b0\u8fd9\u79cd\u8bbe\u8ba1\uff1f\u663e\u7136\uff0cOS kernel\u9700\u8981\u4e3a\u6bcf\u4e2athread\u90fd\u63d0\u4f9b\u4e00\u5957\u201c \u57fa\u7840\u8bbe\u65bd \u201d\u548c\u4e00\u79cd\u201c \u8c03\u5ea6\u673a\u5236 \u201d\u6765\u5b9e\u73b0\u8fd9\u79cd\u8bbe\u8ba1\uff0c\u4e0b\u9762\u5bf9\u6b64\u8fdb\u884c\u5206\u6790\uff1a","title":"Thread run model"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-execution-model/#threadunit#of#user-defined#actionsubroutinefunction","text":"\u8981\u6c42OS\u81f3\u5c11\u8981\u4e3athread\u914d\u5907subroutine/function\u7684\u6267\u884c\u6240\u9700\u8981\u7684\" \u57fa\u7840\u8bbe\u65bd \"\uff0c\u8bf8\u5982\uff1a 1\u3001 Call stack \u6bcf\u4e2athread\u90fd\u6709\u4e00\u4e2a\u81ea\u5df1\u72ec\u7acb\u7684call stack\uff0cfunction\u7684\u8fd0\u884c\u90fd\u662f\u53d1\u751f\u5728call stack\u4e0a\uff0c\u6bcf\u6b21\u8c03\u7528function\uff0c\u5219\u5165\u6808\uff0c \u51fd\u6570\u8fd0\u884c\u7ed3\u675f\uff0c\u5219\u51fa\u6808\uff0c\u8fd9\u5c31\u662fthread\u7684**\u8fd0\u884c\u6a21\u578b**\u3002 Call stack \u53c8\u79f0\u4e3a control stack\uff0c\u6240\u4ee5\u5b83\u4e5f\u4f53\u73b0\u4e86\u5b83\u4e0e**program counter**\uff0c flow of control \u4e4b\u95f4\u7684\u5173\u7cfb\u3002","title":"\u201cthread\u7684unit of user-defined action\u662fsubroutine/function\u201d"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-execution-model/#threados#kernel","text":"OS\u4e2d\u7684\u6240\u6709\u7684thread\u5171\u4eabCPU\uff0c\u201c \u8c03\u5ea6\u673a\u5236 \u201d\u662f\u7531OS kernel scheduler\uff08\u540e\u9762\u7b80\u79f0scheduler\uff09\u6765\u5b8c\u6210\uff0cscheduler\u80fd\u591fsuspend\u3001restart\u4e00\u4e2athread\uff0c\u5728suspend\u4e00\u4e2athread\u4e4b\u524d\u9700\u8981\u4fdd\u5b58thread\u8fd0\u884c\u7684**context**\uff0c\u5728restart\u4e00\u4e2athread\u7684\u65f6\u5019\uff0c\u9700\u8981\u6062\u590d\u4e4b\u524d\u4fdd\u5b58\u7684**context**\uff0ccontext\u7684\u5185\u5bb9\u5982\u4e0b\uff1a Program counter Stack pointer ...... \u8fd9\u5c31\u662f\u201c \u8c03\u5ea6\u673a\u5236 \u201d\u4e2d\u975e\u5e38\u91cd\u8981\u7684**context switch**\u6b65\u9aa4\u3002 \u6bcf\u4e2athread\u90fd\u6709\u81ea\u5df1\u7684\u72ec\u7acb\u7684\u4e00\u4efd\u201c \u57fa\u7840\u8bbe\u65bd \u201d\uff0c\u201c \u57fa\u7840\u8bbe\u65bd \u201d\u5305\u62ec\uff1a thread\u7684 thread control block call stack","title":"\u201cthread\u662fOS kernel\u8c03\u5ea6\u5355\u4f4d\""},{"location":"Kernel/Guide/Multitasking/Process-model/Process-execution-model/#subroutine","text":"\u53c2\u89c1\u5de5\u7a0b programming-language \u7684 Theory\\Programming-language-construct\\Subroutine \u7ae0\u8282\u3002","title":"Subroutine\uff08\u51fd\u6570\uff09"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-execution-model/#call#stack","text":"\u53c2\u89c1\u5de5\u7a0b programming-language \u7684 Theory\\Programming-language-construct\\Subroutine \u7ae0\u8282\u3002","title":"Call stack"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-execution-model/#call#convention","text":"\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u4e86\uff0c\u6bcf\u4e2athread\u90fd\u914d\u5907\u4e86\u81ea\u5df1\u7684call stack\u6765\u4f5c\u4e3asubroutine\u8fd0\u884c\u573a\u6240\uff0c\u7531\u6b64\u5c31\u5f15\u51fa\u4e86\u4e00\u4e9b\u5217\u7684\u95ee\u9898\uff1a\u51fd\u6570\u4f20\u53c2\u5982\u4f55\u5b9e\u73b0\u3001\u5728\u8fdb\u5165\u51fd\u6570\u4e4b\u524d\uff0c\u5982\u4f55\u5f97\u77e5\u8981\u7533\u8bf7\u591a\u5c11\u6808\u7a7a\u95f4\uff1f\u5e94\u8be5\u4e0d\u662f\u63d0\u524d\u4e00\u6b21\u6027\u7533\u8bf7\u8be5\u51fd\u6570\u6240\u9700\u8981\u7684\u6240\u6709\u7684\u6808\u7a7a\u95f4\uff0c\u800c\u662f\u8fd0\u884c\u5230\u8be5\u6307\u4ee4\u7684\u65f6\u5019\uff0c\u624d\u5728\u6808\u4e0a\u5206\u914d\u7a7a\u95f4\u3002\u8fd9\u4e9b\u5185\u5bb9\u90fd\u5c06\u5728\u5de5\u7a0b programming-language \u7684 ABI \u7ae0\u8282\u7684Call-convention\u4e2d\u8fdb\u884c\u8bb2\u89e3\u3002","title":"Call convention"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-execution-model/#stack#unwinding","text":"\u5728function termination\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884cstack unwinding\uff0c\u5f88\u591aprogramming language\u501f\u7528\u8fd9\u4e2a\u673a\u5236\u5efa\u7acb\u8d77\u4e86\u4e00\u4e9b\u975e\u5e38\u4fbf\u5229\u7684feature\u3002","title":"Stack unwinding"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-execution-model/#process#run#model_1","text":"\u6709\u4e86\u524d\u9762\u7684thread run model\uff0c\u90a3\u4e48process\u7684run model\u5c31\u76f8\u5bf9\u6bd4\u8f83\u597d\u5206\u6790\u4e86, \u663e\u7136: \u4e00\u4e2aprocess\u6709\u591a\u4e2athread\u7ec4\u6210\uff0cthread\u72ec\u7acb\u8fdb\u884c\u8fd0\u884c\uff0c\u5171\u4eabprocess\u7684resource","title":"Process run model"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/","text":"Process model: life cycle \u751f \u521b\u5efaprocess \u5360\u7528\u4e86\u54ea\u4e9b\u8d44\u6e90 \u5982\u4f55\u6765\u63a7\u5236process \u5982\u4f55\u9650\u5236\u8d44\u6e90 process\u4e4b\u95f4\u7684\u5173\u7cfb process\u4e4b\u95f4\u5982\u4f55\u8fdb\u884c\u6c9f\u901a \u65f6\u7a7a\u7684\u89d2\u5ea6 process\u7684\u72b6\u6001 \u6b7b","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/#process#model#life#cycle","text":"","title":"Process model: life cycle"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/#_1","text":"\u521b\u5efaprocess","title":"\u751f"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/#_2","text":"","title":"\u5360\u7528\u4e86\u54ea\u4e9b\u8d44\u6e90"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/#process","text":"","title":"\u5982\u4f55\u6765\u63a7\u5236process"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/#_3","text":"","title":"\u5982\u4f55\u9650\u5236\u8d44\u6e90"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/#process_1","text":"","title":"process\u4e4b\u95f4\u7684\u5173\u7cfb"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/#process_2","text":"","title":"process\u4e4b\u95f4\u5982\u4f55\u8fdb\u884c\u6c9f\u901a"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/#_4","text":"","title":"\u65f6\u7a7a\u7684\u89d2\u5ea6"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/#process_3","text":"","title":"process\u7684\u72b6\u6001"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-lifetime/#_5","text":"","title":"\u6b7b"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/","text":"Process resource model process\u53ef\u80fd\u5360\u6709\u7684\u8d44\u6e90\u6709\uff1a resource \u53c2\u8003\u5185\u5bb9 \u63a7\u5236\u7ec8\u7aef man 4 tty file signal handler memory \u6587\u4ef6\u7cfb\u7edf \u5728 3.2. Process Descriptor \u4e2d\u4e5f\u6709\u5bf9\u6b64\u7684\u63cf\u8ff0\u3002 Memory memory\u8fd9\u79cdresource\u662f\u975e\u5e38\u5178\u578b\u7684\uff0c\u53c2\u89c1 Process-memory-model \u3002 Process resource management process\u80fd\u591f\u5360\u6709\u5982\u6b64\u4e4b\u591a\u7684resource\uff0c\u6240\u4ee5\u5bf9resource\u7684management\u662f\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5185\u5bb9\uff0c\u7531\u4e8e\u8fd9\u90e8\u5206\u5185\u5bb9\u548c programming language\u5bc6\u5207\u76f8\u5173\uff0c\u4e14\u4e0d\u540c\u7684programming language\u53ef\u80fd\u91c7\u53d6\u7684\u65b9\u5f0f\u662f\u4e0d\u540c\u7684\uff0c\u6240\u4ee5\u5c06\u8fd9\u90e8\u5206\u5185\u5bb9\u653e\u5230\u4e86\u5de5\u7a0b programming-language \u4e2d\u3002 \u76f8\u5173\u95ee\u9898 process\u5728\u80af\u5b9a\u4f1a\u5360\u7528\u4e00\u5b9a\u7684resource\u7684\uff0c\u6700\u6700\u5178\u578b\u7684\u5c31\u662ffile\u3002\u5173\u4e8e\u6b64\u53ef\u4ee5\u884d\u751f\u51fa\u4e00\u4e9b\u5217\u7684\u95ee\u9898: resource\u7684\u7ee7\u627f\u95ee\u9898 resource\u7684\u7ade\u4e89 resource\u7684\u5171\u4eab \u5728\u5de5\u7a0bParallel-computing\u7684 Concurrent-computing\\Concurrent-server \u7ae0\u8282\u4e2d\u6d89\u53ca\u8fd9\u4e2a\u95ee\u9898\u3002","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/#process#resource#model","text":"process\u53ef\u80fd\u5360\u6709\u7684\u8d44\u6e90\u6709\uff1a resource \u53c2\u8003\u5185\u5bb9 \u63a7\u5236\u7ec8\u7aef man 4 tty file signal handler memory \u6587\u4ef6\u7cfb\u7edf \u5728 3.2. Process Descriptor \u4e2d\u4e5f\u6709\u5bf9\u6b64\u7684\u63cf\u8ff0\u3002","title":"Process resource model"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/#memory","text":"memory\u8fd9\u79cdresource\u662f\u975e\u5e38\u5178\u578b\u7684\uff0c\u53c2\u89c1 Process-memory-model \u3002","title":"Memory"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/#process#resource#management","text":"process\u80fd\u591f\u5360\u6709\u5982\u6b64\u4e4b\u591a\u7684resource\uff0c\u6240\u4ee5\u5bf9resource\u7684management\u662f\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5185\u5bb9\uff0c\u7531\u4e8e\u8fd9\u90e8\u5206\u5185\u5bb9\u548c programming language\u5bc6\u5207\u76f8\u5173\uff0c\u4e14\u4e0d\u540c\u7684programming language\u53ef\u80fd\u91c7\u53d6\u7684\u65b9\u5f0f\u662f\u4e0d\u540c\u7684\uff0c\u6240\u4ee5\u5c06\u8fd9\u90e8\u5206\u5185\u5bb9\u653e\u5230\u4e86\u5de5\u7a0b programming-language \u4e2d\u3002","title":"Process resource management"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/#_1","text":"process\u5728\u80af\u5b9a\u4f1a\u5360\u7528\u4e00\u5b9a\u7684resource\u7684\uff0c\u6700\u6700\u5178\u578b\u7684\u5c31\u662ffile\u3002\u5173\u4e8e\u6b64\u53ef\u4ee5\u884d\u751f\u51fa\u4e00\u4e9b\u5217\u7684\u95ee\u9898: resource\u7684\u7ee7\u627f\u95ee\u9898 resource\u7684\u7ade\u4e89 resource\u7684\u5171\u4eab \u5728\u5de5\u7a0bParallel-computing\u7684 Concurrent-computing\\Concurrent-server \u7ae0\u8282\u4e2d\u6d89\u53ca\u8fd9\u4e2a\u95ee\u9898\u3002","title":"\u76f8\u5173\u95ee\u9898"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/System-resource/","text":"System resource \u672c\u7ae0\u5957\u5229process-resource model\uff0c\u6211\u4eec\u9996\u5148\u770b\u770bprocess\u53ef\u4ee5\u4f7f\u7528\u54ea\u4e9bsystem resource\u3002 \u7ef4\u57fa\u767e\u79d1 System resource \u5b9e\u73b0\u5206\u6790 \u663e\u7136\uff0cOS\u9700\u8981\u63cf\u8ff0\u5404\u79cdsystem resource\uff0c\u9700\u8981\u8bb0\u5f55\u4e0b\u6bcf\u4e2a\u8fdb\u7a0b\u5360\u7528 \u54ea\u4e9b\u8d44\u6e90\u3002","title":"System-resource"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/System-resource/#system#resource","text":"\u672c\u7ae0\u5957\u5229process-resource model\uff0c\u6211\u4eec\u9996\u5148\u770b\u770bprocess\u53ef\u4ee5\u4f7f\u7528\u54ea\u4e9bsystem resource\u3002","title":"System resource"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/System-resource/#system#resource_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1System resource"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/System-resource/#_1","text":"\u663e\u7136\uff0cOS\u9700\u8981\u63cf\u8ff0\u5404\u79cdsystem resource\uff0c\u9700\u8981\u8bb0\u5f55\u4e0b\u6bcf\u4e2a\u8fdb\u7a0b\u5360\u7528 \u54ea\u4e9b\u8d44\u6e90\u3002","title":"\u5b9e\u73b0\u5206\u6790"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/","text":"Process memory model \u9996\u5148\u63cf\u8ff0\u7406\u8bba\uff0c\u7136\u540e\u63cf\u8ff0Linux OS\u7684implementation\u3002","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/#process#memory#model","text":"\u9996\u5148\u63cf\u8ff0\u7406\u8bba\uff0c\u7136\u540e\u63cf\u8ff0Linux OS\u7684implementation\u3002","title":"Process memory model"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/","text":"Linux virtual memory area(VMA) \u672c\u7ae0\u9996\u5148\u7ed9\u51faLinux virtual memory area(VMA)\u7684layout\uff0c\u8fd9\u662f\u7ed3\u8bba\uff0c\u7136\u540e\u63cf\u8ff0\u5982\u4f55\u7f16\u5199\u7a0b\u5e8f\u6765\u8fdb\u884c\u9a8c\u8bc1(\u5728 ./Verification \u7ae0\u8282\u8fdb\u884c\u63cf\u8ff0)\u6216\u8005\u8bf4\u5982\u4f55\u5f97\u51fa\u8fd9\u4e2a\u7ed3\u8bba\u3002 cnblogs Linux\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u5e03\u5c40 \u572832 bit\u7cfb\u7edf\u4e2d\uff0c\u5185\u6838\u5206\u914d1GB\uff0c\u800c\u5404\u4e2a\u7528\u6237\u7a7a\u95f4\u8fdb\u7a0b\u53ef\u7528\u7684\u90e8\u5206\u4e3a3GB\u3002 \u4e0b\u56fe\u5c55\u793a\u4e86\u4e00\u4e2a32\u4f4d\u7cfb\u7edf\u7684\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5e03\u5c40\uff1a \u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7531\u82e5\u5e72\u4e2a\u533a\u57df\u7ec4\u6210\uff1a 1.\u5f53\u524d\u8fd0\u884c\u4ee3\u7801\u7684\u4e8c\u8fdb\u5236\u4ee3\u7801.text\u6bb5\u3002 2.\u7a0b\u5e8f\u4f7f\u7528\u7684\u52a8\u6001\u5e93\u4ee3\u7801\u3002 3.\u5b58\u50a8**\u533a\u5c40\u53d8\u91cf**\u548c**\u9759\u6001\u53d8\u91cf**\u7684\u6570\u636e\u6bb5\uff0cbss,data\u6bb5 4.\u4fdd\u5b58\u52a8\u6001\u5206\u914d\u6570\u636e\u7684\u5806 5.\u4fdd\u5b58\u5c40\u90e8\u53d8\u91cf\u548c\u5b9e\u73b0**\u51fd\u6570\u8c03\u7528**\u7684\u6808 6.\u73af\u5883\u53d8\u91cf\u548c\u547d\u4ee4\u884c\u53c2\u6570\u3002 7.\u6587\u4ef6\u5185\u5bb9\u6620\u5c04\u5230\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5185\u5b58\u6620\u5c04\u3002 \u5982\u679c\u5168\u5c40\u53d8\u91cf randomize_va_space \u8bbe\u7f6e\u4e3a 1 \uff0c\u90a3\u4e48\u542f\u7528\u5730\u5740**\u7a7a\u95f4\u968f\u673a\u5316\u673a\u5236**\uff08\u4e0a\u56fe\u7684 ramdom xxx offset \uff09\u3002\u7528\u6237\u53ef\u4ee5\u901a\u8fc7 /proc/sys/kernel/randomize_va_space \u505c\u7528\u8be5\u7279\u6027\u3002 \u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709 mm_struct (linux/mm_types.h)\u7684\u5b9e\u4f8b\uff0c\u4fdd\u5b58**\u8fdb\u7a0b\u865a\u62df\u5185\u5b58\u7ba1\u7406\u4fe1\u606f**\u3002 struct mm_struct { struct vm_area_struct * mmap ; /* list of VMAs */ struct rb_root mm_rb ; #ifdef CONFIG_MMU unsigned long ( * get_unmapped_area ) ( struct file * filp , unsigned long addr , unsigned long len , unsigned long pgoff , unsigned long flags ); #endif unsigned long mmap_base ; /* base of mmap area */ \u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u7528\u4e8e\u5185\u5b58\u6620\u5c04\u7684\u8d77\u59cb\u5730\u5740\u3002 unsigned long mmap_legacy_base ; /* base of mmap area in bottom-up allocations */ unsigned long task_size ; /* size of task vm space */ \u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u7684 size . struct list_head mmlist ; /* List of maybe swapped mm's. These are globally strung unsigned long start_code, end_code, start_data, end_data;//text\u6bb5\uff0c\u6570\u636e\u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ec8\u6b62\u5730\u5740 unsigned long start_brk, brk, start_stack;//\u5806\u9996\u5730\u5740\uff0c\u5806\u5c3e\u5730\u5740\uff0c\u6808\u9996\u5730\u5740\u3002 unsigned long arg_start, arg_end, env_start, env_end;//\u547d\u4ee4\u884c\u53c2\u6570\uff0c\u73af\u5883\u53d8\u91cf\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ec8\u6b62\u5730\u5740 .... }; **\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u7531\u591a\u4e2a VMA \u7ec4\u6210\uff08 struct mm_struct \u4e2d struct vm_area_struct \\*mmap;/* list of VMAs */ \u6210\u5458\uff09\u3002\u6709\u4e24\u79cd\u7ec4\u7ec7 VMA \u7684\u65b9\u5f0f\uff0c\u94fe\u8868\uff08 mmap \uff09\u548c\u7ea2\u9ed1\u6811\uff08 mm_rb \uff09 VMA\u7ed3\u6784\u4f53\u5982\u4e0b\uff1a struct vm_area_struct { \u3000\u3000 /* The first cache line has the info for VMA tree walking. */ \u3000\u3000 unsigned long vm_start ; /* Our start address within vm_mm. */ \u3000\u3000 unsigned long vm_end ; /* The first byte after our end address within vm_mm. */ \u3000\u3000 /* linked list of VM areas per task, sorted by address */ \u3000\u3000 struct vm_area_struct * vm_next , * vm_prev ; \u3000\u3000 struct rb_node vm_rb ; \u3000\u3000 struct mm_struct * vm_mm ; /* The address space we belong to. */ \u3000\u3000 /* Function pointers to deal with this struct. */ \u3000\u3000 const struct vm_operations_struct * vm_ops ; \u3000\u3000 struct file * vm_file ; /* File we map to (can be NULL). */ \u3000\u3000 void * vm_private_data ; /* was vm_pte (shared mem) */ }; VMA\u94fe\u8868\u7ec4\u7ec7\u5f62\u5f0f\u5982\u4e0b\u56fe\uff1a VMA\u7ea2\u9ed1\u6811\u7ec4\u7ec7\u5f62\u5f0f\u5982\u4e0b\uff1a gnu libc 3.1 Process Memory Concepts A process\u2019 virtual address space is divided into segments. A segment is a contiguous range of virtual addresses. Three important segments are: The text segment contains a program\u2019s instructions and literals and static constants. It is allocated by exec and stays the same size for the life of the virtual address space. The data segment is working storage for the program. It can be preallocated and preloaded by exec and the process can extend or shrink it by calling functions as described in See Resizing the Data Segment . Its lower end is fixed. The stack segment contains a program stack. It grows as the stack grows, but doesn\u2019t shrink when the stack shrinks. TODO https://blog.csdn.net/feilengcui008/article/details/44141495 https://www.cnblogs.com/dyllove98/archive/2013/07/05/3174341.html","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/#linux#virtual#memory#areavma","text":"\u672c\u7ae0\u9996\u5148\u7ed9\u51faLinux virtual memory area(VMA)\u7684layout\uff0c\u8fd9\u662f\u7ed3\u8bba\uff0c\u7136\u540e\u63cf\u8ff0\u5982\u4f55\u7f16\u5199\u7a0b\u5e8f\u6765\u8fdb\u884c\u9a8c\u8bc1(\u5728 ./Verification \u7ae0\u8282\u8fdb\u884c\u63cf\u8ff0)\u6216\u8005\u8bf4\u5982\u4f55\u5f97\u51fa\u8fd9\u4e2a\u7ed3\u8bba\u3002","title":"Linux virtual memory area(VMA)"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/#cnblogs#linux","text":"\u572832 bit\u7cfb\u7edf\u4e2d\uff0c\u5185\u6838\u5206\u914d1GB\uff0c\u800c\u5404\u4e2a\u7528\u6237\u7a7a\u95f4\u8fdb\u7a0b\u53ef\u7528\u7684\u90e8\u5206\u4e3a3GB\u3002 \u4e0b\u56fe\u5c55\u793a\u4e86\u4e00\u4e2a32\u4f4d\u7cfb\u7edf\u7684\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5e03\u5c40\uff1a \u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7531\u82e5\u5e72\u4e2a\u533a\u57df\u7ec4\u6210\uff1a 1.\u5f53\u524d\u8fd0\u884c\u4ee3\u7801\u7684\u4e8c\u8fdb\u5236\u4ee3\u7801.text\u6bb5\u3002 2.\u7a0b\u5e8f\u4f7f\u7528\u7684\u52a8\u6001\u5e93\u4ee3\u7801\u3002 3.\u5b58\u50a8**\u533a\u5c40\u53d8\u91cf**\u548c**\u9759\u6001\u53d8\u91cf**\u7684\u6570\u636e\u6bb5\uff0cbss,data\u6bb5 4.\u4fdd\u5b58\u52a8\u6001\u5206\u914d\u6570\u636e\u7684\u5806 5.\u4fdd\u5b58\u5c40\u90e8\u53d8\u91cf\u548c\u5b9e\u73b0**\u51fd\u6570\u8c03\u7528**\u7684\u6808 6.\u73af\u5883\u53d8\u91cf\u548c\u547d\u4ee4\u884c\u53c2\u6570\u3002 7.\u6587\u4ef6\u5185\u5bb9\u6620\u5c04\u5230\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5185\u5b58\u6620\u5c04\u3002 \u5982\u679c\u5168\u5c40\u53d8\u91cf randomize_va_space \u8bbe\u7f6e\u4e3a 1 \uff0c\u90a3\u4e48\u542f\u7528\u5730\u5740**\u7a7a\u95f4\u968f\u673a\u5316\u673a\u5236**\uff08\u4e0a\u56fe\u7684 ramdom xxx offset \uff09\u3002\u7528\u6237\u53ef\u4ee5\u901a\u8fc7 /proc/sys/kernel/randomize_va_space \u505c\u7528\u8be5\u7279\u6027\u3002 \u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709 mm_struct (linux/mm_types.h)\u7684\u5b9e\u4f8b\uff0c\u4fdd\u5b58**\u8fdb\u7a0b\u865a\u62df\u5185\u5b58\u7ba1\u7406\u4fe1\u606f**\u3002 struct mm_struct { struct vm_area_struct * mmap ; /* list of VMAs */ struct rb_root mm_rb ; #ifdef CONFIG_MMU unsigned long ( * get_unmapped_area ) ( struct file * filp , unsigned long addr , unsigned long len , unsigned long pgoff , unsigned long flags ); #endif unsigned long mmap_base ; /* base of mmap area */ \u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u7528\u4e8e\u5185\u5b58\u6620\u5c04\u7684\u8d77\u59cb\u5730\u5740\u3002 unsigned long mmap_legacy_base ; /* base of mmap area in bottom-up allocations */ unsigned long task_size ; /* size of task vm space */ \u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u7684 size . struct list_head mmlist ; /* List of maybe swapped mm's. These are globally strung unsigned long start_code, end_code, start_data, end_data;//text\u6bb5\uff0c\u6570\u636e\u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ec8\u6b62\u5730\u5740 unsigned long start_brk, brk, start_stack;//\u5806\u9996\u5730\u5740\uff0c\u5806\u5c3e\u5730\u5740\uff0c\u6808\u9996\u5730\u5740\u3002 unsigned long arg_start, arg_end, env_start, env_end;//\u547d\u4ee4\u884c\u53c2\u6570\uff0c\u73af\u5883\u53d8\u91cf\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ec8\u6b62\u5730\u5740 .... }; **\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u7531\u591a\u4e2a VMA \u7ec4\u6210\uff08 struct mm_struct \u4e2d struct vm_area_struct \\*mmap;/* list of VMAs */ \u6210\u5458\uff09\u3002\u6709\u4e24\u79cd\u7ec4\u7ec7 VMA \u7684\u65b9\u5f0f\uff0c\u94fe\u8868\uff08 mmap \uff09\u548c\u7ea2\u9ed1\u6811\uff08 mm_rb \uff09 VMA\u7ed3\u6784\u4f53\u5982\u4e0b\uff1a struct vm_area_struct { \u3000\u3000 /* The first cache line has the info for VMA tree walking. */ \u3000\u3000 unsigned long vm_start ; /* Our start address within vm_mm. */ \u3000\u3000 unsigned long vm_end ; /* The first byte after our end address within vm_mm. */ \u3000\u3000 /* linked list of VM areas per task, sorted by address */ \u3000\u3000 struct vm_area_struct * vm_next , * vm_prev ; \u3000\u3000 struct rb_node vm_rb ; \u3000\u3000 struct mm_struct * vm_mm ; /* The address space we belong to. */ \u3000\u3000 /* Function pointers to deal with this struct. */ \u3000\u3000 const struct vm_operations_struct * vm_ops ; \u3000\u3000 struct file * vm_file ; /* File we map to (can be NULL). */ \u3000\u3000 void * vm_private_data ; /* was vm_pte (shared mem) */ }; VMA\u94fe\u8868\u7ec4\u7ec7\u5f62\u5f0f\u5982\u4e0b\u56fe\uff1a VMA\u7ea2\u9ed1\u6811\u7ec4\u7ec7\u5f62\u5f0f\u5982\u4e0b\uff1a","title":"cnblogs Linux\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u5e03\u5c40"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/#gnu#libc#31#process#memory#concepts","text":"A process\u2019 virtual address space is divided into segments. A segment is a contiguous range of virtual addresses. Three important segments are: The text segment contains a program\u2019s instructions and literals and static constants. It is allocated by exec and stays the same size for the life of the virtual address space. The data segment is working storage for the program. It can be preallocated and preloaded by exec and the process can extend or shrink it by calling functions as described in See Resizing the Data Segment . Its lower end is fixed. The stack segment contains a program stack. It grows as the stack grows, but doesn\u2019t shrink when the stack shrinks.","title":"gnu libc 3.1 Process Memory Concepts"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/#todo","text":"https://blog.csdn.net/feilengcui008/article/details/44141495 https://www.cnblogs.com/dyllove98/archive/2013/07/05/3174341.html","title":"TODO"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Program-break/","text":"Program break \u5728\u9605\u8bfb brk(2) \u2014 Linux manual page \u65f6\uff0c\u5176\u4e2d\u5927\u91cf\u4f7f\u7528\u4e86**program break**\u8fd9\u4e2a\u8bcd\u8bed\uff0c\u90a3\u5b83\u7684\u542b\u4e49\u662f\u4ec0\u4e48\u5462\uff1f\u672c\u6587\u5bf9\u6b64\u8fdb\u884c\u8bf4\u660e\u3002 holbertonschool Hack the Virtual Memory: malloc, the heap & the program break \u5728\u8fd9\u7bc7\u6587\u7ae0\u4e2d\uff0c\u4ecb\u7ecd\u4e86malloc\u3001brk\u3001program break\u3001data segment\u3001heap\u6982\u5ff5\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u5728 Kernel\\Guide\\Multitasking\\Process-model\\Process-resource\\Process-memory-model\\Linux-implementation\\Verification\\Holberton-Hack-the-virtual-memory\\Chapter-3-malloc-the-heap&the-program-break \u4e2d\u6536\u5f55\u4e86\u8fd9\u7bc7\u6587\u7ae0\u3002\u57fa\u672c\u4e0a\uff0c\u901a\u8fc7\u8fd9\u7bc7\u6587\u7ae0\u7684\u9605\u8bfb\u662f\u80fd\u591f\u5b8c\u6574\u7684\u8ba4\u8bc6program break\u7684\u542b\u4e49\u7684\u3002 stackoverflow What is program break? Where does it start from,0x00? A A program break is end of the process's data segment. AKA... the program break is the first location after the end of the uninitialized data segment As to where it starts from, it's system dependent but probably not 0x00. A Oversimplifying: A process has several segments of memory: Code (text) segment, which contains the code to be executed. Data segment, which contains data the compiler knows about (globals and statics). Stack segment, which contains (drumroll...) the stack. (Of course, nowadays it's much more complex. There is a rodata segment, a uninitialized data segment, mappings allocated via mmap, a vdso, ...) One traditional way a program can request more memory in a Unix-like OS is to increment the size of the data segment, and use a memory allocator (i.e. malloc() implementation) to manage the resulting space. This is done via the brk() system call, which changes the point where the data segment \"breaks\"/ends. man7 brk(2) \u2014 Linux manual page brk() and sbrk() change the location of the program break, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment ). Increasing the program break has the effect of allocating memory to the process; decreasing the break deallocates memory.","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Program-break/#program#break","text":"\u5728\u9605\u8bfb brk(2) \u2014 Linux manual page \u65f6\uff0c\u5176\u4e2d\u5927\u91cf\u4f7f\u7528\u4e86**program break**\u8fd9\u4e2a\u8bcd\u8bed\uff0c\u90a3\u5b83\u7684\u542b\u4e49\u662f\u4ec0\u4e48\u5462\uff1f\u672c\u6587\u5bf9\u6b64\u8fdb\u884c\u8bf4\u660e\u3002","title":"Program break"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Program-break/#holbertonschool#hack#the#virtual#memory#malloc#the#heap#the#program#break","text":"\u5728\u8fd9\u7bc7\u6587\u7ae0\u4e2d\uff0c\u4ecb\u7ecd\u4e86malloc\u3001brk\u3001program break\u3001data segment\u3001heap\u6982\u5ff5\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u5728 Kernel\\Guide\\Multitasking\\Process-model\\Process-resource\\Process-memory-model\\Linux-implementation\\Verification\\Holberton-Hack-the-virtual-memory\\Chapter-3-malloc-the-heap&the-program-break \u4e2d\u6536\u5f55\u4e86\u8fd9\u7bc7\u6587\u7ae0\u3002\u57fa\u672c\u4e0a\uff0c\u901a\u8fc7\u8fd9\u7bc7\u6587\u7ae0\u7684\u9605\u8bfb\u662f\u80fd\u591f\u5b8c\u6574\u7684\u8ba4\u8bc6program break\u7684\u542b\u4e49\u7684\u3002","title":"holbertonschool Hack the Virtual Memory: malloc, the heap &amp; the program break"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Program-break/#stackoverflow#what#is#program#break#where#does#it#start#from0x00","text":"A A program break is end of the process's data segment. AKA... the program break is the first location after the end of the uninitialized data segment As to where it starts from, it's system dependent but probably not 0x00. A Oversimplifying: A process has several segments of memory: Code (text) segment, which contains the code to be executed. Data segment, which contains data the compiler knows about (globals and statics). Stack segment, which contains (drumroll...) the stack. (Of course, nowadays it's much more complex. There is a rodata segment, a uninitialized data segment, mappings allocated via mmap, a vdso, ...) One traditional way a program can request more memory in a Unix-like OS is to increment the size of the data segment, and use a memory allocator (i.e. malloc() implementation) to manage the resulting space. This is done via the brk() system call, which changes the point where the data segment \"breaks\"/ends.","title":"stackoverflow What is program break? Where does it start from,0x00?"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Program-break/#man7#brk2#linux#manual#page","text":"brk() and sbrk() change the location of the program break, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment ). Increasing the program break has the effect of allocating memory to the process; decreasing the break deallocates memory.","title":"man7 brk(2) \u2014 Linux manual page"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Size/Unix-virtual-address-space/","text":"How does word size affect the amount of virtual address space available? So, I should really know this stuff already, but I am starting to learn more about the lower levels of software development. I am currently reading Computer Systems: A Programmer's Perspective. by Bryant O'Hallaron. I am on chapter 2 and he is talking about the way data is represented internally. I am having trouble understanding something conceptually and I am sure that I'm about to make my ignorance lucid here. I understand that a \"word\" is just a set of bytes and that the word size is just how many bits wide the system bus is. But, he also says: \"the most important system parameter determined by the word size is the maximum size of the virtual address space . That is, for a machine with a w- bit word size, the virtual addresses can range from 0 to (2^w)-1, giving the program access to at most 2^w bytes \" I am both confused on the general relationship between the word size and the amount of addresses in the system and how the specific formula is w-bit word size=2^w bytes of memory available. I am really scratching my head here, can some one help me out? EDIT: I actually misinterpreted his definition of a word and consequently the definition of word size. What he really said was: Busses are typically designed to transfer fixed-sized chunks of bytes known as words . The number of bytes in a word (the word size ) is a fundamental system parameter that varies across systems. most machines today have word sizes of either 4 bytes(32 bits) or 8 bytes(64 bits). For the sake of our discussion here, we will assume a word size of 4 bytes, and we will assume that buses transfer only one word at a time. which is pretty much a catch-all for the cases discussed in the answers without having to go into detail. He also said he would be oversimplifying some things, perhaps in later sections he will go into more detail. A The idea is that one word of memory can be used as an address in the address space (i.e., a word is wide enough to hold a pointer). If an address were larger than a word, addressing would require multiple sequential words. That's not impossible, but is unreasonably complicated (and likely slow). So, given an w -bit word, how many values can that word represent? How may addresses can it denote? Since any bit can take on two values, we end up with 2\u00b72\u00b72\u00b7\u2026\u00b72 = 2^w 2^w addresses. Addresses are counted starting by zero, so the highest address is 2^w 2^w - 1. Example using a three-bit word: There are 2^3 2^3 =8 possible addresses: bin: 000 001 010 011 100 101 110 111 dec: 0 1 2 3 4 5 6 7 The highest address is 2^3-1 = 8 - 1 = 7 2^3-1 = 8 - 1 = 7 . If the memory is an array of bytes and the address is an index to this array, then using a three-bit word we can only address eight bytes. Even if the array physically holds more bytes, we cannot reach them with a restricted index. Therefore, the amount of virtual memory is restricted by the word size . COMMENTS Ahh, I get it now, so to have 8GB ram on a 32 bit system would be pointless then. \u2013 Luke Dec 23 '14 at 18:36 1 Of course, counterexamples to the idea that word length and memory size are usually equal are common: the 6502 had an 8-bit word size but 16-bit addresses, the 8086 had 16-bit words and 20-bit addresses, the 80286 was likewise 16-bit but used 24-bit addresses, and the Pentium Pro was a 32-bit processor supporting 36-bit addresses. All of these are harder to use than the simple word = pointer scheme we've become used to, but architectures like this are not exactly rare, historically speaking. \u2013 Jules Dec 23 '14 at 18:42 @LukeP Yes, at 4GB or more a 64-bit system is a must. However, there's a technique called \u201c physical address extension \u201d that allows a 32-bit OS running on compatible hardware to handle more than 4GB of physical memory \u2013 although the limit on virtual memory still holds. \u2013 amon Dec 23 '14 at 18:43 @lukep - not exactly pointless, just that you'd have to jump through certain hoops to use the extra memory that might make it more hassle than it's e worth. Note that 32-bit versions of server variants of Windows, for example, can handle up to 64gb of memory, but end-user systems are limited to 4gb because a lot of things stop working properly when you try to extend the memory beyond the 4gb barrier. \u2013 Jules Dec 23 '14 at 18:46 Related reading: x86 memory segmentation , probably the one architecture people are likely to be familiar with that had a segmented memory model and all the hassles that came with it. \u2013 user22815 Dec 23 '14 at 21:35 A I understand that a \"word\" is just a set of bytes and that the word size is just how many bits wide the system bus is. But, he also says: \"the most important system parameter determined by the word size is the maximum size of the virtual address space. That is, for a machine with a w-bit word size, the virtual addresses can range from 0 to (2^w)-1, giving the program access to at most 2^w bytes\" That's assuming a lot. The assumptions are not unreasonable, but holding them in a book pretending to introduce computer architecture to programmers seems a weakness of the book. A word is a sequence of bits with the width used for normal argument of integer computation. (And that's still assuming that the architecture doesn't define a word with another, smaller, size which was the word used in an ancestor of the architecture.) That is often the size of integer registers. Bus have often that size, but they may be smaller or larger and are not really used to define what is the word size. There is an important class of processors for which data addresses have the same size as word. That's not always true. There are other processors may have a smaller or bigger address space (this is somewhat out of fashion, the 8086 had 16-bit words but the addresses were 20-bit wide, the PDP-10 had 36-bit words but the addresses were 18-bit wide). There is an important class of processors for which each byte of memory has its own address. That's not always true. There are other processors which give addresses to words, not to bytes. That's also out of fashion for general purpose processors, but more specialized one like DSP are still doing that. So if you have a processor which is in those two classes, a word of width w bits may holds 2^w different value, each referencing one byte. This is a maximum for the virtual memory size. The processor may have architectural restrictions which prevent the use of all that space (reserving part for the OS, for IO), or it may have other restrictions (the data structures used to map the virtual memory to the physical one in 64-bit processors often are not able to map the whole 64-bit space). There are at least two instances of machines which ignored the high order byte of 32-bit addresses and programmers have taken advantage of that (using those bits for flags and other stuff) leading to a painful evolution when later one wanted to use the bits for addresses (IBM 360 and MC68000 as used on Mac). I actually misinterpreted his original definition. I'm editing the question to reflect his exact definition \u2013 Luke Dec 23 '14 at 18:46 1 @LukeP , that doesn't change much. Word size is a property of the ISA (Instruction Set Architecture). Bus sizes is a property of the implementation of the ISA (also called micro-architecture). A bus may be wider or smaller than a word, that's not important for the programmer. The same ISA may be implemented several times, with different bus size. \u2013 AProgrammer Dec 23 '14 at 18:54 but the bus is still going to be sending the same amount of information over, it just may have to be done in a different amount of \"words\" right? \u2013 Luke Dec 23 '14 at 18:59 Yes. You have to think about the ISA as the interface between software and hardware. And as most interface, its goal is to expose functionality and hide implementation. And buses (there may be several, of different width) are part of the implementation. \u2013 AProgrammer Dec 23 '14 at 20:44","title":"Unix-virtual-address-space"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Size/Unix-virtual-address-space/#how#does#word#size#affect#the#amount#of#virtual#address#space#available","text":"So, I should really know this stuff already, but I am starting to learn more about the lower levels of software development. I am currently reading Computer Systems: A Programmer's Perspective. by Bryant O'Hallaron. I am on chapter 2 and he is talking about the way data is represented internally. I am having trouble understanding something conceptually and I am sure that I'm about to make my ignorance lucid here. I understand that a \"word\" is just a set of bytes and that the word size is just how many bits wide the system bus is. But, he also says: \"the most important system parameter determined by the word size is the maximum size of the virtual address space . That is, for a machine with a w- bit word size, the virtual addresses can range from 0 to (2^w)-1, giving the program access to at most 2^w bytes \" I am both confused on the general relationship between the word size and the amount of addresses in the system and how the specific formula is w-bit word size=2^w bytes of memory available. I am really scratching my head here, can some one help me out? EDIT: I actually misinterpreted his definition of a word and consequently the definition of word size. What he really said was: Busses are typically designed to transfer fixed-sized chunks of bytes known as words . The number of bytes in a word (the word size ) is a fundamental system parameter that varies across systems. most machines today have word sizes of either 4 bytes(32 bits) or 8 bytes(64 bits). For the sake of our discussion here, we will assume a word size of 4 bytes, and we will assume that buses transfer only one word at a time. which is pretty much a catch-all for the cases discussed in the answers without having to go into detail. He also said he would be oversimplifying some things, perhaps in later sections he will go into more detail.","title":"How does word size affect the amount of virtual address space available?"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Size/Unix-virtual-address-space/#a","text":"The idea is that one word of memory can be used as an address in the address space (i.e., a word is wide enough to hold a pointer). If an address were larger than a word, addressing would require multiple sequential words. That's not impossible, but is unreasonably complicated (and likely slow). So, given an w -bit word, how many values can that word represent? How may addresses can it denote? Since any bit can take on two values, we end up with 2\u00b72\u00b72\u00b7\u2026\u00b72 = 2^w 2^w addresses. Addresses are counted starting by zero, so the highest address is 2^w 2^w - 1. Example using a three-bit word: There are 2^3 2^3 =8 possible addresses: bin: 000 001 010 011 100 101 110 111 dec: 0 1 2 3 4 5 6 7 The highest address is 2^3-1 = 8 - 1 = 7 2^3-1 = 8 - 1 = 7 . If the memory is an array of bytes and the address is an index to this array, then using a three-bit word we can only address eight bytes. Even if the array physically holds more bytes, we cannot reach them with a restricted index. Therefore, the amount of virtual memory is restricted by the word size . COMMENTS Ahh, I get it now, so to have 8GB ram on a 32 bit system would be pointless then. \u2013 Luke Dec 23 '14 at 18:36 1 Of course, counterexamples to the idea that word length and memory size are usually equal are common: the 6502 had an 8-bit word size but 16-bit addresses, the 8086 had 16-bit words and 20-bit addresses, the 80286 was likewise 16-bit but used 24-bit addresses, and the Pentium Pro was a 32-bit processor supporting 36-bit addresses. All of these are harder to use than the simple word = pointer scheme we've become used to, but architectures like this are not exactly rare, historically speaking. \u2013 Jules Dec 23 '14 at 18:42 @LukeP Yes, at 4GB or more a 64-bit system is a must. However, there's a technique called \u201c physical address extension \u201d that allows a 32-bit OS running on compatible hardware to handle more than 4GB of physical memory \u2013 although the limit on virtual memory still holds. \u2013 amon Dec 23 '14 at 18:43 @lukep - not exactly pointless, just that you'd have to jump through certain hoops to use the extra memory that might make it more hassle than it's e worth. Note that 32-bit versions of server variants of Windows, for example, can handle up to 64gb of memory, but end-user systems are limited to 4gb because a lot of things stop working properly when you try to extend the memory beyond the 4gb barrier. \u2013 Jules Dec 23 '14 at 18:46 Related reading: x86 memory segmentation , probably the one architecture people are likely to be familiar with that had a segmented memory model and all the hassles that came with it. \u2013 user22815 Dec 23 '14 at 21:35","title":"A"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Size/Unix-virtual-address-space/#a_1","text":"I understand that a \"word\" is just a set of bytes and that the word size is just how many bits wide the system bus is. But, he also says: \"the most important system parameter determined by the word size is the maximum size of the virtual address space. That is, for a machine with a w-bit word size, the virtual addresses can range from 0 to (2^w)-1, giving the program access to at most 2^w bytes\" That's assuming a lot. The assumptions are not unreasonable, but holding them in a book pretending to introduce computer architecture to programmers seems a weakness of the book. A word is a sequence of bits with the width used for normal argument of integer computation. (And that's still assuming that the architecture doesn't define a word with another, smaller, size which was the word used in an ancestor of the architecture.) That is often the size of integer registers. Bus have often that size, but they may be smaller or larger and are not really used to define what is the word size. There is an important class of processors for which data addresses have the same size as word. That's not always true. There are other processors may have a smaller or bigger address space (this is somewhat out of fashion, the 8086 had 16-bit words but the addresses were 20-bit wide, the PDP-10 had 36-bit words but the addresses were 18-bit wide). There is an important class of processors for which each byte of memory has its own address. That's not always true. There are other processors which give addresses to words, not to bytes. That's also out of fashion for general purpose processors, but more specialized one like DSP are still doing that. So if you have a processor which is in those two classes, a word of width w bits may holds 2^w different value, each referencing one byte. This is a maximum for the virtual memory size. The processor may have architectural restrictions which prevent the use of all that space (reserving part for the OS, for IO), or it may have other restrictions (the data structures used to map the virtual memory to the physical one in 64-bit processors often are not able to map the whole 64-bit space). There are at least two instances of machines which ignored the high order byte of 32-bit addresses and programmers have taken advantage of that (using those bits for flags and other stuff) leading to a painful evolution when later one wanted to use the bits for addresses (IBM 360 and MC68000 as used on Mac). I actually misinterpreted his original definition. I'm editing the question to reflect his exact definition \u2013 Luke Dec 23 '14 at 18:46 1 @LukeP , that doesn't change much. Word size is a property of the ISA (Instruction Set Architecture). Bus sizes is a property of the implementation of the ISA (also called micro-architecture). A bus may be wider or smaller than a word, that's not important for the programmer. The same ISA may be implemented several times, with different bus size. \u2013 AProgrammer Dec 23 '14 at 18:54 but the bus is still going to be sending the same amount of information over, it just may have to be done in a different amount of \"words\" right? \u2013 Luke Dec 23 '14 at 18:59 Yes. You have to think about the ISA as the interface between software and hardware. And as most interface, its goal is to expose functionality and hide implementation. And buses (there may be several, of different width) are part of the implementation. \u2013 AProgrammer Dec 23 '14 at 20:44","title":"A"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Size/Virtual-address-space-size-reading-list/","text":"\u201cOut Of Memory\u201d Does Not Refer to Physical Memory Is Virtual memory infinite? A A How much memory can a 64bit machine address at a time? \u201cOut Of Memory\u201d Does Not Refer to Physical Memory Is Virtual memory infinite? I have been asked in an interview if virtual memory is infinite? I answered saying that it is not infinite. Then the interviewer asked the explanation and what I suggested was that in windows we do have a manual way to configure virtual memory to a certain limit. I would like to know if Virtual memory is really Infinite? A First of all, forget the idea that virtual memory is limited by the size of pointers on your machine. Virtual memory limits are not the same as addressing space . You can address more virtual memory than is available in your pointer-based address space using paging. Virtual memory upper limits are set by the OS: for example, on 32-bit Windows the limit is 16TB, and on 64-bit Windows the limit is 256TB. Virtual memory is also physically limited by the available disc space. For an excellent overview, which addresses various misconceptions, see the following: http://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx COMMENTS Yes @stusmith i think you are right about You can address more virtual memory than is available in your pointer-based ,and it is whole idea of using virtual memory. \u2013 Amit Singh Tomar Jul 7 '11 at 10:42 1 Virtual memory is not exactly limited by disk space, it can be allocated but not mapped, so-called \"reserved virtual memory\". See msdn.microsoft.com/en-us/library/windows/desktop/\u2026 and MEM_RESERVE for explanation. \u2013 Sergey Alaev Apr 6 '17 at 9:50 A At the very least, the size of virtual memory is limited by the size of pointers on given platform (unless it has near/far pointers and non-flat memory model). For example, you cannot address more than about 2^32 (4GB) of memory using single 32-bit pointer. In practice, the virtual memory must be backed up with something eventually -- like a pagefile on disk -- so the size of storage enforces a more practical limit. Sorry, that's just wrong. Look up \"PAE\" ( Physical Address Extension ) for example. \u2013 stusmith Jul 7 '11 at 10:18 1 @stusmith : A PAE-enabled Linux-kernel requires that the CPU also support PAE. So, it is limited by the computer architecture, right? \u2013 Priyank Bhatnagar Jul 7 '11 at 10:28 2 @logic_max : Yes, but a 32-bit Intel chip is capable of supporting PAE. Maybe a better way of putting it is: it is the lowest value of [chip support, OS limit, disk space] . Usually that lowest value is disk space. \u2013 stusmith Jul 7 '11 at 10:30 @stusmith I don't think that ARM, PowerPC, MIPS, or many other CPUs have PAE. Neither do older x86 CPUs. There is no right answer to this poor question. In fact, depending on how you count (for the system, for a process), the answer is different, but still not infinite. Down-vote anyone who says it is infinite. \u2013 artless noise May 30 '14 at 17:47 1 It is also not true that everything must be backed by disk. A large zero initialized array can all be backed by a single page of zeros (typically 4-8k). Any read from any address will show zero. On the first write to a page, a fault happens and then the page is allocated (needs disk or memory) and remapped. This can allow large sparse arrays. \u2013 artless noise Jun 2 '14 at 20:52 The sum of the virtual address spaces of all the processes running at once can be larger than what the 'user pointer' register can address - since the 'process id' is effectively part of the virtual address . In some cases these \"process-unique\" addresses actually point to the same PM (e.g. shared libraries, data shared after fork() ) - but even allowing for that, it's possible for the total amount of truly distinct VM pages to exceed what one process can address. \u2013 greggo Aug 13 '14 at 16:51 How much memory can a 64bit machine address at a time?","title":"Virtual-address-space-size-reading-list"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Size/Virtual-address-space-size-reading-list/#out#of#memory#does#not#refer#to#physical#memory","text":"","title":"\u201cOut Of Memory\u201d Does Not Refer to Physical Memory"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Size/Virtual-address-space-size-reading-list/#is#virtual#memory#infinite","text":"I have been asked in an interview if virtual memory is infinite? I answered saying that it is not infinite. Then the interviewer asked the explanation and what I suggested was that in windows we do have a manual way to configure virtual memory to a certain limit. I would like to know if Virtual memory is really Infinite?","title":"Is Virtual memory infinite?"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Size/Virtual-address-space-size-reading-list/#a","text":"First of all, forget the idea that virtual memory is limited by the size of pointers on your machine. Virtual memory limits are not the same as addressing space . You can address more virtual memory than is available in your pointer-based address space using paging. Virtual memory upper limits are set by the OS: for example, on 32-bit Windows the limit is 16TB, and on 64-bit Windows the limit is 256TB. Virtual memory is also physically limited by the available disc space. For an excellent overview, which addresses various misconceptions, see the following: http://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx COMMENTS Yes @stusmith i think you are right about You can address more virtual memory than is available in your pointer-based ,and it is whole idea of using virtual memory. \u2013 Amit Singh Tomar Jul 7 '11 at 10:42 1 Virtual memory is not exactly limited by disk space, it can be allocated but not mapped, so-called \"reserved virtual memory\". See msdn.microsoft.com/en-us/library/windows/desktop/\u2026 and MEM_RESERVE for explanation. \u2013 Sergey Alaev Apr 6 '17 at 9:50","title":"A"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Size/Virtual-address-space-size-reading-list/#a_1","text":"At the very least, the size of virtual memory is limited by the size of pointers on given platform (unless it has near/far pointers and non-flat memory model). For example, you cannot address more than about 2^32 (4GB) of memory using single 32-bit pointer. In practice, the virtual memory must be backed up with something eventually -- like a pagefile on disk -- so the size of storage enforces a more practical limit. Sorry, that's just wrong. Look up \"PAE\" ( Physical Address Extension ) for example. \u2013 stusmith Jul 7 '11 at 10:18 1 @stusmith : A PAE-enabled Linux-kernel requires that the CPU also support PAE. So, it is limited by the computer architecture, right? \u2013 Priyank Bhatnagar Jul 7 '11 at 10:28 2 @logic_max : Yes, but a 32-bit Intel chip is capable of supporting PAE. Maybe a better way of putting it is: it is the lowest value of [chip support, OS limit, disk space] . Usually that lowest value is disk space. \u2013 stusmith Jul 7 '11 at 10:30 @stusmith I don't think that ARM, PowerPC, MIPS, or many other CPUs have PAE. Neither do older x86 CPUs. There is no right answer to this poor question. In fact, depending on how you count (for the system, for a process), the answer is different, but still not infinite. Down-vote anyone who says it is infinite. \u2013 artless noise May 30 '14 at 17:47 1 It is also not true that everything must be backed by disk. A large zero initialized array can all be backed by a single page of zeros (typically 4-8k). Any read from any address will show zero. On the first write to a page, a fault happens and then the page is allocated (needs disk or memory) and remapped. This can allow large sparse arrays. \u2013 artless noise Jun 2 '14 at 20:52 The sum of the virtual address spaces of all the processes running at once can be larger than what the 'user pointer' register can address - since the 'process id' is effectively part of the virtual address . In some cases these \"process-unique\" addresses actually point to the same PM (e.g. shared libraries, data shared after fork() ) - but even allowing for that, it's possible for the total amount of truly distinct VM pages to exceed what one process can address. \u2013 greggo Aug 13 '14 at 16:51","title":"A"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Size/Virtual-address-space-size-reading-list/#how#much#memory#can#a#64bit#machine#address#at#a#time","text":"","title":"How much memory can a 64bit machine address at a time?"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/System-call/mmap/","text":"mmap wikipedia mmap man7 mmap(2) \u2014 Linux manual page gnu libc 13.8 Memory-mapped I/O linuxhint How to use mmap function in C language? The mmap() function is used for mapping between a process address space and either files or devices. When a file is mapped to a process address space, the file can be accessed like an array in the program. This is one of the most efficient ways to access data in the file and provides a seamless coding interface that is natural for a data structure that can be assessed without he abstraction of reading and writing from files. In this article, we are going to discuss how to use the mmap() function in Linux. So, let\u2019s get started.","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/System-call/mmap/#mmap","text":"","title":"mmap"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/System-call/mmap/#wikipedia#mmap","text":"","title":"wikipedia mmap"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/System-call/mmap/#man7#mmap2#linux#manual#page","text":"","title":"man7 mmap(2) \u2014 Linux manual page"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/System-call/mmap/#gnu#libc#138#memory-mapped#io","text":"","title":"gnu libc 13.8 Memory-mapped I/O"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/System-call/mmap/#linuxhint#how#to#use#mmap#function#in#c#language","text":"The mmap() function is used for mapping between a process address space and either files or devices. When a file is mapped to a process address space, the file can be accessed like an array in the program. This is one of the most efficient ways to access data in the file and provides a seamless coding interface that is natural for a data structure that can be assessed without he abstraction of reading and writing from files. In this article, we are going to discuss how to use the mmap() function in Linux. So, let\u2019s get started.","title":"linuxhint How to use mmap function in C language?"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/System-call/sbrk/","text":"sbrk \u662f\u5728\u9605\u8bfb wikipedia C dynamic memory allocation # Heap-based \u65f6\uff0c\u53d1\u73b0\u4e86\u5176\u4e2d\u63d0\u53ca\u4e86 sbrk \u3002 man7 brk(2) \u2014 Linux manual page #include <unistd.h> int brk ( void * addr ); void * sbrk ( intptr_t increment ); brk() and sbrk() change the location of the program break , which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment ). Increasing the program break has the effect of allocating memory to the process; decreasing the break deallocates memory. NOTE: \u5173\u4e8e program break\uff0c\u53c2\u89c1 Kernel\\Guide\\Multitasking\\Process-model\\Process-resource\\Process-memory-model\\Linux-implementation\\Program-break \u7ae0\u8282\u3002 \u4e0a\u8ff0 uninitialized data segment \uff0c\u5176\u5b9e\u5c31\u662fbss\u3002 wikipedia sbrk","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/System-call/sbrk/#sbrk","text":"\u662f\u5728\u9605\u8bfb wikipedia C dynamic memory allocation # Heap-based \u65f6\uff0c\u53d1\u73b0\u4e86\u5176\u4e2d\u63d0\u53ca\u4e86 sbrk \u3002","title":"sbrk"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/System-call/sbrk/#man7#brk2#linux#manual#page","text":"#include <unistd.h> int brk ( void * addr ); void * sbrk ( intptr_t increment ); brk() and sbrk() change the location of the program break , which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment ). Increasing the program break has the effect of allocating memory to the process; decreasing the break deallocates memory. NOTE: \u5173\u4e8e program break\uff0c\u53c2\u89c1 Kernel\\Guide\\Multitasking\\Process-model\\Process-resource\\Process-memory-model\\Linux-implementation\\Program-break \u7ae0\u8282\u3002 \u4e0a\u8ff0 uninitialized data segment \uff0c\u5176\u5b9e\u5c31\u662fbss\u3002","title":"man7 brk(2) \u2014 Linux manual page"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/System-call/sbrk/#wikipedia#sbrk","text":"","title":"wikipedia sbrk"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/","text":"\u5173\u4e8e\u672c\u7ae0 \u7f16\u5199\u7a0b\u5e8f\u6765\u8fdb\u884c\u9a8c\u8bc1\u3002","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/#_1","text":"\u7f16\u5199\u7a0b\u5e8f\u6765\u8fdb\u884c\u9a8c\u8bc1\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Output-virtual-memory-space/","text":"\u8f93\u51fa\u5730\u5740\u7a7a\u95f4 \u539f\u6587\u94fe\u63a5\uff1a https://blog.csdn.net/zhongjiekangping/article/details/6910211 #include <stdio.h> #include <stdlib.h> int global_init_a = 1 ; int global_uninit_a ; static int static_global_init_a = 1 ; static int static_global_uninit_a ; const int const_global_a = 1 ; int global_init_b = 1 ; int global_uninit_b ; static int static_global_init_b = 1 ; static int static_global_uninit_b ; const int const_global_b = 1 ; /*\u4e0a\u9762\u5168\u90e8\u4e3a\u5168\u5c40\u53d8\u91cf\uff0cmain\u51fd\u6570\u4e2d\u7684\u4e3a\u5c40\u90e8\u53d8\u91cf*/ int main () { int local_init_a = 1 ; int local_uninit_a ; static int static_local_init_a = 1 ; static int static_local_uninit_a ; const int const_local_a = 1 ; int local_init_b = 1 ; int local_uninit_b ; static int static_local_init_b = 1 ; static int static_local_uninit_b ; const int const_local_b = 1 ; int * malloc_p_a ; malloc_p_a = malloc ( sizeof ( int )); //\u5c06\u4e0a\u9762\u5b9a\u4e49\u7684\u53d8\u91cf\u5168\u90e8\u90fd\u6253\u5370\u51fa\u6765 printf ( \" \\n &global_init_a=%p \\t global_init_a =% d \\ n \",&global_init_a,global_init_a); printf ( \" &global_uninit_a=%p \\t global_uninit_a =% d \\ n \",&global_uninit_a,global_uninit_a); printf ( \" &static_global_init_a=%p \\t static_global_init_a =% d \\ n \",&static_global_init_a,static_global_init_a); printf ( \"&static_global_uninit_a=%p \\t static_global_uninit_a =% d \\ n \",&static_global_uninit_a,static_global_uninit_a); printf ( \" &const_global_a=%p \\t const_global_a =% d \\ n \",&const_global_a,const_global_a); printf ( \" \\n &global_init_b=%p \\t global_init_b =% d \\ n \",&global_init_b,global_init_b); printf ( \" &global_uninit_b=%p \\t global_uninit_b =% d \\ n \",&global_uninit_b,global_uninit_b); printf ( \" &static_global_init_b=%p \\t static_global_init_b =% d \\ n \",&static_global_init_b,static_global_init_b); printf ( \"&static_global_uninit_b=%p \\t static_global_uninit_b =% d \\ n \",&static_global_uninit_b,static_global_uninit_b); printf ( \" &const_global_b=%p \\t const_global_b =% d \\ n \",&const_global_b,const_global_b); printf ( \" \\n &local_init_a=%p \\t local_init_a =% d \\ n \",&local_init_a,local_init_a); printf ( \" &local_uninit_a=%p \\t local_uninit_a =% d \\ n \",&local_uninit_a,local_uninit_a); printf ( \" &static_local_init_a=%p \\t static_local_init_a =% d \\ n \",&static_local_init_a,static_local_init_a); printf ( \" &static_local_uninit_a=%p \\t static_local_uninit_a =% d \\ n \",&static_local_uninit_a,static_local_uninit_a); printf ( \" &const_local_a=%p \\t const_local_a =% d \\ n \",&const_local_a,const_local_a); printf ( \" \\n &local_init_b=%p \\t local_init_b =% d \\ n \",&local_init_b,local_init_b); printf ( \" &local_uninit_b=%p \\t local_uninit_b =% d \\ n \",&local_uninit_b,local_uninit_b); printf ( \" &static_local_init_b=%p \\t static_local_init_b =% d \\ n \",&static_local_init_b,static_local_init_b); printf ( \" &static_local_uninit_b=%p \\t static_local_uninit_b =% d \\ n \",&static_local_uninit_b,static_local_uninit_b); printf ( \" &const_local_b=%p \\t const_local_b =% d \\ n \",&const_local_b,const_local_b); printf ( \" malloc_p_a=%p \\t * malloc_p_a =% d \\ n \",malloc_p_a,*malloc_p_a); return 0 ; } \u4e0b\u9762\u662f\u8f93\u51fa\u7ed3\u679c\u3002 \u5148\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b\u4e0a\u9762\u7684\u8f93\u51fa\u7ed3\u679c\uff0c\u770b\u770b\u80fd\u5f97\u51fa\u4ec0\u4e48\u7ed3\u8bba\u3002\u8c8c\u4f3c\u5f88\u96be\u5206\u6790\u51fa\u6765\u4ec0\u4e48\u7ed3\u679c\u3002\u597d\u4e86\u6211\u4eec\u7ee7\u7eed\u5f80\u4e0b\u770b\u5427\u3002 \u63a5\u4e0b\u6765\uff0c\u901a\u8fc7\u67e5\u770b**proc\u6587\u4ef6\u7cfb\u7edf**\u4e0b\u7684\u6587\u4ef6\uff0c\u770b\u4e00\u4e0b\u8fd9\u4e2a\u8fdb\u7a0b\u7684**\u771f\u5b9e\u5185\u5b58\u5206\u914d\u60c5\u51b5**\u3002\uff08\u6211\u4eec\u9700\u8981\u5728\u7a0b\u5e8f\u7ed3\u675f\u524d\u52a0\u4e00\u4e2a\u6b7b\u5faa\u73af\uff0c\u4e0d\u8ba9\u8fdb\u7a0b\u7ed3\u675f\uff0c\u4ee5\u4fbf\u6211\u4eec\u8fdb\u4e00\u6b65\u5206\u6790\uff09\u3002 \u200b \u5728 return 0 \u524d\uff0c\u589e\u52a0 while(1); \u8bed\u53e5\u3002 \u91cd\u65b0\u7f16\u8bd1\u540e\uff0c\u8fd0\u884c\u7a0b\u5e8f\uff0c\u7a0b\u5e8f\u5c06\u8fdb\u5165\u6b7b\u5faa\u73af\u3002 \u4f7f\u7528ps\u547d\u4ee4\u67e5\u770b\u4e00\u4e0b\u8fdb\u7a0b\u7684pid\u3002 ps -aux | grep a.out \u67e5\u770b /proc/2699/maps \u6587\u4ef6\uff0c\u8fd9\u4e2a\u6587\u4ef6\u663e\u793a\u4e86\u8fdb\u7a0b\u5728\u5185\u5b58\u7a7a\u95f4\u4e2d\u5404\u4e2a\u533a\u57df\u7684\u5206\u914d\u60c5\u51b5\u3002 cat /proc/2699/maps \u4e0a\u9762\u7ea2\u989c\u8272\u6807\u51fa\u7684\u51e0\u4e2a\u533a\u95f4\u662f\u6211\u4eec\u611f\u5174\u8da3\u7684\u533a\u95f4\uff1a 08048000-08049000 r-xp \u8c8c\u4f3c\u662f\u4ee3\u7801\u6bb5 08049000-0804a000 r--p \u6682\u65f6\u4e0d\u6e05\u695a\uff0c\u770b\u4e0d\u51fa\u6765 0804a000-0804b000 rw-p \u8c8c\u4f3c\u4e3a\u6570\u636e\u6bb5 08a7e000-08a9f000 rw-p \u5806 bff73000-bff88000 rw-p \u6808 \u6211\u4eec\u628a\u8fd9\u4e9b\u6570\u636e\u4e0e\u6700\u540e\u4e00\u6b21\u7684\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u679c\u8fdb\u884c\u6bd4\u8f83\uff0c\u770b\u770b\u6709\u4ec0\u4e48\u7ed3\u8bba\u3002 \u200b &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_a=0 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_a=0 \u200b &const_global_a=0x80487c0 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u4ee3\u7801\u6bb5 const_global_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_b=0 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_b=0 \u200b &const_global_b=0x80487c4 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u4ee3\u7801\u6bb5 const_global_b=1 \u200b &local_init_a=0xbff8600c \u5c40\u90e8\u521d\u59cb\u5316\uff1a\u6808 local_init_a=1 \u200b &local_uninit_a=0xbff86008 \u5c40\u90e8\u672a\u521d\u59cb\u5316\uff1a\u6808 local_uninit_a=134514459 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_a=0 \u200b &const_local_a=0xbff86004 \u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff1a\u6808 const_local_a=1 \u200b &local_init_b=0xbff86000 \u5c40\u90e8\u521d\u59cb\u5316\uff1a\u6808 local_init_b=1 \u200b &local_uninit_b=0xbff85ffc \u5c40\u90e8\u672a\u521d\u59cb\u5316\uff1a\u6808 local_uninit_b=-1074241512 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_b=0 \u200b &const_local_b=0xbff85ff8 \u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff1a\u6808 const_local_b=1 \u200b p_chars=0x80487c8 \u5b57\u7b26\u4e32\u5e38\u91cf\uff1a\u4ee3\u7801\u6bb5 p_chars=abcdef \u200b malloc_p_a=0x8a7e008 malloc\u52a8\u6001\u5206\u914d\uff1a\u5806 *malloc_p_a=0 \u901a\u8fc7\u4ee5\u4e0a\u5206\u6790\u6211\u4eec\u6682\u65f6\u53ef\u4ee5\u5f97\u5230\u7684\u7ed3\u8bba\u5982\u4e0b\uff0c \u5728\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u4e2d \uff1a \u6570\u636e\u6bb5**\u4e2d\u5b58\u653e\uff1a**\u5168\u5c40\u53d8\u91cf \uff08\u521d\u59cb\u5316\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff09\u3001 \u9759\u6001\u53d8\u91cf \uff08\u5168\u5c40\u7684\u548c\u5c40\u90e8\u7684\u3001\u521d\u59cb\u5316\u7684\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff09 \u4ee3\u7801\u6bb5\u4e2d\u5b58\u653e\uff1a\u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff08const\uff09\u3001\u5b57\u7b26\u4e32\u5e38\u91cf \u5806\u4e2d\u5b58\u653e\uff1a\u52a8\u6001\u5206\u914d\u7684\u533a\u57df \u6808\u4e2d\u5b58\u653e\uff1a\u5c40\u90e8\u53d8\u91cf\uff08\u521d\u59cb\u5316\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff0c\u4f46\u4e0d\u5305\u542b\u9759\u6001\u53d8\u91cf\uff09\u3001\u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff08const\uff09 \u8fd9\u91cc\u6211\u4eec\u6ca1\u6709\u53d1\u73b0BSS\u6bb5\uff0c\u4f46\u662f\u6211\u4eec\u5c06\u672a\u521d\u59cb\u5316\u7684\u6570\u636e\u6309\u7167\u5730\u5740\u8fdb\u884c\u6392\u5e8f\u770b\u4e00\u4e0b\uff0c\u53ef\u4ee5\u53d1\u73b0\u4e00\u4e2a\u89c4\u5f8b\u3002 &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_a=0 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_b=0 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_a=0 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_b=0 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_b=0 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_a=0 \u200b \u8fd9\u91cc\u53ef\u4ee5\u53d1\u73b0\uff0c \u521d\u59cb\u5316\u7684\u548c\u672a\u521d\u59cb\u5316\u7684\u6570\u636e\u597d\u50cf\u662f\u5206\u5f00\u5b58\u653e\u7684 \uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u731c\u6d4bBSS\u6bb5\u662f\u5b58\u5728\u7684\uff0c\u53ea\u4e0d\u8fc7\u6570\u636e\u6bb5\u662f\u5206\u4e3a\u521d\u59cb\u5316\u548c\u672a\u521d\u59cb\u5316\uff08\u5373BSS\u6bb5\uff09\u7684\u4e24\u90e8\u5206\uff0c\u4ed6\u4eec\u5728\u52a0\u8f7d\u5230\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u65f6\u662f\u5408\u5e76\u4e3a\u6570\u636e\u6bb5\u4e86\uff0c\u5728\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u4e2d\u6ca1\u6709\u5355\u72ec\u5206\u4e3a\u4e00\u4e2a\u533a\u57df\u3002 \u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\uff0c\u9759\u6001\u6570\u636e\u4e0e\u975e\u9759\u6001\u6570\u636e\u662f\u5426\u662f\u5206\u5f00\u5b58\u653e\u7684\u5462\uff1f\u8bf7\u8bfb\u8005\u81ea\u884c\u5206\u6790\u4e00\u4e0b\u3002 \u63a5\u4e0b\u6765\u6211\u4eec\u4ece**\u7a0b\u5e8f\u7684\u89d2\u5ea6**\u770b\u4e00\u4e0b\uff0c\u8fd9\u4e9b\u5b58\u50a8\u533a\u57df\u662f\u5982\u4f55\u5206\u914d\u7684\u3002\u9996\u5148\u6211\u4eec\u5148\u4ecb\u7ecd\u4e00\u4e0bELF\u6587\u4ef6\u683c\u5f0f\u3002 ELF\uff08Executable and Linkable Format \uff09\u6587\u4ef6\u683c\u5f0f\u662f\u4e00\u4e2a\u5f00\u653e\u6807\u51c6\uff0c\u5404\u79cdUNIX\u7cfb\u7edf\u7684\u53ef\u6267\u884c\u6587\u4ef6\u90fd\u91c7\u7528ELF\u683c\u5f0f\uff0c\u5b83\u6709\u4e09\u79cd\u4e0d\u540c\u7684\u7c7b\u578b\uff1a \u2013\u53ef\u91cd\u5b9a\u4f4d\u7684\u76ee\u6807\u6587\u4ef6\uff08Relocatable\uff0c\u6216\u8005Object File\uff09 \u2013\u53ef\u6267\u884c\u6587\u4ef6\uff08Executable\uff09 \u2013\u5171\u4eab\u5e93\uff08Shared Object\uff0c\u6216\u8005Shared Library\uff09 \u4e0b\u56fe\u4e3aELF\u6587\u4ef6\u7684\u7ed3\u6784\u793a\u610f\u56fe\uff08\u6765\u6e90\uff0c\u4e0d\u8be6\uff09\uff1a \u4e00\u4e2a\u7a0b\u5e8f\u7f16\u8bd1\u751f\u6210\u76ee\u6807\u4ee3\u7801\u6587\u4ef6\uff08ELF\u6587\u4ef6\uff09\u7684\u8fc7\u7a0b\u5982\u4e0b\uff0c\u6b64\u56fe\u5f15\u81ea\u300a\u7a0b\u5e8f\u5458\u7684\u81ea\u6211\u4fee\u517b\u300b\u4e00\u4e66\u7684\u4e00\u4e2a\u56fe\uff1a \u53ef\u4ee5\u901a\u8fc7readelf\u547d\u4ee4\u67e5\u770bEFL\u6587\u4ef6\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u4f8b\u5982 readelf -a a.out \uff0c\u6211\u4eec\u53ea\u5173\u5fc3\u5404\u4e2a\u6bb5\u7684\u5206\u914d\u60c5\u51b5\uff0c\u56e0\u6b64\u6211\u4eec\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\uff1a readelf -S a.out \u5c06\u8fd9\u91cc\u7684\u5185\u5b58\u5e03\u5c40\u4e0e\u4e4b\u524d\u770b\u5230\u7684\u7a0b\u5e8f\u7684\u8fd0\u884c\u7ed3\u679c\u8fdb\u884c\u5206\u6790\uff1a \u200b &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 global_uninit_a=0 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_global_uninit_a=0 \u200b &const_global_a=0x80487c0 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u53ea\u8bfb\u6570\u636e\u6bb5 const_global_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 global_uninit_b=0 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_global_uninit_b=0 \u200b &const_global_b=0x80487c4 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u53ea\u8bfb\u6570\u636e\u6bb5 const_global_b=1 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_local_uninit_a=0 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_local_uninit_b=0 \u200b p_chars=0x80487c8 \u5b57\u7b26\u4e32\u5e38\u91cf\uff1a\u53ea\u8bfb\u6570\u636e\u6bb5 p_chars=abcdef ELF \u6587\u4ef6\u4e00\u822c\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6bb5 : .text section\uff1a\u4e3b\u8981\u662f\u7f16\u8bd1\u540e\u7684\u6e90\u7801\u6307\u4ee4\uff0c\u662f\u53ea\u8bfb\u5b57\u6bb5\u3002 .data section \uff1a\u521d\u59cb\u5316\u540e\u7684\u975econst\u7684\u5168\u5c40\u53d8\u91cf\u3001\u5c40\u90e8static\u53d8\u91cf\u3002 .bss\uff1a\u672a\u521d\u59cb\u5316\u540e\u7684\u975econst\u5168\u5c40\u53d8\u91cf\u3001\u5c40\u90e8static\u53d8\u91cf\u3002 **.rodata\u5b57\u6bb5 \u662f\u5b58\u653e\u53ea\u8bfb\u6570\u636e ** \u5206\u6790\u5230\u8fd9\u4ee5\u540e\uff0c\u6211\u4eec\u5728\u548c\u4e4b\u524d\u5206\u6790\u7684\u7ed3\u679c\u5bf9\u6bd4\u4e00\u4e0b\uff0c \u4f1a\u53d1\u73b0\u786e\u5b9e\u5b58\u5728BSS\u6bb5 \uff0c\u5730\u5740\u4e3a0804a030 \uff0c\u5927\u5c0f\u4e3a0x20\uff0c\u4e4b\u524d\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u672a\u521d\u59cb\u5316\u7684\u7684\u786e\u5b58\u653e\u5728\u8fd9\u4e2a\u5730\u5740\u533a\u95f4\u4e2d\u4e86\uff0c\u53ea\u4e0d\u8fc7\u6267\u884cexec\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u5c06\u8fd9\u90e8\u5206\u7684\u6570\u636e\u521d\u59cb\u5316\u4e3a0\u540e\uff0c\u653e\u5230\u4e86\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u7684\u6570\u636e\u6bb5\u4e2d\u4e86\uff0c\u5728\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u4e2d\u5c31\u6ca1\u6709\u5fc5\u8981\u5b58\u5728BSS\u6bb5\u4e86\uff0c\u56e0\u6b64\u90fd\u79f0\u505a\u6570\u636e\u6bb5\u3002\u540c\u7406\uff0c.rodata\u5b57\u6bb5\u4e5f\u662f\u4e0etext\u6bb5\u653e\u5728\u4e00\u8d77\u4e86\u3002 \u5728ELF\u6587\u4ef6\u4e2d\uff0c\u627e\u4e0d\u5230\u5c40\u90e8\u975e\u9759\u6001\u53d8\u91cf\u548c\u52a8\u6001\u5206\u914d\u7684\u5185\u5bb9\u3002","title":"Output-virtual-memory-space"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Output-virtual-memory-space/#_1","text":"\u539f\u6587\u94fe\u63a5\uff1a https://blog.csdn.net/zhongjiekangping/article/details/6910211 #include <stdio.h> #include <stdlib.h> int global_init_a = 1 ; int global_uninit_a ; static int static_global_init_a = 1 ; static int static_global_uninit_a ; const int const_global_a = 1 ; int global_init_b = 1 ; int global_uninit_b ; static int static_global_init_b = 1 ; static int static_global_uninit_b ; const int const_global_b = 1 ; /*\u4e0a\u9762\u5168\u90e8\u4e3a\u5168\u5c40\u53d8\u91cf\uff0cmain\u51fd\u6570\u4e2d\u7684\u4e3a\u5c40\u90e8\u53d8\u91cf*/ int main () { int local_init_a = 1 ; int local_uninit_a ; static int static_local_init_a = 1 ; static int static_local_uninit_a ; const int const_local_a = 1 ; int local_init_b = 1 ; int local_uninit_b ; static int static_local_init_b = 1 ; static int static_local_uninit_b ; const int const_local_b = 1 ; int * malloc_p_a ; malloc_p_a = malloc ( sizeof ( int )); //\u5c06\u4e0a\u9762\u5b9a\u4e49\u7684\u53d8\u91cf\u5168\u90e8\u90fd\u6253\u5370\u51fa\u6765 printf ( \" \\n &global_init_a=%p \\t global_init_a =% d \\ n \",&global_init_a,global_init_a); printf ( \" &global_uninit_a=%p \\t global_uninit_a =% d \\ n \",&global_uninit_a,global_uninit_a); printf ( \" &static_global_init_a=%p \\t static_global_init_a =% d \\ n \",&static_global_init_a,static_global_init_a); printf ( \"&static_global_uninit_a=%p \\t static_global_uninit_a =% d \\ n \",&static_global_uninit_a,static_global_uninit_a); printf ( \" &const_global_a=%p \\t const_global_a =% d \\ n \",&const_global_a,const_global_a); printf ( \" \\n &global_init_b=%p \\t global_init_b =% d \\ n \",&global_init_b,global_init_b); printf ( \" &global_uninit_b=%p \\t global_uninit_b =% d \\ n \",&global_uninit_b,global_uninit_b); printf ( \" &static_global_init_b=%p \\t static_global_init_b =% d \\ n \",&static_global_init_b,static_global_init_b); printf ( \"&static_global_uninit_b=%p \\t static_global_uninit_b =% d \\ n \",&static_global_uninit_b,static_global_uninit_b); printf ( \" &const_global_b=%p \\t const_global_b =% d \\ n \",&const_global_b,const_global_b); printf ( \" \\n &local_init_a=%p \\t local_init_a =% d \\ n \",&local_init_a,local_init_a); printf ( \" &local_uninit_a=%p \\t local_uninit_a =% d \\ n \",&local_uninit_a,local_uninit_a); printf ( \" &static_local_init_a=%p \\t static_local_init_a =% d \\ n \",&static_local_init_a,static_local_init_a); printf ( \" &static_local_uninit_a=%p \\t static_local_uninit_a =% d \\ n \",&static_local_uninit_a,static_local_uninit_a); printf ( \" &const_local_a=%p \\t const_local_a =% d \\ n \",&const_local_a,const_local_a); printf ( \" \\n &local_init_b=%p \\t local_init_b =% d \\ n \",&local_init_b,local_init_b); printf ( \" &local_uninit_b=%p \\t local_uninit_b =% d \\ n \",&local_uninit_b,local_uninit_b); printf ( \" &static_local_init_b=%p \\t static_local_init_b =% d \\ n \",&static_local_init_b,static_local_init_b); printf ( \" &static_local_uninit_b=%p \\t static_local_uninit_b =% d \\ n \",&static_local_uninit_b,static_local_uninit_b); printf ( \" &const_local_b=%p \\t const_local_b =% d \\ n \",&const_local_b,const_local_b); printf ( \" malloc_p_a=%p \\t * malloc_p_a =% d \\ n \",malloc_p_a,*malloc_p_a); return 0 ; } \u4e0b\u9762\u662f\u8f93\u51fa\u7ed3\u679c\u3002 \u5148\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b\u4e0a\u9762\u7684\u8f93\u51fa\u7ed3\u679c\uff0c\u770b\u770b\u80fd\u5f97\u51fa\u4ec0\u4e48\u7ed3\u8bba\u3002\u8c8c\u4f3c\u5f88\u96be\u5206\u6790\u51fa\u6765\u4ec0\u4e48\u7ed3\u679c\u3002\u597d\u4e86\u6211\u4eec\u7ee7\u7eed\u5f80\u4e0b\u770b\u5427\u3002 \u63a5\u4e0b\u6765\uff0c\u901a\u8fc7\u67e5\u770b**proc\u6587\u4ef6\u7cfb\u7edf**\u4e0b\u7684\u6587\u4ef6\uff0c\u770b\u4e00\u4e0b\u8fd9\u4e2a\u8fdb\u7a0b\u7684**\u771f\u5b9e\u5185\u5b58\u5206\u914d\u60c5\u51b5**\u3002\uff08\u6211\u4eec\u9700\u8981\u5728\u7a0b\u5e8f\u7ed3\u675f\u524d\u52a0\u4e00\u4e2a\u6b7b\u5faa\u73af\uff0c\u4e0d\u8ba9\u8fdb\u7a0b\u7ed3\u675f\uff0c\u4ee5\u4fbf\u6211\u4eec\u8fdb\u4e00\u6b65\u5206\u6790\uff09\u3002 \u200b \u5728 return 0 \u524d\uff0c\u589e\u52a0 while(1); \u8bed\u53e5\u3002 \u91cd\u65b0\u7f16\u8bd1\u540e\uff0c\u8fd0\u884c\u7a0b\u5e8f\uff0c\u7a0b\u5e8f\u5c06\u8fdb\u5165\u6b7b\u5faa\u73af\u3002 \u4f7f\u7528ps\u547d\u4ee4\u67e5\u770b\u4e00\u4e0b\u8fdb\u7a0b\u7684pid\u3002 ps -aux | grep a.out \u67e5\u770b /proc/2699/maps \u6587\u4ef6\uff0c\u8fd9\u4e2a\u6587\u4ef6\u663e\u793a\u4e86\u8fdb\u7a0b\u5728\u5185\u5b58\u7a7a\u95f4\u4e2d\u5404\u4e2a\u533a\u57df\u7684\u5206\u914d\u60c5\u51b5\u3002 cat /proc/2699/maps \u4e0a\u9762\u7ea2\u989c\u8272\u6807\u51fa\u7684\u51e0\u4e2a\u533a\u95f4\u662f\u6211\u4eec\u611f\u5174\u8da3\u7684\u533a\u95f4\uff1a 08048000-08049000 r-xp \u8c8c\u4f3c\u662f\u4ee3\u7801\u6bb5 08049000-0804a000 r--p \u6682\u65f6\u4e0d\u6e05\u695a\uff0c\u770b\u4e0d\u51fa\u6765 0804a000-0804b000 rw-p \u8c8c\u4f3c\u4e3a\u6570\u636e\u6bb5 08a7e000-08a9f000 rw-p \u5806 bff73000-bff88000 rw-p \u6808 \u6211\u4eec\u628a\u8fd9\u4e9b\u6570\u636e\u4e0e\u6700\u540e\u4e00\u6b21\u7684\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u679c\u8fdb\u884c\u6bd4\u8f83\uff0c\u770b\u770b\u6709\u4ec0\u4e48\u7ed3\u8bba\u3002 \u200b &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_a=0 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_a=0 \u200b &const_global_a=0x80487c0 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u4ee3\u7801\u6bb5 const_global_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_b=0 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_b=0 \u200b &const_global_b=0x80487c4 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u4ee3\u7801\u6bb5 const_global_b=1 \u200b &local_init_a=0xbff8600c \u5c40\u90e8\u521d\u59cb\u5316\uff1a\u6808 local_init_a=1 \u200b &local_uninit_a=0xbff86008 \u5c40\u90e8\u672a\u521d\u59cb\u5316\uff1a\u6808 local_uninit_a=134514459 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_a=0 \u200b &const_local_a=0xbff86004 \u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff1a\u6808 const_local_a=1 \u200b &local_init_b=0xbff86000 \u5c40\u90e8\u521d\u59cb\u5316\uff1a\u6808 local_init_b=1 \u200b &local_uninit_b=0xbff85ffc \u5c40\u90e8\u672a\u521d\u59cb\u5316\uff1a\u6808 local_uninit_b=-1074241512 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_b=0 \u200b &const_local_b=0xbff85ff8 \u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff1a\u6808 const_local_b=1 \u200b p_chars=0x80487c8 \u5b57\u7b26\u4e32\u5e38\u91cf\uff1a\u4ee3\u7801\u6bb5 p_chars=abcdef \u200b malloc_p_a=0x8a7e008 malloc\u52a8\u6001\u5206\u914d\uff1a\u5806 *malloc_p_a=0 \u901a\u8fc7\u4ee5\u4e0a\u5206\u6790\u6211\u4eec\u6682\u65f6\u53ef\u4ee5\u5f97\u5230\u7684\u7ed3\u8bba\u5982\u4e0b\uff0c \u5728\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u4e2d \uff1a \u6570\u636e\u6bb5**\u4e2d\u5b58\u653e\uff1a**\u5168\u5c40\u53d8\u91cf \uff08\u521d\u59cb\u5316\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff09\u3001 \u9759\u6001\u53d8\u91cf \uff08\u5168\u5c40\u7684\u548c\u5c40\u90e8\u7684\u3001\u521d\u59cb\u5316\u7684\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff09 \u4ee3\u7801\u6bb5\u4e2d\u5b58\u653e\uff1a\u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff08const\uff09\u3001\u5b57\u7b26\u4e32\u5e38\u91cf \u5806\u4e2d\u5b58\u653e\uff1a\u52a8\u6001\u5206\u914d\u7684\u533a\u57df \u6808\u4e2d\u5b58\u653e\uff1a\u5c40\u90e8\u53d8\u91cf\uff08\u521d\u59cb\u5316\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff0c\u4f46\u4e0d\u5305\u542b\u9759\u6001\u53d8\u91cf\uff09\u3001\u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff08const\uff09 \u8fd9\u91cc\u6211\u4eec\u6ca1\u6709\u53d1\u73b0BSS\u6bb5\uff0c\u4f46\u662f\u6211\u4eec\u5c06\u672a\u521d\u59cb\u5316\u7684\u6570\u636e\u6309\u7167\u5730\u5740\u8fdb\u884c\u6392\u5e8f\u770b\u4e00\u4e0b\uff0c\u53ef\u4ee5\u53d1\u73b0\u4e00\u4e2a\u89c4\u5f8b\u3002 &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_a=0 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_b=0 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_a=0 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_b=0 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_b=0 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_a=0 \u200b \u8fd9\u91cc\u53ef\u4ee5\u53d1\u73b0\uff0c \u521d\u59cb\u5316\u7684\u548c\u672a\u521d\u59cb\u5316\u7684\u6570\u636e\u597d\u50cf\u662f\u5206\u5f00\u5b58\u653e\u7684 \uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u731c\u6d4bBSS\u6bb5\u662f\u5b58\u5728\u7684\uff0c\u53ea\u4e0d\u8fc7\u6570\u636e\u6bb5\u662f\u5206\u4e3a\u521d\u59cb\u5316\u548c\u672a\u521d\u59cb\u5316\uff08\u5373BSS\u6bb5\uff09\u7684\u4e24\u90e8\u5206\uff0c\u4ed6\u4eec\u5728\u52a0\u8f7d\u5230\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u65f6\u662f\u5408\u5e76\u4e3a\u6570\u636e\u6bb5\u4e86\uff0c\u5728\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u4e2d\u6ca1\u6709\u5355\u72ec\u5206\u4e3a\u4e00\u4e2a\u533a\u57df\u3002 \u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\uff0c\u9759\u6001\u6570\u636e\u4e0e\u975e\u9759\u6001\u6570\u636e\u662f\u5426\u662f\u5206\u5f00\u5b58\u653e\u7684\u5462\uff1f\u8bf7\u8bfb\u8005\u81ea\u884c\u5206\u6790\u4e00\u4e0b\u3002 \u63a5\u4e0b\u6765\u6211\u4eec\u4ece**\u7a0b\u5e8f\u7684\u89d2\u5ea6**\u770b\u4e00\u4e0b\uff0c\u8fd9\u4e9b\u5b58\u50a8\u533a\u57df\u662f\u5982\u4f55\u5206\u914d\u7684\u3002\u9996\u5148\u6211\u4eec\u5148\u4ecb\u7ecd\u4e00\u4e0bELF\u6587\u4ef6\u683c\u5f0f\u3002 ELF\uff08Executable and Linkable Format \uff09\u6587\u4ef6\u683c\u5f0f\u662f\u4e00\u4e2a\u5f00\u653e\u6807\u51c6\uff0c\u5404\u79cdUNIX\u7cfb\u7edf\u7684\u53ef\u6267\u884c\u6587\u4ef6\u90fd\u91c7\u7528ELF\u683c\u5f0f\uff0c\u5b83\u6709\u4e09\u79cd\u4e0d\u540c\u7684\u7c7b\u578b\uff1a \u2013\u53ef\u91cd\u5b9a\u4f4d\u7684\u76ee\u6807\u6587\u4ef6\uff08Relocatable\uff0c\u6216\u8005Object File\uff09 \u2013\u53ef\u6267\u884c\u6587\u4ef6\uff08Executable\uff09 \u2013\u5171\u4eab\u5e93\uff08Shared Object\uff0c\u6216\u8005Shared Library\uff09 \u4e0b\u56fe\u4e3aELF\u6587\u4ef6\u7684\u7ed3\u6784\u793a\u610f\u56fe\uff08\u6765\u6e90\uff0c\u4e0d\u8be6\uff09\uff1a \u4e00\u4e2a\u7a0b\u5e8f\u7f16\u8bd1\u751f\u6210\u76ee\u6807\u4ee3\u7801\u6587\u4ef6\uff08ELF\u6587\u4ef6\uff09\u7684\u8fc7\u7a0b\u5982\u4e0b\uff0c\u6b64\u56fe\u5f15\u81ea\u300a\u7a0b\u5e8f\u5458\u7684\u81ea\u6211\u4fee\u517b\u300b\u4e00\u4e66\u7684\u4e00\u4e2a\u56fe\uff1a \u53ef\u4ee5\u901a\u8fc7readelf\u547d\u4ee4\u67e5\u770bEFL\u6587\u4ef6\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u4f8b\u5982 readelf -a a.out \uff0c\u6211\u4eec\u53ea\u5173\u5fc3\u5404\u4e2a\u6bb5\u7684\u5206\u914d\u60c5\u51b5\uff0c\u56e0\u6b64\u6211\u4eec\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\uff1a readelf -S a.out \u5c06\u8fd9\u91cc\u7684\u5185\u5b58\u5e03\u5c40\u4e0e\u4e4b\u524d\u770b\u5230\u7684\u7a0b\u5e8f\u7684\u8fd0\u884c\u7ed3\u679c\u8fdb\u884c\u5206\u6790\uff1a \u200b &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 global_uninit_a=0 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_global_uninit_a=0 \u200b &const_global_a=0x80487c0 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u53ea\u8bfb\u6570\u636e\u6bb5 const_global_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 global_uninit_b=0 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_global_uninit_b=0 \u200b &const_global_b=0x80487c4 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u53ea\u8bfb\u6570\u636e\u6bb5 const_global_b=1 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_local_uninit_a=0 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_local_uninit_b=0 \u200b p_chars=0x80487c8 \u5b57\u7b26\u4e32\u5e38\u91cf\uff1a\u53ea\u8bfb\u6570\u636e\u6bb5 p_chars=abcdef ELF \u6587\u4ef6\u4e00\u822c\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6bb5 : .text section\uff1a\u4e3b\u8981\u662f\u7f16\u8bd1\u540e\u7684\u6e90\u7801\u6307\u4ee4\uff0c\u662f\u53ea\u8bfb\u5b57\u6bb5\u3002 .data section \uff1a\u521d\u59cb\u5316\u540e\u7684\u975econst\u7684\u5168\u5c40\u53d8\u91cf\u3001\u5c40\u90e8static\u53d8\u91cf\u3002 .bss\uff1a\u672a\u521d\u59cb\u5316\u540e\u7684\u975econst\u5168\u5c40\u53d8\u91cf\u3001\u5c40\u90e8static\u53d8\u91cf\u3002 **.rodata\u5b57\u6bb5 \u662f\u5b58\u653e\u53ea\u8bfb\u6570\u636e ** \u5206\u6790\u5230\u8fd9\u4ee5\u540e\uff0c\u6211\u4eec\u5728\u548c\u4e4b\u524d\u5206\u6790\u7684\u7ed3\u679c\u5bf9\u6bd4\u4e00\u4e0b\uff0c \u4f1a\u53d1\u73b0\u786e\u5b9e\u5b58\u5728BSS\u6bb5 \uff0c\u5730\u5740\u4e3a0804a030 \uff0c\u5927\u5c0f\u4e3a0x20\uff0c\u4e4b\u524d\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u672a\u521d\u59cb\u5316\u7684\u7684\u786e\u5b58\u653e\u5728\u8fd9\u4e2a\u5730\u5740\u533a\u95f4\u4e2d\u4e86\uff0c\u53ea\u4e0d\u8fc7\u6267\u884cexec\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u5c06\u8fd9\u90e8\u5206\u7684\u6570\u636e\u521d\u59cb\u5316\u4e3a0\u540e\uff0c\u653e\u5230\u4e86\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u7684\u6570\u636e\u6bb5\u4e2d\u4e86\uff0c\u5728\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u4e2d\u5c31\u6ca1\u6709\u5fc5\u8981\u5b58\u5728BSS\u6bb5\u4e86\uff0c\u56e0\u6b64\u90fd\u79f0\u505a\u6570\u636e\u6bb5\u3002\u540c\u7406\uff0c.rodata\u5b57\u6bb5\u4e5f\u662f\u4e0etext\u6bb5\u653e\u5728\u4e00\u8d77\u4e86\u3002 \u5728ELF\u6587\u4ef6\u4e2d\uff0c\u627e\u4e0d\u5230\u5c40\u90e8\u975e\u9759\u6001\u53d8\u91cf\u548c\u52a8\u6001\u5206\u914d\u7684\u5185\u5bb9\u3002","title":"\u8f93\u51fa\u5730\u5740\u7a7a\u95f4"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/","text":"\u5173\u4e8e\u672c\u7ae0 \u7f16\u5199\u7a0b\u5e8f\u6765\u8fdb\u884c\u9a8c\u8bc1\u3002 holbertonschool Code review: string concatenation in C holbertonschool Hack the virtual memory: the stack, registers and assembly code \u53c2\u89c1 ./The-stack-registers-and-assembly-code \u7ae0\u8282\u3002","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/#_1","text":"\u7f16\u5199\u7a0b\u5e8f\u6765\u8fdb\u884c\u9a8c\u8bc1\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/#holbertonschool#code#review#string#concatenation#in#c","text":"","title":"holbertonschool Code review: string concatenation in C"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/#holbertonschool#hack#the#virtual#memory#the#stack#registers#and#assembly#code","text":"\u53c2\u89c1 ./The-stack-registers-and-assembly-code \u7ae0\u8282\u3002","title":"holbertonschool Hack the virtual memory: the stack, registers and assembly code"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/Chapter-0-C-strings%26proc-filesystem/","text":"Chapter 0: Hack The Virtual Memory: C strings & /proc","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/Chapter-0-C-strings%26proc-filesystem/#chapter#0#hack#the#virtual#memory#c#strings#proc","text":"","title":"Chapter 0: Hack The Virtual Memory: C strings &amp; /proc"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/Chapter-2-Drawing-the-VM-diagram/","text":"Chapter 2: Hack The Virtual Memory: Drawing the VM diagram","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/Chapter-2-Drawing-the-VM-diagram/#chapter#2#hack#the#virtual#memory#drawing#the#vm#diagram","text":"","title":"Chapter 2: Hack The Virtual Memory: Drawing the VM diagram"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/Chapter-3-malloc-the-heap%26the-program-break/","text":"Chapter 3: Hack the Virtual Memory: malloc, the heap & the program break This is the fourth chapter in a series around virtual memory. The goal is to learn some CS basics, but in a different and more practical way. The heap In this chapter we will look at the heap and malloc in order to answer some of the questions we ended with at the end of the previous chapter : Why doesn\u2019t our allocated memory start at the very beginning of the heap ( 0x2050010 vs 02050000 )? What are those first 16 bytes used for? Is the heap actually growing upwards? strace , brk and sbrk malloc is a \u201cregular\u201d function (as opposed to a system call), so it must call some kind of syscall in order to manipulate the heap. Let\u2019s use strace to find out. strace is a program used to trace system calls and signals. Any program will always use a few syscalls before your main function is executed. In order to know which syscalls are used by malloc , we will add a write syscall before and after the call to malloc ( 3-main.c ). #include <stdio.h> #include <stdlib.h> #include <unistd.h> /** * main - let's find out which syscall malloc is using * * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS */ int main ( void ) { void * p ; write ( 1 , \"BEFORE MALLOC \\n \" , 14 ); p = malloc ( 1 ); write ( 1 , \"AFTER MALLOC \\n \" , 13 ); printf ( \"%p \\n \" , p ); getchar (); return ( EXIT_SUCCESS ); } julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 3-main.c -o 3 julien@holberton:~/holberton/w/hackthevm3$ strace ./3 execve(\"./3\", [\"./3\"], [/* 61 vars */]) = 0 ... write(1, \"BEFORE MALLOC\\n\", 14BEFORE MALLOC ) = 14 brk(0) = 0xe70000 brk(0xe91000) = 0xe91000 write(1, \"AFTER MALLOC\\n\", 13AFTER MALLOC ) = 13 ... read(0, From the above listing we can focus on this: brk(0) = 0xe70000 brk(0xe91000) = 0xe91000 -> malloc is using the brk system call in order to manipulate the heap. From brk man page ( man brk ), we can see what this system call is doing: ... int brk(void *addr); void *sbrk(intptr_t increment); ... DESCRIPTION brk() and sbrk() change the location of the program break, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment). Increasing the program break has the effect of allocating memory to the process; decreas\u2010 ing the break deallocates memory. brk() sets the end of the data segment to the value specified by addr, when that value is reasonable, the system has enough memory, and the process does not exceed its maximum data size (see setrlimit(2)). sbrk() increments the program's data space by increment bytes. Calling sbrk() with an increment of 0 can be used to find the current location of the program break. The program break is the address of the first location beyond the current end of the data region of the program in the virual memory. NOTE: \u5173\u4e8edata region\uff0c\u53c2\u89c1 Kernel\\Guide\\Multitasking\\Process-model\\Process-resource\\Process-memory-model\\Virtual-address-space \uff0c\u5176\u4e2d\u63f4\u5f15\u4e86 wikipedia Memory address # Contents of each memory location \u4e2d\u7684\u5185\u5bb9: In modern multitasking environment, an application process usually has in its address space (or spaces) chunks of memory of following types: 1) Machine code , including: program's own code (historically known as code segment or text segment ); shared libraries . 2) Data , including: initialized data ( data segment ); uninitialized (but allocated) variables; run-time stack ; heap ; shared memory and memory mapped files . \u663e\u7136\u4e0a\u8ff0 data region \u548c wikipedia Memory address # Contents of each memory location \u4e2d\u76842) Data \u4e0d\u662f\u540c\u4e00\u4e2a\u6982\u5ff5\uff0c\u5b83\u6240\u6307\u4e3a data segment \u3002 By increasing the value of the program break , via brk or sbrk , the function malloc creates a new space that can then be used by the process to dynamically allocate memory (using malloc ). So the heap is actually an extension of the data segment of the program. NOTE: \u8fd9\u6bb5\u8bdd\u603b\u7ed3\u4e86heap\u548cdata segment\u4e4b\u95f4\u7684\u5173\u8054 The first call to brk ( brk(0) ) returns the current address of the program break to malloc . And the second call is the one that actually creates new memory (since 0xe91000 > 0xe70000 ) by increasing the value of the program break . In the above example, the heap is now starting at 0xe70000 and ends at 0xe91000 . Let\u2019s double check with the /proc/[PID]/maps file: julien@holberton:/proc/3855$ ps aux | grep \\ \\./3$ julien 4011 0.0 0.0 4748 708 pts/9 S+ 13:04 0:00 strace ./3 julien 4014 0.0 0.0 4336 644 pts/9 S+ 13:04 0:00 ./3 julien@holberton:/proc/3855$ cd /proc/4014 julien@holberton:/proc/4014$ cat maps 00400000-00401000 r-xp 00000000 08:01 176967 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3 00600000-00601000 r--p 00000000 08:01 176967 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3 00601000-00602000 rw-p 00001000 08:01 176967 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3 00e70000-00e91000 rw-p 00000000 00:00 0 [heap] ... julien@holberton:/proc/4014$ -> 00e70000-00e91000 rw-p 00000000 00:00 0 [heap] matches the pointers returned back to malloc by brk . That\u2019s great, but wait, why did malloc increment the heap by 00e91000 \u2013 00e70000 = 0x21000 or 135168 bytes, when we only asked for only 1 byte? Many mallocs What will happen if we call malloc several times? ( 4-main.c ) #include <stdio.h> #include <stdlib.h> #include <unistd.h> /** * main - many calls to malloc * * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS */ int main ( void ) { void * p ; write ( 1 , \"BEFORE MALLOC #0 \\n \" , 17 ); p = malloc ( 1024 ); write ( 1 , \"AFTER MALLOC #0 \\n \" , 16 ); printf ( \"%p \\n \" , p ); write ( 1 , \"BEFORE MALLOC #1 \\n \" , 17 ); p = malloc ( 1024 ); write ( 1 , \"AFTER MALLOC #1 \\n \" , 16 ); printf ( \"%p \\n \" , p ); write ( 1 , \"BEFORE MALLOC #2 \\n \" , 17 ); p = malloc ( 1024 ); write ( 1 , \"AFTER MALLOC #2 \\n \" , 16 ); printf ( \"%p \\n \" , p ); write ( 1 , \"BEFORE MALLOC #3 \\n \" , 17 ); p = malloc ( 1024 ); write ( 1 , \"AFTER MALLOC #3 \\n \" , 16 ); printf ( \"%p \\n \" , p ); getchar (); return ( EXIT_SUCCESS ); } julien @ holberton : ~/ holberton / w / hackthevm3$ gcc - Wall - Wextra - pedantic - Werror 4 - main . c - o 4 julien @ holberton : ~/ holberton / w / hackthevm3$ strace . / 4 execve ( \"./4\" , [ \"./4\" ], [ /* 61 vars */ ]) = 0 ... write ( 1 , \"BEFORE MALLOC #0 \\n \" , 17 BEFORE MALLOC # 0 ) = 17 brk ( 0 ) = 0x1314000 brk ( 0x1335000 ) = 0x1335000 write ( 1 , \"AFTER MALLOC #0 \\n \" , 16 AFTER MALLOC # 0 ) = 16 ... write ( 1 , \"0x1314010 \\n \" , 100 x1314010 ) = 10 write ( 1 , \"BEFORE MALLOC #1 \\n \" , 17 BEFORE MALLOC # 1 ) = 17 write ( 1 , \"AFTER MALLOC #1 \\n \" , 16 AFTER MALLOC # 1 ) = 16 write ( 1 , \"0x1314420 \\n \" , 100 x1314420 ) = 10 write ( 1 , \"BEFORE MALLOC #2 \\n \" , 17 BEFORE MALLOC # 2 ) = 17 write ( 1 , \"AFTER MALLOC #2 \\n \" , 16 AFTER MALLOC # 2 ) = 16 write ( 1 , \"0x1314830 \\n \" , 100 x1314830 ) = 10 write ( 1 , \"BEFORE MALLOC #3 \\n \" , 17 BEFORE MALLOC # 3 ) = 17 write ( 1 , \"AFTER MALLOC #3 \\n \" , 16 AFTER MALLOC # 3 ) = 16 write ( 1 , \"0x1314c40 \\n \" , 100 x1314c40 ) = 10 ... read ( 0 , -> malloc is NOT calling brk each time we call it. The first time, malloc creates a new space (the heap) for the program (by increasing the program break location). The following times, malloc uses the same space to give our program \u201cnew\u201d chunks of memory. Those \u201cnew\u201d chunks of memory are part of the memory previously allocated using brk . This way, malloc doesn\u2019t have to use syscalls ( brk ) every time we call it, and thus it makes malloc \u2013 and our programs using malloc \u2013 faster. It also allows malloc and free to optimize the usage of the memory. Let\u2019s double check that we have only one heap, allocated by the first call to brk : julien@holberton:/proc/4014$ ps aux | grep \\ \\./4$ julien 4169 0.0 0.0 4748 688 pts/9 S+ 13:33 0:00 strace ./4 julien 4172 0.0 0.0 4336 656 pts/9 S+ 13:33 0:00 ./4 julien@holberton:/proc/4014$ cd /proc/4172 julien@holberton:/proc/4172$ cat maps 00400000-00401000 r-xp 00000000 08:01 176973 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4 00600000-00601000 r--p 00000000 08:01 176973 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4 00601000-00602000 rw-p 00001000 08:01 176973 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4 01314000-01335000 rw-p 00000000 00:00 0 [heap] 7f4a3f2c4000-7f4a3f47e000 r-xp 00000000 08:01 136253 /lib/x86_64-linux-gnu/libc-2.19.so 7f4a3f47e000-7f4a3f67e000 ---p 001ba000 08:01 136253 /lib/x86_64-linux-gnu/libc-2.19.so 7f4a3f67e000-7f4a3f682000 r--p 001ba000 08:01 136253 /lib/x86_64-linux-gnu/libc-2.19.so 7f4a3f682000-7f4a3f684000 rw-p 001be000 08:01 136253 /lib/x86_64-linux-gnu/libc-2.19.so 7f4a3f684000-7f4a3f689000 rw-p 00000000 00:00 0 7f4a3f689000-7f4a3f6ac000 r-xp 00000000 08:01 136229 /lib/x86_64-linux-gnu/ld-2.19.so 7f4a3f890000-7f4a3f893000 rw-p 00000000 00:00 0 7f4a3f8a7000-7f4a3f8ab000 rw-p 00000000 00:00 0 7f4a3f8ab000-7f4a3f8ac000 r--p 00022000 08:01 136229 /lib/x86_64-linux-gnu/ld-2.19.so 7f4a3f8ac000-7f4a3f8ad000 rw-p 00023000 08:01 136229 /lib/x86_64-linux-gnu/ld-2.19.so 7f4a3f8ad000-7f4a3f8ae000 rw-p 00000000 00:00 0 7ffd1ba73000-7ffd1ba94000 rw-p 00000000 00:00 0 [stack] 7ffd1bbed000-7ffd1bbef000 r--p 00000000 00:00 0 [vvar] 7ffd1bbef000-7ffd1bbf1000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] julien@holberton:/proc/4172$ -> We have only one [heap] and the addresses match those returned by sbrk : 0x1314000 & 0x1335000","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/Chapter-3-malloc-the-heap%26the-program-break/#chapter#3#hack#the#virtual#memory#malloc#the#heap#the#program#break","text":"This is the fourth chapter in a series around virtual memory. The goal is to learn some CS basics, but in a different and more practical way.","title":"Chapter 3: Hack the Virtual Memory: malloc, the heap &amp; the program break"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/Chapter-3-malloc-the-heap%26the-program-break/#the#heap","text":"In this chapter we will look at the heap and malloc in order to answer some of the questions we ended with at the end of the previous chapter : Why doesn\u2019t our allocated memory start at the very beginning of the heap ( 0x2050010 vs 02050000 )? What are those first 16 bytes used for? Is the heap actually growing upwards?","title":"The heap"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/Chapter-3-malloc-the-heap%26the-program-break/#strace#brk#and#sbrk","text":"malloc is a \u201cregular\u201d function (as opposed to a system call), so it must call some kind of syscall in order to manipulate the heap. Let\u2019s use strace to find out. strace is a program used to trace system calls and signals. Any program will always use a few syscalls before your main function is executed. In order to know which syscalls are used by malloc , we will add a write syscall before and after the call to malloc ( 3-main.c ). #include <stdio.h> #include <stdlib.h> #include <unistd.h> /** * main - let's find out which syscall malloc is using * * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS */ int main ( void ) { void * p ; write ( 1 , \"BEFORE MALLOC \\n \" , 14 ); p = malloc ( 1 ); write ( 1 , \"AFTER MALLOC \\n \" , 13 ); printf ( \"%p \\n \" , p ); getchar (); return ( EXIT_SUCCESS ); } julien@holberton:~/holberton/w/hackthevm3$ gcc -Wall -Wextra -pedantic -Werror 3-main.c -o 3 julien@holberton:~/holberton/w/hackthevm3$ strace ./3 execve(\"./3\", [\"./3\"], [/* 61 vars */]) = 0 ... write(1, \"BEFORE MALLOC\\n\", 14BEFORE MALLOC ) = 14 brk(0) = 0xe70000 brk(0xe91000) = 0xe91000 write(1, \"AFTER MALLOC\\n\", 13AFTER MALLOC ) = 13 ... read(0, From the above listing we can focus on this: brk(0) = 0xe70000 brk(0xe91000) = 0xe91000 -> malloc is using the brk system call in order to manipulate the heap. From brk man page ( man brk ), we can see what this system call is doing: ... int brk(void *addr); void *sbrk(intptr_t increment); ... DESCRIPTION brk() and sbrk() change the location of the program break, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment). Increasing the program break has the effect of allocating memory to the process; decreas\u2010 ing the break deallocates memory. brk() sets the end of the data segment to the value specified by addr, when that value is reasonable, the system has enough memory, and the process does not exceed its maximum data size (see setrlimit(2)). sbrk() increments the program's data space by increment bytes. Calling sbrk() with an increment of 0 can be used to find the current location of the program break. The program break is the address of the first location beyond the current end of the data region of the program in the virual memory. NOTE: \u5173\u4e8edata region\uff0c\u53c2\u89c1 Kernel\\Guide\\Multitasking\\Process-model\\Process-resource\\Process-memory-model\\Virtual-address-space \uff0c\u5176\u4e2d\u63f4\u5f15\u4e86 wikipedia Memory address # Contents of each memory location \u4e2d\u7684\u5185\u5bb9: In modern multitasking environment, an application process usually has in its address space (or spaces) chunks of memory of following types: 1) Machine code , including: program's own code (historically known as code segment or text segment ); shared libraries . 2) Data , including: initialized data ( data segment ); uninitialized (but allocated) variables; run-time stack ; heap ; shared memory and memory mapped files . \u663e\u7136\u4e0a\u8ff0 data region \u548c wikipedia Memory address # Contents of each memory location \u4e2d\u76842) Data \u4e0d\u662f\u540c\u4e00\u4e2a\u6982\u5ff5\uff0c\u5b83\u6240\u6307\u4e3a data segment \u3002 By increasing the value of the program break , via brk or sbrk , the function malloc creates a new space that can then be used by the process to dynamically allocate memory (using malloc ). So the heap is actually an extension of the data segment of the program. NOTE: \u8fd9\u6bb5\u8bdd\u603b\u7ed3\u4e86heap\u548cdata segment\u4e4b\u95f4\u7684\u5173\u8054 The first call to brk ( brk(0) ) returns the current address of the program break to malloc . And the second call is the one that actually creates new memory (since 0xe91000 > 0xe70000 ) by increasing the value of the program break . In the above example, the heap is now starting at 0xe70000 and ends at 0xe91000 . Let\u2019s double check with the /proc/[PID]/maps file: julien@holberton:/proc/3855$ ps aux | grep \\ \\./3$ julien 4011 0.0 0.0 4748 708 pts/9 S+ 13:04 0:00 strace ./3 julien 4014 0.0 0.0 4336 644 pts/9 S+ 13:04 0:00 ./3 julien@holberton:/proc/3855$ cd /proc/4014 julien@holberton:/proc/4014$ cat maps 00400000-00401000 r-xp 00000000 08:01 176967 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3 00600000-00601000 r--p 00000000 08:01 176967 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3 00601000-00602000 rw-p 00001000 08:01 176967 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/3 00e70000-00e91000 rw-p 00000000 00:00 0 [heap] ... julien@holberton:/proc/4014$ -> 00e70000-00e91000 rw-p 00000000 00:00 0 [heap] matches the pointers returned back to malloc by brk . That\u2019s great, but wait, why did malloc increment the heap by 00e91000 \u2013 00e70000 = 0x21000 or 135168 bytes, when we only asked for only 1 byte?","title":"strace, brk and sbrk"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/Chapter-3-malloc-the-heap%26the-program-break/#many#mallocs","text":"What will happen if we call malloc several times? ( 4-main.c ) #include <stdio.h> #include <stdlib.h> #include <unistd.h> /** * main - many calls to malloc * * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS */ int main ( void ) { void * p ; write ( 1 , \"BEFORE MALLOC #0 \\n \" , 17 ); p = malloc ( 1024 ); write ( 1 , \"AFTER MALLOC #0 \\n \" , 16 ); printf ( \"%p \\n \" , p ); write ( 1 , \"BEFORE MALLOC #1 \\n \" , 17 ); p = malloc ( 1024 ); write ( 1 , \"AFTER MALLOC #1 \\n \" , 16 ); printf ( \"%p \\n \" , p ); write ( 1 , \"BEFORE MALLOC #2 \\n \" , 17 ); p = malloc ( 1024 ); write ( 1 , \"AFTER MALLOC #2 \\n \" , 16 ); printf ( \"%p \\n \" , p ); write ( 1 , \"BEFORE MALLOC #3 \\n \" , 17 ); p = malloc ( 1024 ); write ( 1 , \"AFTER MALLOC #3 \\n \" , 16 ); printf ( \"%p \\n \" , p ); getchar (); return ( EXIT_SUCCESS ); } julien @ holberton : ~/ holberton / w / hackthevm3$ gcc - Wall - Wextra - pedantic - Werror 4 - main . c - o 4 julien @ holberton : ~/ holberton / w / hackthevm3$ strace . / 4 execve ( \"./4\" , [ \"./4\" ], [ /* 61 vars */ ]) = 0 ... write ( 1 , \"BEFORE MALLOC #0 \\n \" , 17 BEFORE MALLOC # 0 ) = 17 brk ( 0 ) = 0x1314000 brk ( 0x1335000 ) = 0x1335000 write ( 1 , \"AFTER MALLOC #0 \\n \" , 16 AFTER MALLOC # 0 ) = 16 ... write ( 1 , \"0x1314010 \\n \" , 100 x1314010 ) = 10 write ( 1 , \"BEFORE MALLOC #1 \\n \" , 17 BEFORE MALLOC # 1 ) = 17 write ( 1 , \"AFTER MALLOC #1 \\n \" , 16 AFTER MALLOC # 1 ) = 16 write ( 1 , \"0x1314420 \\n \" , 100 x1314420 ) = 10 write ( 1 , \"BEFORE MALLOC #2 \\n \" , 17 BEFORE MALLOC # 2 ) = 17 write ( 1 , \"AFTER MALLOC #2 \\n \" , 16 AFTER MALLOC # 2 ) = 16 write ( 1 , \"0x1314830 \\n \" , 100 x1314830 ) = 10 write ( 1 , \"BEFORE MALLOC #3 \\n \" , 17 BEFORE MALLOC # 3 ) = 17 write ( 1 , \"AFTER MALLOC #3 \\n \" , 16 AFTER MALLOC # 3 ) = 16 write ( 1 , \"0x1314c40 \\n \" , 100 x1314c40 ) = 10 ... read ( 0 , -> malloc is NOT calling brk each time we call it. The first time, malloc creates a new space (the heap) for the program (by increasing the program break location). The following times, malloc uses the same space to give our program \u201cnew\u201d chunks of memory. Those \u201cnew\u201d chunks of memory are part of the memory previously allocated using brk . This way, malloc doesn\u2019t have to use syscalls ( brk ) every time we call it, and thus it makes malloc \u2013 and our programs using malloc \u2013 faster. It also allows malloc and free to optimize the usage of the memory. Let\u2019s double check that we have only one heap, allocated by the first call to brk : julien@holberton:/proc/4014$ ps aux | grep \\ \\./4$ julien 4169 0.0 0.0 4748 688 pts/9 S+ 13:33 0:00 strace ./4 julien 4172 0.0 0.0 4336 656 pts/9 S+ 13:33 0:00 ./4 julien@holberton:/proc/4014$ cd /proc/4172 julien@holberton:/proc/4172$ cat maps 00400000-00401000 r-xp 00000000 08:01 176973 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4 00600000-00601000 r--p 00000000 08:01 176973 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4 00601000-00602000 rw-p 00001000 08:01 176973 /home/julien/holberton/w/hack_the_virtual_memory/03. The Heap/4 01314000-01335000 rw-p 00000000 00:00 0 [heap] 7f4a3f2c4000-7f4a3f47e000 r-xp 00000000 08:01 136253 /lib/x86_64-linux-gnu/libc-2.19.so 7f4a3f47e000-7f4a3f67e000 ---p 001ba000 08:01 136253 /lib/x86_64-linux-gnu/libc-2.19.so 7f4a3f67e000-7f4a3f682000 r--p 001ba000 08:01 136253 /lib/x86_64-linux-gnu/libc-2.19.so 7f4a3f682000-7f4a3f684000 rw-p 001be000 08:01 136253 /lib/x86_64-linux-gnu/libc-2.19.so 7f4a3f684000-7f4a3f689000 rw-p 00000000 00:00 0 7f4a3f689000-7f4a3f6ac000 r-xp 00000000 08:01 136229 /lib/x86_64-linux-gnu/ld-2.19.so 7f4a3f890000-7f4a3f893000 rw-p 00000000 00:00 0 7f4a3f8a7000-7f4a3f8ab000 rw-p 00000000 00:00 0 7f4a3f8ab000-7f4a3f8ac000 r--p 00022000 08:01 136229 /lib/x86_64-linux-gnu/ld-2.19.so 7f4a3f8ac000-7f4a3f8ad000 rw-p 00023000 08:01 136229 /lib/x86_64-linux-gnu/ld-2.19.so 7f4a3f8ad000-7f4a3f8ae000 rw-p 00000000 00:00 0 7ffd1ba73000-7ffd1ba94000 rw-p 00000000 00:00 0 [stack] 7ffd1bbed000-7ffd1bbef000 r--p 00000000 00:00 0 [vvar] 7ffd1bbef000-7ffd1bbf1000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] julien@holberton:/proc/4172$ -> We have only one [heap] and the addresses match those returned by sbrk : 0x1314000 & 0x1335000","title":"Many mallocs"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/The-stack-registers-and-assembly-code/","text":"holbertonschool Hack the virtual memory: the stack, registers and assembly code","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Linux-implementation/Verification/Holberton-Hack-the-virtual-memory/The-stack-registers-and-assembly-code/#holbertonschool#hack#the#virtual#memory#the#stack#registers#and#assembly#code","text":"","title":"holbertonschool Hack the virtual memory: the stack, registers and assembly code"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/","text":"Virtual address space \u672c\u6587\u6240\u63cf\u8ff0\u7684\u662f\u7406\u8bba\u7684\u3001\u903b\u8f91\u7684\uff0c\u5728 ./Linux-implementation \u7ae0\u8282\u63cf\u8ff0\u4e86Linux\u4e2d\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u3002 \u7406\u89e3\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4 \u6211\u4eec\u77e5\u9053\u6211\u4eec\u7f16\u5199\u7684**\u5e94\u7528\u7a0b\u5e8f**\u6700\u7ec8\u8981\u4ee5**\u8fdb\u7a0b**\u7684\u5f62\u5f0f\u6765\u8fd0\u884c\uff0c\u4efb\u4f55\u4e00\u4e2a**\u8fdb\u7a0b**\u90fd\u88ab\u8d4b\u4e88\u5176\u81ea\u5df1\u7684**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\uff0c\u8be5**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u8986\u76d6\u4e86\u4e00\u4e2a\u76f8\u5f53\u5927\u7684\u8303\u56f4\uff0c\u5bf9\u4e8e32\u4f4d\u64cd\u4f5c\u7cfb\u7edf\uff0c\u5176\u8fdb\u7a0b\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u4e3a 2^{32}=4,294,967,296 2^{32}=4,294,967,296 Byte\uff0c\u8fd9\u4f7f\u5f97\u4e00\u4e2a**\u6307\u9488**\u53ef\u4ee5\u4f7f\u7528\u4ece 0x00000000 \u5230 0xFFFFFFFF \u76844GB\u8303\u56f4\u4e4b\u5185\u7684\u4efb\u4f55\u4e00\u4e2a\u503c\u3002\u867d\u7136\u6bcf\u4e00\u4e2a32\u4f4d\u8fdb\u7a0b\u53ef\u4f7f\u7528**4GB**\u7684**\u5730\u5740\u7a7a\u95f4**\uff0c\u4f46\u5e76\u4e0d\u610f\u5473\u7740\u6bcf\u4e00\u4e2a\u8fdb\u7a0b**\u5b9e\u9645**\u62e5\u6709 4GB \u7684**\u7269\u7406\u5730\u5740\u7a7a\u95f4**\uff0c\u8be5\u5730\u5740\u7a7a\u95f4\u4ec5\u4ec5\u662f\u4e00\u4e2a**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\uff0c\u5b83\u662f\u4e00\u4e2a\u903b\u8f91\u4e0a\u7684\u8bbe\u8ba1\u3002\u6b64**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u53ea\u662f\u5185\u5b58\u5730\u5740\u7684\u4e00\u4e2a\u8303\u56f4\u3002\u8fdb\u7a0b\u5b9e\u9645\u53ef\u4ee5\u5f97\u5230\u7684**\u7269\u7406\u5185\u5b58**\u8981\u8fdc\u5c0f\u4e8e\u5176**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u3002\u8fdb\u7a0b\u7684**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u662f\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u6240\u79c1\u6709\u7684\uff0c\u5728\u8fdb\u7a0b\u5185\u8fd0\u884c\u7684**\u7ebf\u7a0b**\u5bf9**\u5185\u5b58\u7a7a\u95f4**\u7684\u8bbf\u95ee\u90fd\u88ab\u9650\u5236\u5728**\u8c03\u7528\u8fdb\u7a0b**\u4e4b\u5185\uff0c\u800c\u4e0d\u80fd\u8bbf\u95ee\u5c5e\u4e8e\u5176\u4ed6\u8fdb\u7a0b\u7684\u5185\u5b58\u7a7a\u95f4\u3002\u8fd9\u6837\uff0c\u5728\u4e0d\u540c\u7684\u8fdb\u7a0b\u4e2d\u53ef\u4ee5\u4f7f\u7528\u76f8\u540c\u5730\u5740\u7684\u6307\u9488\u6765\u6307\u5411\u5c5e\u4e8e\u5404\u81ea\u8c03\u7528\u8fdb\u7a0b\u7684\u5185\u5bb9\u800c\u4e0d\u4f1a\u7531\u6b64\u5f15\u8d77\u6df7\u4e71\u3002 \u901a\u8fc7\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u63cf\u8ff0\uff0c\u53ef\u4ee5\u77e5\u9053\u8fdb\u7a0b\u4f7f\u7528\u7684\u5168\u90e8\u8d44\u6e90\u662f\u2019\u865a\u62df\u2018\u7684\uff0c\u6211\u4eec\u77e5\u9053\u6211\u4eec\u7f16\u5199\u7684**\u5e94\u7528\u7a0b\u5e8f**\u6700\u7ec8\u8981\u4ee5**\u8fdb\u7a0b**\u7684\u5f62\u5f0f\u6765\u8fd0\u884c\uff0c\u56e0\u800c\u8fdb\u7a0b\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e2a\u865a\u62df\u673a\uff08\u865a\u62df\u7684\u8ba1\u7b97\u673a\uff09\uff0c\u6240\u4ee5\u6211\u4eec\u5f88\u5bb9\u6613\u611f\u53d7\u5230\u81ea\u5df1\u7f16\u5199\u7684\u5e94\u7528\u7a0b\u5e8f\u4f3c\u4e4e\u4f7f\u7528\u7684\u662f\u6240\u6709\u7684\u8ba1\u7b97\u673a\u8d44\u6e90\uff0c32bit\u7684\u8ba1\u7b97\u673a\u6211\u4eec\u8fdb\u7a0b\u4f3c\u4e4e\u5c31\u662f\u4f7f\u7528\u5b8c\u6574\u76844G\u5185\u5b58\uff0c\u4f46\u662f\u5bf9\u7cfb\u7edf\u7a0d\u6709\u4e86\u89e3\uff0c\u6211\u4eec\u5c31\u77e5\u9053\u4e00\u4e2a\u8fdb\u7a0b\u4f7f\u7528\u7684\u7269\u7406\u5185\u5b58\u5b9e\u9645\u53ef\u80fd\u4e0d\u5230\u51e0\u767em\u751a\u81f3\u51e0m\uff01\u8fd9\u5c31\u662f\u4e00\u79cd\u865a\u62df\uff0c \u8fdb\u7a0b\u4f7f\u7528\u7684\u662f\u865a\u62df\u7684\u5168\u90e8\u8ba1\u7b97\u673a\u8d44\u6e90 \uff01\u56de\u6765\u518d\u770b\u5185\u5b58\uff0c\u5b9e\u9645\u4e0a\u4f7f\u7528\u51e0m\u7684\u5185\u5b58\uff0c\u4f46\u6bcf\u4e2a\u8fdb\u7a0b\u7684\u865a\u62df\u5185\u5b58\u5374\u662f4G\uff01\u8fd9\u5c31\u662f\u865a\u62df\u5185\u5b58\u7684\u5965\u5999\uff01 \u865a\u62df\u5185\u5b58\u7a7a\u95f4\uff08virtual memory area,VMA\uff09\uff0c\u4e5f\u79f0\u4f5c\u7ebf\u6027\u533a\u3002\u865a\u62df\u5b58\u50a8\u5668\u662f\u4e00\u4e2a\u62bd\u8c61\u6982\u5ff5\uff0c\u5b83\u4e3a\u6bcf\u4e00\u4e2a\u8fdb\u7a0b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5047\u8c61\uff0c\u597d\u50cf\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u5728\u72ec\u5360\u7684\u4f7f\u7528\u4e3b\u5b58\u3002\u6bcf\u4e2a\u8fdb\u7a0b\u770b\u5230\u7684\u5b58\u50a8\u5668\u90fd\u662f\u4e00\u81f4\u7684\uff0c\u79f0\u4e4b\u4e3a\u865a\u62df\u5730\u5740\u7a7a\u95f4\u3002 wikipedia Memory address # Contents of each memory location See also: binary data Each memory location in a stored-program computer holds a binary number or decimal number of some sort . Its interpretation, as data of some data type or as an instruction, and use are determined by the instructions which retrieve and manipulate it. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\uff0c\u5bf9interpretation model\u7684\u603b\u7ed3\u662f\u975e\u5e38\u597d\u7684\u3002 Address space in application programming In modern multitasking environment, an application process usually has in its address space (or spaces) chunks of memory of following types: 1) Machine code , including: program's own code (historically known as code segment or text segment ); shared libraries . 2) Data , including: initialized data ( data segment ); uninitialized (but allocated) variables; run-time stack ; heap ; shared memory and memory mapped files . Some parts of address space may be not mapped at all. NOTE: \u4e0a\u8ff0\u7684\u5bf9VMA\u7684\u5206\u7c7b\u662f\u66f4\u52a0\u6e05\u6670\u7684\uff0c\u5b83\u662f\u7b26\u5408\"function and data model\"\u7684\uff0c\u5b83\u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a\u66f4\u9ad8\u7684\u89d2\u5ea6\u6765\u5ba1\u89c6VMA\u3002 wikipedia Virtual address space In computing , a virtual address space ( VAS ) or address space is the set of ranges of virtual addresses that an operating system makes available to a process. The range of virtual addresses usually starts at a low address and can extend to the highest address allowed by the computer's instruction set architecture and supported by the operating system 's pointer size implementation, which can be 4 bytes for 32-bit or 8 bytes for 64-bit OS versions. This provides several benefits, one of which is security through process isolation assuming each process is given a separate address space . NOTE: process isolation\u662f\u975e\u5e38\u6709\u5fc5\u8981\u7684\uff0c\u56e0\u4e3a\u5f53OS\u4e2d\u8fd0\u884c\u591a\u4e2aprocess\u7684\u65f6\u5019\uff0cOS\u5c31\u9700\u8981\u8fdb\u884c\u8c03\u5ea6\uff0c\u56e0\u6b64\u5c31\u6709\u53ef\u80fd\u6682\u505c\u67d0\u4e2aprocess\u7684\u6267\u884c\u800c\u8f6c\u53bb\u6267\u884c\u53e6\u5916\u4e00\u4e2aprocess\uff1b\u53ef\u80fd\u8fc7\u6765\u4e00\u4e9b\u65f6\u95f4\u540e\uff0c\u518dresume\u4e4b\u524d\u6682\u505c\u7684process\uff1b\u53ef\u4ee5\u770b\u5230\uff0c\u4e3a\u4e86\u8fbe\u5230\u4f7fprocess\u53ef\u4e2d\u65ad\uff0c\u4e0d\u540cprocess\u4e4b\u95f4\u7684isolation\u975e\u5e38\u91cd\u8981\uff0c\u88ab\u4e2d\u65ad\u7684process\u7684address space\u5e94\u5f53\u8981\u514d\u6536\u5176\u4ed6\u7684\u6b63\u5728running\u7684process\u7684\u5f71\u54cd\uff1b Example When a new application on a 32-bit OS is executed, the process has a 4 GiB VAS: each one of the memory addresses (from 0 to 2^{32} \u2212 1 2^{32} \u2212 1 ) in that space can have a single byte as a value. Initially, none of them have values ('-' represents no value). Using or setting values in such a VAS would cause a memory exception . NOTE : \u4e0a\u8ff032-bit\u6307\u7684\u662fOS\u7684Word size 0 4 GiB VAS |----------------------------------------------| Then the application's executable file is mapped into the VAS. Addresses in the process VAS are mapped to bytes in the exe file. The OS manages the mapping: 0 4 GiB VAS |---vvvvvvv------------------------------------| mapping |-----| file bytes app.exe The v's are values from bytes in the mapped file . Then, required DLL files are mapped (this includes custom libraries as well as system ones such as kernel32.dll and user32.dll ): 0 4 GiB VAS |---vvvvvvv----vvvvvv---vvvv-------------------| mapping ||||||| |||||| |||| file bytes app.exe kernel user The process then starts executing bytes in the exe file. However, the only way the process can use or set '-' values in its VAS is to ask the OS to map them to bytes from a file . A common way to use VAS memory in this way is to map it to the page file . The page file is a single file, but multiple distinct sets of contiguous bytes can be mapped into a VAS: 0 4 GiB VAS |---vvvvvvv----vvvvvv---vvvv----vv---v----vvv--| mapping ||||||| |||||| |||| || | ||| file bytes app.exe kernel user system_page_file And different parts of the page file can map into the VAS of different processes: 0 4 GiB VAS 1 |---vvvv-------vvvvvv---vvvv----vv---v----vvv--| mapping |||| |||||| |||| || | ||| file bytes app1 app2 kernel user system_page_file mapping |||| |||||| |||| || | VAS 2 |--------vvvv--vvvvvv---vvvv-------vv---v------| On Microsoft Windows 32-bit, by default, only 2 GiB are made available to processes for their own use.[ 2] The other 2 GiB are used by the operating system. On later 32-bit editions of Microsoft Windows it is possible to extend the user-mode virtual address space to 3 GiB while only 1 GiB is left for kernel-mode virtual address space by marking the programs as IMAGE_FILE_LARGE_ADDRESS_AWARE and enabling the /3GB switch in the boot.ini file. On Microsoft Windows 64-bit, in a process running an executable that was linked with /LARGEADDRESSAWARE:NO, the operating system artificially limits the user mode portion of the process's virtual address space to 2 GiB. This applies to both 32- and 64-bit executables.[ 5] [ 6] Processes running executables that were linked with the /LARGEADDRESSAWARE:YES option, which is the default for 64-bit Visual Studio 2010 and later, have access to more than 2 GiB of virtual address space: Up to 4 GiB for 32-bit executables, up to 8 TiB for 64-bit executables in Windows through Windows 8, and up to 128 TiB for 64-bit executables in Windows 8.1 and later. Allocating memory via C 's malloc establishes the page file as the backing store for any new virtual address space. However, a process can also explicitly map file bytes. Linux For x86 CPUs, Linux 32-bit allows splitting the user and kernel address ranges in different ways: 3G/1G user/kernel (default), 1G/3G user/kernel or 2G/2G user/kernel . wikipedia Data segment # Program memory A computer program memory can be largely categorized into two sections: read-only and read/write. This distinction grew from early systems holding their main program in read-only memory such as Mask ROM , PROM or EEPROM . As systems became more complex and programs were loaded from other media into RAM instead of executing from ROM, the idea that some portions of the program's memory should not be modified was retained. These became the .text and .rodata segments of the program, and the remainder which could be written to divided into a number of other segments for specific tasks. This shows the typical layout of a simple computer's program memory with the text, various data, and stack and heap sections. Text Data BSS Heap Stack geeksforgeeks Memory Layout of C Programs A typical memory representation of C program consists of following sections. \\1. Text segment \\2. Initialized data segment (usually called simply the Data Segment ) \\3. Uninitialized data segment (often called the \u201c bss \u201d segment) \\4. Stack \\5. Heap TODO: Memory layout of a process in linux https://inst.eecs.berkeley.edu/~cs161/sp15/slides/lec3-sw-vulns.pdf https://inst.eecs.berkeley.edu/ https://cpp.tech-academy.co.uk/memory-layout/ https://cpp.tech-academy.co.uk/ https://stackoverflow.com/questions/3080375/how-is-the-memory-layout-of-a-c-c-program Memory layout of process with thread \u524d\u9762\u4ecb\u7ecd\u4e86\u6bcf\u4e2athread\u90fd\u6709\u81ea\u5df1\u7684call stack\uff0c\u90a3\u5b83\u4eec\u7684call stack\u7684layout\u662f\u5982\u4f55\u7684\u5462\uff1f\u672c\u8282\u5bf9\u6b64\u8fdb\u884c\u8ba8\u8bba\u3002 stackoverflow The memory layout of a multithreaded process A I just tested it with a short Python \"program\" in the interactive interpreter: import threading import time def d (): time . sleep ( 120 ) t = [ threading . Thread ( target = d ) for _ in range ( 250 )] for i in t : i . start () Then I pressed ^Z and looked at the appropriate /proc/.../maps file for this process. It showed me 00048000-00049000 ---p 00000000 00:00 0 00049000-00848000 rw-p 00000000 00:00 0 [stack:28625] 00848000-00849000 ---p 00000000 00:00 0 00849000-01048000 rw-p 00000000 00:00 0 [stack:28624] 01048000-01049000 ---p 00000000 00:00 0 01049000-01848000 rw-p 00000000 00:00 0 [stack:28623] 01848000-01849000 ---p 00000000 00:00 0 01849000-02048000 rw-p 00000000 00:00 0 [stack:28622] ... 47700000-47701000 ---p 00000000 00:00 0 47701000-47f00000 rw-p 00000000 00:00 0 [stack:28483] 47f00000-47f01000 ---p 00000000 00:00 0 47f01000-48700000 rw-p 00000000 00:00 0 [stack:28482] ... bd777000-bd778000 ---p 00000000 00:00 0 bd778000-bdf77000 rw-p 00000000 00:00 0 [stack:28638] bdf77000-bdf78000 ---p 00000000 00:00 0 bdf78000-be777000 rw-p 00000000 00:00 0 [stack:28639] be777000-be778000 ---p 00000000 00:00 0 be778000-bef77000 rw-p 00000000 00:00 0 [stack:28640] bef77000-bef78000 ---p 00000000 00:00 0 bef78000-bf777000 rw-p 00000000 00:00 0 [stack:28641] bf85c000-bf87d000 rw-p 00000000 00:00 0 [stack] which shows what I already suspected: the stacks are allocated with a relative distance which is (hopefully) large enough. The stacks have a relative distance of 8 MiB (this is the default value; it is possible to set it otherwise), and one page at the top is protected in order to detect a stack overflow. The one at the bottom is the \"main\" stack; it can - in this example - grow until the next one is reached.","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#virtual#address#space","text":"\u672c\u6587\u6240\u63cf\u8ff0\u7684\u662f\u7406\u8bba\u7684\u3001\u903b\u8f91\u7684\uff0c\u5728 ./Linux-implementation \u7ae0\u8282\u63cf\u8ff0\u4e86Linux\u4e2d\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u3002","title":"Virtual address space"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#_1","text":"\u6211\u4eec\u77e5\u9053\u6211\u4eec\u7f16\u5199\u7684**\u5e94\u7528\u7a0b\u5e8f**\u6700\u7ec8\u8981\u4ee5**\u8fdb\u7a0b**\u7684\u5f62\u5f0f\u6765\u8fd0\u884c\uff0c\u4efb\u4f55\u4e00\u4e2a**\u8fdb\u7a0b**\u90fd\u88ab\u8d4b\u4e88\u5176\u81ea\u5df1\u7684**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\uff0c\u8be5**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u8986\u76d6\u4e86\u4e00\u4e2a\u76f8\u5f53\u5927\u7684\u8303\u56f4\uff0c\u5bf9\u4e8e32\u4f4d\u64cd\u4f5c\u7cfb\u7edf\uff0c\u5176\u8fdb\u7a0b\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u4e3a 2^{32}=4,294,967,296 2^{32}=4,294,967,296 Byte\uff0c\u8fd9\u4f7f\u5f97\u4e00\u4e2a**\u6307\u9488**\u53ef\u4ee5\u4f7f\u7528\u4ece 0x00000000 \u5230 0xFFFFFFFF \u76844GB\u8303\u56f4\u4e4b\u5185\u7684\u4efb\u4f55\u4e00\u4e2a\u503c\u3002\u867d\u7136\u6bcf\u4e00\u4e2a32\u4f4d\u8fdb\u7a0b\u53ef\u4f7f\u7528**4GB**\u7684**\u5730\u5740\u7a7a\u95f4**\uff0c\u4f46\u5e76\u4e0d\u610f\u5473\u7740\u6bcf\u4e00\u4e2a\u8fdb\u7a0b**\u5b9e\u9645**\u62e5\u6709 4GB \u7684**\u7269\u7406\u5730\u5740\u7a7a\u95f4**\uff0c\u8be5\u5730\u5740\u7a7a\u95f4\u4ec5\u4ec5\u662f\u4e00\u4e2a**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\uff0c\u5b83\u662f\u4e00\u4e2a\u903b\u8f91\u4e0a\u7684\u8bbe\u8ba1\u3002\u6b64**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u53ea\u662f\u5185\u5b58\u5730\u5740\u7684\u4e00\u4e2a\u8303\u56f4\u3002\u8fdb\u7a0b\u5b9e\u9645\u53ef\u4ee5\u5f97\u5230\u7684**\u7269\u7406\u5185\u5b58**\u8981\u8fdc\u5c0f\u4e8e\u5176**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u3002\u8fdb\u7a0b\u7684**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u662f\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u6240\u79c1\u6709\u7684\uff0c\u5728\u8fdb\u7a0b\u5185\u8fd0\u884c\u7684**\u7ebf\u7a0b**\u5bf9**\u5185\u5b58\u7a7a\u95f4**\u7684\u8bbf\u95ee\u90fd\u88ab\u9650\u5236\u5728**\u8c03\u7528\u8fdb\u7a0b**\u4e4b\u5185\uff0c\u800c\u4e0d\u80fd\u8bbf\u95ee\u5c5e\u4e8e\u5176\u4ed6\u8fdb\u7a0b\u7684\u5185\u5b58\u7a7a\u95f4\u3002\u8fd9\u6837\uff0c\u5728\u4e0d\u540c\u7684\u8fdb\u7a0b\u4e2d\u53ef\u4ee5\u4f7f\u7528\u76f8\u540c\u5730\u5740\u7684\u6307\u9488\u6765\u6307\u5411\u5c5e\u4e8e\u5404\u81ea\u8c03\u7528\u8fdb\u7a0b\u7684\u5185\u5bb9\u800c\u4e0d\u4f1a\u7531\u6b64\u5f15\u8d77\u6df7\u4e71\u3002 \u901a\u8fc7\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u63cf\u8ff0\uff0c\u53ef\u4ee5\u77e5\u9053\u8fdb\u7a0b\u4f7f\u7528\u7684\u5168\u90e8\u8d44\u6e90\u662f\u2019\u865a\u62df\u2018\u7684\uff0c\u6211\u4eec\u77e5\u9053\u6211\u4eec\u7f16\u5199\u7684**\u5e94\u7528\u7a0b\u5e8f**\u6700\u7ec8\u8981\u4ee5**\u8fdb\u7a0b**\u7684\u5f62\u5f0f\u6765\u8fd0\u884c\uff0c\u56e0\u800c\u8fdb\u7a0b\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e2a\u865a\u62df\u673a\uff08\u865a\u62df\u7684\u8ba1\u7b97\u673a\uff09\uff0c\u6240\u4ee5\u6211\u4eec\u5f88\u5bb9\u6613\u611f\u53d7\u5230\u81ea\u5df1\u7f16\u5199\u7684\u5e94\u7528\u7a0b\u5e8f\u4f3c\u4e4e\u4f7f\u7528\u7684\u662f\u6240\u6709\u7684\u8ba1\u7b97\u673a\u8d44\u6e90\uff0c32bit\u7684\u8ba1\u7b97\u673a\u6211\u4eec\u8fdb\u7a0b\u4f3c\u4e4e\u5c31\u662f\u4f7f\u7528\u5b8c\u6574\u76844G\u5185\u5b58\uff0c\u4f46\u662f\u5bf9\u7cfb\u7edf\u7a0d\u6709\u4e86\u89e3\uff0c\u6211\u4eec\u5c31\u77e5\u9053\u4e00\u4e2a\u8fdb\u7a0b\u4f7f\u7528\u7684\u7269\u7406\u5185\u5b58\u5b9e\u9645\u53ef\u80fd\u4e0d\u5230\u51e0\u767em\u751a\u81f3\u51e0m\uff01\u8fd9\u5c31\u662f\u4e00\u79cd\u865a\u62df\uff0c \u8fdb\u7a0b\u4f7f\u7528\u7684\u662f\u865a\u62df\u7684\u5168\u90e8\u8ba1\u7b97\u673a\u8d44\u6e90 \uff01\u56de\u6765\u518d\u770b\u5185\u5b58\uff0c\u5b9e\u9645\u4e0a\u4f7f\u7528\u51e0m\u7684\u5185\u5b58\uff0c\u4f46\u6bcf\u4e2a\u8fdb\u7a0b\u7684\u865a\u62df\u5185\u5b58\u5374\u662f4G\uff01\u8fd9\u5c31\u662f\u865a\u62df\u5185\u5b58\u7684\u5965\u5999\uff01 \u865a\u62df\u5185\u5b58\u7a7a\u95f4\uff08virtual memory area,VMA\uff09\uff0c\u4e5f\u79f0\u4f5c\u7ebf\u6027\u533a\u3002\u865a\u62df\u5b58\u50a8\u5668\u662f\u4e00\u4e2a\u62bd\u8c61\u6982\u5ff5\uff0c\u5b83\u4e3a\u6bcf\u4e00\u4e2a\u8fdb\u7a0b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5047\u8c61\uff0c\u597d\u50cf\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u5728\u72ec\u5360\u7684\u4f7f\u7528\u4e3b\u5b58\u3002\u6bcf\u4e2a\u8fdb\u7a0b\u770b\u5230\u7684\u5b58\u50a8\u5668\u90fd\u662f\u4e00\u81f4\u7684\uff0c\u79f0\u4e4b\u4e3a\u865a\u62df\u5730\u5740\u7a7a\u95f4\u3002","title":"\u7406\u89e3\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#wikipedia#memory#address#contents#of#each#memory#location","text":"See also: binary data Each memory location in a stored-program computer holds a binary number or decimal number of some sort . Its interpretation, as data of some data type or as an instruction, and use are determined by the instructions which retrieve and manipulate it. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\uff0c\u5bf9interpretation model\u7684\u603b\u7ed3\u662f\u975e\u5e38\u597d\u7684\u3002","title":"wikipedia Memory address # Contents of each memory location"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#address#space#in#application#programming","text":"In modern multitasking environment, an application process usually has in its address space (or spaces) chunks of memory of following types: 1) Machine code , including: program's own code (historically known as code segment or text segment ); shared libraries . 2) Data , including: initialized data ( data segment ); uninitialized (but allocated) variables; run-time stack ; heap ; shared memory and memory mapped files . Some parts of address space may be not mapped at all. NOTE: \u4e0a\u8ff0\u7684\u5bf9VMA\u7684\u5206\u7c7b\u662f\u66f4\u52a0\u6e05\u6670\u7684\uff0c\u5b83\u662f\u7b26\u5408\"function and data model\"\u7684\uff0c\u5b83\u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a\u66f4\u9ad8\u7684\u89d2\u5ea6\u6765\u5ba1\u89c6VMA\u3002","title":"Address space in application programming"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#wikipedia#virtual#address#space","text":"In computing , a virtual address space ( VAS ) or address space is the set of ranges of virtual addresses that an operating system makes available to a process. The range of virtual addresses usually starts at a low address and can extend to the highest address allowed by the computer's instruction set architecture and supported by the operating system 's pointer size implementation, which can be 4 bytes for 32-bit or 8 bytes for 64-bit OS versions. This provides several benefits, one of which is security through process isolation assuming each process is given a separate address space . NOTE: process isolation\u662f\u975e\u5e38\u6709\u5fc5\u8981\u7684\uff0c\u56e0\u4e3a\u5f53OS\u4e2d\u8fd0\u884c\u591a\u4e2aprocess\u7684\u65f6\u5019\uff0cOS\u5c31\u9700\u8981\u8fdb\u884c\u8c03\u5ea6\uff0c\u56e0\u6b64\u5c31\u6709\u53ef\u80fd\u6682\u505c\u67d0\u4e2aprocess\u7684\u6267\u884c\u800c\u8f6c\u53bb\u6267\u884c\u53e6\u5916\u4e00\u4e2aprocess\uff1b\u53ef\u80fd\u8fc7\u6765\u4e00\u4e9b\u65f6\u95f4\u540e\uff0c\u518dresume\u4e4b\u524d\u6682\u505c\u7684process\uff1b\u53ef\u4ee5\u770b\u5230\uff0c\u4e3a\u4e86\u8fbe\u5230\u4f7fprocess\u53ef\u4e2d\u65ad\uff0c\u4e0d\u540cprocess\u4e4b\u95f4\u7684isolation\u975e\u5e38\u91cd\u8981\uff0c\u88ab\u4e2d\u65ad\u7684process\u7684address space\u5e94\u5f53\u8981\u514d\u6536\u5176\u4ed6\u7684\u6b63\u5728running\u7684process\u7684\u5f71\u54cd\uff1b","title":"wikipedia Virtual address space"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#example","text":"When a new application on a 32-bit OS is executed, the process has a 4 GiB VAS: each one of the memory addresses (from 0 to 2^{32} \u2212 1 2^{32} \u2212 1 ) in that space can have a single byte as a value. Initially, none of them have values ('-' represents no value). Using or setting values in such a VAS would cause a memory exception . NOTE : \u4e0a\u8ff032-bit\u6307\u7684\u662fOS\u7684Word size 0 4 GiB VAS |----------------------------------------------| Then the application's executable file is mapped into the VAS. Addresses in the process VAS are mapped to bytes in the exe file. The OS manages the mapping: 0 4 GiB VAS |---vvvvvvv------------------------------------| mapping |-----| file bytes app.exe The v's are values from bytes in the mapped file . Then, required DLL files are mapped (this includes custom libraries as well as system ones such as kernel32.dll and user32.dll ): 0 4 GiB VAS |---vvvvvvv----vvvvvv---vvvv-------------------| mapping ||||||| |||||| |||| file bytes app.exe kernel user The process then starts executing bytes in the exe file. However, the only way the process can use or set '-' values in its VAS is to ask the OS to map them to bytes from a file . A common way to use VAS memory in this way is to map it to the page file . The page file is a single file, but multiple distinct sets of contiguous bytes can be mapped into a VAS: 0 4 GiB VAS |---vvvvvvv----vvvvvv---vvvv----vv---v----vvv--| mapping ||||||| |||||| |||| || | ||| file bytes app.exe kernel user system_page_file And different parts of the page file can map into the VAS of different processes: 0 4 GiB VAS 1 |---vvvv-------vvvvvv---vvvv----vv---v----vvv--| mapping |||| |||||| |||| || | ||| file bytes app1 app2 kernel user system_page_file mapping |||| |||||| |||| || | VAS 2 |--------vvvv--vvvvvv---vvvv-------vv---v------| On Microsoft Windows 32-bit, by default, only 2 GiB are made available to processes for their own use.[ 2] The other 2 GiB are used by the operating system. On later 32-bit editions of Microsoft Windows it is possible to extend the user-mode virtual address space to 3 GiB while only 1 GiB is left for kernel-mode virtual address space by marking the programs as IMAGE_FILE_LARGE_ADDRESS_AWARE and enabling the /3GB switch in the boot.ini file. On Microsoft Windows 64-bit, in a process running an executable that was linked with /LARGEADDRESSAWARE:NO, the operating system artificially limits the user mode portion of the process's virtual address space to 2 GiB. This applies to both 32- and 64-bit executables.[ 5] [ 6] Processes running executables that were linked with the /LARGEADDRESSAWARE:YES option, which is the default for 64-bit Visual Studio 2010 and later, have access to more than 2 GiB of virtual address space: Up to 4 GiB for 32-bit executables, up to 8 TiB for 64-bit executables in Windows through Windows 8, and up to 128 TiB for 64-bit executables in Windows 8.1 and later. Allocating memory via C 's malloc establishes the page file as the backing store for any new virtual address space. However, a process can also explicitly map file bytes.","title":"Example"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#linux","text":"For x86 CPUs, Linux 32-bit allows splitting the user and kernel address ranges in different ways: 3G/1G user/kernel (default), 1G/3G user/kernel or 2G/2G user/kernel .","title":"Linux"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#wikipedia#data#segment#program#memory","text":"A computer program memory can be largely categorized into two sections: read-only and read/write. This distinction grew from early systems holding their main program in read-only memory such as Mask ROM , PROM or EEPROM . As systems became more complex and programs were loaded from other media into RAM instead of executing from ROM, the idea that some portions of the program's memory should not be modified was retained. These became the .text and .rodata segments of the program, and the remainder which could be written to divided into a number of other segments for specific tasks. This shows the typical layout of a simple computer's program memory with the text, various data, and stack and heap sections.","title":"wikipedia Data segment # Program memory"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#text","text":"","title":"Text"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#data","text":"","title":"Data"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#bss","text":"","title":"BSS"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#heap","text":"","title":"Heap"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#stack","text":"","title":"Stack"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#geeksforgeeks#memory#layout#of#c#programs","text":"A typical memory representation of C program consists of following sections. \\1. Text segment \\2. Initialized data segment (usually called simply the Data Segment ) \\3. Uninitialized data segment (often called the \u201c bss \u201d segment) \\4. Stack \\5. Heap","title":"geeksforgeeks Memory Layout of C Programs"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#todo#memory#layout#of#a#process#in#linux","text":"https://inst.eecs.berkeley.edu/~cs161/sp15/slides/lec3-sw-vulns.pdf https://inst.eecs.berkeley.edu/ https://cpp.tech-academy.co.uk/memory-layout/ https://cpp.tech-academy.co.uk/ https://stackoverflow.com/questions/3080375/how-is-the-memory-layout-of-a-c-c-program","title":"TODO: Memory layout of a process in linux"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#memory#layout#of#process#with#thread","text":"\u524d\u9762\u4ecb\u7ecd\u4e86\u6bcf\u4e2athread\u90fd\u6709\u81ea\u5df1\u7684call stack\uff0c\u90a3\u5b83\u4eec\u7684call stack\u7684layout\u662f\u5982\u4f55\u7684\u5462\uff1f\u672c\u8282\u5bf9\u6b64\u8fdb\u884c\u8ba8\u8bba\u3002","title":"Memory layout of process with thread"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/#stackoverflow#the#memory#layout#of#a#multithreaded#process","text":"A I just tested it with a short Python \"program\" in the interactive interpreter: import threading import time def d (): time . sleep ( 120 ) t = [ threading . Thread ( target = d ) for _ in range ( 250 )] for i in t : i . start () Then I pressed ^Z and looked at the appropriate /proc/.../maps file for this process. It showed me 00048000-00049000 ---p 00000000 00:00 0 00049000-00848000 rw-p 00000000 00:00 0 [stack:28625] 00848000-00849000 ---p 00000000 00:00 0 00849000-01048000 rw-p 00000000 00:00 0 [stack:28624] 01048000-01049000 ---p 00000000 00:00 0 01049000-01848000 rw-p 00000000 00:00 0 [stack:28623] 01848000-01849000 ---p 00000000 00:00 0 01849000-02048000 rw-p 00000000 00:00 0 [stack:28622] ... 47700000-47701000 ---p 00000000 00:00 0 47701000-47f00000 rw-p 00000000 00:00 0 [stack:28483] 47f00000-47f01000 ---p 00000000 00:00 0 47f01000-48700000 rw-p 00000000 00:00 0 [stack:28482] ... bd777000-bd778000 ---p 00000000 00:00 0 bd778000-bdf77000 rw-p 00000000 00:00 0 [stack:28638] bdf77000-bdf78000 ---p 00000000 00:00 0 bdf78000-be777000 rw-p 00000000 00:00 0 [stack:28639] be777000-be778000 ---p 00000000 00:00 0 be778000-bef77000 rw-p 00000000 00:00 0 [stack:28640] bef77000-bef78000 ---p 00000000 00:00 0 bef78000-bf777000 rw-p 00000000 00:00 0 [stack:28641] bf85c000-bf87d000 rw-p 00000000 00:00 0 [stack] which shows what I already suspected: the stacks are allocated with a relative distance which is (hopefully) large enough. The stacks have a relative distance of 8 MiB (this is the default value; it is possible to set it otherwise), and one page at the top is protected in order to detect a stack overflow. The one at the bottom is the \"main\" stack; it can - in this example - grow until the next one is reached.","title":"stackoverflow The memory layout of a multithreaded process"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Thinking/","text":"\u5173\u4e8eVirtual address space\u7684\u601d\u8003 \u4e00\u4e2aprocess\u7684virtual address space\u7684\u4e0a\u9650\uff1f \u6211\u4e4b\u524d\u51fa\u73b0out-of-memory\u7684\u60c5\u51b5\u662f\uff1aprocess\u975e\u5e38\u9ad8\u9891\u5730\u6267\u884c\u4e00\u4e2a\u5b58\u5728memory leakage\u7684function\uff0c\u6700\u7ec8\u5bfc\u81f4out-of-memory\uff08\u8fd9\u4e2afunction\u4f7f\u7528\u7684\u662f malloc \u5f0f\u7684\uff0c\u6240\u4ee5\u5b83\u6240\u83b7\u5f97\u7684memory\u662f\u4f4d\u4e8eheap\u7684\uff0c\u90a3\u4f4d\u4e8eheap\u4e0a\u7684memory\u6ca1\u6709\u4e0a\u9650\u5417\uff1f\u5b83\u5982\u4f55\u80fd\u591f\u5bfc\u81f4out-of-memory\uff1f\uff09\u3002\u4e00\u4e2aprocess\u5982\u4f55\u80fd\u591f\u5c06\u4e00\u53f0\u673a\u5668\u7684memory\u8017\u5c3d\uff1f\u8fd9\u4e2a\u95ee\u9898\u8f6c\u6362\u4e00\u4e0b\u5c31\u662f\u96be\u9053\u4e00\u4e2aprocess\u7684address space\u6ca1\u6709\u4e0a\u9650\u5417? \u4e00\u4e2aprocess\u7684address space\u662f\u6709\u4e0a\u9650\u7684\uff0c\u8fd9\u5c31\u662fvirtual address\u7684\u957f\u5ea6\u51b3\u5b9a\u7684\uff0c\u6bd4\u598232bit\uff0c\u5219\u5b83\u7684\u4e0a\u9650\u5c31\u662f4G\uff08\u4ec5\u4ec5\u53ea\u67094G\uff0c\u8fd9\u53ef\u80fd\u5417\uff1f\uff09\u76f4\u89c2\u611f\u53d7virtual address\u7684\u957f\u5ea6\u5c31\u662fC\u4e2d\u7684\u6307\u9488\u7c7b\u578b\u7684\u957f\u5ea6\uff0c\u6b63\u5982\u5728 Virtual address space \u4e2d\u6240\u63cf\u8ff0\u7684\u3002 \u9700\u8981\u8003\u8651\u7684\u4e00\u4e2a\u95ee\u9898\u662f\uff1aCPU\u7684word size\u548cvirtual address length\u4e4b\u95f4\u7684\u5173\u7cfb\u3002\u4e24\u8005\u80af\u5b9a\u4e0d\u662f\u4e00\u56de\u4e8b\u513f\u3002 \u6bcf\u4e2aprocess\u6709\u4e00\u4e2avirtual address space\uff0c\u4e0e\u8fd9\u4e2avirtual address space\u76f8\u5339\u914d\u7684\u662f\u4e00\u4e2apage table\uff0c\u8fd9\u4e2apage table\u8bb0\u5f55\u7740\u5f52\u5c5e\u4e8e\u5b83\u7684\u6240\u6709\u7684memory\uff0c\u90a3\u662f\u5426\u662f\u5728\u9884\u5148\u5c31\u5c06\u8fd9\u4e2apage table\u7684size\u7ed9\u56fa\u5b9a\u4e86\u5462\uff1f\u8fd8\u662f\u540e\u7eed\u5728process\u8fd0\u884c\u8fc7\u7a0b\u4e2d\uff0c\u8fd9\u4e2apage table\u7684\u5927\u5c0f\u4f1a\u6539\u53d8\uff1f \u4e0eout-of-memory\u76f8\u5173\u7684\u53e6\u5916\u4e00\u4e2a\u95ee\u9898\u662f\uff1astackoverflow\u3002 virtual address\u7684\u610f\u4e49 lazy\uff0c\u5373\u65e0\u9700\u4e00\u6b21\u6027\u5206\u914d\u6574\u4e2avirtual address space\uff0c\u800c\u662f\u7528\u65f6\u518d\u5206\u914d\u3002 copy on write \u5176\u5b9e\u901a\u8fc7\u8fd9\u4e2a\u601d\u8003\u624d\u53d1\u73b0virtual memory\u7684\u91cd\u8981\u4ef7\u503c\u6240\u5728\uff0c\u5b83\u662f\u5b9e\u73b0demand page\u7684\u57fa\u7840\uff0c\u5b83\u662f\u5b9e\u73b0\u6269\u5145memory\u7684\u57fa\u7840\uff0c\u5b83\u662f\u5b9e\u73b0copy on write\u7684\u57fa\u7840\u3002 linux process virtual address space\u548cpage table\u4e4b\u95f4\u7684\u5173\u7cfb \u5f53\u7136\u662f\u6709\u5dee\u522b\u7684\uff0cprocess virtual address space\u5219\u662f\u8868\u793a\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u5176\u4e2d\u6240\u4f7f\u7528\u7684\u662fvirtual address\uff0cpage table\u662f\u8bb0\u5f55\u7740virtual address\u548cphysical address\u4e4b\u95f4\u7684\u6620\u5c04\u5173\u7cfb\u3002 \u663e\u7136page table\u5bf9user\u662f\u900f\u660e\u7684\uff0c\u4f46\u662f\u6211\u4eec\u5374\u53ef\u4ee5\u8bbf\u95ee\u5230virtual address\uff0c\u901a\u8fc7pointer\u3002 \u63cf\u8ff0process virtual address space\u7684\u6570\u636e\u7ed3\u6784 \u57289.2. The Memory Descriptor\u4e2d\u6307\u51fa\uff1a mm_struct \u63cf\u8ff0page table\u7684data structure \u6bcf\u4e2avirtual address space\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684page table\uff0c\u90a3\u8fd9page table\u7684data structure\u662f\u5982\u4f55\u7684\uff1f \u5176\u5b9e\u8fd9\u5728Chapter 2. Memory Addressing\u4e2d\u5df2\u7ecf\u63cf\u8ff0\u4e86\u3002 \u4ecememory usage\u7684\u89d2\u5ea6\u6765\u5206\u6790process\u7684\u8fd0\u884c \u8fdb\u7a0b\u7684\u8fd0\u884c\u4f34\u968f\u7740\u5185\u5b58\u7684\u4f7f\u7528\uff0c\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u8fd8\u6ca1\u6709\u4e00\u4e2a\u5b8c\u6574\u3001\u6e05\u6670\u7684\u8ba4\u77e5\u3002\u5982\u4f55\u65f6\u5206\u914dmemory\uff1f\u4f55\u65f6\u56de\u6536memory\uff1f \u5206\u914dmemory\u7684\u573a\u666f\uff1a \u51fd\u6570\u8c03\u7528 stored program \u5728context switch\u7684\u65f6\u5019\uff0cOS\u9700\u8981\u5c06process\u7684context\u4fdd\u5b58\u8d77\u6765 \u5176\u5b9e\u6211\u77e5\u9053\uff0c\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\u7684\u66f4\u597d\u7684\u65b9\u5f0f\u662f\u9605\u8bfb\u8ba1\u7b97\u673a\u6267\u884c\u6307\u4ee4\u7684\u6d41\u7a0b\u3002 Address space \u8fd9\u4e2a\u95ee\u9898\u662f\u7531\u524d\u9762\u7684\u5173\u4e8eprocess\u7684resource\u7684\u601d\u8003\u884d\u751f\u51fa\u6765\u7684\u3002Address space\u662f\u4e00\u4e2aprocess\u975e\u5e38\u91cd\u8981\u7684resource\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u5b83\u662fprocess\u8fdb\u884c\u6d3b\u52a8\u7684\u7a7a\u95f4\u3002\u76ee\u524d\u7684OS\u90fd\u662f\u91c7\u7528\u7684virtual address\uff0c\u5373process\u8fd0\u884c\u7684\u65f6\u5019\uff0c\u6240\u4f7f\u7528\u7684\u662fvirtual memory\uff0c\u6240\u4ee5\u4e5f\u53ef\u4ee5\u5c06Address space\u79f0\u4e3aVirtual address space\u3002\u5173\u4e8eprocess\u7684Virtual address space\uff0c\u6211\u6709\u5982\u4e0b\u7591\u95ee\uff1a Question: process\u4f7f\u7528virtual memory\uff0c\u5e76\u4e14\u4f7f\u7528\u57fa\u4e8epage\u7684memory management\uff0c\u90a3\u5b83\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u57fa\u4e8epage\u7684virtual memory\u5462\uff1f\u662f\u5206\u5272\u4e3a\u4e00\u4e2a\u4e00\u4e2a\u7684page\uff1f \u7ecf\u8fc7\u7b80\u5355\u7684\u601d\u8003\uff0c\u6211\u89c9\u5f97\u5e94\u8be5\u662f\u7f16\u8bd1\u5668\u5728\u7ed9\u751f\u6210\u4ee3\u7801\u7684\u65f6\u5019\u5176\u5b9e\u662f\u4e0d\u9700\u8981\u8003\u8651\u8fd9\u4e2a\u95ee\u9898\u7684\uff0c\u56e0\u4e3a\u662fOS\u5728\u8fd0\u884cprogram\u7684\u65f6\u5019\u6309\u7167page\u8fdb\u884cmemory management\uff0c\u65e0\u8bba\u7f16\u8bd1\u5668\u751f\u6210\u7684program\u662f\u600e\u6837\u7684\uff0c\u662fOS\u8d1f\u8d23\u5c06\u8fd9\u4e9bprogram\u88c5\u5165\u5230memory\u4e2d\uff0c\u8fd9\u4e00\u5207\u5bf9compiler\u800c\u8a00\u90fd\u662f\u900f\u660e\u7684\u3002 \u4f46\u662f\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5ef6\u4f38\u4e00\u4e0b\uff1a\u6211\u4eec\u77e5\u9053\uff0c\u7f16\u8bd1\u5668\u751f\u6210\u7684\u4ee3\u7801\u80af\u5b9a\u662f\u9700\u8981\u9075\u5faaalignment\u7684\uff0c\u90a3\u8fd9\u5c31\u6d89\u53ca\u5230alignment\u548cpage size\u4e4b\u95f4\u7684\u5173\u7cfb\uff1b\u5e94\u8be5\u53ea\u8981\u7b26\u5408alignment\uff0c\u90a3\u4e48\u5e94\u8be5\u5c31\u4e0d\u4f1a\u5b58\u5728\u4e00\u4e2a\u6570\u636e\u5b58\u50a8\u8de8\u8d8a\u4e86\u591a\u4e2apage\u7684\u60c5\u51b5\u4e86\u3002 Question: \u8fdb\u7a0b\u7684virtual address space\u90fd\u662f\u76f8\u540c\u7684\uff0c\u90a3virtual address\u662f\u5982\u4f55\u6620\u5c04\u5230physical memory address\u7684\u5462\uff1f \u65e2\u7136\u4f7f\u7528\u7684\u662fdemand page\uff0c\u4e5f\u5c31\u662f\u5728process\u8fd0\u884c\u7684\u65f6\u5019\u9700\u8981\u8bbf\u95ee\u8be5virtual memory\u7684\u65f6\u5019\uff0c\u624dallocate physical memory\u6216\u8005swap-in\uff0c\u624d\u5c06virtual address\u6620\u5c04\u5230physical memory\u5e76\u5c06\u8fd9\u4e9b\u4fe1\u606f\u4fdd\u5b58\u5230\u8be5process\u7684page table\u4e2d\u3002 \u5176\u5b9e\u901a\u8fc7\u8fd9\u4e2a\u601d\u8003\u624d\u53d1\u73b0virtual memory\u7684\u91cd\u8981\u4ef7\u503c\u6240\u5728\uff0c\u5b83\u662f\u5b9e\u73b0demand page\u7684\u57fa\u7840\uff0c\u5b83\u662f\u5b9e\u73b0\u6269\u5145memory\u7684\u57fa\u7840\uff0c\u5b83\u662f\u5b9e\u73b0copy on write\u7684\u57fa\u7840\u3002 Question: \u59821.6.8.4. Process virtual address space handling\u8282\u6240\u53d9\u8ff0\u7684 The kernel usually stores a process virtual address space as a list of memory area descriptors . \u5373\u6211\u4eec\u901a\u5e38\u5c06virtual address space\u5206\u5272\u4e3a\u591a\u5757\uff0c\u90a3\u662f\u5728\u4ec0\u4e48\u5730\u65b9\u5c06virtual address space\u5206\u5272\u4e3a\u5982\u4e0a\u6240\u8ff0\u7684a list of memory area descriptors \uff1f operating system\u91c7\u7528\u7684\u662fdemand paging\uff0c\u5e76\u4e14stack\u7684\u589e\u957f\u65b9\u5411\u548cheap\u7684\u589e\u957f\u65b9\u5411\u76f8\u53cd\uff0c\u90a3\u8fd9\u4e9b\u53c8\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u5462\uff1f \u8981\u60f3\u5b8c\u5168\u7406\u89e3\u8fd9\u4e2a\u95ee\u9898\uff0c\u9605\u8bfbcalling convention\u3002\u6211\u89c9\u5f97process\u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\uff0c\u5bf9call stack\u7684\u7ef4\u62a4\u662f\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u6d3b\u52a8\uff0c\u6bcf\u6b21new\u4e00\u4e2a\u6808\u5e27\u90fd\u9700\u8981\u5206\u914d\u65b0\u7684\u5185\u5b58\u7a7a\u95f4\u91cd\u8981\u624d\u80fd\u591f\u4fdd\u8bc1process\u8fd0\u884c\u4e0b\u53bb\u3002 \u53e6\u5916\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u4e3a\u4ec0\u4e48\u9700\u8981\u7533\u8bf7memory\uff1f \u5176\u5b9e\u5982\u679c\u8fd9\u4e2a\u7cfb\u7edf\u4e2d\u53ea\u6709\u4e00\u4e2a\u7a0b\u5e8f\u7684\u8bdd\uff0c\u90a3\u4e48\u5b83\u60f3\u600e\u4e48\u6837\u4f7f\u7528memory\u5c31\u600e\u4e48\u6837\u4f7f\u7528memory\uff0c\u4f46\u662f\u95ee\u9898\u662f\uff0c\u6211\u4eec\u7684\u7cfb\u7edf\u662f\u9700\u8981\u652f\u6301\u591a\u4efb\u52a1\u7684\uff0c\u90a3\u5b83\u5c31\u9700\u8981\u505a\u597d\u4e0d\u540c\u7684process\u4e4b\u95f4\u7684\u9694\u79bb\uff0cA process\u4e0d\u80fd\u591f\u4f7f\u7528B process\u7684\u4e1c\u897f\u3002\u6240\u4ee5\uff0c\u6240\u6709\u7684process\u90fd\u5fc5\u987b\u8981\u5148\u60f3OS\u7533\u8bf7memory\uff0c\u7136\u540e\u624d\u80fd\u591f\u4f7f\u7528\uff0cOS\u4f1a\u8bb0\u4f4fmemory\u7684\u6240\u5c5e\uff0c\u8fd9\u6837\u5c31\u80fd\u591f\u4fdd\u8bc1\u4e0d\u51b2\u7a81\u4e86\u3002\u5176\u6b21\u662fprocess\u7684\u8fd0\u884c\u662f\u9700\u8981\u4e00\u5b9a\u7684memory space\u6765\u5b58\u653e\u5b83\u7684\u76f8\u5173\u7684\u6570\u636e\u7684\uff0c\u6bd4\u5982\u5728\u53d1\u751fcontext switch\u7684\u65f6\u5019\uff0c\u5c31\u9700\u8981\u5c06\u5b83\u7684context\u76f8\u5173\u7684\u6570\u636e\u90fd\u4fdd\u5b58\u5230\u5b83\u7684memory space\u4e2d\u6765\u3002\u53e6\u5916\u4e00\u4e2a\u5c31\u662fprocess\u7684call stack\uff0c\u8fd9\u662f\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u9700\u8981memory space\u7684\u573a\u6240\u3002 Question: \u5982\u524d\u6240\u8ff0\uff0c\u6808\u4e5f\u662fvirtual address space\u7684\u6210\u5206\u4e4b\u4e00\uff0c\u6bcf\u4e2athread\u90fd\u6709\u5404\u81ea**\u72ec\u7acb**\u7684call stack\uff0c\u800c\u6240\u6709\u7684thread\u7406\u8bba\u4e0a\u90fd\u662f\u5171\u4eabprocess\u7684virtual address space\u7684\uff0c\u90a3\u8fd9\u53c8\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u5462\uff1f \u5176\u5b9e\u6700\u6700\u7b80\u5355\u7684\u65b9\u5f0f\u662f\u67e5\u770b task_descriptor \u7684\u6210\u5458\u53d8\u91cf See also Is kernel data segment in process address space? Anatomy of a Program in Memory Does every process have its own page table? How do I save space with inverted page tables? Page table Why one page table per process What are high memory and low memory on Linux?","title":"Thinking"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Thinking/#virtual#address#space","text":"","title":"\u5173\u4e8eVirtual address space\u7684\u601d\u8003"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Thinking/#processvirtual#address#space","text":"\u6211\u4e4b\u524d\u51fa\u73b0out-of-memory\u7684\u60c5\u51b5\u662f\uff1aprocess\u975e\u5e38\u9ad8\u9891\u5730\u6267\u884c\u4e00\u4e2a\u5b58\u5728memory leakage\u7684function\uff0c\u6700\u7ec8\u5bfc\u81f4out-of-memory\uff08\u8fd9\u4e2afunction\u4f7f\u7528\u7684\u662f malloc \u5f0f\u7684\uff0c\u6240\u4ee5\u5b83\u6240\u83b7\u5f97\u7684memory\u662f\u4f4d\u4e8eheap\u7684\uff0c\u90a3\u4f4d\u4e8eheap\u4e0a\u7684memory\u6ca1\u6709\u4e0a\u9650\u5417\uff1f\u5b83\u5982\u4f55\u80fd\u591f\u5bfc\u81f4out-of-memory\uff1f\uff09\u3002\u4e00\u4e2aprocess\u5982\u4f55\u80fd\u591f\u5c06\u4e00\u53f0\u673a\u5668\u7684memory\u8017\u5c3d\uff1f\u8fd9\u4e2a\u95ee\u9898\u8f6c\u6362\u4e00\u4e0b\u5c31\u662f\u96be\u9053\u4e00\u4e2aprocess\u7684address space\u6ca1\u6709\u4e0a\u9650\u5417? \u4e00\u4e2aprocess\u7684address space\u662f\u6709\u4e0a\u9650\u7684\uff0c\u8fd9\u5c31\u662fvirtual address\u7684\u957f\u5ea6\u51b3\u5b9a\u7684\uff0c\u6bd4\u598232bit\uff0c\u5219\u5b83\u7684\u4e0a\u9650\u5c31\u662f4G\uff08\u4ec5\u4ec5\u53ea\u67094G\uff0c\u8fd9\u53ef\u80fd\u5417\uff1f\uff09\u76f4\u89c2\u611f\u53d7virtual address\u7684\u957f\u5ea6\u5c31\u662fC\u4e2d\u7684\u6307\u9488\u7c7b\u578b\u7684\u957f\u5ea6\uff0c\u6b63\u5982\u5728 Virtual address space \u4e2d\u6240\u63cf\u8ff0\u7684\u3002 \u9700\u8981\u8003\u8651\u7684\u4e00\u4e2a\u95ee\u9898\u662f\uff1aCPU\u7684word size\u548cvirtual address length\u4e4b\u95f4\u7684\u5173\u7cfb\u3002\u4e24\u8005\u80af\u5b9a\u4e0d\u662f\u4e00\u56de\u4e8b\u513f\u3002 \u6bcf\u4e2aprocess\u6709\u4e00\u4e2avirtual address space\uff0c\u4e0e\u8fd9\u4e2avirtual address space\u76f8\u5339\u914d\u7684\u662f\u4e00\u4e2apage table\uff0c\u8fd9\u4e2apage table\u8bb0\u5f55\u7740\u5f52\u5c5e\u4e8e\u5b83\u7684\u6240\u6709\u7684memory\uff0c\u90a3\u662f\u5426\u662f\u5728\u9884\u5148\u5c31\u5c06\u8fd9\u4e2apage table\u7684size\u7ed9\u56fa\u5b9a\u4e86\u5462\uff1f\u8fd8\u662f\u540e\u7eed\u5728process\u8fd0\u884c\u8fc7\u7a0b\u4e2d\uff0c\u8fd9\u4e2apage table\u7684\u5927\u5c0f\u4f1a\u6539\u53d8\uff1f \u4e0eout-of-memory\u76f8\u5173\u7684\u53e6\u5916\u4e00\u4e2a\u95ee\u9898\u662f\uff1astackoverflow\u3002","title":"\u4e00\u4e2aprocess\u7684virtual address space\u7684\u4e0a\u9650\uff1f"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Thinking/#virtual#address","text":"lazy\uff0c\u5373\u65e0\u9700\u4e00\u6b21\u6027\u5206\u914d\u6574\u4e2avirtual address space\uff0c\u800c\u662f\u7528\u65f6\u518d\u5206\u914d\u3002 copy on write \u5176\u5b9e\u901a\u8fc7\u8fd9\u4e2a\u601d\u8003\u624d\u53d1\u73b0virtual memory\u7684\u91cd\u8981\u4ef7\u503c\u6240\u5728\uff0c\u5b83\u662f\u5b9e\u73b0demand page\u7684\u57fa\u7840\uff0c\u5b83\u662f\u5b9e\u73b0\u6269\u5145memory\u7684\u57fa\u7840\uff0c\u5b83\u662f\u5b9e\u73b0copy on write\u7684\u57fa\u7840\u3002","title":"virtual address\u7684\u610f\u4e49"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Thinking/#linux#process#virtual#address#spacepage#table","text":"\u5f53\u7136\u662f\u6709\u5dee\u522b\u7684\uff0cprocess virtual address space\u5219\u662f\u8868\u793a\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u5176\u4e2d\u6240\u4f7f\u7528\u7684\u662fvirtual address\uff0cpage table\u662f\u8bb0\u5f55\u7740virtual address\u548cphysical address\u4e4b\u95f4\u7684\u6620\u5c04\u5173\u7cfb\u3002 \u663e\u7136page table\u5bf9user\u662f\u900f\u660e\u7684\uff0c\u4f46\u662f\u6211\u4eec\u5374\u53ef\u4ee5\u8bbf\u95ee\u5230virtual address\uff0c\u901a\u8fc7pointer\u3002","title":"linux process virtual address space\u548cpage table\u4e4b\u95f4\u7684\u5173\u7cfb"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Thinking/#process#virtual#address#space","text":"\u57289.2. The Memory Descriptor\u4e2d\u6307\u51fa\uff1a mm_struct","title":"\u63cf\u8ff0process virtual address space\u7684\u6570\u636e\u7ed3\u6784"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Thinking/#page#tabledata#structure","text":"\u6bcf\u4e2avirtual address space\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684page table\uff0c\u90a3\u8fd9page table\u7684data structure\u662f\u5982\u4f55\u7684\uff1f \u5176\u5b9e\u8fd9\u5728Chapter 2. Memory Addressing\u4e2d\u5df2\u7ecf\u63cf\u8ff0\u4e86\u3002","title":"\u63cf\u8ff0page table\u7684data structure"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Thinking/#memory#usageprocess","text":"\u8fdb\u7a0b\u7684\u8fd0\u884c\u4f34\u968f\u7740\u5185\u5b58\u7684\u4f7f\u7528\uff0c\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u8fd8\u6ca1\u6709\u4e00\u4e2a\u5b8c\u6574\u3001\u6e05\u6670\u7684\u8ba4\u77e5\u3002\u5982\u4f55\u65f6\u5206\u914dmemory\uff1f\u4f55\u65f6\u56de\u6536memory\uff1f \u5206\u914dmemory\u7684\u573a\u666f\uff1a \u51fd\u6570\u8c03\u7528 stored program \u5728context switch\u7684\u65f6\u5019\uff0cOS\u9700\u8981\u5c06process\u7684context\u4fdd\u5b58\u8d77\u6765 \u5176\u5b9e\u6211\u77e5\u9053\uff0c\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\u7684\u66f4\u597d\u7684\u65b9\u5f0f\u662f\u9605\u8bfb\u8ba1\u7b97\u673a\u6267\u884c\u6307\u4ee4\u7684\u6d41\u7a0b\u3002","title":"\u4ecememory usage\u7684\u89d2\u5ea6\u6765\u5206\u6790process\u7684\u8fd0\u884c"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Thinking/#address#space","text":"\u8fd9\u4e2a\u95ee\u9898\u662f\u7531\u524d\u9762\u7684\u5173\u4e8eprocess\u7684resource\u7684\u601d\u8003\u884d\u751f\u51fa\u6765\u7684\u3002Address space\u662f\u4e00\u4e2aprocess\u975e\u5e38\u91cd\u8981\u7684resource\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u5b83\u662fprocess\u8fdb\u884c\u6d3b\u52a8\u7684\u7a7a\u95f4\u3002\u76ee\u524d\u7684OS\u90fd\u662f\u91c7\u7528\u7684virtual address\uff0c\u5373process\u8fd0\u884c\u7684\u65f6\u5019\uff0c\u6240\u4f7f\u7528\u7684\u662fvirtual memory\uff0c\u6240\u4ee5\u4e5f\u53ef\u4ee5\u5c06Address space\u79f0\u4e3aVirtual address space\u3002\u5173\u4e8eprocess\u7684Virtual address space\uff0c\u6211\u6709\u5982\u4e0b\u7591\u95ee\uff1a Question: process\u4f7f\u7528virtual memory\uff0c\u5e76\u4e14\u4f7f\u7528\u57fa\u4e8epage\u7684memory management\uff0c\u90a3\u5b83\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u57fa\u4e8epage\u7684virtual memory\u5462\uff1f\u662f\u5206\u5272\u4e3a\u4e00\u4e2a\u4e00\u4e2a\u7684page\uff1f \u7ecf\u8fc7\u7b80\u5355\u7684\u601d\u8003\uff0c\u6211\u89c9\u5f97\u5e94\u8be5\u662f\u7f16\u8bd1\u5668\u5728\u7ed9\u751f\u6210\u4ee3\u7801\u7684\u65f6\u5019\u5176\u5b9e\u662f\u4e0d\u9700\u8981\u8003\u8651\u8fd9\u4e2a\u95ee\u9898\u7684\uff0c\u56e0\u4e3a\u662fOS\u5728\u8fd0\u884cprogram\u7684\u65f6\u5019\u6309\u7167page\u8fdb\u884cmemory management\uff0c\u65e0\u8bba\u7f16\u8bd1\u5668\u751f\u6210\u7684program\u662f\u600e\u6837\u7684\uff0c\u662fOS\u8d1f\u8d23\u5c06\u8fd9\u4e9bprogram\u88c5\u5165\u5230memory\u4e2d\uff0c\u8fd9\u4e00\u5207\u5bf9compiler\u800c\u8a00\u90fd\u662f\u900f\u660e\u7684\u3002 \u4f46\u662f\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5ef6\u4f38\u4e00\u4e0b\uff1a\u6211\u4eec\u77e5\u9053\uff0c\u7f16\u8bd1\u5668\u751f\u6210\u7684\u4ee3\u7801\u80af\u5b9a\u662f\u9700\u8981\u9075\u5faaalignment\u7684\uff0c\u90a3\u8fd9\u5c31\u6d89\u53ca\u5230alignment\u548cpage size\u4e4b\u95f4\u7684\u5173\u7cfb\uff1b\u5e94\u8be5\u53ea\u8981\u7b26\u5408alignment\uff0c\u90a3\u4e48\u5e94\u8be5\u5c31\u4e0d\u4f1a\u5b58\u5728\u4e00\u4e2a\u6570\u636e\u5b58\u50a8\u8de8\u8d8a\u4e86\u591a\u4e2apage\u7684\u60c5\u51b5\u4e86\u3002 Question: \u8fdb\u7a0b\u7684virtual address space\u90fd\u662f\u76f8\u540c\u7684\uff0c\u90a3virtual address\u662f\u5982\u4f55\u6620\u5c04\u5230physical memory address\u7684\u5462\uff1f \u65e2\u7136\u4f7f\u7528\u7684\u662fdemand page\uff0c\u4e5f\u5c31\u662f\u5728process\u8fd0\u884c\u7684\u65f6\u5019\u9700\u8981\u8bbf\u95ee\u8be5virtual memory\u7684\u65f6\u5019\uff0c\u624dallocate physical memory\u6216\u8005swap-in\uff0c\u624d\u5c06virtual address\u6620\u5c04\u5230physical memory\u5e76\u5c06\u8fd9\u4e9b\u4fe1\u606f\u4fdd\u5b58\u5230\u8be5process\u7684page table\u4e2d\u3002 \u5176\u5b9e\u901a\u8fc7\u8fd9\u4e2a\u601d\u8003\u624d\u53d1\u73b0virtual memory\u7684\u91cd\u8981\u4ef7\u503c\u6240\u5728\uff0c\u5b83\u662f\u5b9e\u73b0demand page\u7684\u57fa\u7840\uff0c\u5b83\u662f\u5b9e\u73b0\u6269\u5145memory\u7684\u57fa\u7840\uff0c\u5b83\u662f\u5b9e\u73b0copy on write\u7684\u57fa\u7840\u3002 Question: \u59821.6.8.4. Process virtual address space handling\u8282\u6240\u53d9\u8ff0\u7684 The kernel usually stores a process virtual address space as a list of memory area descriptors . \u5373\u6211\u4eec\u901a\u5e38\u5c06virtual address space\u5206\u5272\u4e3a\u591a\u5757\uff0c\u90a3\u662f\u5728\u4ec0\u4e48\u5730\u65b9\u5c06virtual address space\u5206\u5272\u4e3a\u5982\u4e0a\u6240\u8ff0\u7684a list of memory area descriptors \uff1f operating system\u91c7\u7528\u7684\u662fdemand paging\uff0c\u5e76\u4e14stack\u7684\u589e\u957f\u65b9\u5411\u548cheap\u7684\u589e\u957f\u65b9\u5411\u76f8\u53cd\uff0c\u90a3\u8fd9\u4e9b\u53c8\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u5462\uff1f \u8981\u60f3\u5b8c\u5168\u7406\u89e3\u8fd9\u4e2a\u95ee\u9898\uff0c\u9605\u8bfbcalling convention\u3002\u6211\u89c9\u5f97process\u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\uff0c\u5bf9call stack\u7684\u7ef4\u62a4\u662f\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u6d3b\u52a8\uff0c\u6bcf\u6b21new\u4e00\u4e2a\u6808\u5e27\u90fd\u9700\u8981\u5206\u914d\u65b0\u7684\u5185\u5b58\u7a7a\u95f4\u91cd\u8981\u624d\u80fd\u591f\u4fdd\u8bc1process\u8fd0\u884c\u4e0b\u53bb\u3002 \u53e6\u5916\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u4e3a\u4ec0\u4e48\u9700\u8981\u7533\u8bf7memory\uff1f \u5176\u5b9e\u5982\u679c\u8fd9\u4e2a\u7cfb\u7edf\u4e2d\u53ea\u6709\u4e00\u4e2a\u7a0b\u5e8f\u7684\u8bdd\uff0c\u90a3\u4e48\u5b83\u60f3\u600e\u4e48\u6837\u4f7f\u7528memory\u5c31\u600e\u4e48\u6837\u4f7f\u7528memory\uff0c\u4f46\u662f\u95ee\u9898\u662f\uff0c\u6211\u4eec\u7684\u7cfb\u7edf\u662f\u9700\u8981\u652f\u6301\u591a\u4efb\u52a1\u7684\uff0c\u90a3\u5b83\u5c31\u9700\u8981\u505a\u597d\u4e0d\u540c\u7684process\u4e4b\u95f4\u7684\u9694\u79bb\uff0cA process\u4e0d\u80fd\u591f\u4f7f\u7528B process\u7684\u4e1c\u897f\u3002\u6240\u4ee5\uff0c\u6240\u6709\u7684process\u90fd\u5fc5\u987b\u8981\u5148\u60f3OS\u7533\u8bf7memory\uff0c\u7136\u540e\u624d\u80fd\u591f\u4f7f\u7528\uff0cOS\u4f1a\u8bb0\u4f4fmemory\u7684\u6240\u5c5e\uff0c\u8fd9\u6837\u5c31\u80fd\u591f\u4fdd\u8bc1\u4e0d\u51b2\u7a81\u4e86\u3002\u5176\u6b21\u662fprocess\u7684\u8fd0\u884c\u662f\u9700\u8981\u4e00\u5b9a\u7684memory space\u6765\u5b58\u653e\u5b83\u7684\u76f8\u5173\u7684\u6570\u636e\u7684\uff0c\u6bd4\u5982\u5728\u53d1\u751fcontext switch\u7684\u65f6\u5019\uff0c\u5c31\u9700\u8981\u5c06\u5b83\u7684context\u76f8\u5173\u7684\u6570\u636e\u90fd\u4fdd\u5b58\u5230\u5b83\u7684memory space\u4e2d\u6765\u3002\u53e6\u5916\u4e00\u4e2a\u5c31\u662fprocess\u7684call stack\uff0c\u8fd9\u662f\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u9700\u8981memory space\u7684\u573a\u6240\u3002 Question: \u5982\u524d\u6240\u8ff0\uff0c\u6808\u4e5f\u662fvirtual address space\u7684\u6210\u5206\u4e4b\u4e00\uff0c\u6bcf\u4e2athread\u90fd\u6709\u5404\u81ea**\u72ec\u7acb**\u7684call stack\uff0c\u800c\u6240\u6709\u7684thread\u7406\u8bba\u4e0a\u90fd\u662f\u5171\u4eabprocess\u7684virtual address space\u7684\uff0c\u90a3\u8fd9\u53c8\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u5462\uff1f \u5176\u5b9e\u6700\u6700\u7b80\u5355\u7684\u65b9\u5f0f\u662f\u67e5\u770b task_descriptor \u7684\u6210\u5458\u53d8\u91cf","title":"Address space"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Thinking/#see#also","text":"Is kernel data segment in process address space? Anatomy of a Program in Memory Does every process have its own page table? How do I save space with inverted page tables? Page table Why one page table per process What are high memory and low memory on Linux?","title":"See also"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/BSS/","text":".bss \u5176\u5b9e\u5c31\u662f**Uninitialized data segment** \u3002 wikipedia .bss In computer programming , the block starting symbol (abbreviated to .bss or bss ) is the portion of an object file , executable, or assembly language code that contains statically-allocated variables that are declared but have not been assigned a value yet. It is often referred to as the \"bss section\" or \"bss segment\".","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/BSS/#bss","text":"\u5176\u5b9e\u5c31\u662f**Uninitialized data segment** \u3002","title":".bss"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/BSS/#wikipedia#bss","text":"In computer programming , the block starting symbol (abbreviated to .bss or bss ) is the portion of an object file , executable, or assembly language code that contains statically-allocated variables that are declared but have not been assigned a value yet. It is often referred to as the \"bss section\" or \"bss segment\".","title":"wikipedia .bss"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Code-segment/","text":"Code segment wikipedia Code segment In computing , a code segment , also known as a text segment or simply as text , is a portion of an object file or the corresponding section of the program's virtual address space that contains executable instructions .[ 1] The term \"segment\" comes from the memory segment , which is a historical approach to memory management that has been succeeded by paging .","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Code-segment/#code#segment","text":"","title":"Code segment"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Code-segment/#wikipedia#code#segment","text":"In computing , a code segment , also known as a text segment or simply as text , is a portion of an object file or the corresponding section of the program's virtual address space that contains executable instructions .[ 1] The term \"segment\" comes from the memory segment , which is a historical approach to memory management that has been succeeded by paging .","title":"wikipedia Code segment"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Data-segment/","text":"Data segment wikipedia Data segment In computing , a data segment (often denoted .data ) is a portion of an object file or the corresponding address space of a program that contains initialized static variables , that is, global variables and static local variables . The size of this segment is determined by the size of the values in the program's source code, and does not change at run time . NOTE: \u5728\u4e00\u4e9b\u5176\u4ed6\u7684\u6587\u7ae0\u4e2d\uff0c\u4e5f\u4f7f\u7528\u4e86 data segment \u8fd9\u4e2a\u8bcd\uff0c\u5728\u5176\u4e2d\u7684\u4e00\u4e9b\u5185\u5bb9\u521d\u8bfb\u8d77\u6765\u662f\u4f1a\u548c\u4e0a\u9762\u7684\u6700\u540e\u4e00\u53e5\u8bdd \"and does not change at run time \" \u76f8\u77db\u76fe\u7684\uff0c\u5728\u4e0b\u9762\u7ae0\u8282\u4e2d\uff0c\u7f57\u5217\u4e86\u8fd9\u4e9b\u6587\u7ae0\uff0c\u8fd9\u4e9b\u6587\u7ae0\u4e3b\u8981\u662fLinux OS\u76f8\u5173\u7684\uff0c\u5176\u5b9e\u5b83\u4eec\u662f\u5e76\u4e0d\u77db\u76fe\u7684\uff0c\u8fd9\u4e9b\u6587\u7ae0\u7684\u5185\u5bb9\u6d89\u53ca\u5230\u4e86\u5e95\u5c42\u7684\u5b9e\u73b0\u7ec6\u8282\uff0c\u5f53\u6df1\u5165\u8fd9\u4e9b\u5b9e\u73b0\u7ec6\u8282\u540e\uff0c\u4f1a\u53d1\u73b0\u5b83\u4eec\u5176\u5b9e\u662f\u5e76\u4e0d\u77db\u76fe\u7684\u3002 Use case \u4e0b\u9762\u8fd9\u4e9b\u6587\u7ae0\u4e2d\uff0c\u4e5f\u4f7f\u7528\u4e86data segment\u8fd9\u4e2a\u8bcd\u8bed\uff0c\u521d\u8bfb\u8d77\u6765\uff0c\u662f\u548c wikipedia Data segment \u4e2d\u7684 \"The size of this segment is determined by the size of the values in the program's source code, and does not change at run time \" \u76f8\u77db\u76fe\u7684\uff0c\u53c2\u770b Kernel\\Guide\\Multitasking\\Process-model\\Process-resource\\Process-memory-model\\Linux-implementation \u7ae0\u8282\u5b66\u4e60\u5b9e\u73b0\u7ec6\u8282\u540e\uff0c\u4ece\u5b9e\u73b0\u89d2\u5ea6\u6765\u770b\uff0c\u5b83\u4eec\u662f\u5e76\u4e0d\u77db\u76fe\u7684\u3002 wikipedia C dynamic memory allocation # Implementations # Heap-based Implementation of the allocator is commonly done using the heap , or data segment . The allocator will usually expand and contract the heap to fulfill allocation requests. wikipedia sbrk brk and sbrk are basic memory management system calls used in Unix and Unix-like operating systems to control the amount of memory allocated to the data segment of the process .[ 1] NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\uff0c\u8bf4\u660e\u4e86\u5728Linux OS\u4e2d\u7684implementation\u4e2d\u4f1a\u6539\u53d8 the data segment of the process \u3002 man7 brk(2) \u2014 Linux manual page brk() and sbrk() change the location of the program break, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment ).","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Data-segment/#data#segment","text":"","title":"Data segment"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Data-segment/#wikipedia#data#segment","text":"In computing , a data segment (often denoted .data ) is a portion of an object file or the corresponding address space of a program that contains initialized static variables , that is, global variables and static local variables . The size of this segment is determined by the size of the values in the program's source code, and does not change at run time . NOTE: \u5728\u4e00\u4e9b\u5176\u4ed6\u7684\u6587\u7ae0\u4e2d\uff0c\u4e5f\u4f7f\u7528\u4e86 data segment \u8fd9\u4e2a\u8bcd\uff0c\u5728\u5176\u4e2d\u7684\u4e00\u4e9b\u5185\u5bb9\u521d\u8bfb\u8d77\u6765\u662f\u4f1a\u548c\u4e0a\u9762\u7684\u6700\u540e\u4e00\u53e5\u8bdd \"and does not change at run time \" \u76f8\u77db\u76fe\u7684\uff0c\u5728\u4e0b\u9762\u7ae0\u8282\u4e2d\uff0c\u7f57\u5217\u4e86\u8fd9\u4e9b\u6587\u7ae0\uff0c\u8fd9\u4e9b\u6587\u7ae0\u4e3b\u8981\u662fLinux OS\u76f8\u5173\u7684\uff0c\u5176\u5b9e\u5b83\u4eec\u662f\u5e76\u4e0d\u77db\u76fe\u7684\uff0c\u8fd9\u4e9b\u6587\u7ae0\u7684\u5185\u5bb9\u6d89\u53ca\u5230\u4e86\u5e95\u5c42\u7684\u5b9e\u73b0\u7ec6\u8282\uff0c\u5f53\u6df1\u5165\u8fd9\u4e9b\u5b9e\u73b0\u7ec6\u8282\u540e\uff0c\u4f1a\u53d1\u73b0\u5b83\u4eec\u5176\u5b9e\u662f\u5e76\u4e0d\u77db\u76fe\u7684\u3002","title":"wikipedia Data segment"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Data-segment/#use#case","text":"\u4e0b\u9762\u8fd9\u4e9b\u6587\u7ae0\u4e2d\uff0c\u4e5f\u4f7f\u7528\u4e86data segment\u8fd9\u4e2a\u8bcd\u8bed\uff0c\u521d\u8bfb\u8d77\u6765\uff0c\u662f\u548c wikipedia Data segment \u4e2d\u7684 \"The size of this segment is determined by the size of the values in the program's source code, and does not change at run time \" \u76f8\u77db\u76fe\u7684\uff0c\u53c2\u770b Kernel\\Guide\\Multitasking\\Process-model\\Process-resource\\Process-memory-model\\Linux-implementation \u7ae0\u8282\u5b66\u4e60\u5b9e\u73b0\u7ec6\u8282\u540e\uff0c\u4ece\u5b9e\u73b0\u89d2\u5ea6\u6765\u770b\uff0c\u5b83\u4eec\u662f\u5e76\u4e0d\u77db\u76fe\u7684\u3002","title":"Use case"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Data-segment/#wikipedia#c#dynamic#memory#allocation#implementations#heap-based","text":"Implementation of the allocator is commonly done using the heap , or data segment . The allocator will usually expand and contract the heap to fulfill allocation requests.","title":"wikipedia C dynamic memory allocation # Implementations # Heap-based"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Data-segment/#wikipedia#sbrk","text":"brk and sbrk are basic memory management system calls used in Unix and Unix-like operating systems to control the amount of memory allocated to the data segment of the process .[ 1] NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\uff0c\u8bf4\u660e\u4e86\u5728Linux OS\u4e2d\u7684implementation\u4e2d\u4f1a\u6539\u53d8 the data segment of the process \u3002","title":"wikipedia sbrk"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Data-segment/#man7#brk2#linux#manual#page","text":"brk() and sbrk() change the location of the program break, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment ).","title":"man7 brk(2) \u2014 Linux manual page"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Heap/","text":"Heap wikipedia Data segment # Program memory # Heap The heap area commonly begins at the end of the .bss and .data segments and grows to larger addresses from there. The heap area is managed by malloc , calloc, realloc, and free, which may use the brk and sbrk system calls to adjust its size (note that the use of brk/sbrk and a single \"heap area\" is not required to fulfill the contract(\u5408\u540c\u3001\u5951\u7ea6) of malloc/calloc/realloc/free; they may also be implemented using mmap /munmap to reserve/unreserve potentially non-contiguous regions of virtual memory into the process' virtual address space ). The heap area is shared by all threads, shared libraries, and dynamically loaded modules in a process. NOTE: OS\u91cd\u8981\u63d0\u4f9b\u4e86\u4e24\u79cd\u4f7f\u7528heap\u7684\u65b9\u5f0f: 1) malloc , calloc, realloc, and free 2) mmap /munmap","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Heap/#heap","text":"","title":"Heap"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Heap/#wikipedia#data#segment#program#memory#heap","text":"The heap area commonly begins at the end of the .bss and .data segments and grows to larger addresses from there. The heap area is managed by malloc , calloc, realloc, and free, which may use the brk and sbrk system calls to adjust its size (note that the use of brk/sbrk and a single \"heap area\" is not required to fulfill the contract(\u5408\u540c\u3001\u5951\u7ea6) of malloc/calloc/realloc/free; they may also be implemented using mmap /munmap to reserve/unreserve potentially non-contiguous regions of virtual memory into the process' virtual address space ). The heap area is shared by all threads, shared libraries, and dynamically loaded modules in a process. NOTE: OS\u91cd\u8981\u63d0\u4f9b\u4e86\u4e24\u79cd\u4f7f\u7528heap\u7684\u65b9\u5f0f: 1) malloc , calloc, realloc, and free 2) mmap /munmap","title":"wikipedia Data segment # Program memory # Heap"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Memory-mapped-file/","text":"Memory-mapped file wikipedia Memory-mapped file A memory-mapped file is a segment of virtual memory [ 1] that has been assigned a direct byte-for-byte correlation with some portion of a file or file-like resource. This resource is typically a file that is physically present on disk, but can also be a device, shared memory object, or other resource that the operating system can reference through a file descriptor . Once present, this correlation between the file and the memory space permits applications to treat the mapped portion as if it were primary memory. Common uses Perhaps the most common use for a memory-mapped file is the process loader in most modern operating systems (including Microsoft Windows and Unix-like systems.) When a process is started, the operating system uses a memory mapped file to bring the executable file, along with any loadable modules, into memory for execution. Most memory-mapping systems use a technique called demand paging , where the file is loaded into physical memory in subsets (one page each), and only when that page is actually referenced.[ 11] In the specific case of executable files, this permits the OS to selectively load only those portions of a process image that actually need to execute. Another common use for memory-mapped files is to share memory between multiple processes. In modern protected mode operating systems, processes are generally not permitted to access memory space that is allocated for use by another process. (A program's attempt to do so causes invalid page faults or segmentation violations .) There are a number of techniques available to safely share memory , and memory-mapped file I/O is one of the most popular. Two or more applications can simultaneously map a single physical file into memory and access this memory. For example, the Microsoft Windows operating system provides a mechanism for applications to memory-map a shared segment of the system's page file itself and share data via this section. NOTE: inter-process communication Platform support Some free portable implementations of memory-mapped files for Microsoft Windows and POSIX-compliant platforms are: Boost.Interprocess,[ 15] in Boost C++ Libraries Boost.Iostreams,[ 16] also in Boost C++ Libraries Fmstream[ 17] Cpp-mmf[ 18]","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Memory-mapped-file/#memory-mapped#file","text":"","title":"Memory-mapped file"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Memory-mapped-file/#wikipedia#memory-mapped#file","text":"A memory-mapped file is a segment of virtual memory [ 1] that has been assigned a direct byte-for-byte correlation with some portion of a file or file-like resource. This resource is typically a file that is physically present on disk, but can also be a device, shared memory object, or other resource that the operating system can reference through a file descriptor . Once present, this correlation between the file and the memory space permits applications to treat the mapped portion as if it were primary memory.","title":"wikipedia Memory-mapped file"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Memory-mapped-file/#common#uses","text":"Perhaps the most common use for a memory-mapped file is the process loader in most modern operating systems (including Microsoft Windows and Unix-like systems.) When a process is started, the operating system uses a memory mapped file to bring the executable file, along with any loadable modules, into memory for execution. Most memory-mapping systems use a technique called demand paging , where the file is loaded into physical memory in subsets (one page each), and only when that page is actually referenced.[ 11] In the specific case of executable files, this permits the OS to selectively load only those portions of a process image that actually need to execute. Another common use for memory-mapped files is to share memory between multiple processes. In modern protected mode operating systems, processes are generally not permitted to access memory space that is allocated for use by another process. (A program's attempt to do so causes invalid page faults or segmentation violations .) There are a number of techniques available to safely share memory , and memory-mapped file I/O is one of the most popular. Two or more applications can simultaneously map a single physical file into memory and access this memory. For example, the Microsoft Windows operating system provides a mechanism for applications to memory-map a shared segment of the system's page file itself and share data via this section. NOTE: inter-process communication","title":"Common uses"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Memory-mapped-file/#platform#support","text":"Some free portable implementations of memory-mapped files for Microsoft Windows and POSIX-compliant platforms are: Boost.Interprocess,[ 15] in Boost C++ Libraries Boost.Iostreams,[ 16] also in Boost C++ Libraries Fmstream[ 17] Cpp-mmf[ 18]","title":"Platform support"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bba\u548cstack\u548cheap\u3002 stackoverflow What and where are the stack and heap? A The stack is the memory set aside as scratch space for a thread of execution. When a function is called, a block is reserved on the top of the stack for local variables and some bookkeeping data. When that function returns, the block becomes unused and can be used the next time a function is called. The stack is always reserved in a LIFO (last in first out) order; the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack; freeing a block from the stack is nothing more than adjusting one pointer. The heap is memory set aside for dynamic allocation. Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune(\u534f\u8c03) heap performance for different usage patterns. Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation). To answer your questions directly: To what extent are they controlled by the OS or language runtime? The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application. What is their scope? The stack is attached to a thread, so when the thread exits the stack is reclaimed. The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits. What determines the size of each of them? The size of the stack is set when a thread is created. The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system). What makes one faster? The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or deallocation. Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe , i.e. each allocation and deallocation needs to be - typically - synchronized with \"all\" other heap accesses in the program. NOTE: \u4e0a\u8ff0\u662f Stack-VS-heap/Operation-on-stack-VS-on-heap \u3002 A clear demonstration: Image source: vikashazrati.wordpress.com programmerinterview What\u2019s the difference between a stack and a heap?","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/#_1","text":"\u672c\u7ae0\u8ba8\u8bba\u548cstack\u548cheap\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/#stackoverflow#what#and#where#are#the#stack#and#heap","text":"A The stack is the memory set aside as scratch space for a thread of execution. When a function is called, a block is reserved on the top of the stack for local variables and some bookkeeping data. When that function returns, the block becomes unused and can be used the next time a function is called. The stack is always reserved in a LIFO (last in first out) order; the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack; freeing a block from the stack is nothing more than adjusting one pointer. The heap is memory set aside for dynamic allocation. Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune(\u534f\u8c03) heap performance for different usage patterns. Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation). To answer your questions directly: To what extent are they controlled by the OS or language runtime? The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application. What is their scope? The stack is attached to a thread, so when the thread exits the stack is reclaimed. The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits. What determines the size of each of them? The size of the stack is set when a thread is created. The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system). What makes one faster? The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or deallocation. Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe , i.e. each allocation and deallocation needs to be - typically - synchronized with \"all\" other heap accesses in the program. NOTE: \u4e0a\u8ff0\u662f Stack-VS-heap/Operation-on-stack-VS-on-heap \u3002 A clear demonstration: Image source: vikashazrati.wordpress.com","title":"stackoverflow What and where are the stack and heap?"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/#programmerinterview#whats#the#difference#between#a#stack#and#a#heap","text":"","title":"programmerinterview What\u2019s the difference between a stack and a heap?"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/","text":"Operation on the stack VS operation on the heap \u5728\u5de5\u7a0bLinux-OS\u4e2d\uff0c\u5206\u6790\u4e86process\u7684memory model\uff0c\u5b83\u4e3b\u8981\u7531\u5982\u4e0b\u4e24\u90e8\u5206\u7ec4\u6210: 1 stack 2 heap \u90a3operation on the stack VS operation on the heap? \u4e0b\u9762\u662f\u5206\u6790\u7d20\u6750: \u7d20\u6750 1)stackoverflow Meaning of acronym SSO in the context of std::string # A Operations on automatic variables (\"from the stack\", which are variables that you create without calling malloc / new ) are generally much faster than those involving the free store (\"the heap\", which are variables that are created using new ). However, the size of automatic arrays is fixed at compile time, but the size of arrays from the free store is not. Moreover, the stack size is limited (typically a few MiB), whereas the free store is only limited by your system's memory. SSO is the Short / Small String Optimization . A std::string typically stores the string as a pointer to the free store (\"the heap\"), which gives similar performance characteristics as if you were to call new char [size] . This prevents a stack overflow for very large strings, but it can be slower, especially with copy operations . As an optimization, many implementations of std::string create a small automatic array , NOTE: C++\u4e2d\u7684\u5206\u7c7b: 1 automatic object 2 dynamic object \u4e0a\u8ff0operation\uff0c\u5305\u62ec\u4e86: 1 new 2) stackoverflow What and where are the stack and heap? # A The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or deallocation. Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe , i.e. each allocation and deallocation needs to be - typically - synchronized with \"all\" other heap accesses in the program. Benchmark \u524d\u9762\u7ed9\u51fa\u4e86\u7406\u8bba\u7684\u5206\u6790\uff0c\u90a3\u4e48\u6211\u4eec\u8981\u5982\u4f55\u6765\u8fdb\u884c\u9a8c\u8bc1\u5462? \u4e0b\u9762\u662f\u4ee5C++ std::string \u6765\u8fdb\u884c\u8bf4\u660e\u7684\u4f8b\u5b50\uff0c\u5173\u4e8eC++ std::string \u7684\u5b9e\u73b0\uff0c\u53c2\u89c1 \u5de5\u7a0bprogramming language\u7684 C-and-C++\\String\\C++string \u7ae0\u8282\uff0c\u5b83\u662f\u975e\u5e38\u80fd\u591f\u4f53\u73b0Operation on the stack VS operation on the heap: stackoverflow Meaning of acronym SSO in the context of std::string # A # Benchmarks As already explained by the other answers, SSO means Small / Short String Optimization . The motivation behind this optimization is the undeniable(\u4e0d\u53ef\u5426\u8ba4\u7684) evidence that applications in general handle much more shorter strings than longer strings. As explained by David Stone in his answer above , the std::string class uses an internal buffer to store contents up to a given length, and this eliminates the need to dynamically allocate memory. This makes the code more efficient and faster . This other related answer clearly shows that the size of the internal buffer depends on the std::string implementation, which varies from platform to platform (see benchmark results below). Here is a small program that benchmarks the copy operation of lots of strings with the same length. It starts printing the time to copy 10 million strings with length = 1. Then it repeats with strings of length = 2. It keeps going until the length is 50. #include <string> #include <iostream> #include <vector> #include <chrono> static const char CHARS [] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" ; static const int ARRAY_SIZE = sizeof ( CHARS ) - 1 ; static const int BENCHMARK_SIZE = 10000000 ; static const int MAX_STRING_LENGTH = 50 ; using time_point = std :: chrono :: high_resolution_clock :: time_point ; void benchmark ( std :: vector < std :: string > & list ) { std :: chrono :: high_resolution_clock :: time_point t1 = std :: chrono :: high_resolution_clock :: now (); // force a copy of each string in the loop iteration for ( const auto s : list ) { std :: cout << s ; } std :: chrono :: high_resolution_clock :: time_point t2 = std :: chrono :: high_resolution_clock :: now (); const auto duration = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( t2 - t1 ). count (); std :: cerr << list [ 0 ]. length () << ',' << duration << '\\n' ; } void addRandomString ( std :: vector < std :: string > & list , const int length ) { std :: string s ( length , 0 ); for ( int i = 0 ; i < length ; ++ i ) { s [ i ] = CHARS [ rand () % ARRAY_SIZE ]; } list . push_back ( s ); } int main () { std :: cerr << \"length,time \\n \" ; for ( int length = 1 ; length <= MAX_STRING_LENGTH ; length ++ ) { std :: vector < std :: string > list ; for ( int i = 0 ; i < BENCHMARK_SIZE ; i ++ ) { addRandomString ( list , length ); } benchmark ( list ); } return 0 ; } // g++ --std=c++11 test.cpp If you want to run this program, you should do it like ./a.out > /dev/null so that the time to print the strings isn't counted. The numbers that matter are printed to stderr , so they will show up in the console. I have created charts with the output from my MacBook and Ubuntu machines. Note that there is a huge jump in the time to copy the strings when the length reaches a given point. That's the moment when strings don't fit in the internal buffer anymore and memory allocation has to be used. Note also that on the linux machine, the jump happens when the length of the string reaches 16. On the macbook, the jump happens when the length reaches 23. This confirms that SSO depends on the platform implementation. Optimization \u907f\u514dsystem call new heap allocation \u7531\u4e8e\u76f8\u6bd4\u4e0eautomatic object\uff0csystem call new heap allocation\u4e00\u4e2adynamic object\u662f\u975e\u5e38\u8017\u65f6\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u5c3d\u53ef\u80fd\u5730**\u907f\u514dsystem call new heap allocation**: \u4e0b\u9762\u662f\u4e00\u4e9b\u4f8b\u5b50: Producer/consumer\u6a21\u578b \u5728producer/consumer\u6a21\u578b\u4e2d\uff0c\u6bcf\u6b21\u90fd\u8c03\u7528system call new\u51fa\u4e00\u4e2amessage\uff0c\u8fd9\u662f\u975e\u5e38\u4f4e\u6548\u7684\uff0c\u800c\u662f\u5e94\u8be5: 1) \u4f7f\u7528buffer/cache/queue\uff0c\u63d0\u524d\u5206\u914d\u597d\u5185\u5b58\u7a7a\u95f4\uff0c\u7136\u540e\u5411\u8fd9\u4e2abuffer/cache/queue\u8fdb\u884cread/write\uff0c\u65e0\u8bba\u662fread\u8fd8\u662fwrite\uff0c\u5176\u5b9e\u6240\u5bf9\u5e94\u7684\u90fd\u662fcopy\uff0c\u76f8\u6bd4\u4e8esystem call\u800c\u8a00\uff0ccopy\u662f\u66f4\u52a0\u9ad8\u6548\u7684 2) \u5bf9\u4e8emessage\uff0c\u6700\u597d\u4f7f\u7528automatic object\uff0c\u901a\u8fc7copy to/from buffer/cache/queue \u6700\u6700\u5178\u578b\u7684\u4f8b\u5b50\u662fspdlog asynchronous\u7684\u505a\u6cd5\u3002 C++ std::string SSO \u907f\u514d\u6bcf\u6b21system call new heap allocation\u7684\u53e6\u5916\u4e00\u4e2a\u4f8b\u5b50\u662fC++ std::string SSO\uff0c\u53c2\u89c1\u5de5\u7a0bprogramming language\u7684 C-and-C++\\String\\C++string \u7ae0\u8282\u3002 thoughts \u76f8\u6bd4\u4e8ecopy\u3001move\uff0cnew\u624d\u662f\u6162\u7684","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#operation#on#the#stack#vs#operation#on#the#heap","text":"\u5728\u5de5\u7a0bLinux-OS\u4e2d\uff0c\u5206\u6790\u4e86process\u7684memory model\uff0c\u5b83\u4e3b\u8981\u7531\u5982\u4e0b\u4e24\u90e8\u5206\u7ec4\u6210: 1 stack 2 heap \u90a3operation on the stack VS operation on the heap? \u4e0b\u9762\u662f\u5206\u6790\u7d20\u6750:","title":"Operation on the stack VS operation on the heap"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#_1","text":"","title":"\u7d20\u6750"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#1stackoverflow#meaning#of#acronym#sso#in#the#context#of#stdstring#a","text":"Operations on automatic variables (\"from the stack\", which are variables that you create without calling malloc / new ) are generally much faster than those involving the free store (\"the heap\", which are variables that are created using new ). However, the size of automatic arrays is fixed at compile time, but the size of arrays from the free store is not. Moreover, the stack size is limited (typically a few MiB), whereas the free store is only limited by your system's memory. SSO is the Short / Small String Optimization . A std::string typically stores the string as a pointer to the free store (\"the heap\"), which gives similar performance characteristics as if you were to call new char [size] . This prevents a stack overflow for very large strings, but it can be slower, especially with copy operations . As an optimization, many implementations of std::string create a small automatic array , NOTE: C++\u4e2d\u7684\u5206\u7c7b: 1 automatic object 2 dynamic object \u4e0a\u8ff0operation\uff0c\u5305\u62ec\u4e86: 1 new","title":"1)stackoverflow Meaning of acronym SSO in the context of std::string # A"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#2#stackoverflow#what#and#where#are#the#stack#and#heap#a","text":"The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or deallocation. Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe , i.e. each allocation and deallocation needs to be - typically - synchronized with \"all\" other heap accesses in the program.","title":"2) stackoverflow What and where are the stack and heap? # A"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#benchmark","text":"\u524d\u9762\u7ed9\u51fa\u4e86\u7406\u8bba\u7684\u5206\u6790\uff0c\u90a3\u4e48\u6211\u4eec\u8981\u5982\u4f55\u6765\u8fdb\u884c\u9a8c\u8bc1\u5462? \u4e0b\u9762\u662f\u4ee5C++ std::string \u6765\u8fdb\u884c\u8bf4\u660e\u7684\u4f8b\u5b50\uff0c\u5173\u4e8eC++ std::string \u7684\u5b9e\u73b0\uff0c\u53c2\u89c1 \u5de5\u7a0bprogramming language\u7684 C-and-C++\\String\\C++string \u7ae0\u8282\uff0c\u5b83\u662f\u975e\u5e38\u80fd\u591f\u4f53\u73b0Operation on the stack VS operation on the heap:","title":"Benchmark"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#stackoverflow#meaning#of#acronym#sso#in#the#context#of#stdstring#a#benchmarks","text":"As already explained by the other answers, SSO means Small / Short String Optimization . The motivation behind this optimization is the undeniable(\u4e0d\u53ef\u5426\u8ba4\u7684) evidence that applications in general handle much more shorter strings than longer strings. As explained by David Stone in his answer above , the std::string class uses an internal buffer to store contents up to a given length, and this eliminates the need to dynamically allocate memory. This makes the code more efficient and faster . This other related answer clearly shows that the size of the internal buffer depends on the std::string implementation, which varies from platform to platform (see benchmark results below). Here is a small program that benchmarks the copy operation of lots of strings with the same length. It starts printing the time to copy 10 million strings with length = 1. Then it repeats with strings of length = 2. It keeps going until the length is 50. #include <string> #include <iostream> #include <vector> #include <chrono> static const char CHARS [] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" ; static const int ARRAY_SIZE = sizeof ( CHARS ) - 1 ; static const int BENCHMARK_SIZE = 10000000 ; static const int MAX_STRING_LENGTH = 50 ; using time_point = std :: chrono :: high_resolution_clock :: time_point ; void benchmark ( std :: vector < std :: string > & list ) { std :: chrono :: high_resolution_clock :: time_point t1 = std :: chrono :: high_resolution_clock :: now (); // force a copy of each string in the loop iteration for ( const auto s : list ) { std :: cout << s ; } std :: chrono :: high_resolution_clock :: time_point t2 = std :: chrono :: high_resolution_clock :: now (); const auto duration = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( t2 - t1 ). count (); std :: cerr << list [ 0 ]. length () << ',' << duration << '\\n' ; } void addRandomString ( std :: vector < std :: string > & list , const int length ) { std :: string s ( length , 0 ); for ( int i = 0 ; i < length ; ++ i ) { s [ i ] = CHARS [ rand () % ARRAY_SIZE ]; } list . push_back ( s ); } int main () { std :: cerr << \"length,time \\n \" ; for ( int length = 1 ; length <= MAX_STRING_LENGTH ; length ++ ) { std :: vector < std :: string > list ; for ( int i = 0 ; i < BENCHMARK_SIZE ; i ++ ) { addRandomString ( list , length ); } benchmark ( list ); } return 0 ; } // g++ --std=c++11 test.cpp If you want to run this program, you should do it like ./a.out > /dev/null so that the time to print the strings isn't counted. The numbers that matter are printed to stderr , so they will show up in the console. I have created charts with the output from my MacBook and Ubuntu machines. Note that there is a huge jump in the time to copy the strings when the length reaches a given point. That's the moment when strings don't fit in the internal buffer anymore and memory allocation has to be used. Note also that on the linux machine, the jump happens when the length of the string reaches 16. On the macbook, the jump happens when the length reaches 23. This confirms that SSO depends on the platform implementation.","title":"stackoverflow Meaning of acronym SSO in the context of std::string # A # Benchmarks"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#optimization","text":"","title":"Optimization"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#system#call#new#heap#allocation","text":"\u7531\u4e8e\u76f8\u6bd4\u4e0eautomatic object\uff0csystem call new heap allocation\u4e00\u4e2adynamic object\u662f\u975e\u5e38\u8017\u65f6\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u5c3d\u53ef\u80fd\u5730**\u907f\u514dsystem call new heap allocation**: \u4e0b\u9762\u662f\u4e00\u4e9b\u4f8b\u5b50:","title":"\u907f\u514dsystem call new heap allocation"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#producerconsumer","text":"\u5728producer/consumer\u6a21\u578b\u4e2d\uff0c\u6bcf\u6b21\u90fd\u8c03\u7528system call new\u51fa\u4e00\u4e2amessage\uff0c\u8fd9\u662f\u975e\u5e38\u4f4e\u6548\u7684\uff0c\u800c\u662f\u5e94\u8be5: 1) \u4f7f\u7528buffer/cache/queue\uff0c\u63d0\u524d\u5206\u914d\u597d\u5185\u5b58\u7a7a\u95f4\uff0c\u7136\u540e\u5411\u8fd9\u4e2abuffer/cache/queue\u8fdb\u884cread/write\uff0c\u65e0\u8bba\u662fread\u8fd8\u662fwrite\uff0c\u5176\u5b9e\u6240\u5bf9\u5e94\u7684\u90fd\u662fcopy\uff0c\u76f8\u6bd4\u4e8esystem call\u800c\u8a00\uff0ccopy\u662f\u66f4\u52a0\u9ad8\u6548\u7684 2) \u5bf9\u4e8emessage\uff0c\u6700\u597d\u4f7f\u7528automatic object\uff0c\u901a\u8fc7copy to/from buffer/cache/queue \u6700\u6700\u5178\u578b\u7684\u4f8b\u5b50\u662fspdlog asynchronous\u7684\u505a\u6cd5\u3002","title":"Producer/consumer\u6a21\u578b"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#c#stdstring#sso","text":"\u907f\u514d\u6bcf\u6b21system call new heap allocation\u7684\u53e6\u5916\u4e00\u4e2a\u4f8b\u5b50\u662fC++ std::string SSO\uff0c\u53c2\u89c1\u5de5\u7a0bprogramming language\u7684 C-and-C++\\String\\C++string \u7ae0\u8282\u3002","title":"C++ std::string SSO"},{"location":"Kernel/Guide/Multitasking/Process-model/Process-resource/Process-memory-model/Virtual-address-space/Segment/Stack-VS-heap/Operation-on-stack-VS-on-heap/#thoughts","text":"\u76f8\u6bd4\u4e8ecopy\u3001move\uff0cnew\u624d\u662f\u6162\u7684","title":"thoughts"},{"location":"Kernel/Guide/Multitasking/Sched/","text":"","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Sched/Context-switch/","text":"Context switch In computing, a context switch is the process of storing the state of a process or of a thread , so that it can be restored and execution resumed from the same point later. This allows multiple processes to share a single CPU , and is an essential feature of a multitasking operating system . The precise meaning of the phrase \u201ccontext switch\u201d varies significantly in usage. In a multitasking context , it refers to the process of storing the system state for one task, so that task can be paused and another task resumed. A context switch can also occur as the result of an interrupt , such as when a task needs to access disk storage , freeing up CPU time for other tasks. Some operating systems also require a context switch to move between user mode and kernel mode tasks. The process of context switching can have a negative impact on system performance, although the size of this effect depends on the nature of the switch being performed. Cost Context switches are usually computationally intensive \uff08\u8ba1\u7b97\u5bc6\u96c6\u578b\u7684\uff09, and much of the design of operating systems is to optimize the use of context switches . Switching from one process to another requires a certain amount of time for doing the administration\uff08\u7ba1\u7406\uff09 \u2013 saving and loading registers and memory maps, updating various tables and lists, etc. What is actually involved in a context switch varies between these senses and between processors and operating systems. For example, in the Linux kernel , context switching involves switching registers, stack pointer, and program counter , but is independent of address space switching, though in a process switch an address space switch also happens. Further still, analogous context switching happens between user threads , notably green threads , and is often very light-weight, saving and restoring minimal context. In extreme cases, such as switching between goroutines in Go , a context switch is equivalent to a coroutine yield, which is only marginally\uff08\u7a0d\u5fae\uff09 more expensive than a subroutine call. When to switch There are three potential triggers for a context switch: Multitasking Most commonly, within some scheduling scheme, one process must be switched out of the CPU so another process can run. This context switch can be triggered by the process making itself unrunnable, such as by waiting for an I/O or synchronization operation to complete. On a pre-emptive multitasking system, the scheduler may also switch out processes which are still runnable. To prevent other processes from being starved of CPU time, preemptive schedulers often configure a timer interrupt to fire when a process exceeds its time slice . This interrupt ensures that the scheduler will gain control to perform a context switch. Interrupt handling Modern architectures are interrupt driven. This means that if the CPU requests data from a disk, for example, it does not need to busy-wait until the read is over; it can issue the request and continue with some other execution. When the read is over, the CPU can be interrupted and presented with the read. For interrupts, a program called an interrupt handler is installed, and it is the interrupt handler that handles the interrupt from the disk. When an interrupt occurs, the hardware automatically switches a part of the context (at least enough to allow the handler to return to the interrupted code). The handler may save additional context, depending on details of the particular hardware and software designs. Often only a minimal part of the context is changed in order to minimize the amount of time spent handling the interrupt. The kernel does not spawn or schedule a special process to handle interrupts, but instead the handler executes in the (often partial) context established at the beginning of interrupt handling. Once interrupt servicing is complete, the context in effect before the interrupt occurred is restored so that the interrupted process can resume execution in its proper state. User and kernel mode switching When a transition between user mode and kernel mode is required in an operating system, a context switch is not necessary; a mode transition is not by itself a context switch. However, depending on the operating system, a context switch may also take place at this time. Steps In a switch, the state of process currently executing must be saved somehow, so that when it is rescheduled, this state can be restored. The process state includes all the registers that the process may be using, especially the program counter , plus any other operating system specific data that may be necessary. This is usually stored in a data structure called a process control block (PCB) or switchframe . The PCB might be stored on a per-process stack in kernel memory (as opposed to the user-mode call stack ), or there may be some specific operating system defined data structure for this information. A handle to the PCB is added to a queue of processes that are ready to run, often called the ready queue . Since the operating system has effectively suspended the execution of one process, it can then switch context by choosing a process from the ready queue and restoring its PCB. In doing so, the program counter from the PCB is loaded, and thus execution can continue in the chosen process. Process and thread priority can influence which process is chosen from the ready queue (i.e., it may be a priority queue ).","title":"Context-switch"},{"location":"Kernel/Guide/Multitasking/Sched/Context-switch/#context#switch","text":"In computing, a context switch is the process of storing the state of a process or of a thread , so that it can be restored and execution resumed from the same point later. This allows multiple processes to share a single CPU , and is an essential feature of a multitasking operating system . The precise meaning of the phrase \u201ccontext switch\u201d varies significantly in usage. In a multitasking context , it refers to the process of storing the system state for one task, so that task can be paused and another task resumed. A context switch can also occur as the result of an interrupt , such as when a task needs to access disk storage , freeing up CPU time for other tasks. Some operating systems also require a context switch to move between user mode and kernel mode tasks. The process of context switching can have a negative impact on system performance, although the size of this effect depends on the nature of the switch being performed.","title":"Context switch"},{"location":"Kernel/Guide/Multitasking/Sched/Context-switch/#cost","text":"Context switches are usually computationally intensive \uff08\u8ba1\u7b97\u5bc6\u96c6\u578b\u7684\uff09, and much of the design of operating systems is to optimize the use of context switches . Switching from one process to another requires a certain amount of time for doing the administration\uff08\u7ba1\u7406\uff09 \u2013 saving and loading registers and memory maps, updating various tables and lists, etc. What is actually involved in a context switch varies between these senses and between processors and operating systems. For example, in the Linux kernel , context switching involves switching registers, stack pointer, and program counter , but is independent of address space switching, though in a process switch an address space switch also happens. Further still, analogous context switching happens between user threads , notably green threads , and is often very light-weight, saving and restoring minimal context. In extreme cases, such as switching between goroutines in Go , a context switch is equivalent to a coroutine yield, which is only marginally\uff08\u7a0d\u5fae\uff09 more expensive than a subroutine call.","title":"Cost"},{"location":"Kernel/Guide/Multitasking/Sched/Context-switch/#when#to#switch","text":"There are three potential triggers for a context switch:","title":"When to switch"},{"location":"Kernel/Guide/Multitasking/Sched/Context-switch/#multitasking","text":"Most commonly, within some scheduling scheme, one process must be switched out of the CPU so another process can run. This context switch can be triggered by the process making itself unrunnable, such as by waiting for an I/O or synchronization operation to complete. On a pre-emptive multitasking system, the scheduler may also switch out processes which are still runnable. To prevent other processes from being starved of CPU time, preemptive schedulers often configure a timer interrupt to fire when a process exceeds its time slice . This interrupt ensures that the scheduler will gain control to perform a context switch.","title":"Multitasking"},{"location":"Kernel/Guide/Multitasking/Sched/Context-switch/#interrupt#handling","text":"Modern architectures are interrupt driven. This means that if the CPU requests data from a disk, for example, it does not need to busy-wait until the read is over; it can issue the request and continue with some other execution. When the read is over, the CPU can be interrupted and presented with the read. For interrupts, a program called an interrupt handler is installed, and it is the interrupt handler that handles the interrupt from the disk. When an interrupt occurs, the hardware automatically switches a part of the context (at least enough to allow the handler to return to the interrupted code). The handler may save additional context, depending on details of the particular hardware and software designs. Often only a minimal part of the context is changed in order to minimize the amount of time spent handling the interrupt. The kernel does not spawn or schedule a special process to handle interrupts, but instead the handler executes in the (often partial) context established at the beginning of interrupt handling. Once interrupt servicing is complete, the context in effect before the interrupt occurred is restored so that the interrupted process can resume execution in its proper state.","title":"Interrupt handling"},{"location":"Kernel/Guide/Multitasking/Sched/Context-switch/#user#and#kernel#mode#switching","text":"When a transition between user mode and kernel mode is required in an operating system, a context switch is not necessary; a mode transition is not by itself a context switch. However, depending on the operating system, a context switch may also take place at this time.","title":"User and kernel mode switching"},{"location":"Kernel/Guide/Multitasking/Sched/Context-switch/#steps","text":"In a switch, the state of process currently executing must be saved somehow, so that when it is rescheduled, this state can be restored. The process state includes all the registers that the process may be using, especially the program counter , plus any other operating system specific data that may be necessary. This is usually stored in a data structure called a process control block (PCB) or switchframe . The PCB might be stored on a per-process stack in kernel memory (as opposed to the user-mode call stack ), or there may be some specific operating system defined data structure for this information. A handle to the PCB is added to a queue of processes that are ready to run, often called the ready queue . Since the operating system has effectively suspended the execution of one process, it can then switch context by choosing a process from the ready queue and restoring its PCB. In doing so, the program counter from the PCB is loaded, and thus execution can continue in the chosen process. Process and thread priority can influence which process is chosen from the ready queue (i.e., it may be a priority queue ).","title":"Steps"},{"location":"Kernel/Guide/Multitasking/Sched/Unix-Scheduler-and-Dispatcher/","text":"Keeping track of processes Processes (PCBs) are manipulated by two main components of the OS in order to achieve the effects of multiprogramming: - Scheduler : determines the order in which processes will gain access to the CPU. Efficiency and fair-play are issues here. - Dispatcher : actually allocates CPU to the process selected by the scheduler .","title":"Unix-Scheduler-and-Dispatcher"},{"location":"Kernel/Guide/Multitasking/Sched/Unix-Scheduler-and-Dispatcher/#keeping#track#of#processes","text":"Processes (PCBs) are manipulated by two main components of the OS in order to achieve the effects of multiprogramming: - Scheduler : determines the order in which processes will gain access to the CPU. Efficiency and fair-play are issues here. - Dispatcher : actually allocates CPU to the process selected by the scheduler .","title":"Keeping track of processes"},{"location":"Kernel/Guide/Multitasking/Sched/man-7-sched/","text":"SCHED(7)","title":"man-7-sched"},{"location":"Kernel/Guide/Multitasking/Sched/man-7-sched/#sched7","text":"","title":"SCHED(7)"},{"location":"Kernel/Guide/Multitasking/Sched/Cooperative-multitasking/","text":"Cooperative multitasking wikipedia Cooperative multitasking Cooperative multitasking , also known as non-preemptive multitasking , is a style of computer multitasking in which the operating system never initiates a context switch from a running process to another process. Instead, processes voluntarily yield control periodically(\u5b9a\u671f\u7684) or when idle or logically blocked in order to enable multiple applications to be run concurrently. This type of multitasking is called \"cooperative\" because all programs must cooperate for the entire scheduling scheme to work. In this scheme, the process scheduler of an operating system is known as a cooperative scheduler , having its role reduced down to starting the processes and letting them return control back to it voluntarily.[ 1] [ 2] NOTE: \u7531process\u4e3b\u52a8 yield control\uff0c\u800c\u4e0d\u662f\u6709operating system\uff1b Usage Although it is rarely used in modern larger systems, it is widely used in memory-constrained embedded systems and also, in specific applications such as CICS or the JES2 subsystem. Cooperative multitasking was the primary scheduling scheme for 16-bit applications employed by Microsoft Windows before Windows 95 and Windows NT (such as Windows 3.1x ), and by the classic Mac OS . Windows 9x used non- preemptive multitasking for 16-bit legacy applications, and the PowerPC Versions of Mac OS X prior to Leopard used it for classic applications.[ 1] NetWare , which is a network-oriented operating system, used cooperative multitasking up to NetWare 6.5. Cooperative multitasking is still used on RISC OS systems.[ 3] Cooperative multitasking is used with await in languages with a single-threaded event-loop in their runtime, like JavaScript or Python. Problems As a cooperatively multitasked system relies on each process regularly giving up time to other processes on the system, one poorly designed program can consume all of the CPU time for itself, either by performing extensive calculations or by busy waiting ; both would cause the whole system to hang . In a server environment, this is a hazard that makes the entire environment unacceptably fragile.[ 1] However, cooperative multitasking allows much simpler implementation of applications because their execution is never unexpectedly interrupted by the process scheduler; for example, various functions inside the application do not need to be reentrant .[ 2] In contrast, preemptive multitasking interrupts applications and gives control to other processes outside the application's control. See also Preemptive multitasking","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Sched/Cooperative-multitasking/#cooperative#multitasking","text":"","title":"Cooperative multitasking"},{"location":"Kernel/Guide/Multitasking/Sched/Cooperative-multitasking/#wikipedia#cooperative#multitasking","text":"Cooperative multitasking , also known as non-preemptive multitasking , is a style of computer multitasking in which the operating system never initiates a context switch from a running process to another process. Instead, processes voluntarily yield control periodically(\u5b9a\u671f\u7684) or when idle or logically blocked in order to enable multiple applications to be run concurrently. This type of multitasking is called \"cooperative\" because all programs must cooperate for the entire scheduling scheme to work. In this scheme, the process scheduler of an operating system is known as a cooperative scheduler , having its role reduced down to starting the processes and letting them return control back to it voluntarily.[ 1] [ 2] NOTE: \u7531process\u4e3b\u52a8 yield control\uff0c\u800c\u4e0d\u662f\u6709operating system\uff1b","title":"wikipedia Cooperative multitasking"},{"location":"Kernel/Guide/Multitasking/Sched/Cooperative-multitasking/#usage","text":"Although it is rarely used in modern larger systems, it is widely used in memory-constrained embedded systems and also, in specific applications such as CICS or the JES2 subsystem. Cooperative multitasking was the primary scheduling scheme for 16-bit applications employed by Microsoft Windows before Windows 95 and Windows NT (such as Windows 3.1x ), and by the classic Mac OS . Windows 9x used non- preemptive multitasking for 16-bit legacy applications, and the PowerPC Versions of Mac OS X prior to Leopard used it for classic applications.[ 1] NetWare , which is a network-oriented operating system, used cooperative multitasking up to NetWare 6.5. Cooperative multitasking is still used on RISC OS systems.[ 3] Cooperative multitasking is used with await in languages with a single-threaded event-loop in their runtime, like JavaScript or Python.","title":"Usage"},{"location":"Kernel/Guide/Multitasking/Sched/Cooperative-multitasking/#problems","text":"As a cooperatively multitasked system relies on each process regularly giving up time to other processes on the system, one poorly designed program can consume all of the CPU time for itself, either by performing extensive calculations or by busy waiting ; both would cause the whole system to hang . In a server environment, this is a hazard that makes the entire environment unacceptably fragile.[ 1] However, cooperative multitasking allows much simpler implementation of applications because their execution is never unexpectedly interrupted by the process scheduler; for example, various functions inside the application do not need to be reentrant .[ 2] In contrast, preemptive multitasking interrupts applications and gives control to other processes outside the application's control.","title":"Problems"},{"location":"Kernel/Guide/Multitasking/Sched/Cooperative-multitasking/#see#also","text":"Preemptive multitasking","title":"See also"},{"location":"Kernel/Guide/Multitasking/Sched/Preemptive-multitasking/","text":"Preemption (computing) In computing , preemption is the act of temporarily interrupting a task being carried out by a computer system , without requiring its cooperation, and with the intention of resuming the task at a later time. Such changes of the executed task are known as context switches . It is normally carried out by a privileged task or part of the system known as a preemptive scheduler , which has the power to preempt , or interrupt, and later resume, other tasks in the system. User mode and kernel mode see also: Kernel preemption In any given system design, some operations performed by the system may not be preemptible\uff08\u53ef\u62a2\u5360\u7684\uff09. This usually applies to kernel functions and service interrupts which, if not permitted to run to completion \uff08\u8fd0\u884c\u5b8c\u6210\uff09, would tend to produce race conditions resulting in deadlock . Barring\uff08\u7981\u6b62\uff09 the scheduler from preempting tasks while they are processing kernel functions simplifies the kernel design at the expense of system responsiveness\uff08 \u7981\u6b62\u8c03\u5ea6\u7a0b\u5e8f\u5728\u5904\u7406\u5185\u6838\u51fd\u6570\u65f6\u62a2\u5360\u4efb\u52a1\uff0c\u4ece\u800c\u4ee5\u7cfb\u7edf\u54cd\u5e94\u4e3a\u4ee3\u4ef7\u7b80\u5316\u5185\u6838\u8bbe\u8ba1\uff09. The distinction between user mode and kernel mode , which determines privilege level within the system, may also be used to distinguish whether a task is currently preemptible. Most modern systems have preemptive kernels , designed to permit tasks to be preempted even when in kernel mode. Examples of such systems are Solaris 2.0/SunOS 5.0,[ 1] Windows NT , Linux kernel (2.6.x and newer), AIX and some BSD systems ( NetBSD , since version 5). Preemptive multitasking The term preemptive multitasking is used to distinguish a multitasking operating system , which permits preemption of tasks\uff08\u5141\u8bb8\u62a2\u5360\u4efb\u52a1\uff09, from a cooperative multitasking system wherein processes or tasks must be explicitly programmed to yield \uff08\u653e\u5f03\u6267\u884c\uff0c\u8ba9\u6e21\uff09 when they do not need system resources. In simple terms: Preemptive multitasking involves the use of an interrupt mechanism which suspends the currently executing process and invokes a scheduler to determine which process should execute next. Therefore, all processes will get some amount of CPU time at any given time. In preemptive multitasking, the operating system kernel can also initiate a context switch to satisfy the scheduling policy 's priority constraint, thus preempting\uff08\u62a2\u5360\uff09 the active task. In general, preemption means \"prior seizure of\". When the high priority task at that instance seizes\uff08\u593a\u53d6\uff09 the currently running task, it is known as preemptive scheduling (\u62a2\u5360\u5f0f\u8c03\u5ea6\uff09. The term \"preemptive multitasking\" is sometimes mistakenly used when the intended meaning is more specific, referring instead to the class of scheduling policies known as time-shared scheduling , or time-sharing . Preemptive multitasking allows the computer system to more reliably guarantee each process a regular \"slice\" of operating time. It also allows the system to rapidly deal with important external events like incoming data, which might require the immediate attention of one or another process. At any specific time, processes can be grouped into two categories: those that are waiting for input or output (called \" I/O bound \"), and those that are fully utilizing the CPU (\" CPU bound \"). In early systems, processes would often \"poll\", or \" busywait \" while waiting for requested input (such as disk, keyboard or network input). During this time, the process was not performing useful work, but still maintained complete control of the CPU. With the advent of interrupts and preemptive multitasking , these I/O bound processes could be \"blocked\", or put on hold, pending the arrival of the necessary data, allowing other processes to utilize the CPU. As the arrival of the requested data would generate an interrupt, blocked processes could be guaranteed a timely return to execution. Although multitasking techniques were originally developed to allow multiple users to share a single machine, it soon became apparent that multitasking was useful regardless of the number of users. Many operating systems, from mainframes down to single-user personal computers and no-user control systems (like those in robotic spacecraft ), have recognized the usefulness of multitasking support for a variety of reasons. Multitasking makes it possible for a single user to run multiple applications at the same time, or to run \"background\" processes while retaining control of the computer. Time slice The period of time for which a process is allowed to run in a preemptive multitasking system is generally called the time slice or quantum . The scheduler is run once every time slice to choose the next process to run. The length of each time slice can be critical to balancing system performance vs process responsiveness - if the time slice is too short then the scheduler will consume too much processing time, but if the time slice is too long, processes will take longer to respond to input. An interrupt is scheduled to allow the operating system kernel to switch between processes when their time slices expire, effectively allowing the processor\u2019s time to be shared between a number of tasks, giving the illusion that it is dealing with these tasks in parallel (simultaneously). The operating system which controls such a design is called a multi-tasking system. System support Today, nearly all operating systems support preemptive multitasking , including the current versions of Windows , macOS , Linux (including Android ) and iOS . Some of the earliest operating systems available to home users featuring preemptive multitasking were Sinclair QDOS (1984[ 2] ) and Amiga OS (1985). These both ran on Motorola 68000 -family microprocessors without memory management. Amiga OS used dynamic loading of relocatable code blocks (\" hunks \" in Amiga jargon) to multitask preemptively all processes in the same flat address space. Early PC operating systems such as MS-DOS and PC DOS , did not support multitasking at all, however alternative operating systems such as MP/M-86 (1981) and Concurrent CP/M-86 did support preemptive multitasking. Other Unix-like systems including MINIX and Coherent provided preemptive multitasking on 1980s-era personal computers. Later DOS versions natively supporting preemptive multitasking/multithreading include Concurrent DOS , Multiuser DOS , Novell DOS (later called Caldera OpenDOS and DR-DOS 7.02 and higher). Since Concurrent DOS 386 , they could also run multiple DOS programs concurrently in virtual DOS machines . The earliest version of Windows to support a limited form of preemptive multitasking was Windows 2.1x , which used the Intel 80386 's Virtual 8086 mode to run DOS applications in virtual 8086 machines , commonly known as \"DOS boxes\", which could be preempted. In Windows 95, 98 and Me , 32-bit applications were made preemptive by running each one in a separate address space, but 16-bit applications remained cooperative for backward compatibility.[ 3] In Windows 3.1x (protected mode), the kernel and virtual device drivers ran preemptively, but all 16-bit applications were non-preemptive and shared the same address space. Preemptive multitasking has always been supported by Windows NT (all versions), OS/2 (native applications), Unix and Unix-like systems (such as Linux , BSD and macOS ), VMS , OS/360 , and many other operating systems designed for use in the academic and medium-to-large business markets. Although there were plans to upgrade the cooperative multitasking found in the classic Mac OS to a preemptive model (and a preemptive API did exist in Mac OS 9 , although in a limited sense[ 4] ), these were abandoned in favor of Mac OS X (now called macOS) that, as a hybrid of the old Mac System style and NeXTSTEP , is an operating system based on the Mach kernel and derived in part from BSD , which had always provided Unix-like preemptive multitasking.","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Sched/Preemptive-multitasking/#preemption#computing","text":"In computing , preemption is the act of temporarily interrupting a task being carried out by a computer system , without requiring its cooperation, and with the intention of resuming the task at a later time. Such changes of the executed task are known as context switches . It is normally carried out by a privileged task or part of the system known as a preemptive scheduler , which has the power to preempt , or interrupt, and later resume, other tasks in the system.","title":"Preemption (computing)"},{"location":"Kernel/Guide/Multitasking/Sched/Preemptive-multitasking/#user#mode#and#kernel#mode","text":"see also: Kernel preemption In any given system design, some operations performed by the system may not be preemptible\uff08\u53ef\u62a2\u5360\u7684\uff09. This usually applies to kernel functions and service interrupts which, if not permitted to run to completion \uff08\u8fd0\u884c\u5b8c\u6210\uff09, would tend to produce race conditions resulting in deadlock . Barring\uff08\u7981\u6b62\uff09 the scheduler from preempting tasks while they are processing kernel functions simplifies the kernel design at the expense of system responsiveness\uff08 \u7981\u6b62\u8c03\u5ea6\u7a0b\u5e8f\u5728\u5904\u7406\u5185\u6838\u51fd\u6570\u65f6\u62a2\u5360\u4efb\u52a1\uff0c\u4ece\u800c\u4ee5\u7cfb\u7edf\u54cd\u5e94\u4e3a\u4ee3\u4ef7\u7b80\u5316\u5185\u6838\u8bbe\u8ba1\uff09. The distinction between user mode and kernel mode , which determines privilege level within the system, may also be used to distinguish whether a task is currently preemptible. Most modern systems have preemptive kernels , designed to permit tasks to be preempted even when in kernel mode. Examples of such systems are Solaris 2.0/SunOS 5.0,[ 1] Windows NT , Linux kernel (2.6.x and newer), AIX and some BSD systems ( NetBSD , since version 5).","title":"User mode and kernel mode"},{"location":"Kernel/Guide/Multitasking/Sched/Preemptive-multitasking/#preemptive#multitasking","text":"The term preemptive multitasking is used to distinguish a multitasking operating system , which permits preemption of tasks\uff08\u5141\u8bb8\u62a2\u5360\u4efb\u52a1\uff09, from a cooperative multitasking system wherein processes or tasks must be explicitly programmed to yield \uff08\u653e\u5f03\u6267\u884c\uff0c\u8ba9\u6e21\uff09 when they do not need system resources. In simple terms: Preemptive multitasking involves the use of an interrupt mechanism which suspends the currently executing process and invokes a scheduler to determine which process should execute next. Therefore, all processes will get some amount of CPU time at any given time. In preemptive multitasking, the operating system kernel can also initiate a context switch to satisfy the scheduling policy 's priority constraint, thus preempting\uff08\u62a2\u5360\uff09 the active task. In general, preemption means \"prior seizure of\". When the high priority task at that instance seizes\uff08\u593a\u53d6\uff09 the currently running task, it is known as preemptive scheduling (\u62a2\u5360\u5f0f\u8c03\u5ea6\uff09. The term \"preemptive multitasking\" is sometimes mistakenly used when the intended meaning is more specific, referring instead to the class of scheduling policies known as time-shared scheduling , or time-sharing . Preemptive multitasking allows the computer system to more reliably guarantee each process a regular \"slice\" of operating time. It also allows the system to rapidly deal with important external events like incoming data, which might require the immediate attention of one or another process. At any specific time, processes can be grouped into two categories: those that are waiting for input or output (called \" I/O bound \"), and those that are fully utilizing the CPU (\" CPU bound \"). In early systems, processes would often \"poll\", or \" busywait \" while waiting for requested input (such as disk, keyboard or network input). During this time, the process was not performing useful work, but still maintained complete control of the CPU. With the advent of interrupts and preemptive multitasking , these I/O bound processes could be \"blocked\", or put on hold, pending the arrival of the necessary data, allowing other processes to utilize the CPU. As the arrival of the requested data would generate an interrupt, blocked processes could be guaranteed a timely return to execution. Although multitasking techniques were originally developed to allow multiple users to share a single machine, it soon became apparent that multitasking was useful regardless of the number of users. Many operating systems, from mainframes down to single-user personal computers and no-user control systems (like those in robotic spacecraft ), have recognized the usefulness of multitasking support for a variety of reasons. Multitasking makes it possible for a single user to run multiple applications at the same time, or to run \"background\" processes while retaining control of the computer.","title":"Preemptive multitasking"},{"location":"Kernel/Guide/Multitasking/Sched/Preemptive-multitasking/#time#slice","text":"The period of time for which a process is allowed to run in a preemptive multitasking system is generally called the time slice or quantum . The scheduler is run once every time slice to choose the next process to run. The length of each time slice can be critical to balancing system performance vs process responsiveness - if the time slice is too short then the scheduler will consume too much processing time, but if the time slice is too long, processes will take longer to respond to input. An interrupt is scheduled to allow the operating system kernel to switch between processes when their time slices expire, effectively allowing the processor\u2019s time to be shared between a number of tasks, giving the illusion that it is dealing with these tasks in parallel (simultaneously). The operating system which controls such a design is called a multi-tasking system.","title":"Time slice"},{"location":"Kernel/Guide/Multitasking/Sched/Preemptive-multitasking/#system#support","text":"Today, nearly all operating systems support preemptive multitasking , including the current versions of Windows , macOS , Linux (including Android ) and iOS . Some of the earliest operating systems available to home users featuring preemptive multitasking were Sinclair QDOS (1984[ 2] ) and Amiga OS (1985). These both ran on Motorola 68000 -family microprocessors without memory management. Amiga OS used dynamic loading of relocatable code blocks (\" hunks \" in Amiga jargon) to multitask preemptively all processes in the same flat address space. Early PC operating systems such as MS-DOS and PC DOS , did not support multitasking at all, however alternative operating systems such as MP/M-86 (1981) and Concurrent CP/M-86 did support preemptive multitasking. Other Unix-like systems including MINIX and Coherent provided preemptive multitasking on 1980s-era personal computers. Later DOS versions natively supporting preemptive multitasking/multithreading include Concurrent DOS , Multiuser DOS , Novell DOS (later called Caldera OpenDOS and DR-DOS 7.02 and higher). Since Concurrent DOS 386 , they could also run multiple DOS programs concurrently in virtual DOS machines . The earliest version of Windows to support a limited form of preemptive multitasking was Windows 2.1x , which used the Intel 80386 's Virtual 8086 mode to run DOS applications in virtual 8086 machines , commonly known as \"DOS boxes\", which could be preempted. In Windows 95, 98 and Me , 32-bit applications were made preemptive by running each one in a separate address space, but 16-bit applications remained cooperative for backward compatibility.[ 3] In Windows 3.1x (protected mode), the kernel and virtual device drivers ran preemptively, but all 16-bit applications were non-preemptive and shared the same address space. Preemptive multitasking has always been supported by Windows NT (all versions), OS/2 (native applications), Unix and Unix-like systems (such as Linux , BSD and macOS ), VMS , OS/360 , and many other operating systems designed for use in the academic and medium-to-large business markets. Although there were plans to upgrade the cooperative multitasking found in the classic Mac OS to a preemptive model (and a preemptive API did exist in Mac OS 9 , although in a limited sense[ 4] ), these were abandoned in favor of Mac OS X (now called macOS) that, as a hybrid of the old Mac System style and NeXTSTEP , is an operating system based on the Mach kernel and derived in part from BSD , which had always provided Unix-like preemptive multitasking.","title":"System support"},{"location":"Kernel/Guide/Multitasking/Sched/Preemptive-multitasking/Kernel-preemption/","text":"Kernel preemption Kernel preemption is a method used mainly in monolithic and hybrid kernels where all or most device drivers are run in kernel space , whereby the scheduler is permitted to forcibly perform a context switch (i.e. preemptively schedule; on behalf of a runnable and higher priority process) on a driver or other part of the kernel during its execution, rather than co-operatively waiting for the driver or kernel function (such as a system call ) to complete its execution and return control of the processor to the scheduler.[ 1] [ 2] [ 3] [ 4] There are two main benefits to this method in monolithic and hybrid kernels, and answer one of the main criticisms of monolithic kernels from microkernel advocates, which is that: A device driver can enter an infinite loop or other unrecoverable state, crashing the whole system.[ 1] Some drivers and system calls on monolithic kernels are slow to execute, and cannot return control of the processor to the scheduler or other program until they complete execution.[ 2] See also Linux kernel preemption","title":"Kernel-preemption"},{"location":"Kernel/Guide/Multitasking/Sched/Preemptive-multitasking/Kernel-preemption/#kernel#preemption","text":"Kernel preemption is a method used mainly in monolithic and hybrid kernels where all or most device drivers are run in kernel space , whereby the scheduler is permitted to forcibly perform a context switch (i.e. preemptively schedule; on behalf of a runnable and higher priority process) on a driver or other part of the kernel during its execution, rather than co-operatively waiting for the driver or kernel function (such as a system call ) to complete its execution and return control of the processor to the scheduler.[ 1] [ 2] [ 3] [ 4] There are two main benefits to this method in monolithic and hybrid kernels, and answer one of the main criticisms of monolithic kernels from microkernel advocates, which is that: A device driver can enter an infinite loop or other unrecoverable state, crashing the whole system.[ 1] Some drivers and system calls on monolithic kernels are slow to execute, and cannot return control of the processor to the scheduler or other program until they complete execution.[ 2]","title":"Kernel preemption"},{"location":"Kernel/Guide/Multitasking/Sched/Preemptive-multitasking/Kernel-preemption/#see#also","text":"Linux kernel preemption","title":"See also"},{"location":"Kernel/Guide/Multitasking/Sched/Processor-affinity/","text":"\u5173\u4e8e\u672c\u7ae0 \u7ef4\u57fa\u767e\u79d1 Processor affinity man 1 taskset \u5982\u4f55\u6307\u5b9a\u8fdb\u7a0b\u8fd0\u884c\u7684CPU(\u547d\u4ee4\u884c taskset) \u540c\u65f6\uff0c\u56e0\u4e3a\u6700\u8fd1\u5728\u770bredis\u7684\u76f8\u5173\u8d44\u6599\uff0credis\u4f5c\u4e3a\u5355\u8fdb\u7a0b\u6a21\u578b\u7684\u7a0b\u5e8f\uff0c\u4e3a\u4e86\u5145\u5206\u5229\u7528\u591a\u6838CPU\uff0c\u5e38\u5e38\u5728\u4e00\u53f0server\u4e0a\u4f1a\u542f\u52a8\u591a\u4e2a\u5b9e\u4f8b\u3002\u800c\u4e3a\u4e86\u51cf\u5c11\u5207\u6362\u7684\u5f00\u9500\uff0c\u6709\u5fc5\u8981\u4e3a\u6bcf\u4e2a\u5b9e\u4f8b\u6307\u5b9a\u5176\u6240\u8fd0\u884c\u7684CPU\u3002 \u663e\u793a\u8fdb\u7a0b\u8fd0\u884c\u7684CPU taskset -p 21184 pid 21184's current affinity mask: ffffff \uff0c ffffff \u5b9e\u9645\u4e0a\u662f\u4e8c\u8fdb\u523624\u4e2a\u4f4e\u4f4d\u5747\u4e3a1\u7684bitmask\uff0c\u6bcf\u4e00\u4e2a1\u5bf9\u5e94\u4e8e1\u4e2aCPU\uff0c\u8868\u793a\u8be5\u8fdb\u7a0b\u572824\u4e2aCPU\u4e0a\u8fd0\u884c\u3002 \u6307\u5b9a\u8fdb\u7a0b\u8fd0\u884c\u5728\u67d0\u4e2a\u7279\u5b9a\u7684CPU\u4e0a skset -p c 3 21184 3\u8868\u793aCPU\u5c06\u53ea\u4f1a\u8fd0\u884c\u5728\u7b2c4\u4e2aCPU\u4e0a\uff08\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09\u3002 \u663e\u793a\u7ed3\u679c\uff1a pid 21184 's current affinity list: 0-23 pid 21184' s new affinity list: 3 \u8fdb\u7a0b\u542f\u52a8\u65f6\u6307\u5b9aCPU taskset -c 1 ./redis-server ../redis.conf","title":"Introduction"},{"location":"Kernel/Guide/Multitasking/Sched/Processor-affinity/#_1","text":"","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Kernel/Guide/Multitasking/Sched/Processor-affinity/#processor#affinity","text":"","title":"\u7ef4\u57fa\u767e\u79d1Processor affinity"},{"location":"Kernel/Guide/Multitasking/Sched/Processor-affinity/#man#1#taskset","text":"","title":"man 1 taskset"},{"location":"Kernel/Guide/Multitasking/Sched/Processor-affinity/#cpu#taskset","text":"\u540c\u65f6\uff0c\u56e0\u4e3a\u6700\u8fd1\u5728\u770bredis\u7684\u76f8\u5173\u8d44\u6599\uff0credis\u4f5c\u4e3a\u5355\u8fdb\u7a0b\u6a21\u578b\u7684\u7a0b\u5e8f\uff0c\u4e3a\u4e86\u5145\u5206\u5229\u7528\u591a\u6838CPU\uff0c\u5e38\u5e38\u5728\u4e00\u53f0server\u4e0a\u4f1a\u542f\u52a8\u591a\u4e2a\u5b9e\u4f8b\u3002\u800c\u4e3a\u4e86\u51cf\u5c11\u5207\u6362\u7684\u5f00\u9500\uff0c\u6709\u5fc5\u8981\u4e3a\u6bcf\u4e2a\u5b9e\u4f8b\u6307\u5b9a\u5176\u6240\u8fd0\u884c\u7684CPU\u3002","title":"\u5982\u4f55\u6307\u5b9a\u8fdb\u7a0b\u8fd0\u884c\u7684CPU(\u547d\u4ee4\u884c taskset)"},{"location":"Kernel/Guide/Multitasking/Sched/Processor-affinity/#cpu","text":"taskset -p 21184 pid 21184's current affinity mask: ffffff \uff0c ffffff \u5b9e\u9645\u4e0a\u662f\u4e8c\u8fdb\u523624\u4e2a\u4f4e\u4f4d\u5747\u4e3a1\u7684bitmask\uff0c\u6bcf\u4e00\u4e2a1\u5bf9\u5e94\u4e8e1\u4e2aCPU\uff0c\u8868\u793a\u8be5\u8fdb\u7a0b\u572824\u4e2aCPU\u4e0a\u8fd0\u884c\u3002","title":"\u663e\u793a\u8fdb\u7a0b\u8fd0\u884c\u7684CPU"},{"location":"Kernel/Guide/Multitasking/Sched/Processor-affinity/#cpu_1","text":"skset -p c 3 21184 3\u8868\u793aCPU\u5c06\u53ea\u4f1a\u8fd0\u884c\u5728\u7b2c4\u4e2aCPU\u4e0a\uff08\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09\u3002 \u663e\u793a\u7ed3\u679c\uff1a pid 21184 's current affinity list: 0-23 pid 21184' s new affinity list: 3","title":"\u6307\u5b9a\u8fdb\u7a0b\u8fd0\u884c\u5728\u67d0\u4e2a\u7279\u5b9a\u7684CPU\u4e0a"},{"location":"Kernel/Guide/Multitasking/Sched/Processor-affinity/#cpu_2","text":"taskset -c 1 ./redis-server ../redis.conf","title":"\u8fdb\u7a0b\u542f\u52a8\u65f6\u6307\u5b9aCPU"},{"location":"Kernel/Guide/Read-code/","text":"\u5982\u4f55\u9605\u8bfblinux OS kernel\u6e90\u4ee3\u7801 \u5982\u4f55\u9605\u8bfblinux kernel\u7684source code\uff1f\u5728\u62ff\u8d77\u672c\u4e66\u7684\u65f6\u5019\u6211\u601d\u8003\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u4e0b\u9762\u662f\u6211\u68c0\u7d22\u5230\u7684\u6211\u89c9\u5f97\u6709\u9053\u7406\u7684 \u89c2\u70b9 \uff1a Focus on data structures . Understanding data structures is usually more important than code . If you are only shown data structures but no code, you still get the big picture of the system. Vice versa, if shown only code but not data structures, it's very hard to understand the system. \"I will, in fact, claim that the difference between a bad programmer and a good one is whether he considers his code or his data structures more important. Bad programmers worry about the code. Good programmers worry about data structures and their relationships.\" -- Linus Torvalds \"Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won't usually need your flowcharts; they'll be obvious.\" -- Fred Brooks. How to understand Linux kernel source code for a beginner? \u4ecestructure\u5165\u624b\uff0c\u672c\u4e66\u4e5f\u662f\u5982\u6b64\u3002","title":"Introduction"},{"location":"Kernel/Guide/Read-code/#linux#os#kernel","text":"\u5982\u4f55\u9605\u8bfblinux kernel\u7684source code\uff1f\u5728\u62ff\u8d77\u672c\u4e66\u7684\u65f6\u5019\u6211\u601d\u8003\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u4e0b\u9762\u662f\u6211\u68c0\u7d22\u5230\u7684\u6211\u89c9\u5f97\u6709\u9053\u7406\u7684 \u89c2\u70b9 \uff1a Focus on data structures . Understanding data structures is usually more important than code . If you are only shown data structures but no code, you still get the big picture of the system. Vice versa, if shown only code but not data structures, it's very hard to understand the system. \"I will, in fact, claim that the difference between a bad programmer and a good one is whether he considers his code or his data structures more important. Bad programmers worry about the code. Good programmers worry about data structures and their relationships.\" -- Linus Torvalds \"Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won't usually need your flowcharts; they'll be obvious.\" -- Fred Brooks. How to understand Linux kernel source code for a beginner? \u4ecestructure\u5165\u624b\uff0c\u672c\u4e66\u4e5f\u662f\u5982\u6b64\u3002","title":"\u5982\u4f55\u9605\u8bfblinux OS kernel\u6e90\u4ee3\u7801"},{"location":"Kernel/Guide/User-system/","text":"Linux user system linux OS\u4e2d\u6709user\u3001group\u7684\u6982\u5ff5\uff0c\u8fd9\u4e24\u4e2a\u6982\u5ff5\u662flinux OS\u4e2d\u975e\u5e38\u975e\u5e38\u57fa\u7840\u7684\u6982\u5ff5\uff0c\u56e0\u4e3alinux OS\u4e2d\u7684\u5f88\u591a\u6982\u5ff5\u90fd\u662f\u5efa\u7acb\u5728\u8fd9\u4e24\u4e2a\u91cd\u8981\u7684\u6982\u5ff5\u4e4b\u4e0a\uff0c\u6211\u4eec\u5c06\u5b83\u4eec\u79f0\u4e3a\u201cuser system\u201d\uff0c\u6211\u76ee\u524d\u5728\u5b98\u65b9\u6587\u6863\u4e2d\u8fd8\u6ca1\u6709\u627e\u5230\u5bf9linux OS\u7684user system\u7684\u4e13\u95e8\u4ecb\u7ecd\u7684\u6587\u7ae0\u3002 linux OS\u4e2d\u7684\u5f88\u591a\u5176\u4ed6\u554a\u6982\u5ff5\u90fd\u662f\u5efa\u7acbuser system\u4e4b\u4e0a\u7684\uff0c\u76f4\u63a5\u7684\u4f53\u73b0\u5c31\u662f\u5b83\u4eec\u90fd\u5177\u5907\u8868\u793a\u5176user\u4fe1\u606f\u7684\u5c5e\u6027\uff0c\u6bd4\u5982file\u3001process\u3002file\u7684user\u4fe1\u606f\u8868\u793a\u5b83\u7684\u6240\u5c5e\uff0cprocess\u7684user \u4fe1\u606f\u8868\u793a\u5b83\u662f\u54ea\u4e2auser\u7684\u6d3b\u52a8\u3002 linux OS\u5728user system\u4e0a\u5efa\u7acb\u8d77\u4e86permission system\uff08\u6743\u9650\u7cfb\u7edf\uff09\uff0c\u5373\u8868\u793a\u54ea\u4e9b\u7528\u6237\u5177\u5907\u54ea\u4e9bpermission\uff08\u6743\u9650\uff09\uff0c\u5178\u578b\u7684\u5c31\u662flinux OS\u4e2d\u7684file\u4f1a\u8bb0\u5f55\u4e0b\u5b83\u7684permission\u4fe1\u606f\uff0c\u5373\u54ea\u4e9b\u7528\u6237\u53ef\u4ee5\u5bf9\u5b83\u6267\u884c\u600e\u6837\u7684\u64cd\u4f5c\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u89c1 man 1 chmod \uff0c\u8fd9\u4ec5\u4ec5\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0clinux OS\u7684permission system\u4f1a\u6d89\u53ca\u5230\u975e\u5e38\u591a\u7684\u5185\u5bb9\u3002 TODO: \u4e0b\u9762\u8bb0\u5f55\u4e86\u4e00\u4e9b\u4e0epermission system\u76f8\u5173\u7684\u5185\u5bb9\uff1a \u7ef4\u57fa\u767e\u79d1 File system permissions \u7ef4\u57fa\u767e\u79d1 Access-control list man 5 acl linux OS\u5728user system\u4e0a\u5efa\u7acb\u8d77\u4e86resource management system\uff0c\u5373\u5bf9OS\u4e2d\u7684user\u6240\u5360\u7528\u7684OS resource\u8fdb\u884c\u9650\u5236\u3002 linux\u7684user system\u5c31\u50cf\u662f\u4eba\u7c7b\u793e\u4f1a\u7684\u6237\u7c4d\u7c3f\u3002 Process and user process\u53ef\u4ee5\u770b\u505a\u662fuser\u7684\u6d3b\u52a8\u3001\u770b\u505a\u662fuser\u5bf9OS\u4f7f\u7528\u3002 Operation of user system \u53ea\u6709root\u7528\u6237\u5177\u5907\u64cd\u4f5cuser system\u7684\u6743\u9650\uff1a \u6dfb\u52a0\u7528\u6237\uff1a useradd(8)","title":"Introduction"},{"location":"Kernel/Guide/User-system/#linux#user#system","text":"linux OS\u4e2d\u6709user\u3001group\u7684\u6982\u5ff5\uff0c\u8fd9\u4e24\u4e2a\u6982\u5ff5\u662flinux OS\u4e2d\u975e\u5e38\u975e\u5e38\u57fa\u7840\u7684\u6982\u5ff5\uff0c\u56e0\u4e3alinux OS\u4e2d\u7684\u5f88\u591a\u6982\u5ff5\u90fd\u662f\u5efa\u7acb\u5728\u8fd9\u4e24\u4e2a\u91cd\u8981\u7684\u6982\u5ff5\u4e4b\u4e0a\uff0c\u6211\u4eec\u5c06\u5b83\u4eec\u79f0\u4e3a\u201cuser system\u201d\uff0c\u6211\u76ee\u524d\u5728\u5b98\u65b9\u6587\u6863\u4e2d\u8fd8\u6ca1\u6709\u627e\u5230\u5bf9linux OS\u7684user system\u7684\u4e13\u95e8\u4ecb\u7ecd\u7684\u6587\u7ae0\u3002 linux OS\u4e2d\u7684\u5f88\u591a\u5176\u4ed6\u554a\u6982\u5ff5\u90fd\u662f\u5efa\u7acbuser system\u4e4b\u4e0a\u7684\uff0c\u76f4\u63a5\u7684\u4f53\u73b0\u5c31\u662f\u5b83\u4eec\u90fd\u5177\u5907\u8868\u793a\u5176user\u4fe1\u606f\u7684\u5c5e\u6027\uff0c\u6bd4\u5982file\u3001process\u3002file\u7684user\u4fe1\u606f\u8868\u793a\u5b83\u7684\u6240\u5c5e\uff0cprocess\u7684user \u4fe1\u606f\u8868\u793a\u5b83\u662f\u54ea\u4e2auser\u7684\u6d3b\u52a8\u3002 linux OS\u5728user system\u4e0a\u5efa\u7acb\u8d77\u4e86permission system\uff08\u6743\u9650\u7cfb\u7edf\uff09\uff0c\u5373\u8868\u793a\u54ea\u4e9b\u7528\u6237\u5177\u5907\u54ea\u4e9bpermission\uff08\u6743\u9650\uff09\uff0c\u5178\u578b\u7684\u5c31\u662flinux OS\u4e2d\u7684file\u4f1a\u8bb0\u5f55\u4e0b\u5b83\u7684permission\u4fe1\u606f\uff0c\u5373\u54ea\u4e9b\u7528\u6237\u53ef\u4ee5\u5bf9\u5b83\u6267\u884c\u600e\u6837\u7684\u64cd\u4f5c\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u89c1 man 1 chmod \uff0c\u8fd9\u4ec5\u4ec5\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0clinux OS\u7684permission system\u4f1a\u6d89\u53ca\u5230\u975e\u5e38\u591a\u7684\u5185\u5bb9\u3002 TODO: \u4e0b\u9762\u8bb0\u5f55\u4e86\u4e00\u4e9b\u4e0epermission system\u76f8\u5173\u7684\u5185\u5bb9\uff1a \u7ef4\u57fa\u767e\u79d1 File system permissions \u7ef4\u57fa\u767e\u79d1 Access-control list man 5 acl linux OS\u5728user system\u4e0a\u5efa\u7acb\u8d77\u4e86resource management system\uff0c\u5373\u5bf9OS\u4e2d\u7684user\u6240\u5360\u7528\u7684OS resource\u8fdb\u884c\u9650\u5236\u3002 linux\u7684user system\u5c31\u50cf\u662f\u4eba\u7c7b\u793e\u4f1a\u7684\u6237\u7c4d\u7c3f\u3002","title":"Linux user system"},{"location":"Kernel/Guide/User-system/#process#and#user","text":"process\u53ef\u4ee5\u770b\u505a\u662fuser\u7684\u6d3b\u52a8\u3001\u770b\u505a\u662fuser\u5bf9OS\u4f7f\u7528\u3002","title":"Process and user"},{"location":"Kernel/Guide/User-system/#operation#of#user#system","text":"\u53ea\u6709root\u7528\u6237\u5177\u5907\u64cd\u4f5cuser system\u7684\u6743\u9650\uff1a \u6dfb\u52a0\u7528\u6237\uff1a useradd(8)","title":"Operation of user system"},{"location":"Linux-Foundation/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8bb0\u5f55\u6211\u9605\u8bfb Linux Foundation Referenced Specifications \u7684\u7b14\u8bb0\uff0cLinux Foundation Referenced Specifications\u5bf9linux\u7684\u65b9\u65b9\u9762\u9762\u90fd\u8fdb\u884c\u4e86\u4ecb\u7ecd\uff0c\u9700\u8981\u4ed4\u7ec6\u9605\u8bfb\u3002","title":"Introduction"},{"location":"Linux-Foundation/#_1","text":"\u672c\u7ae0\u8bb0\u5f55\u6211\u9605\u8bfb Linux Foundation Referenced Specifications \u7684\u7b14\u8bb0\uff0cLinux Foundation Referenced Specifications\u5bf9linux\u7684\u65b9\u65b9\u9762\u9762\u90fd\u8fdb\u884c\u4e86\u4ecb\u7ecd\uff0c\u9700\u8981\u4ed4\u7ec6\u9605\u8bfb\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Linux-Foundation/Linux-Foundation-Referenced-Specifications/","text":"","title":"Linux-Foundation-Referenced-Specifications"},{"location":"Linux-Foundation/LSB-Core/LSB-Core/","text":"Linux Standard Base Core Specification for X86-64","title":"LSB-Core"},{"location":"Linux-Foundation/LSB-Core/LSB-Core/#linux#standard#base#core#specification#for#x86-64","text":"","title":"Linux Standard Base Core Specification for X86-64"},{"location":"Linux-Foundation/LSB-Core/librt/","text":"librt https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/librt.html https://stackoverflow.com/questions/2418157/c-error-undefined-reference-to-clock-gettime-and-clock-settime https://docs.oracle.com/cd/E86824_01/html/E54772/librt-3lib.html","title":"librt"},{"location":"Linux-Foundation/LSB-Core/librt/#librt","text":"https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/librt.html https://stackoverflow.com/questions/2418157/c-error-undefined-reference-to-clock-gettime-and-clock-settime https://docs.oracle.com/cd/E86824_01/html/E54772/librt-3lib.html","title":"librt"},{"location":"Network/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8bb0\u5f55network\u76f8\u5173\u5185\u5bb9\uff0c\u91cd\u8981\u96c6\u4e2d\u5728\u5982\u4e0b\u51e0\u4e2a\u65b9\u9762: \u7ae0\u8282 \u4e3b\u8981\u5185\u5bb9 Network\\Protocol \u4e3b\u8981\u4ecb\u7ecd\u7f51\u7edc\u534f\u8bae\u76f8\u5173\u77e5\u8bc6 Network\\Programming \u4e3b\u8981\u4ecb\u7ecd\u7f51\u7edc\u7f16\u7a0b\u76f8\u5173\u7684\u5185\u5bb9 Network\\Tools \u4e3b\u8981\u4ecb\u7ecd\u7f51\u7edc\u76f8\u5173\u7684\u5de5\u5177\uff0c\u8fd9\u4e9b\u5de5\u5177\u5728\u8fdb\u884ctroubleshoot\u7684\u65f6\u5019\uff0c\u975e\u5e38\u6709\u7528 \u8d8a\u6765\u8d8a\u591a\u7684\u57fa\u4e8enetwork\u7684application\uff0c\u56e0\u6b64software engineer\u8d8a\u6765\u8d8a\u591a\u5730\u548cnetwork\u6253\u4ea4\u9053\u3002 Resource PacketLife.net \u975e\u5e38\u597d\u7684\u4e00\u4e2a\u7f51\u7ad9\uff0c\u4f5c\u8005\u662f\u4e00\u4e2anetwork engineer\uff0c\u603b\u7ed3\u4e86\u975e\u5e38\u591a\u7684network\u76f8\u5173\u7684\u5185\u5bb9\u3002","title":"Introduction"},{"location":"Network/#_1","text":"\u672c\u7ae0\u8bb0\u5f55network\u76f8\u5173\u5185\u5bb9\uff0c\u91cd\u8981\u96c6\u4e2d\u5728\u5982\u4e0b\u51e0\u4e2a\u65b9\u9762: \u7ae0\u8282 \u4e3b\u8981\u5185\u5bb9 Network\\Protocol \u4e3b\u8981\u4ecb\u7ecd\u7f51\u7edc\u534f\u8bae\u76f8\u5173\u77e5\u8bc6 Network\\Programming \u4e3b\u8981\u4ecb\u7ecd\u7f51\u7edc\u7f16\u7a0b\u76f8\u5173\u7684\u5185\u5bb9 Network\\Tools \u4e3b\u8981\u4ecb\u7ecd\u7f51\u7edc\u76f8\u5173\u7684\u5de5\u5177\uff0c\u8fd9\u4e9b\u5de5\u5177\u5728\u8fdb\u884ctroubleshoot\u7684\u65f6\u5019\uff0c\u975e\u5e38\u6709\u7528 \u8d8a\u6765\u8d8a\u591a\u7684\u57fa\u4e8enetwork\u7684application\uff0c\u56e0\u6b64software engineer\u8d8a\u6765\u8d8a\u591a\u5730\u548cnetwork\u6253\u4ea4\u9053\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Network/#resource","text":"PacketLife.net \u975e\u5e38\u597d\u7684\u4e00\u4e2a\u7f51\u7ad9\uff0c\u4f5c\u8005\u662f\u4e00\u4e2anetwork engineer\uff0c\u603b\u7ed3\u4e86\u975e\u5e38\u591a\u7684network\u76f8\u5173\u7684\u5185\u5bb9\u3002","title":"Resource"},{"location":"Network/TODO/","text":"TODO Theory na.infn TCP Connection Establishment and Termination \u8fd9\u7bc7\u6587\u7ae0\u5185\u5bb9\u975e\u5e38\u5168\u9762\u3002 coolshell TCP \u7684\u90a3\u4e9b\u4e8b\u513f\uff08\u4e0a\uff09 coolshell TCP \u7684\u90a3\u4e9b\u4e8b\u513f\uff08\u4e0b\uff09 tcpipguide The TCP/IP Guide Programming 20201029: \u53d1\u9001\u7f13\u5b58\u6ee1 \u4eca\u5929\u542c\u65b9\u4fca\u8bf4\u4e86\u8fd9\u6837\u7684\u4e00\u79cd\u64cd\u4f5c: TCP\u7684\u53d1\u9001\u7f13\u5b58\u6ee1\u4e86\uff0c\u9700\u8981\u5c06\u7528\u6237\u6570\u636e\u653e\u5230\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u961f\u5217\u4e2d\u3002","title":"TODO"},{"location":"Network/TODO/#todo","text":"","title":"TODO"},{"location":"Network/TODO/#theory","text":"na.infn TCP Connection Establishment and Termination \u8fd9\u7bc7\u6587\u7ae0\u5185\u5bb9\u975e\u5e38\u5168\u9762\u3002 coolshell TCP \u7684\u90a3\u4e9b\u4e8b\u513f\uff08\u4e0a\uff09 coolshell TCP \u7684\u90a3\u4e9b\u4e8b\u513f\uff08\u4e0b\uff09 tcpipguide The TCP/IP Guide","title":"Theory"},{"location":"Network/TODO/#programming","text":"","title":"Programming"},{"location":"Network/TODO/#20201029","text":"\u4eca\u5929\u542c\u65b9\u4fca\u8bf4\u4e86\u8fd9\u6837\u7684\u4e00\u79cd\u64cd\u4f5c: TCP\u7684\u53d1\u9001\u7f13\u5b58\u6ee1\u4e86\uff0c\u9700\u8981\u5c06\u7528\u6237\u6570\u636e\u653e\u5230\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u961f\u5217\u4e2d\u3002","title":"20201029: \u53d1\u9001\u7f13\u5b58\u6ee1"},{"location":"Network/Programming/","text":"","title":"Introduction"},{"location":"Network/Programming/Reconnect/","text":"\u65ad\u7ebf\u91cd\u8fde https://stackoverflow.com/questions/37029341/how-to-reconnect-socket-using-threads https://stackoverflow.com/questions/57323865/how-to-reconnect-to-tcp-server-after-network-goes-down-and-comes-back-up-again redis reconnect https://stackoverflow.com/questions/10879426/how-to-reconnect-redis-connection https://github.com/NodeRedis/node-redis/issues/1007 https://developer.ibm.com/depmodels/cloud/articles/error-detection-and-handling-with-redis/ \u4e00\u79cd\u89e3\u51b3\u65b9\u6848\u662f\u4f7f\u7528\u4e00\u4e2athread\uff0c\u6bcf\u9694\u4e00\u6bb5\u65f6\u95f4\u5c31\u53d6\u68c0\u67e5\uff0c\u53e6\u5916\u4e00\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u5f53\u51fa\u73b0\u9519\u8bef\u7684\u65f6\u5019\uff0c\u624d\u53bb\u91cd\u8fde\u3002","title":"Reconnect"},{"location":"Network/Programming/Reconnect/#_1","text":"https://stackoverflow.com/questions/37029341/how-to-reconnect-socket-using-threads https://stackoverflow.com/questions/57323865/how-to-reconnect-to-tcp-server-after-network-goes-down-and-comes-back-up-again","title":"\u65ad\u7ebf\u91cd\u8fde"},{"location":"Network/Programming/Reconnect/#redis#reconnect","text":"https://stackoverflow.com/questions/10879426/how-to-reconnect-redis-connection https://github.com/NodeRedis/node-redis/issues/1007 https://developer.ibm.com/depmodels/cloud/articles/error-detection-and-handling-with-redis/ \u4e00\u79cd\u89e3\u51b3\u65b9\u6848\u662f\u4f7f\u7528\u4e00\u4e2athread\uff0c\u6bcf\u9694\u4e00\u6bb5\u65f6\u95f4\u5c31\u53d6\u68c0\u67e5\uff0c\u53e6\u5916\u4e00\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u5f53\u51fa\u73b0\u9519\u8bef\u7684\u65f6\u5019\uff0c\u624d\u53bb\u91cd\u8fde\u3002","title":"redis reconnect"},{"location":"Network/Programming/Socket/","text":"Socket wikipedia Network socket A network socket is an internal endpoint for sending or receiving data within a node on a computer network . Concretely, it is a representation of this endpoint in networking software ( protocol stack ), such as an entry in a table (listing communication protocol, destination, status, etc.), and is a form of system resource . The term socket is analogous to physical female connectors , communication between two nodes through a channel being visualized as a cable with two male connectors plugging into sockets at each node. Similarly, the term port (another term for a female connector ) is used for external endpoints at a node, and the term socket is also used for an internal endpoint of local inter-process communication (IPC) (not over a network). However, the analogy is strained, as network communication need not be one-to-one or have a dedicated communication channel . NOTE: \u672f\u8bed\u5957\u63a5\u5b57\u7c7b\u4f3c\u4e8e\u7269\u7406\u6bcd\u8fde\u63a5\u5668\uff0c\u901a\u8fc7\u4fe1\u9053\u5c06\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u7684\u901a\u4fe1\u89c6\u4e3a\u7535\u7f06\uff0c\u5176\u4e2d\u4e24\u4e2a\u516c\u8fde\u63a5\u5668\u63d2\u5165\u6bcf\u4e2a\u8282\u70b9\u7684\u63d2\u5ea7\u3002 \u7c7b\u4f3c\u5730\uff0c\u672f\u8bed\u7aef\u53e3\uff08\u5973\u6027\u8fde\u63a5\u5668\u7684\u53e6\u4e00\u4e2a\u672f\u8bed\uff09\u7528\u4e8e\u8282\u70b9\u5904\u7684\u5916\u90e8\u7aef\u70b9\uff0c\u672f\u8bed\u5957\u63a5\u5b57\u4e5f\u7528\u4e8e\u672c\u5730\u8fdb\u7a0b\u95f4\u901a\u4fe1\uff08IPC\uff09\u7684\u5185\u90e8\u7aef\u70b9\uff08\u4e0d\u901a\u8fc7\u7f51\u7edc\uff09\u3002 \u7136\u800c\uff0c\u7c7b\u6bd4\u662f\u7d27\u5f20\u7684\uff0c\u56e0\u4e3a\u7f51\u7edc\u901a\u4fe1\u4e0d\u9700\u8981\u662f\u4e00\u5bf9\u4e00\u7684\u6216\u5177\u6709\u4e13\u7528\u7684\u901a\u4fe1\u4fe1\u9053\u3002 Use A process can refer to a socket using a socket descriptor , a type of handle . A process first requests that the protocol stack create a socket , and the stack returns a descriptor to the process so it can identify the socket. The process then passes the descriptor back to the protocol stack when it wishes to send or receive data using this socket . Unlike ports , sockets are specific to one node; they are local resources and cannot be referred to directly by other nodes. Further, sockets are not necessarily associated with a persistent connection ( channel ) for communication between two nodes, nor is there necessarily some single other endpoint. For example, a datagram socket can be used for connectionless communication , and a multicast socket can be used to send to multiple nodes. However, in practice for internet communication, sockets are generally used to connect to a specific endpoint and often with a persistent connection. NOTE : socket\u7684\u884c\u4e3a\u7531\u5b83\u7684protocol\u6765\u6307\u5b9a\uff1b Socket addresses In practice, socket usually refers to a socket in an Internet Protocol (IP) network (where a socket may be called an Internet socket ), in particular for the Transmission Control Protocol (TCP), which is a protocol for one-to-one connections. In this context, sockets are assumed to be associated with a specific socket address , namely the IP address and a port number for the local node, and there is a corresponding socket address at the foreign node (other node), which itself has an associated socket, used by the foreign process. Associating a socket with a socket address is called binding . NOTE : \u662f\u5426\u662f\u6240\u6709\u7684socket\u90fd\u9700\u8981***binding***\uff1f\u4e0d\u662f\u7684\uff0c\u53c2\u89c1\u300anetworking-code.md\u300b\uff0c\u5176\u4e2d\u5c55\u793a\u4e86\u57fa\u672c\u7684TCP\u548cUDP socket\u7684\u7f16\u7a0b\u8303\u5f0f\uff1b Note that while a local process can communicate with a foreign process by sending or receiving data to or from a foreign socket address , it does not have access to the foreign socket itself, nor can it use the foreign socket descriptor , as these are both internal to the foreign node. For example, in a connection between 10.20.30.40:4444 and 50.60.70.80:8888 (local IP address:local port, foreign IP address:foreign port), there will also be an associated socket at each end, corresponding to the internal representation of the connection by the protocol stack on that node. These are referred to locally by numerical socket descriptors, say 317 at one side and 922 at the other. A process on node 10.20.30.40 can request to communicate with node 50.60.70.80 on port 8888 (request that the protocol stack create a socket to communicate with that destination), and once it has created a socket and received a socket descriptor (317), it can communicate via this socket by using the descriptor (317). The protocol stack will then forward data to and from node 50.60.70.80 on port 8888. However, a process on node 10.20.30.40 cannot request to communicate based on the foreign socket descriptor, (e.g. \"socket 922\" or \"socket 922 on node 50.60.70.80\") as these are internal to the foreign node and are not usable by the protocol stack on node 10.20.30.40. Socket pairs Communicating local and remote sockets are called socket pairs . Each socket pair is described by a unique 4-tuple consisting of source and destination IP addresses and port numbers, i.e. of local and remote socket addresses.[ 8] [ 9] As seen in the discussion above, in the TCP case, each unique socket pair 4-tuple is assigned a socket number, while in the UDP case, each unique local socket address is assigned a socket number. NOTE: How many tuples are there in a connection? wikipedia Berkeley sockets Berkeley sockets is an application programming interface (API) for Internet sockets and Unix domain sockets , used for inter-process communication (IPC). It is commonly implemented as a library of linkable modules. It originated with the 4.2BSD Unix operating system, released in 1983. A socket is an abstract representation ( handle ) for the local endpoint of a network communication path. The Berkeley sockets API represents it as a file descriptor ( file handle ) in the Unix philosophy that provides a common interface for input and output to streams of data. Berkeley sockets evolved with little modification from a de facto standard into a component of the POSIX specification. The term POSIX sockets is essentially synonymous with Berkeley sockets , but they are also known as BSD sockets , acknowledging the first implementation in the Berkeley Software Distribution .","title":"Socket"},{"location":"Network/Programming/Socket/#socket","text":"","title":"Socket"},{"location":"Network/Programming/Socket/#wikipedia#network#socket","text":"A network socket is an internal endpoint for sending or receiving data within a node on a computer network . Concretely, it is a representation of this endpoint in networking software ( protocol stack ), such as an entry in a table (listing communication protocol, destination, status, etc.), and is a form of system resource . The term socket is analogous to physical female connectors , communication between two nodes through a channel being visualized as a cable with two male connectors plugging into sockets at each node. Similarly, the term port (another term for a female connector ) is used for external endpoints at a node, and the term socket is also used for an internal endpoint of local inter-process communication (IPC) (not over a network). However, the analogy is strained, as network communication need not be one-to-one or have a dedicated communication channel . NOTE: \u672f\u8bed\u5957\u63a5\u5b57\u7c7b\u4f3c\u4e8e\u7269\u7406\u6bcd\u8fde\u63a5\u5668\uff0c\u901a\u8fc7\u4fe1\u9053\u5c06\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u7684\u901a\u4fe1\u89c6\u4e3a\u7535\u7f06\uff0c\u5176\u4e2d\u4e24\u4e2a\u516c\u8fde\u63a5\u5668\u63d2\u5165\u6bcf\u4e2a\u8282\u70b9\u7684\u63d2\u5ea7\u3002 \u7c7b\u4f3c\u5730\uff0c\u672f\u8bed\u7aef\u53e3\uff08\u5973\u6027\u8fde\u63a5\u5668\u7684\u53e6\u4e00\u4e2a\u672f\u8bed\uff09\u7528\u4e8e\u8282\u70b9\u5904\u7684\u5916\u90e8\u7aef\u70b9\uff0c\u672f\u8bed\u5957\u63a5\u5b57\u4e5f\u7528\u4e8e\u672c\u5730\u8fdb\u7a0b\u95f4\u901a\u4fe1\uff08IPC\uff09\u7684\u5185\u90e8\u7aef\u70b9\uff08\u4e0d\u901a\u8fc7\u7f51\u7edc\uff09\u3002 \u7136\u800c\uff0c\u7c7b\u6bd4\u662f\u7d27\u5f20\u7684\uff0c\u56e0\u4e3a\u7f51\u7edc\u901a\u4fe1\u4e0d\u9700\u8981\u662f\u4e00\u5bf9\u4e00\u7684\u6216\u5177\u6709\u4e13\u7528\u7684\u901a\u4fe1\u4fe1\u9053\u3002","title":"wikipedia Network socket"},{"location":"Network/Programming/Socket/#use","text":"A process can refer to a socket using a socket descriptor , a type of handle . A process first requests that the protocol stack create a socket , and the stack returns a descriptor to the process so it can identify the socket. The process then passes the descriptor back to the protocol stack when it wishes to send or receive data using this socket . Unlike ports , sockets are specific to one node; they are local resources and cannot be referred to directly by other nodes. Further, sockets are not necessarily associated with a persistent connection ( channel ) for communication between two nodes, nor is there necessarily some single other endpoint. For example, a datagram socket can be used for connectionless communication , and a multicast socket can be used to send to multiple nodes. However, in practice for internet communication, sockets are generally used to connect to a specific endpoint and often with a persistent connection. NOTE : socket\u7684\u884c\u4e3a\u7531\u5b83\u7684protocol\u6765\u6307\u5b9a\uff1b","title":"Use"},{"location":"Network/Programming/Socket/#socket#addresses","text":"In practice, socket usually refers to a socket in an Internet Protocol (IP) network (where a socket may be called an Internet socket ), in particular for the Transmission Control Protocol (TCP), which is a protocol for one-to-one connections. In this context, sockets are assumed to be associated with a specific socket address , namely the IP address and a port number for the local node, and there is a corresponding socket address at the foreign node (other node), which itself has an associated socket, used by the foreign process. Associating a socket with a socket address is called binding . NOTE : \u662f\u5426\u662f\u6240\u6709\u7684socket\u90fd\u9700\u8981***binding***\uff1f\u4e0d\u662f\u7684\uff0c\u53c2\u89c1\u300anetworking-code.md\u300b\uff0c\u5176\u4e2d\u5c55\u793a\u4e86\u57fa\u672c\u7684TCP\u548cUDP socket\u7684\u7f16\u7a0b\u8303\u5f0f\uff1b Note that while a local process can communicate with a foreign process by sending or receiving data to or from a foreign socket address , it does not have access to the foreign socket itself, nor can it use the foreign socket descriptor , as these are both internal to the foreign node. For example, in a connection between 10.20.30.40:4444 and 50.60.70.80:8888 (local IP address:local port, foreign IP address:foreign port), there will also be an associated socket at each end, corresponding to the internal representation of the connection by the protocol stack on that node. These are referred to locally by numerical socket descriptors, say 317 at one side and 922 at the other. A process on node 10.20.30.40 can request to communicate with node 50.60.70.80 on port 8888 (request that the protocol stack create a socket to communicate with that destination), and once it has created a socket and received a socket descriptor (317), it can communicate via this socket by using the descriptor (317). The protocol stack will then forward data to and from node 50.60.70.80 on port 8888. However, a process on node 10.20.30.40 cannot request to communicate based on the foreign socket descriptor, (e.g. \"socket 922\" or \"socket 922 on node 50.60.70.80\") as these are internal to the foreign node and are not usable by the protocol stack on node 10.20.30.40.","title":"Socket addresses"},{"location":"Network/Programming/Socket/#socket#pairs","text":"Communicating local and remote sockets are called socket pairs . Each socket pair is described by a unique 4-tuple consisting of source and destination IP addresses and port numbers, i.e. of local and remote socket addresses.[ 8] [ 9] As seen in the discussion above, in the TCP case, each unique socket pair 4-tuple is assigned a socket number, while in the UDP case, each unique local socket address is assigned a socket number. NOTE: How many tuples are there in a connection?","title":"Socket pairs"},{"location":"Network/Programming/Socket/#wikipedia#berkeley#sockets","text":"Berkeley sockets is an application programming interface (API) for Internet sockets and Unix domain sockets , used for inter-process communication (IPC). It is commonly implemented as a library of linkable modules. It originated with the 4.2BSD Unix operating system, released in 1983. A socket is an abstract representation ( handle ) for the local endpoint of a network communication path. The Berkeley sockets API represents it as a file descriptor ( file handle ) in the Unix philosophy that provides a common interface for input and output to streams of data. Berkeley sockets evolved with little modification from a de facto standard into a component of the POSIX specification. The term POSIX sockets is essentially synonymous with Berkeley sockets , but they are also known as BSD sockets , acknowledging the first implementation in the Berkeley Software Distribution .","title":"wikipedia Berkeley sockets"},{"location":"Network/Programming/man-7-socket/","text":"SOCKET(7) Linux Programmer's Manual NAME \u200b socket - Linux socket interface SYNOPSIS #include <sys/socket.h> sockfd = socket ( int socket_family , int socket_type , int protocol ); DESCRIPTION This manual page describes the Linux networking socket layer user interface. The BSD compatible sockets are the uniform interface between the user process and the network protocol stacks in the kernel. The protocol modules are grouped into protocol families like AF_INET , AF_IPX , AF_PACKET and socket types like SOCK_STREAM or SOCK_DGRAM . See socket(2) for more information on families and types . SUMMARY : \u5728APUE\u768416.2 Socket Descriptors\u4e2d\u5c06 socket(2) \u79f0\u4e4b\u4e3a domain \uff0c\u5e76\u4e14 man 2 socket \u4e2d\uff0c\u4e5f\u53eb\u505a domain \uff0c\u6211\u89c9\u5f97 domain \u66f4\u597d\u7406\u89e3\uff1b Socket-layer functions These functions are used by the user process to send or receive packets and to do other socket operations. For more information see their respective manual pages. socket(2) creates a socket, connect(2) connects a socket to a remote socket address, the bind(2) function binds a socket to a local socket address , listen(2) tells the socket that new connections shall be accepted, and accept(2) is used to get a new socket with a new incoming connection. socketpair(2) returns two connected anonymous sockets (implemented only for a few local families like AF_UNIX ) SUMMARY : \u901a\u8fc7 getaddrinfo(3) \u5c06address\u548cport\u8fdb\u884c\u7ed3\u5408\uff0c\u5f97\u5230 struct addrinfo \uff0c\u7136\u540e\u6839\u636e struct addrinfo \u6765\u521b\u5efasocket\uff0cbind\u7b49\uff0c\u5177\u4f53\u5b9e\u4f8b\u53c2\u89c1 http://man7.org/linux/man-pages/man3/getaddrinfo.3.html \uff1b send(2) , sendto(2) , and sendmsg(2) send data over a socket, and recv(2) , recvfrom(2) , recvmsg(2) receive data from a socket. poll(2) and select(2) wait for arriving data or a readiness to send data. In addition, the standard I/O operations like write(2) , writev(2) , sendfile(2) , read(2) , and readv(2) can be used to read and write data. getsockname(2) returns the local socket address and getpeername(2) returns the remote socket address . getsockopt(2) and setsockopt(2) are used to set or get socket layer or protocol options. ioctl(2) can be used to set or read some other options. close(2) is used to close a socket. shutdown(2) closes parts of a full-duplex socket connection. Seeking, or calling pread(2) or pwrite(2) with a nonzero position is not supported on sockets. It is possible to do nonblocking I/O on sockets by setting the O_NONBLOCK flag on a socket file descriptor using fcntl(2) . Then all operations that would block will (usually) return with EAGAIN (operation should be retried later); connect(2) will return EINPROGRESS error. The user can then wait for various events via poll(2) or select(2) . \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 I/O events \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Event \u2502 Poll flag \u2502 Occurrence \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read \u2502 POLLIN \u2502 New data arrived. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read \u2502 POLLIN \u2502 A connection setup has been completed (for \u2502 \u2502 \u2502 \u2502 connection-oriented sockets) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read \u2502 POLLHUP \u2502 A disconnection request has been initiated \u2502 \u2502 \u2502 \u2502 by the other end. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read \u2502 POLLHUP \u2502 A connection is broken (only for connec\u2010 \u2502 \u2502 \u2502 \u2502 tion-oriented protocols). When the socket \u2502 \u2502 \u2502 \u2502 is written SIGPIPE is also sent. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Write \u2502 POLLOUT \u2502 Socket has enough send buffer space for \u2502 \u2502 \u2502 \u2502 writing new data. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read/Write \u2502 POLLIN| \u2502 An outgoing connect(2) finished. \u2502 \u2502 \u2502 POLLOUT \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read/Write \u2502 POLLERR \u2502 An asynchronous error occurred. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read/Write \u2502 POLLHUP \u2502 The other end has shut down one direction. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Exception \u2502 POLLPRI \u2502 Urgent data arrived. SIGURG is sent then. \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 An alternative to poll(2) and select(2) is to let the kernel inform the application about events via a SIGIO signal. For that the O_ASYNC flag must be set on a socket file descriptor via fcntl(2) and a valid signal handler for SIGIO must be installed via sigaction(2) . See the Signals discussion below. Socket address structures Each socket domain has its own format for socket addresses, with a domain-specific address structure . Each of these structures begins with an integer \"family\" field (typed as sa_family_t ) that indicates the type of the address structure. This allows the various system calls (e.g., connect(2) , bind(2) , accept(2) , getsockname(2) , getpeername(2) ), which are generic to all socket domains , to determine the domain of a particular socket address. To allow any type of socket address to be passed to interfaces in the sockets API, the type struct sockaddr is defined. The purpose of this type is purely to allow casting of domain-specific socket address types to a \"generic\" type, so as to avoid compiler warnings about type mismatches in calls to the sockets API. In addition, the sockets API provides the data type struct sockaddr_storage . This type is suitable to accommodate all supported domain-specific socket address structures; it is large enough and is aligned properly. (In particular, it is large enough to hold IPv6 socket addresses.) The structure includes the following field, which can be used to identify the type of socket address actually stored in the structure: sa_family_t ss_family; The sockaddr_storage structure is useful in programs that must handle socket addresses in a generic way (e.g., programs that must deal with both IPv4 and IPv6 socket addresses). Socket options The socket options listed below can be set by using setsockopt(2) and read with getsockopt(2) with the socket level set to SOL_SOCKET for all sockets. Unless otherwise noted, optval is a pointer to an int . SO_ACCEPTCONN Returns a value indicating whether or not this socket has been marked to accept connections with listen(2) . The value 0 indicates that this is not a listening socket , the value 1 indicates that this is a listening socket . This socket option is read-only. SO_BINDTODEVICE Bind this socket to a particular device like eth0 as specified in the passed interface name. If the name is an empty string or the option length is zero, the socket device binding is removed. The passed option is a variable-length null-terminated interface name string with the maximum size of IFNAMSIZ . If a socket is bound to an interface, only packets received from that particular interface are processed by the socket. Note that this works only for some socket types, particularly AF_INET sockets. It is not supported for packet sockets (use normal bind(2) there). Before Linux 3.8, this socket option could be set, but could not retrieved with getsockopt(2). Since Linux 3.8, it is readable. The optlen argument should contain the buffer size available to receive the device name and is recommended to be IFNAMSZ bytes. The real device name length is reported back in the optlen argument. SO_BROADCAST Set or get the broadcast flag . When enabled, datagram sockets are allowed to send packets to a broadcast address . This option has no effect on stream-oriented sockets . SO_BSDCOMPAT Enable BSD bug-to-bug compatibility. This is used by the UDP protocol module in Linux 2.0 and 2.2. If enabled ICMP errors received for a UDP socket will not be passed to the user program. In later kernel versions, support for this option has been phased out: Linux 2.4 silently ignores it, and Linux 2.6 generates a kernel warning ( printk() ) if a program uses this option. Linux 2.0 also enabled BSD bug-to-bug compatibility options (random header changing, skipping of the broadcast flag) for raw sockets with this option, but that was removed in Linux 2.2. SO_DEBUG Enable socket debugging. Only allowed for processes with the CAP_NET_ADMIN capability or an effective user ID of 0. SO_DOMAIN (since Linux 2.6.32) Retrieves the socket domain as an integer, returning a value such as AF_INET6 . See socket(2) for details. This socket option is read-only. SO_ERROR Get and clear the pending socket error. This socket option is read-only. Expects an integer. \u200b SO_DONTROUTE Don't send via a gateway, send only to directly connected hosts. The same effect can be achieved by setting the MSG_DONTROUTE flag on a socket send(2) operation. Expects an integer boolean flag. SO_KEEPALIVE Enable sending of keep-alive messages on connection-oriented sockets. Expects an integer boolean flag. SO_LINGER Sets or gets the SO_LINGER option. The argument is a linger structure. struct linger { int l_onoff ; /* linger active */ int l_linger ; /* how many seconds to linger for */ }; When enabled, a close(2) or shutdown(2) will not return until all queued messages for the socket have been successfully sent or the linger timeout has been reached. Otherwise, the call returns immediately and the closing is done in the background. When the socket is closed as part of exit(2), it always lingers in the background. SO_MARK (since Linux 2.6.25) \u200b Set the mark for each packet sent through this socket (similar to the netfilter MARK target but socket-based). Changing the \u200b mark can be used for mark-based routing without netfilter or for packet filtering. Setting this option requires the \u200b CAP_NET_ADMIN capability. \u200b SO_OOBINLINE If this option is enabled, out-of-band data is directly placed into the receive data stream. Otherwise out-of-band data is passed only when the MSG_OOB flag is set during receiving. SO_PASSCRED Enable or disable the receiving of the SCM_CREDENTIALS control message. For more information see unix(7). SO_PEEK_OFF (since Linux 3.4) This option, which is currently supported only for unix(7) sockets, sets the value of the \"peek offset\" for the recv(2) system call when used with MSG_PEEK flag. When this option is set to a negative value (it is set to -1 for all new sockets), traditional behavior is provided: recv(2) with the MSG_PEEK flag will peek data from the front of the queue. When the option is set to a value greater than or equal to zero, then the next peek at data queued in the socket will occur at the byte offset specified by the option value. At the same time, the \"peek offset\" will be incremented by the number of bytes that were peeked from the queue, so that a subsequent peek will return the next data in the queue.i If data is removed from the front of the queue via a call to recv(2) (or similar) without the MSG_PEEK flag, the \"peek offset\" will be decreased by the number of bytes removed. In other words, receiving data without the MSG_PEEK flag will cause the \"peek offset\" to be adjusted to maintain the correct relative position in the queued data, so that a subsequent peek will retrieve the data that would have been retrieved had the data not been removed. For datagram sockets, if the \"peek offset\" points to the middle of a packet, the data returned will be marked with the MSG_TRUNC flag. The following example serves to illustrate the use of SO_PEEK_OFF. Suppose a stream socket has the following queued input data: aabbccddeeff The following sequence of recv(2) calls would have the effect noted in the comments: int ov = 4; // Set peek offset to 4 setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov)); recv(fd, buf, 2, MSG_PEEK); // Peeks \"cc\"; offset set to 6 recv(fd, buf, 2, MSG_PEEK); // Peeks \"dd\"; offset set to 8 recv(fd, buf, 2, 0); // Reads \"aa\"; offset set to 6 recv(fd, buf, 2, MSG_PEEK); // Peeks \"ee\"; offset set to 8 SO_PEERCRED \u200b Return the credentials of the foreign process connected to this socket. This is possible only for connected AF_UNIX stream \u200b sockets and AF_UNIX stream and datagram socket pairs created using socketpair(2); see unix(7). The returned credentials are \u200b those that were in effect at the time of the call to connect(2) or socketpair(2). The argument is a ucred structure; define \u200b the GNU_SOURCE feature test macro to obtain the definition of that structure from . This socket option is read- \u200b only. \u200b SO_PRIORITY \u200b Set the protocol-defined priority for all packets to be sent on this socket. Linux uses this value to order the networking \u200b queues: packets with a higher priority may be processed first depending on the selected device queueing discipline. For ip(7), \u200b this also sets the IP type-of-service (TOS) field for outgoing packets. Setting a priority outside the range 0 to 6 requires \u200b the CAP_NET_ADMIN capability. \u200b SO_PROTOCOL (since Linux 2.6.32) \u200b Retrieves the socket protocol as an integer, returning a value such as IPPROTO_SCTP. See socket(2) for details. This socket \u200b option is read-only. \u200b SO_RCVBUF Sets or gets the maximum socket receive buffer in bytes. The kernel doubles this value (to allow space for bookkeeping overhead) when it is set using setsockopt(2) , and this doubled value is returned by getsockopt(2) . The default value is set by the /proc/sys/net/core/rmem_default file, and the maximum allowed value is set by the /proc/sys/net/core/rmem_max file. The minimum (doubled) value for this option is 256. SO_RCVBUFFORCE (since Linux 2.6.14) Using this socket option, a privileged ( CAP_NET_ADMIN ) process can perform the same task as SO_RCVBUF, but the rmem_max limit can be overridden. SO_RCVLOWAT and SO_SNDLOWAT Specify the minimum number of bytes in the buffer until the socket layer will pass the data to the protocol ( SO_SNDLOWAT ) or the user on receiving ( SO_RCVLOWAT ). These two values are initialized to 1. SO_SNDLOWAT is not changeable on Linux ( setsockopt(2) fails with the error ENOPROTOOPT ). SO_RCVLOWAT is changeable only since Linux 2.4. Before Linux 2.6.28, the select(2) and poll(2) system calls currently do not respect the SO_RCVLOWAT setting on Linux, and mark a socket readable when even a single byte of data is available. A subsequent read from the socket will block until SO_RCVLOWAT bytes are available. SUMMARY : \u4e0a\u9762\u8fd9\u4e00\u6bb5\u63cf\u8ff0\u662f\u975e\u5e38\u4e0d\u6e05\u695a\u7684\uff0c\u53ef\u4ee5\u53c2\u89c1 A SO_RCVTIMEO and SO_SNDTIMEO Specify the receiving or sending timeouts until reporting an error. The argument is a struct timeval . If an input or output function blocks for this period of time, and data has been sent or received, the return value of that function will be the amount of data transferred; if no data has been transferred and the timeout has been reached then -1 is returned with errno set to EAGAIN or EWOULDBLOCK , or EINPROGRESS (for connect(2) ) just as if the socket was specified to be nonblocking . If the timeout is set to zero (the default) then the operation will never timeout. Timeouts only have effect for system calls that perform socket I/O (e.g., read(2) , recvmsg(2) , send(2) , sendmsg(2) ); timeouts have no effect for select(2) , poll(2) , epoll_wait(2) , and so on. SO_REUSEADDR Indicates that the rules used in validating addresses supplied in a bind(2) call should allow reuse of local addresses. For AF_INET sockets this means that a socket may bind, except when there is an active listening socket bound to the address. When the listening socket is bound to INADDR_ANY with a specific port then it is not possible to bind to this port for any local address. Argument is an integer boolean flag. SO_SNDBUF \u200b Sets or gets the maximum socket send buffer in bytes. The kernel doubles this value (to allow space for bookkeeping overhead) \u200b when it is set using setsockopt(2), and this doubled value is returned by getsockopt(2). The default value is set by the \u200b /proc/sys/net/core/wmem_default file and the maximum allowed value is set by the /proc/sys/net/core/wmem_max file. The minimum \u200b (doubled) value for this option is 2048. \u200b SO_SNDBUFFORCE (since Linux 2.6.14) \u200b Using this socket option, a privileged (CAP_NET_ADMIN) process can perform the same task as SO_SNDBUF, but the wmem_max limit \u200b can be overridden. \u200b SO_TIMESTAMP \u200b Enable or disable the receiving of the SO_TIMESTAMP control message. The timestamp control message is sent with level \u200b SOL_SOCKET and the cmsg_data field is a struct timeval indicating the reception time of the last packet passed to the user in \u200b this call. See cmsg(3) for details on control messages. \u200b SO_TYPE \u200b Gets the socket type as an integer (e.g., SOCK_STREAM). This socket option is read-only. Signals When writing onto a connection-oriented socket that has been shut down (by the local or the remote end) SIGPIPE is sent to the writing process and EPIPE is returned. The signal is not sent when the write call specified the MSG_NOSIGNAL flag. When requested with the FIOSETOWN fcntl(2) or SIOCSPGRP ioctl(2) , SIGIO is sent when an I/O event occurs. It is possible to use poll(2) or select(2) in the signal handler to find out which socket the event occurred on. An alternative (in Linux 2.2) is to set a real-time signal using the F_SETSIG fcntl(2) ; the handler of the real time signal will be called with the file descriptor in the si_fd field of its siginfo_t . See fcntl(2) for more information. Under some circumstances (e.g., multiple processes accessing a single socket), the condition that caused the SIGIO may have already disappeared when the process reacts to the signal. If this happens, the process should wait again because Linux will resend the signal later. /proc interfaces \u200b The core socket networking parameters can be accessed via files in the directory /proc/sys/net/core/. rmem_default contains the default setting in bytes of the socket receive buffer. rmem_max contains the maximum socket receive buffer size in bytes which a user may set by using the SO_RCVBUF socket option. wmem_default contains the default setting in bytes of the socket send buffer. wmem_max contains the maximum socket send buffer size in bytes which a user may set by using the SO_SNDBUF socket option. message_cost and message_burst configure the token bucket filter used to load limit warning messages caused by external network events. netdev_max_backlog Maximum number of packets in the global input queue. optmem_max Maximum length of ancillary data and user control data like the iovecs per socket. Ioctls These operations can be accessed using ioctl(2): error = ioctl(ip_socket, ioctl_type, &value_result); SIOCGSTAMP Return a struct timeval with the receive timestamp of the last packet passed to the user. This is useful for accurate round trip time measurements. See setitimer(2) for a description of struct timeval. This ioctl should be used only if the socket option SO_TIMESTAMP is not set on the socket. Otherwise, it returns the timestamp of the last packet that was received while SO_TIMESTAMP was not set, or it fails if no such packet has been received, (i.e., ioctl(2) returns -1 with errno set to ENOENT). SIOCSPGRP Set the process or process group to send SIGIO or SIGURG signals to when an asynchronous I/O operation has finished or urgent data is available. The argument is a pointer to a pid_t. If the argument is positive, send the signals to that process. If the argument is negative, send the signals to the process group with the ID of the absolute value of the argument. The process may only choose itself or its own process group to receive signals unless it has the CAP_KILL capability or an effective UID of 0. FIOASYNC Change the O_ASYNC flag to enable or disable asynchronous I/O mode of the socket. Asynchronous I/O mode means that the SIGIO signal or the signal set with F_SETSIG is raised when a new I/O event occurs. Argument is an integer boolean flag. (This operation is synonymous with the use of fcntl(2) to set the O_ASYNC flag.) SIOCGPGRP Get the current process or process group that receives SIGIO or SIGURG signals, or 0 when none is set. Valid fcntl(2) operations: FIOGETOWN The same as the SIOCGPGRP ioctl(2). FIOSETOWN The same as the SIOCSPGRP ioctl(2). VERSIONS SO_BINDTODEVICE was introduced in Linux 2.0.30. SO_PASSCRED is new in Linux 2.2. The /proc interfaces was introduced in Linux 2.2. SO_RCVTIMEO and SO_SNDTIMEO are supported since Linux 2.3.41. Earlier, timeouts were fixed to a protocol-specific setting, and could not be read or written. NOTES Linux assumes that half of the send/receive buffer is used for internal kernel structures; thus the values in the corresponding /proc files are twice what can be observed on the wire. Linux will only allow port reuse with the SO_REUSEADDR option when this option was set both in the previous program that performed a bind(2) to the port and in the program that wants to reuse the port. This differs from some implementations (e.g., FreeBSD) where only the later program needs to set the SO_REUSEADDR option. Typically this difference is invisible, since, for example, a server program is designed to always set this option. BUGS The CONFIG_FILTER socket options SO_ATTACH_FILTER and SO_DETACH_FILTER are not documented. The suggested interface to use them is via the libpcap library. SEE ALSO getsockopt(2), connect(2), setsockopt(2), socket(2), capabilities(7), ddp(7), ip(7), packet(7), tcp(7), udp(7), unix(7) COLOPHON This page is part of release 3.53 of the Linux man-pages project. A description of the project, and information about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/ . Linux 2013-06-21 SOCKET(7)","title":"man-7-socket"},{"location":"Network/Programming/man-7-socket/#socket7#linux#programmers#manual","text":"","title":"SOCKET(7) Linux Programmer's Manual"},{"location":"Network/Programming/man-7-socket/#name","text":"\u200b socket - Linux socket interface","title":"NAME"},{"location":"Network/Programming/man-7-socket/#synopsis","text":"#include <sys/socket.h> sockfd = socket ( int socket_family , int socket_type , int protocol );","title":"SYNOPSIS"},{"location":"Network/Programming/man-7-socket/#description","text":"This manual page describes the Linux networking socket layer user interface. The BSD compatible sockets are the uniform interface between the user process and the network protocol stacks in the kernel. The protocol modules are grouped into protocol families like AF_INET , AF_IPX , AF_PACKET and socket types like SOCK_STREAM or SOCK_DGRAM . See socket(2) for more information on families and types . SUMMARY : \u5728APUE\u768416.2 Socket Descriptors\u4e2d\u5c06 socket(2) \u79f0\u4e4b\u4e3a domain \uff0c\u5e76\u4e14 man 2 socket \u4e2d\uff0c\u4e5f\u53eb\u505a domain \uff0c\u6211\u89c9\u5f97 domain \u66f4\u597d\u7406\u89e3\uff1b","title":"DESCRIPTION"},{"location":"Network/Programming/man-7-socket/#socket-layer#functions","text":"These functions are used by the user process to send or receive packets and to do other socket operations. For more information see their respective manual pages. socket(2) creates a socket, connect(2) connects a socket to a remote socket address, the bind(2) function binds a socket to a local socket address , listen(2) tells the socket that new connections shall be accepted, and accept(2) is used to get a new socket with a new incoming connection. socketpair(2) returns two connected anonymous sockets (implemented only for a few local families like AF_UNIX ) SUMMARY : \u901a\u8fc7 getaddrinfo(3) \u5c06address\u548cport\u8fdb\u884c\u7ed3\u5408\uff0c\u5f97\u5230 struct addrinfo \uff0c\u7136\u540e\u6839\u636e struct addrinfo \u6765\u521b\u5efasocket\uff0cbind\u7b49\uff0c\u5177\u4f53\u5b9e\u4f8b\u53c2\u89c1 http://man7.org/linux/man-pages/man3/getaddrinfo.3.html \uff1b send(2) , sendto(2) , and sendmsg(2) send data over a socket, and recv(2) , recvfrom(2) , recvmsg(2) receive data from a socket. poll(2) and select(2) wait for arriving data or a readiness to send data. In addition, the standard I/O operations like write(2) , writev(2) , sendfile(2) , read(2) , and readv(2) can be used to read and write data. getsockname(2) returns the local socket address and getpeername(2) returns the remote socket address . getsockopt(2) and setsockopt(2) are used to set or get socket layer or protocol options. ioctl(2) can be used to set or read some other options. close(2) is used to close a socket. shutdown(2) closes parts of a full-duplex socket connection. Seeking, or calling pread(2) or pwrite(2) with a nonzero position is not supported on sockets. It is possible to do nonblocking I/O on sockets by setting the O_NONBLOCK flag on a socket file descriptor using fcntl(2) . Then all operations that would block will (usually) return with EAGAIN (operation should be retried later); connect(2) will return EINPROGRESS error. The user can then wait for various events via poll(2) or select(2) . \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 I/O events \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Event \u2502 Poll flag \u2502 Occurrence \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read \u2502 POLLIN \u2502 New data arrived. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read \u2502 POLLIN \u2502 A connection setup has been completed (for \u2502 \u2502 \u2502 \u2502 connection-oriented sockets) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read \u2502 POLLHUP \u2502 A disconnection request has been initiated \u2502 \u2502 \u2502 \u2502 by the other end. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read \u2502 POLLHUP \u2502 A connection is broken (only for connec\u2010 \u2502 \u2502 \u2502 \u2502 tion-oriented protocols). When the socket \u2502 \u2502 \u2502 \u2502 is written SIGPIPE is also sent. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Write \u2502 POLLOUT \u2502 Socket has enough send buffer space for \u2502 \u2502 \u2502 \u2502 writing new data. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read/Write \u2502 POLLIN| \u2502 An outgoing connect(2) finished. \u2502 \u2502 \u2502 POLLOUT \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read/Write \u2502 POLLERR \u2502 An asynchronous error occurred. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Read/Write \u2502 POLLHUP \u2502 The other end has shut down one direction. \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Exception \u2502 POLLPRI \u2502 Urgent data arrived. SIGURG is sent then. \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 An alternative to poll(2) and select(2) is to let the kernel inform the application about events via a SIGIO signal. For that the O_ASYNC flag must be set on a socket file descriptor via fcntl(2) and a valid signal handler for SIGIO must be installed via sigaction(2) . See the Signals discussion below.","title":"Socket-layer functions"},{"location":"Network/Programming/man-7-socket/#socket#address#structures","text":"Each socket domain has its own format for socket addresses, with a domain-specific address structure . Each of these structures begins with an integer \"family\" field (typed as sa_family_t ) that indicates the type of the address structure. This allows the various system calls (e.g., connect(2) , bind(2) , accept(2) , getsockname(2) , getpeername(2) ), which are generic to all socket domains , to determine the domain of a particular socket address. To allow any type of socket address to be passed to interfaces in the sockets API, the type struct sockaddr is defined. The purpose of this type is purely to allow casting of domain-specific socket address types to a \"generic\" type, so as to avoid compiler warnings about type mismatches in calls to the sockets API. In addition, the sockets API provides the data type struct sockaddr_storage . This type is suitable to accommodate all supported domain-specific socket address structures; it is large enough and is aligned properly. (In particular, it is large enough to hold IPv6 socket addresses.) The structure includes the following field, which can be used to identify the type of socket address actually stored in the structure: sa_family_t ss_family; The sockaddr_storage structure is useful in programs that must handle socket addresses in a generic way (e.g., programs that must deal with both IPv4 and IPv6 socket addresses).","title":"Socket address structures"},{"location":"Network/Programming/man-7-socket/#socket#options","text":"The socket options listed below can be set by using setsockopt(2) and read with getsockopt(2) with the socket level set to SOL_SOCKET for all sockets. Unless otherwise noted, optval is a pointer to an int .","title":"Socket options"},{"location":"Network/Programming/man-7-socket/#so_acceptconn","text":"Returns a value indicating whether or not this socket has been marked to accept connections with listen(2) . The value 0 indicates that this is not a listening socket , the value 1 indicates that this is a listening socket . This socket option is read-only.","title":"SO_ACCEPTCONN"},{"location":"Network/Programming/man-7-socket/#so_bindtodevice","text":"Bind this socket to a particular device like eth0 as specified in the passed interface name. If the name is an empty string or the option length is zero, the socket device binding is removed. The passed option is a variable-length null-terminated interface name string with the maximum size of IFNAMSIZ . If a socket is bound to an interface, only packets received from that particular interface are processed by the socket. Note that this works only for some socket types, particularly AF_INET sockets. It is not supported for packet sockets (use normal bind(2) there). Before Linux 3.8, this socket option could be set, but could not retrieved with getsockopt(2). Since Linux 3.8, it is readable. The optlen argument should contain the buffer size available to receive the device name and is recommended to be IFNAMSZ bytes. The real device name length is reported back in the optlen argument.","title":"SO_BINDTODEVICE"},{"location":"Network/Programming/man-7-socket/#so_broadcast","text":"Set or get the broadcast flag . When enabled, datagram sockets are allowed to send packets to a broadcast address . This option has no effect on stream-oriented sockets .","title":"SO_BROADCAST"},{"location":"Network/Programming/man-7-socket/#so_bsdcompat","text":"Enable BSD bug-to-bug compatibility. This is used by the UDP protocol module in Linux 2.0 and 2.2. If enabled ICMP errors received for a UDP socket will not be passed to the user program. In later kernel versions, support for this option has been phased out: Linux 2.4 silently ignores it, and Linux 2.6 generates a kernel warning ( printk() ) if a program uses this option. Linux 2.0 also enabled BSD bug-to-bug compatibility options (random header changing, skipping of the broadcast flag) for raw sockets with this option, but that was removed in Linux 2.2.","title":"SO_BSDCOMPAT"},{"location":"Network/Programming/man-7-socket/#so_debug","text":"Enable socket debugging. Only allowed for processes with the CAP_NET_ADMIN capability or an effective user ID of 0.","title":"SO_DEBUG"},{"location":"Network/Programming/man-7-socket/#so_domain#since#linux#2632","text":"Retrieves the socket domain as an integer, returning a value such as AF_INET6 . See socket(2) for details. This socket option is read-only.","title":"SO_DOMAIN (since Linux 2.6.32)"},{"location":"Network/Programming/man-7-socket/#so_error","text":"Get and clear the pending socket error. This socket option is read-only. Expects an integer. \u200b","title":"SO_ERROR"},{"location":"Network/Programming/man-7-socket/#so_dontroute","text":"Don't send via a gateway, send only to directly connected hosts. The same effect can be achieved by setting the MSG_DONTROUTE flag on a socket send(2) operation. Expects an integer boolean flag.","title":"SO_DONTROUTE"},{"location":"Network/Programming/man-7-socket/#so_keepalive","text":"Enable sending of keep-alive messages on connection-oriented sockets. Expects an integer boolean flag.","title":"SO_KEEPALIVE"},{"location":"Network/Programming/man-7-socket/#so_linger","text":"Sets or gets the SO_LINGER option. The argument is a linger structure. struct linger { int l_onoff ; /* linger active */ int l_linger ; /* how many seconds to linger for */ }; When enabled, a close(2) or shutdown(2) will not return until all queued messages for the socket have been successfully sent or the linger timeout has been reached. Otherwise, the call returns immediately and the closing is done in the background. When the socket is closed as part of exit(2), it always lingers in the background.","title":"SO_LINGER"},{"location":"Network/Programming/man-7-socket/#so_mark#since#linux#2625","text":"\u200b Set the mark for each packet sent through this socket (similar to the netfilter MARK target but socket-based). Changing the \u200b mark can be used for mark-based routing without netfilter or for packet filtering. Setting this option requires the \u200b CAP_NET_ADMIN capability. \u200b SO_OOBINLINE If this option is enabled, out-of-band data is directly placed into the receive data stream. Otherwise out-of-band data is passed only when the MSG_OOB flag is set during receiving. SO_PASSCRED Enable or disable the receiving of the SCM_CREDENTIALS control message. For more information see unix(7). SO_PEEK_OFF (since Linux 3.4) This option, which is currently supported only for unix(7) sockets, sets the value of the \"peek offset\" for the recv(2) system call when used with MSG_PEEK flag. When this option is set to a negative value (it is set to -1 for all new sockets), traditional behavior is provided: recv(2) with the MSG_PEEK flag will peek data from the front of the queue. When the option is set to a value greater than or equal to zero, then the next peek at data queued in the socket will occur at the byte offset specified by the option value. At the same time, the \"peek offset\" will be incremented by the number of bytes that were peeked from the queue, so that a subsequent peek will return the next data in the queue.i If data is removed from the front of the queue via a call to recv(2) (or similar) without the MSG_PEEK flag, the \"peek offset\" will be decreased by the number of bytes removed. In other words, receiving data without the MSG_PEEK flag will cause the \"peek offset\" to be adjusted to maintain the correct relative position in the queued data, so that a subsequent peek will retrieve the data that would have been retrieved had the data not been removed. For datagram sockets, if the \"peek offset\" points to the middle of a packet, the data returned will be marked with the MSG_TRUNC flag. The following example serves to illustrate the use of SO_PEEK_OFF. Suppose a stream socket has the following queued input data: aabbccddeeff The following sequence of recv(2) calls would have the effect noted in the comments: int ov = 4; // Set peek offset to 4 setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov)); recv(fd, buf, 2, MSG_PEEK); // Peeks \"cc\"; offset set to 6 recv(fd, buf, 2, MSG_PEEK); // Peeks \"dd\"; offset set to 8 recv(fd, buf, 2, 0); // Reads \"aa\"; offset set to 6 recv(fd, buf, 2, MSG_PEEK); // Peeks \"ee\"; offset set to 8","title":"SO_MARK (since Linux 2.6.25)"},{"location":"Network/Programming/man-7-socket/#so_peercred","text":"\u200b Return the credentials of the foreign process connected to this socket. This is possible only for connected AF_UNIX stream \u200b sockets and AF_UNIX stream and datagram socket pairs created using socketpair(2); see unix(7). The returned credentials are \u200b those that were in effect at the time of the call to connect(2) or socketpair(2). The argument is a ucred structure; define \u200b the GNU_SOURCE feature test macro to obtain the definition of that structure from . This socket option is read- \u200b only. \u200b","title":"SO_PEERCRED"},{"location":"Network/Programming/man-7-socket/#so_priority","text":"\u200b Set the protocol-defined priority for all packets to be sent on this socket. Linux uses this value to order the networking \u200b queues: packets with a higher priority may be processed first depending on the selected device queueing discipline. For ip(7), \u200b this also sets the IP type-of-service (TOS) field for outgoing packets. Setting a priority outside the range 0 to 6 requires \u200b the CAP_NET_ADMIN capability. \u200b","title":"SO_PRIORITY"},{"location":"Network/Programming/man-7-socket/#so_protocol#since#linux#2632","text":"\u200b Retrieves the socket protocol as an integer, returning a value such as IPPROTO_SCTP. See socket(2) for details. This socket \u200b option is read-only. \u200b","title":"SO_PROTOCOL (since Linux 2.6.32)"},{"location":"Network/Programming/man-7-socket/#so_rcvbuf","text":"Sets or gets the maximum socket receive buffer in bytes. The kernel doubles this value (to allow space for bookkeeping overhead) when it is set using setsockopt(2) , and this doubled value is returned by getsockopt(2) . The default value is set by the /proc/sys/net/core/rmem_default file, and the maximum allowed value is set by the /proc/sys/net/core/rmem_max file. The minimum (doubled) value for this option is 256.","title":"SO_RCVBUF"},{"location":"Network/Programming/man-7-socket/#so_rcvbufforce#since#linux#2614","text":"Using this socket option, a privileged ( CAP_NET_ADMIN ) process can perform the same task as SO_RCVBUF, but the rmem_max limit can be overridden.","title":"SO_RCVBUFFORCE (since Linux 2.6.14)"},{"location":"Network/Programming/man-7-socket/#so_rcvlowat#and#so_sndlowat","text":"Specify the minimum number of bytes in the buffer until the socket layer will pass the data to the protocol ( SO_SNDLOWAT ) or the user on receiving ( SO_RCVLOWAT ). These two values are initialized to 1. SO_SNDLOWAT is not changeable on Linux ( setsockopt(2) fails with the error ENOPROTOOPT ). SO_RCVLOWAT is changeable only since Linux 2.4. Before Linux 2.6.28, the select(2) and poll(2) system calls currently do not respect the SO_RCVLOWAT setting on Linux, and mark a socket readable when even a single byte of data is available. A subsequent read from the socket will block until SO_RCVLOWAT bytes are available. SUMMARY : \u4e0a\u9762\u8fd9\u4e00\u6bb5\u63cf\u8ff0\u662f\u975e\u5e38\u4e0d\u6e05\u695a\u7684\uff0c\u53ef\u4ee5\u53c2\u89c1 A","title":"SO_RCVLOWAT and SO_SNDLOWAT"},{"location":"Network/Programming/man-7-socket/#so_rcvtimeo#and#so_sndtimeo","text":"Specify the receiving or sending timeouts until reporting an error. The argument is a struct timeval . If an input or output function blocks for this period of time, and data has been sent or received, the return value of that function will be the amount of data transferred; if no data has been transferred and the timeout has been reached then -1 is returned with errno set to EAGAIN or EWOULDBLOCK , or EINPROGRESS (for connect(2) ) just as if the socket was specified to be nonblocking . If the timeout is set to zero (the default) then the operation will never timeout. Timeouts only have effect for system calls that perform socket I/O (e.g., read(2) , recvmsg(2) , send(2) , sendmsg(2) ); timeouts have no effect for select(2) , poll(2) , epoll_wait(2) , and so on.","title":"SO_RCVTIMEO and SO_SNDTIMEO"},{"location":"Network/Programming/man-7-socket/#so_reuseaddr","text":"Indicates that the rules used in validating addresses supplied in a bind(2) call should allow reuse of local addresses. For AF_INET sockets this means that a socket may bind, except when there is an active listening socket bound to the address. When the listening socket is bound to INADDR_ANY with a specific port then it is not possible to bind to this port for any local address. Argument is an integer boolean flag.","title":"SO_REUSEADDR"},{"location":"Network/Programming/man-7-socket/#so_sndbuf","text":"\u200b Sets or gets the maximum socket send buffer in bytes. The kernel doubles this value (to allow space for bookkeeping overhead) \u200b when it is set using setsockopt(2), and this doubled value is returned by getsockopt(2). The default value is set by the \u200b /proc/sys/net/core/wmem_default file and the maximum allowed value is set by the /proc/sys/net/core/wmem_max file. The minimum \u200b (doubled) value for this option is 2048. \u200b","title":"SO_SNDBUF"},{"location":"Network/Programming/man-7-socket/#so_sndbufforce#since#linux#2614","text":"\u200b Using this socket option, a privileged (CAP_NET_ADMIN) process can perform the same task as SO_SNDBUF, but the wmem_max limit \u200b can be overridden. \u200b","title":"SO_SNDBUFFORCE (since Linux 2.6.14)"},{"location":"Network/Programming/man-7-socket/#so_timestamp","text":"\u200b Enable or disable the receiving of the SO_TIMESTAMP control message. The timestamp control message is sent with level \u200b SOL_SOCKET and the cmsg_data field is a struct timeval indicating the reception time of the last packet passed to the user in \u200b this call. See cmsg(3) for details on control messages. \u200b","title":"SO_TIMESTAMP"},{"location":"Network/Programming/man-7-socket/#so_type","text":"\u200b Gets the socket type as an integer (e.g., SOCK_STREAM). This socket option is read-only.","title":"SO_TYPE"},{"location":"Network/Programming/man-7-socket/#signals","text":"When writing onto a connection-oriented socket that has been shut down (by the local or the remote end) SIGPIPE is sent to the writing process and EPIPE is returned. The signal is not sent when the write call specified the MSG_NOSIGNAL flag. When requested with the FIOSETOWN fcntl(2) or SIOCSPGRP ioctl(2) , SIGIO is sent when an I/O event occurs. It is possible to use poll(2) or select(2) in the signal handler to find out which socket the event occurred on. An alternative (in Linux 2.2) is to set a real-time signal using the F_SETSIG fcntl(2) ; the handler of the real time signal will be called with the file descriptor in the si_fd field of its siginfo_t . See fcntl(2) for more information. Under some circumstances (e.g., multiple processes accessing a single socket), the condition that caused the SIGIO may have already disappeared when the process reacts to the signal. If this happens, the process should wait again because Linux will resend the signal later.","title":"Signals"},{"location":"Network/Programming/man-7-socket/#proc#interfaces","text":"\u200b The core socket networking parameters can be accessed via files in the directory /proc/sys/net/core/. rmem_default contains the default setting in bytes of the socket receive buffer. rmem_max contains the maximum socket receive buffer size in bytes which a user may set by using the SO_RCVBUF socket option. wmem_default contains the default setting in bytes of the socket send buffer. wmem_max contains the maximum socket send buffer size in bytes which a user may set by using the SO_SNDBUF socket option. message_cost and message_burst configure the token bucket filter used to load limit warning messages caused by external network events. netdev_max_backlog Maximum number of packets in the global input queue. optmem_max Maximum length of ancillary data and user control data like the iovecs per socket. Ioctls These operations can be accessed using ioctl(2): error = ioctl(ip_socket, ioctl_type, &value_result); SIOCGSTAMP Return a struct timeval with the receive timestamp of the last packet passed to the user. This is useful for accurate round trip time measurements. See setitimer(2) for a description of struct timeval. This ioctl should be used only if the socket option SO_TIMESTAMP is not set on the socket. Otherwise, it returns the timestamp of the last packet that was received while SO_TIMESTAMP was not set, or it fails if no such packet has been received, (i.e., ioctl(2) returns -1 with errno set to ENOENT). SIOCSPGRP Set the process or process group to send SIGIO or SIGURG signals to when an asynchronous I/O operation has finished or urgent data is available. The argument is a pointer to a pid_t. If the argument is positive, send the signals to that process. If the argument is negative, send the signals to the process group with the ID of the absolute value of the argument. The process may only choose itself or its own process group to receive signals unless it has the CAP_KILL capability or an effective UID of 0. FIOASYNC Change the O_ASYNC flag to enable or disable asynchronous I/O mode of the socket. Asynchronous I/O mode means that the SIGIO signal or the signal set with F_SETSIG is raised when a new I/O event occurs. Argument is an integer boolean flag. (This operation is synonymous with the use of fcntl(2) to set the O_ASYNC flag.) SIOCGPGRP Get the current process or process group that receives SIGIO or SIGURG signals, or 0 when none is set. Valid fcntl(2) operations: FIOGETOWN The same as the SIOCGPGRP ioctl(2). FIOSETOWN The same as the SIOCSPGRP ioctl(2). VERSIONS SO_BINDTODEVICE was introduced in Linux 2.0.30. SO_PASSCRED is new in Linux 2.2. The /proc interfaces was introduced in Linux 2.2. SO_RCVTIMEO and SO_SNDTIMEO are supported since Linux 2.3.41. Earlier, timeouts were fixed to a protocol-specific setting, and could not be read or written. NOTES Linux assumes that half of the send/receive buffer is used for internal kernel structures; thus the values in the corresponding /proc files are twice what can be observed on the wire. Linux will only allow port reuse with the SO_REUSEADDR option when this option was set both in the previous program that performed a bind(2) to the port and in the program that wants to reuse the port. This differs from some implementations (e.g., FreeBSD) where only the later program needs to set the SO_REUSEADDR option. Typically this difference is invisible, since, for example, a server program is designed to always set this option. BUGS The CONFIG_FILTER socket options SO_ATTACH_FILTER and SO_DETACH_FILTER are not documented. The suggested interface to use them is via the libpcap library. SEE ALSO getsockopt(2), connect(2), setsockopt(2), socket(2), capabilities(7), ddp(7), ip(7), packet(7), tcp(7), udp(7), unix(7) COLOPHON This page is part of release 3.53 of the Linux man-pages project. A description of the project, and information about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/ . Linux 2013-06-21 SOCKET(7)","title":"/proc interfaces"},{"location":"Network/Programming/Send-file/","text":"Send file developer.51cto \u9ad8\u6027\u80fd\u5f00\u53d1\u7684\u201c\u5341\u5927\u6b66\u5668\u201d\uff0c\u7231\u4e86\u7231\u4e86\uff01# I/O\u4f18\u5316\uff1a\u96f6\u62f7\u8d1d\u6280\u672f \u5728\u9605\u8bfb developer.51cto \u9ad8\u6027\u80fd\u5f00\u53d1\u7684\u201c\u5341\u5927\u6b66\u5668\u201d\uff0c\u7231\u4e86\u7231\u4e86\uff01# I/O\u4f18\u5316\uff1a\u96f6\u62f7\u8d1d\u6280\u672f \u65f6\uff0c\u5176\u4e2d\u4ecb\u7ecd\u4e86 man 2 sendfile : I/O \u4f18\u5316\uff1a\u96f6\u62f7\u8d1d\u6280\u672f \u4e0a\u9762\u7684\u5de5\u4f5c\u7ebf\u7a0b\uff0c\u4ece\u78c1\u76d8\u8bfb\u6587\u4ef6\u3001\u518d\u901a\u8fc7\u7f51\u7edc\u53d1\u9001\u6570\u636e\uff0c\u6570\u636e\u4ece\u78c1\u76d8\u5230\u7f51\u7edc\uff0c\u515c\u515c\u8f6c\u8f6c\u9700\u8981\u62f7\u8d1d\u56db\u6b21\uff0c\u5176\u4e2d CPU \u4eb2\u81ea\u642c\u8fd0\u90fd\u9700\u8981\u4e24\u6b21\u3002 \u96f6\u62f7\u8d1d\u6280\u672f\uff0c\u89e3\u653e CPU\uff0c\u6587\u4ef6\u6570\u636e\u76f4\u63a5\u4ece\u5185\u6838\u53d1\u9001\u51fa\u53bb\uff0c\u65e0\u9700\u518d\u62f7\u8d1d\u5230\u5e94\u7528\u7a0b\u5e8f\u7f13\u51b2\u533a\uff0c\u767d\u767d\u6d6a\u8d39\u8d44\u6e90\u3002 Linux API\uff1a ssize_t sendfile ( int out_fd , int in_fd , off_t * offset , size_t count ); \u51fd\u6570\u540d\u5b57\u5df2\u7ecf\u628a\u51fd\u6570\u7684\u529f\u80fd\u89e3\u91ca\u7684\u5f88\u660e\u663e\u4e86\uff1a\u53d1\u9001\u6587\u4ef6\u3002\u6307\u5b9a\u8981\u53d1\u9001\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u7f51\u7edc\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26\uff0c\u4e00\u4e2a\u51fd\u6570\u641e\u5b9a! man 2 sendfile(2) sendfile() copies data between one file descriptor and another. Because this copying is done within the kernel , sendfile() is more efficient than the combination of read(2) and write(2) , which would require transferring data to and from user space . NOTE:\u4e0a\u9762\u7ae0\u8282\u5df2\u7ecf\u8be6\u7ec6\u4ecb\u7ecd\u4e86\u8fd9\u6837\u505a\u7684\u539f\u56e0\u3002","title":"Introduction"},{"location":"Network/Programming/Send-file/#send#file","text":"","title":"Send file"},{"location":"Network/Programming/Send-file/#developer51cto#io","text":"\u5728\u9605\u8bfb developer.51cto \u9ad8\u6027\u80fd\u5f00\u53d1\u7684\u201c\u5341\u5927\u6b66\u5668\u201d\uff0c\u7231\u4e86\u7231\u4e86\uff01# I/O\u4f18\u5316\uff1a\u96f6\u62f7\u8d1d\u6280\u672f \u65f6\uff0c\u5176\u4e2d\u4ecb\u7ecd\u4e86 man 2 sendfile : I/O \u4f18\u5316\uff1a\u96f6\u62f7\u8d1d\u6280\u672f \u4e0a\u9762\u7684\u5de5\u4f5c\u7ebf\u7a0b\uff0c\u4ece\u78c1\u76d8\u8bfb\u6587\u4ef6\u3001\u518d\u901a\u8fc7\u7f51\u7edc\u53d1\u9001\u6570\u636e\uff0c\u6570\u636e\u4ece\u78c1\u76d8\u5230\u7f51\u7edc\uff0c\u515c\u515c\u8f6c\u8f6c\u9700\u8981\u62f7\u8d1d\u56db\u6b21\uff0c\u5176\u4e2d CPU \u4eb2\u81ea\u642c\u8fd0\u90fd\u9700\u8981\u4e24\u6b21\u3002 \u96f6\u62f7\u8d1d\u6280\u672f\uff0c\u89e3\u653e CPU\uff0c\u6587\u4ef6\u6570\u636e\u76f4\u63a5\u4ece\u5185\u6838\u53d1\u9001\u51fa\u53bb\uff0c\u65e0\u9700\u518d\u62f7\u8d1d\u5230\u5e94\u7528\u7a0b\u5e8f\u7f13\u51b2\u533a\uff0c\u767d\u767d\u6d6a\u8d39\u8d44\u6e90\u3002 Linux API\uff1a ssize_t sendfile ( int out_fd , int in_fd , off_t * offset , size_t count ); \u51fd\u6570\u540d\u5b57\u5df2\u7ecf\u628a\u51fd\u6570\u7684\u529f\u80fd\u89e3\u91ca\u7684\u5f88\u660e\u663e\u4e86\uff1a\u53d1\u9001\u6587\u4ef6\u3002\u6307\u5b9a\u8981\u53d1\u9001\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u7f51\u7edc\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26\uff0c\u4e00\u4e2a\u51fd\u6570\u641e\u5b9a!","title":"developer.51cto \u9ad8\u6027\u80fd\u5f00\u53d1\u7684\u201c\u5341\u5927\u6b66\u5668\u201d\uff0c\u7231\u4e86\u7231\u4e86\uff01# I/O\u4f18\u5316\uff1a\u96f6\u62f7\u8d1d\u6280\u672f"},{"location":"Network/Programming/Send-file/#man#2#sendfile2","text":"sendfile() copies data between one file descriptor and another. Because this copying is done within the kernel , sendfile() is more efficient than the combination of read(2) and write(2) , which would require transferring data to and from user space . NOTE:\u4e0a\u9762\u7ae0\u8282\u5df2\u7ecf\u8be6\u7ec6\u4ecb\u7ecd\u4e86\u8fd9\u6837\u505a\u7684\u539f\u56e0\u3002","title":"man 2 sendfile(2)"},{"location":"Network/Protocol/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bba\u9996\u5148\u8ba8\u8bbacommunication protocol\uff0c\u5b83\u662f\u6bd4network protocol\u66f4\u52a0\u5bbd\u6cdb\u7684\u6982\u5ff5\uff0c\u7136\u540e\u8ba8\u8bbanetwork protocol(\u7f51\u7edc\u7684\u4e3b\u8981\u5185\u5bb9)\u3002 What is communication protocol? Communication protocol is a kind of language \u4ecelanguage\u7684\u89d2\u5ea6\u6765\u770b\uff0c Communication protocol \u662f\u4e00\u79cd\u8bed\u8a00\uff0c\u5b83\u662f\u901a\u4fe1\u591a\u65b9\u7684\u7ea6\u5b9a\u7684\u6c9f\u901a\u7684\u8bed\u8a00\u3002 Protocol VS format superuser What are the general differences between a format and a protocol A : Format - applies to files NOTE: \u53c2\u89c1 Programming\\IO\\File-IO\\File-format\\File-format \u7ae0\u8282 Protocol - applies to communications In both instances you are talking about the index of various bytes in a stream and what they are supposed to represent. NOTE: \u8fd9\u662f\u4e24\u8005\u7684\u5171\u540c\u4e4b\u5904\uff0c\u5173\u4e8estream\uff0c\u53c2\u89c1\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Model\\Stream \u7ae0\u8282 Protocol can get more involved, as many protocols work in a \" request-response \" fashion where the client issues a well-formed request , and then a server responds with a well-formed response . So there may be different schema for request, response. Requests may change client or server \"state\" and thus the schema may be different again given a particular state. NOTE: protocol\u6d89\u53ca\u5230\u591a\u65b9\u7684\u53c2\u4e0e\uff0c\u56e0\u6b64\u5b83\u6bd4format\u8003\u8651\u7684\u95ee\u9898\u8981\u591a\u5f97\u591a File formats are typically always following the same schema unless they are a different version, though they can be complex as well - later bytes in a file format may depend on earlier bytes (the .PST file format or the Windows Registry hive format, for example). A : A format describes the structure of some data, whereas a protocol defines a procedure to handle this data. If you take TCP as an example, you have a definition of the format of a data packet, which tells you at which bit position a specified field like the checksum of a packet starts and ends, and the protocol defines that for opening a TCP connection you need three packets, one from client to server with the SYN-bit set, a second one from server to client with ACK- and SYN-bit set and a third one with ACK-bit set from client to server. NOTE: format\u4ec5\u4ec5\u63cf\u8ff0\u4e86structure\uff0c\u5173\u4e8efile format\uff0c\u53c2\u89c1 Programming\\IO\\File-IO \u7ae0\u8282\u3002 \u5982\u4f55\u8bc4\u5224protocol\u7684\u597d\u574f\uff1f protocol\u7684\u4f18\u70b9\u4e0e\u7f3a\u70b9\uff0c\u4ee5 Redis Protocol specification \u4e3a\u4f8b\u8fdb\u884c\u8bf4\u660e\u3002 Network protocol Network protocol\u662f\u4e00\u79cdcommunication protocol\uff0c\u5b83\u5c06\u662f\u672c\u7ae0\u63a2\u8ba8\u7684\u4e3b\u8981\u5185\u5bb9\u3002 \u6211\u4eec\u9664\u4e86\u9700\u8981\u5b66\u4e60\u76ee\u524dnetwork\u4e2d\uff0c\u88ab\u5e7f\u6cdb\u91c7\u7528\u7684\u3001\u6807\u51c6\u5316\u7684protocol(\u6bd4\u5982TCP/IP\u534f\u8bae\u65cf)\uff0c\u8fd8\u9700\u8981\u5b66\u4e60\u5982\u4f55\u6765\u8bbe\u8ba1application protocol(\u5e94\u7528\u5c42\u534f\u8bae)\uff0c\u8fd9\u5c06\u5728 ./Application-protocol \u7ae0\u8282\u4e2d\u8ba8\u8bba\u3002","title":"Introduction"},{"location":"Network/Protocol/#_1","text":"\u672c\u7ae0\u8ba8\u8bba\u9996\u5148\u8ba8\u8bbacommunication protocol\uff0c\u5b83\u662f\u6bd4network protocol\u66f4\u52a0\u5bbd\u6cdb\u7684\u6982\u5ff5\uff0c\u7136\u540e\u8ba8\u8bbanetwork protocol(\u7f51\u7edc\u7684\u4e3b\u8981\u5185\u5bb9)\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Network/Protocol/#what#is#communication#protocol","text":"","title":"What is communication protocol?"},{"location":"Network/Protocol/#communication#protocol#is#a#kind#of#language","text":"\u4ecelanguage\u7684\u89d2\u5ea6\u6765\u770b\uff0c Communication protocol \u662f\u4e00\u79cd\u8bed\u8a00\uff0c\u5b83\u662f\u901a\u4fe1\u591a\u65b9\u7684\u7ea6\u5b9a\u7684\u6c9f\u901a\u7684\u8bed\u8a00\u3002","title":"Communication protocol is a kind of language"},{"location":"Network/Protocol/#protocol#vs#format","text":"","title":"Protocol VS format"},{"location":"Network/Protocol/#superuser#what#are#the#general#differences#between#a#format#and#a#protocol","text":"A : Format - applies to files NOTE: \u53c2\u89c1 Programming\\IO\\File-IO\\File-format\\File-format \u7ae0\u8282 Protocol - applies to communications In both instances you are talking about the index of various bytes in a stream and what they are supposed to represent. NOTE: \u8fd9\u662f\u4e24\u8005\u7684\u5171\u540c\u4e4b\u5904\uff0c\u5173\u4e8estream\uff0c\u53c2\u89c1\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Model\\Stream \u7ae0\u8282 Protocol can get more involved, as many protocols work in a \" request-response \" fashion where the client issues a well-formed request , and then a server responds with a well-formed response . So there may be different schema for request, response. Requests may change client or server \"state\" and thus the schema may be different again given a particular state. NOTE: protocol\u6d89\u53ca\u5230\u591a\u65b9\u7684\u53c2\u4e0e\uff0c\u56e0\u6b64\u5b83\u6bd4format\u8003\u8651\u7684\u95ee\u9898\u8981\u591a\u5f97\u591a File formats are typically always following the same schema unless they are a different version, though they can be complex as well - later bytes in a file format may depend on earlier bytes (the .PST file format or the Windows Registry hive format, for example). A : A format describes the structure of some data, whereas a protocol defines a procedure to handle this data. If you take TCP as an example, you have a definition of the format of a data packet, which tells you at which bit position a specified field like the checksum of a packet starts and ends, and the protocol defines that for opening a TCP connection you need three packets, one from client to server with the SYN-bit set, a second one from server to client with ACK- and SYN-bit set and a third one with ACK-bit set from client to server. NOTE: format\u4ec5\u4ec5\u63cf\u8ff0\u4e86structure\uff0c\u5173\u4e8efile format\uff0c\u53c2\u89c1 Programming\\IO\\File-IO \u7ae0\u8282\u3002","title":"superuser What are the general differences between a format and a protocol"},{"location":"Network/Protocol/#protocol","text":"protocol\u7684\u4f18\u70b9\u4e0e\u7f3a\u70b9\uff0c\u4ee5 Redis Protocol specification \u4e3a\u4f8b\u8fdb\u884c\u8bf4\u660e\u3002","title":"\u5982\u4f55\u8bc4\u5224protocol\u7684\u597d\u574f\uff1f"},{"location":"Network/Protocol/#network#protocol","text":"Network protocol\u662f\u4e00\u79cdcommunication protocol\uff0c\u5b83\u5c06\u662f\u672c\u7ae0\u63a2\u8ba8\u7684\u4e3b\u8981\u5185\u5bb9\u3002 \u6211\u4eec\u9664\u4e86\u9700\u8981\u5b66\u4e60\u76ee\u524dnetwork\u4e2d\uff0c\u88ab\u5e7f\u6cdb\u91c7\u7528\u7684\u3001\u6807\u51c6\u5316\u7684protocol(\u6bd4\u5982TCP/IP\u534f\u8bae\u65cf)\uff0c\u8fd8\u9700\u8981\u5b66\u4e60\u5982\u4f55\u6765\u8bbe\u8ba1application protocol(\u5e94\u7528\u5c42\u534f\u8bae)\uff0c\u8fd9\u5c06\u5728 ./Application-protocol \u7ae0\u8282\u4e2d\u8ba8\u8bba\u3002","title":"Network protocol"},{"location":"Network/Protocol/MAC-address/","text":"MAC address \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6bcf\u4e2a\u7f51\u5361\u6709\u4e00\u4e2aMAC address\uff0c\u5982\u679c\u4e00\u53f0\u8ba1\u7b97\u673a\u6709\u591a\u4e2a\u7f51\u5361\uff0c\u5219\u5176\u5c31\u6709\u591a\u4e2aMAC address\u3002 \u7ef4\u57fa\u767e\u79d1 MAC address \u5982\u4f55\u83b7\u5f97mac\u5730\u5740 appuals How to Find MAC Address on Linux","title":"MAC-address"},{"location":"Network/Protocol/MAC-address/#mac#address","text":"\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6bcf\u4e2a\u7f51\u5361\u6709\u4e00\u4e2aMAC address\uff0c\u5982\u679c\u4e00\u53f0\u8ba1\u7b97\u673a\u6709\u591a\u4e2a\u7f51\u5361\uff0c\u5219\u5176\u5c31\u6709\u591a\u4e2aMAC address\u3002","title":"MAC address"},{"location":"Network/Protocol/MAC-address/#mac#address_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1MAC address"},{"location":"Network/Protocol/MAC-address/#mac","text":"appuals How to Find MAC Address on Linux","title":"\u5982\u4f55\u83b7\u5f97mac\u5730\u5740"},{"location":"Network/Protocol/Message-boundary/","text":"Message Boundaries learningnetwork.cisco TCP / UDP Preserving Message Boundaries Hello, I have been reading a book which describes the following: UDP \"preserves message boundaries \" whereas TCP does not. What exactly does this mean? Thank You A1 Grant, I think it means that in UDP, the data is sent in clearly defined (size-wise) packages. In TCP on the other hand the window size might vary. So, imagine you need to transmit the following line of data: \" THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG \". In UDP you'd split that into fixed size chunks (depending on what application you use) and end up with the following: *THE** QU**iCK** BR**OWN** FO**X J**UMP**S O**VER** TH**E L**AZY** DO**G . The asterisks in this exmple delimit the message start and end. So, you end up with clear **boundaries for each message. Now let's use TCP to transmit the same. We start with medium window size , but our bandwidth is good, so we start growing the window dynamically and end up with something like this. *THE*2* QUICK*3* BROWN FO*4*X JUMPS OVER THE*5*LAZY DOG* As you see, we've got different size chunks of data ( segments in TCP lingo), but all of them have sequence numbers , so can be easily re-assembled in the right order. So, short answer to your question is \"this is to do with payload size and the way that payload gets split into transportable chunks\". I might be wrong A2 hi,dudes: A \"message boundary\" is the separation between two messages being sent over a protocol. UDP preserves message boundaries. If you send \" FOO \" and then \" BAR \" over UDP , the other end will receive two datagrams, one containing \" FOO \" and the other containing \" BAR \". If you send \" FOO \" and then \" BAR \" over TCP, no message boundary is preserved. The other end might get \" FOO \" and then \" BAR \". Or it might get \" FOOBAR \". Or it might get \" F \" and then \" OOB \" and then \" AR \". TCP does not make any attempt to preserve application message boundaries -- it's just a stream of bytes in each direction. linux-c-programming UDP message boundary Hi All When using TCP socket , I loop send() or recv() until ALL the data has been transmitted (or error, disconnect, etc.), because TCP socket packet is transmitted in stream nature, maybe a byte, bytes or all bytes in one transfer. The UDP socket preserve message boundary which TCP socket doesn't. Does this means single call to sendto() will processed by single call recvfrom() ?, and how about packet that exceeds UDP data MAX size?. So in code, do I need to loop sendto() or recvfrom() to transmit the data?. Example codes is: char packet [ 100 ]; size_t nbytes = 0 ; int ret ; while ( nbytes < sizeof ( packet )) { ret = recvfrom ( socket , packet + nbytes , addr , 0 , sizeof ( packet ) - nbytes ); if ( ret <= 0 ) { /* deal with recvfrom() error */ } nbytes += ret } Thanks -- To unsubscribe from this list: send the line \"unsubscribe linux-c-programming\" in the body of a message to *** @vger .kernel.org More majordomo info at http://vger.kernel.org/majordomo-info.html Post by Randi Botse Hi All When using TCP socket, I loop send() or recv() until ALL the data has been transmitted (or error, disconnect, etc.), because TCP socket packet is transmitted in stream nature, maybe a byte, bytes or all bytes in one transfer. TCP is like a water tap(a character device) that you need to \"format\" yourself with boundaries/etc. Post by Randi Botse The UDP socket preserve message boundary which TCP socket doesn't. Does this means single call to sendto() will processed by single call recvfrom() ?, and how about packet that exceeds UDP data MAX size?. UDP is more like a block device , a letter/package sent. It's only the single packet that is sent, and only that same single packet that will be received (or go missing in the post) I believe the error you might be referring to is this one from a Linux 2.6 based Ubuntu 6.0.5 man page for recvfrom : man recv(2) > All three routines return the length of the message on successful completion. If a message is too long to fit in the supplied buffer , excess bytes may be discarded depending on the type of socket the message is received from. MSG_TRUNC (since Linux 2.2) For raw (AF_PACKET), Internet datagram (since Linux 2.4.27/2.6.8), netlink (since Linux 2.6.22) and UNIX datagram (since Linux 3.4) sockets: return the real length of the packet or datagram, even when it was longer than the passed buffer. Not implemented for UNIX domain ( unix (7)) sockets. For use with Internet stream sockets, see tcp (7). In other words, you have been sent a 1024 byte long packet with sentto(2) , but recvfrom(2) only had a 900 bytes buffer , then sorry,you've lost 124 bytes. Looking at the recv(2) manual page, I recall that recv(2) / recvfrom(2) will return the size of the packer received, so if you've provided a 65535 byte buffer, and was only sent 1024 bytes, then recv(2) / recvfrom(2) will return the 1024 bytes answer. Post by Randi Botse So in code, do I need to loop sendto() or recvfrom() to transmit the data?. It depends on the data being sent, but for every sendto(2) , you will need a single recv(2) / recvfrom(2) with a correctly sized buffer to receive that single message. Post by Randi Botse char packet [ 100 ]; size_t nbytes = 0 ; int ret ; while ( nbytes < sizeof ( packet )) { ret = recvfrom ( socket , packet + nbytes , addr , 0 , sizeof ( packet ) - nbytes ); if ( ret <= 0 ) { /* deal with recvfrom() error */ } nbytes += ret } That is TCP, for UDP you will have something like: sender: char buffer [ 1024 ]; int size_of_data = fill_buffer_withdata ( buffer , 1024 ); sendto ( socket , buffer , size_of_data , flags ); receiver: chat buffer [ 1024 ]; int size_of_data = recv ( socket , buffer , 1024 , flags ); if size_of_data > 1024 then throw_error else do_something_with_data ( buffer , size_of_data ); end there are another method, using MSG_PEEK in the flags before reading the real data and remove that from the queue.","title":"Message-boundary"},{"location":"Network/Protocol/Message-boundary/#message#boundaries","text":"","title":"Message Boundaries"},{"location":"Network/Protocol/Message-boundary/#learningnetworkcisco#tcp#udp#preserving#message#boundaries","text":"Hello, I have been reading a book which describes the following: UDP \"preserves message boundaries \" whereas TCP does not. What exactly does this mean? Thank You","title":"learningnetwork.cisco TCP / UDP Preserving Message Boundaries"},{"location":"Network/Protocol/Message-boundary/#a1","text":"Grant, I think it means that in UDP, the data is sent in clearly defined (size-wise) packages. In TCP on the other hand the window size might vary. So, imagine you need to transmit the following line of data: \" THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG \". In UDP you'd split that into fixed size chunks (depending on what application you use) and end up with the following: *THE** QU**iCK** BR**OWN** FO**X J**UMP**S O**VER** TH**E L**AZY** DO**G . The asterisks in this exmple delimit the message start and end. So, you end up with clear **boundaries for each message. Now let's use TCP to transmit the same. We start with medium window size , but our bandwidth is good, so we start growing the window dynamically and end up with something like this. *THE*2* QUICK*3* BROWN FO*4*X JUMPS OVER THE*5*LAZY DOG* As you see, we've got different size chunks of data ( segments in TCP lingo), but all of them have sequence numbers , so can be easily re-assembled in the right order. So, short answer to your question is \"this is to do with payload size and the way that payload gets split into transportable chunks\". I might be wrong","title":"A1"},{"location":"Network/Protocol/Message-boundary/#a2","text":"hi,dudes: A \"message boundary\" is the separation between two messages being sent over a protocol. UDP preserves message boundaries. If you send \" FOO \" and then \" BAR \" over UDP , the other end will receive two datagrams, one containing \" FOO \" and the other containing \" BAR \". If you send \" FOO \" and then \" BAR \" over TCP, no message boundary is preserved. The other end might get \" FOO \" and then \" BAR \". Or it might get \" FOOBAR \". Or it might get \" F \" and then \" OOB \" and then \" AR \". TCP does not make any attempt to preserve application message boundaries -- it's just a stream of bytes in each direction.","title":"A2"},{"location":"Network/Protocol/Message-boundary/#linux-c-programming#udp#message#boundary","text":"Hi All When using TCP socket , I loop send() or recv() until ALL the data has been transmitted (or error, disconnect, etc.), because TCP socket packet is transmitted in stream nature, maybe a byte, bytes or all bytes in one transfer. The UDP socket preserve message boundary which TCP socket doesn't. Does this means single call to sendto() will processed by single call recvfrom() ?, and how about packet that exceeds UDP data MAX size?. So in code, do I need to loop sendto() or recvfrom() to transmit the data?. Example codes is: char packet [ 100 ]; size_t nbytes = 0 ; int ret ; while ( nbytes < sizeof ( packet )) { ret = recvfrom ( socket , packet + nbytes , addr , 0 , sizeof ( packet ) - nbytes ); if ( ret <= 0 ) { /* deal with recvfrom() error */ } nbytes += ret } Thanks -- To unsubscribe from this list: send the line \"unsubscribe linux-c-programming\" in the body of a message to *** @vger .kernel.org More majordomo info at http://vger.kernel.org/majordomo-info.html","title":"linux-c-programming UDP message boundary"},{"location":"Network/Protocol/Message-boundary/#post#by#randi#botse","text":"Hi All When using TCP socket, I loop send() or recv() until ALL the data has been transmitted (or error, disconnect, etc.), because TCP socket packet is transmitted in stream nature, maybe a byte, bytes or all bytes in one transfer. TCP is like a water tap(a character device) that you need to \"format\" yourself with boundaries/etc. Post by Randi Botse The UDP socket preserve message boundary which TCP socket doesn't. Does this means single call to sendto() will processed by single call recvfrom() ?, and how about packet that exceeds UDP data MAX size?. UDP is more like a block device , a letter/package sent. It's only the single packet that is sent, and only that same single packet that will be received (or go missing in the post) I believe the error you might be referring to is this one from a Linux 2.6 based Ubuntu 6.0.5 man page for recvfrom : man recv(2) > All three routines return the length of the message on successful completion. If a message is too long to fit in the supplied buffer , excess bytes may be discarded depending on the type of socket the message is received from. MSG_TRUNC (since Linux 2.2) For raw (AF_PACKET), Internet datagram (since Linux 2.4.27/2.6.8), netlink (since Linux 2.6.22) and UNIX datagram (since Linux 3.4) sockets: return the real length of the packet or datagram, even when it was longer than the passed buffer. Not implemented for UNIX domain ( unix (7)) sockets. For use with Internet stream sockets, see tcp (7). In other words, you have been sent a 1024 byte long packet with sentto(2) , but recvfrom(2) only had a 900 bytes buffer , then sorry,you've lost 124 bytes. Looking at the recv(2) manual page, I recall that recv(2) / recvfrom(2) will return the size of the packer received, so if you've provided a 65535 byte buffer, and was only sent 1024 bytes, then recv(2) / recvfrom(2) will return the 1024 bytes answer. Post by Randi Botse So in code, do I need to loop sendto() or recvfrom() to transmit the data?. It depends on the data being sent, but for every sendto(2) , you will need a single recv(2) / recvfrom(2) with a correctly sized buffer to receive that single message. Post by Randi Botse char packet [ 100 ]; size_t nbytes = 0 ; int ret ; while ( nbytes < sizeof ( packet )) { ret = recvfrom ( socket , packet + nbytes , addr , 0 , sizeof ( packet ) - nbytes ); if ( ret <= 0 ) { /* deal with recvfrom() error */ } nbytes += ret } That is TCP, for UDP you will have something like: sender: char buffer [ 1024 ]; int size_of_data = fill_buffer_withdata ( buffer , 1024 ); sendto ( socket , buffer , size_of_data , flags ); receiver: chat buffer [ 1024 ]; int size_of_data = recv ( socket , buffer , 1024 , flags ); if size_of_data > 1024 then throw_error else do_something_with_data ( buffer , size_of_data ); end there are another method, using MSG_PEEK in the flags before reading the real data and remove that from the queue.","title":"Post by Randi Botse"},{"location":"Network/Protocol/Network-protocol-model/","text":"Network protocol model \u672c\u6587\u8ba8\u8bbanetwork protocol model\uff0c\u5b83\u662f\u5178\u578b\u7684\u5c42\u6b21\u5316\u6a21\u578b/\u7ed3\u6784\uff1b\u5efa\u7acb\u8d77\u5b8c\u6574\u7684network protocol model\u975e\u5e38\u91cd\u8981\uff0c\u5b83\u8ba9\u6211\u4eec\u5b8c\u6574\u5730\u8ba4\u8bc6network\u3002 model \u7b80\u4ecb OSI model \u7406\u8bba\u6a21\u578b\uff0c\u5b9e\u9645\u5e76\u6ca1\u6709\u91c7\u7528\u5b83 Internet protocol suit \u5b9e\u9645\u91c7\u7528\u7684\u6a21\u578b wikipedia OSI model The Open Systems Interconnection model ( OSI model ) is a conceptual model that characterizes and standardizes the communication functions of a telecommunication or computing system without regard to its underlying internal structure and technology. Its goal is the interoperability of diverse communication systems with standard protocols . The model partitions a communication system into abstraction layers . The original version of the model defined seven layers. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u6700\u540e\u4e00\u53e5\u4e2d\u7684original\u8ba9\u6211\u60f3\u8d77\u6765\u4e86\u5728\u5927\u5b66\u7684\u65f6\u5019\u5b66\u4e60network\u7684\u65f6\u5019\uff0c\u5176\u4e2d\u8bf4\u660e\u8fc7**\u5b9e\u73b0**\u548c**\u7406\u8bba**\u4e4b\u95f4\u7684\u5dee\u5f02\uff1a\u5373\u5b9e\u73b0\u53ef\u80fd\u5e76\u4e0d\u4f1a\u6309\u7167\u7406\u8bba\u4e2d\u6240\u5b9a\u4e49\u7684\u6a21\u578b\u6765\u8fdb\u884c\uff0c\u5728\u5b9e\u73b0\u7684\u65f6\u5019\u53ef\u80fd\u4f1a\u8fdb\u884c\u7b80\u5316\u3002 NOTE: \u9700\u8981\u548c Internet protocol suite \u5bf9\u6bd4\u7740\u6765\u770b\u3002 A layer serves the layer above it and is served by the layer below it. For example, a layer that provides error-free communications across a network provides the path needed by applications above it, while it calls the next lower layer to send and receive packets that constitute\uff08\u7ec4\u6210\uff09 the contents of that path . Two instances at the same layer are visualized as connected by a horizontal connection in that layer. NOTE: \u8fd9\u6bb5\u8bdd\u4ece\u6a2a\u5411\u548c\u7eb5\u5411\u5bf9OSI\u7684\u5404\u5c42\u4e4b\u95f4\u7684\u5173\u7cfb\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002 The model is a product of the Open Systems Interconnection project at the International Organization for Standardization (ISO). NOTE: \u5728programmer\u8fdb\u884cprogramming\u7684\u65f6\u5019\uff0c\u5f80\u5f80\u662f\u7531programmer\u6765\u81ea\u5df1\u9009\u62e9\u60f3\u8981\u4f7f\u7528\u7684protocol\uff1b\u53ef\u4ee5\u770b\u5230OSI\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u591a\u79cdprotocol\u3002 Communication in the OSI-Model (example with layers 3 to 5) OSI model by layer OSI model by layer layer name example 7. Application layer - FTP - Gopher - HTTP 6. Presentation layer - MIME - XDR 5. Session layer 4. Transport layer - TCP - UDP 3. Network layer - IP ( IPv4 IPv6 ) - ICMP 2. Data link layer - ATM - ARP 1. Physical layer wikipedia Internet protocol suite The Internet protocol suite is the conceptual model and set of communications protocols used in the Internet and similar computer networks . It is commonly known as TCP/IP because the foundational protocols in the suite are the Transmission Control Protocol (TCP) and the Internet Protocol (IP). It is occasionally known as the Department of Defense ( DoD ) model because the development of the networking method was funded by the United States Department of Defense through DARPA . NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c **Internet protocol suite**\u624d\u662f\u771f\u6b63\u7528\u4e8eInternet\u7684\uff0c\u800c\u4e0d\u662f OSI model \u3002 The Internet protocol suite provides end-to-end data communication specifying how data should be packetized, addressed, transmitted, routed , and received. This functionality is organized into four abstraction layers , which classify all related protocols according to the scope of networking involved.[ 1] [ 2] From lowest to highest, the layers are the link layer , containing communication methods for data that remains within a single network segment (link); the internet layer , providing internetworking between independent networks; the transport layer , handling host-to-host communication ; and the application layer , providing process-to-process data exchange for applications. The technical standards underlying the Internet protocol suite and its constituent protocols are maintained by the Internet Engineering Task Force (IETF). The Internet protocol suite predates\uff08\u65e9\u4e8e\uff09 the OSI model , a more comprehensive reference framework for general networking systems. Internet protocol suite by layer layer name example 4 Application layer FTP HTTP NFS SMTP Telnet 3 Transport layer TCP UDP SCTP DCCP SPX 2 Network layer IP ( IPv4 IPv6 ) ICMP IPsec IGMP IPX AppleTalk X.25 PLP 1 Link layer ARP NDP OSPF Tunnels L2TP PPP MAC Ethernet Wi-Fi DSL ISDN FDDI NOTE: \u770b\u4e86\u4e0a\u9762\u7684Internet protocol suite\uff0c\u6211\u6240\u60f3\u5230\u7684\u662f\u5728\u4f7f\u7528socket\u8fdb\u884cprogramming\u7684\u65f6\u5019\uff0c\u6211\u9700\u8981\u6307\u5b9a\u7684\u5185\u5bb9\u5305\u62ec Transport layer \uff08\u4f7f\u7528\u54ea\u79cdtransport protocol\uff0c\u662fTCP\u8fd8\u662fUDP\uff0c\u8fd8\u662f\u5176\u4ed6\u7684\uff09\u548c Network layer \uff08\u4f7f\u7528\u7684\u662fIPV4\u8fd8\u662fIPV6\uff09\uff0c\u5373socket\u662f\u5efa\u7acb\u5728 Transport layer \u7684\uff1b\u6309\u7167OSI model\uff0c\u5728 Transport layer \u4e4b\u4e0a\u8fd8\u6709layer5\u548clayer6\u624d\u80fd\u591f\u5230\u8fbe Application layer \uff0c\u4f46\u662f\u5728 Internet protocol suite \u4e2d\uff0c Transport layer \u4e4b\u4e0a\u5c31\u662f Application layer \uff0c\u5e76\u4e14\u5728\u5b9e\u9645\u4e2d\uff0c\u90fd\u662f\u91c7\u7528\u7684 Internet protocol suite \uff0c\u6240\u4ee5\u6211\u4e5f\u5e94\u8be5\u6309\u7167 Internet protocol suite \u6765\u8fdb\u884c\u601d\u8003\uff1b\u6211\u4eec\u5f80\u5f80\u662f\u5728 Application layer \u8fdb\u884cprogram\uff0c\u5728application layer\u6211\u4eec\u4f7f\u7528socket\u6765\u5b9e\u73b0application layer protocol\uff0c\u4ee5\u6ee1\u8db3application\u7684\u8981\u6c42\uff1b\u5728\u6211\u4eec\u5b9e\u9645\u8fdb\u884cprogram\u7684\u65f6\u5019\uff0c\u5982\u679c\u8981\u5f00\u53d1\u4e00\u4e2anetwork application\uff0c\u6211\u4eec\u5f80\u5f80\u662f\u4ece\u4ece\u9876\u5411\u4e0b\u6765\u8fdb\u884c\u5f00\u53d1\u8bbe\u8ba1\u7684\uff0c\u6211\u4eec\u5f80\u5f80\u662f\u9996\u5148\u5f00\u53d1application protocol\uff0c\u6bd4\u5982redis\u7684 RESP \u3002port\u662f\u548capplication layer protocol\u76f8\u5173\u7684\uff1b Formal specification and standards The characteristic architecture of the Internet Protocol Suite is its broad division into operating scopes for the protocols that constitute its core functionality. The defining specification of the suite is RFC 1122 , which broadly outlines four abstraction layers . [1] These have stood the test of time, as the IETF has never modified this structure. As such a model of networking, the Internet Protocol Suite predates the OSI model, a more comprehensive reference framework for general networking systems. NOTE: \u6458\u5f55\u539f\u6587\u4e2d\u7684\u8fd9\u4e00\u6bb5\uff0c\u91cd\u8981\u662f\u4e3a\u4e86\u5f3a\u8c03 RFC 1122 , \u5b83\u662fInternet protocol suit\u7684formal description\uff0c\u6240\u4ee5\u5f88\u591a\u5173\u4e8eInternet protocol suit\u7684\u95ee\u9898\u90fd\u53ef\u4ee5\u5728\u5176\u4e2d\u627e\u5230\u7b54\u6848\uff0c\u5e76\u4e14\u53ef\u4ee5\u770b\u5230\u539f\u6587\u4e2d\uff0c\u6709\u591a\u5904\u662f\u5f15\u7528RFC 1122\u7684\uff0c\u6211\u5df2\u7ecf\u5c06RFC 1122\u4e0b\u8f7d\u4e86\u3002 Protocol data unit \u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u6982\u5ff5\u5c31\u662fprotocol data unit\uff0cPDU\uff0c\u5373\u201c\u534f\u8bae\u6570\u636e\u5355\u5143\u201d\uff0c\u5b83\u662f\u63cf\u8ff0\u4e0b\u4e00\u8282Mechanism\u7684\u524d\u63d0\u3002\u5b83\u7b26\u5408\u5728\u6587\u7ae0\u300aUnit\u300b\u4e2d\u63d0\u51fa\u7684\u601d\u60f3\u7684\u3002 wikipedia Protocol data unit Example: PDU of layer of OSI model layer name PDU 4 transport layer TCP segment or UDP datagram 3 network layer packet 2 data link layer frame 1 physical layer bit or, more generally, symbol . RFC 1122 \u4e0b\u9762\u662f RFC 1122 \u4e2d\u7ed9\u51fa\u7684\u63cf\u8ff0 terminology explanation Segment A segment is the unit of end-to-end transmission in the TCP protocol . A segment consists of a TCP header followed by application data . A segment is transmitted by encapsulation inside an IP datagram . Message In this description of the lower-layer protocols, a message is the unit of transmission in a transport layer protocol . In particular, a TCP segment is a message. A message consists of a transport protocol header followed by application protocol data. To be transmitted end-to-end through the Internet, a message must be encapsulated inside a datagram . IP Datagram An IP datagram is the unit of end-to-end transmission in the IP protocol. An IP datagram consists of an IP header followed by transport layer data, i.e., of an IP header followed by a message. Packet A packet is the unit of data passed across the interface between the internet layer and the link layer. It includes an IP header and data. A packet may be a complete IP datagram or a fragment of an IP datagram. Frame A frame is the unit of transmission in a link layer protocol, and consists of a link-layer header followed by a packet. Max length of PUD \u524d\u9762\u4ecb\u7ecd\u4e86PUC\uff0c\u4e0e\u5b83\u76f8\u5173\u7684\u53e6\u5916\u4e00\u4e2a\u95ee\u9898\u662f\uff1a\u5b83\u7684\u6700\u5927\u957f\u5ea6\uff1b Example: PDU of layer of OSI model layer name PDU max length 4 transport layer TCP segment or UDP datagram Maximum segment size 3 network layer packet Maximum transmission unit 2 data link layer frame 1 physical layer bit or, more generally, symbol . Mechanism NOTE: \u8fd9\u662f\u6211\u5728\u9605\u8bfbwikipedia Internet protocol suite \u7684 Key architectural principles \u7684\u63d2\u56fe\"Encapsulation of application data descending through the layers described in RFC 1122 \"\u65f6\uff0c\u6709\u611f\u800c\u53d1\uff0c\u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662f: \u673a\u5236\uff0cnetwork protocol model\u7684\u8fd0\u884c\u673a\u5236\u3002 \u672c\u6587\u63cf\u8ff0protocol stack\u7684\u8fd0\u884c\u673a\u5236\uff0c\u5176\u5b9e\u5b83\u7684\u8fd0\u884c\u673a\u5236\u76f8\u5bf9\u662f\u6bd4\u8f83\u7b80\u5355\u7684\uff0c\u53ef\u4ee5\u770b\u505a\u662f\u4e24\u4e2a\u65b9\u5411: Descend(\u5411\u4e0b) Ascend(\u5411\u4e0a) Disassemble / Reassemble Disassemble \u62c6\u5f00 Reassemble \u91cd\u65b0\u88c5\u914d\u3001\u91cd\u65b0\u96c6\u5408 \u663e\u7136\u4e24\u8005\u63cf\u8ff0\u7684\u662f\u76f8\u53cd\u7684\u8fc7\u7a0b\u3002 \u4e0d\u540cPUD\u7684\u6700\u5927\u957f\u5ea6\u53ef\u80fd\u4e0d\u540c\uff0c\u8fd9\u5c31\u5bfc\u81f4\u4e86Disassemble / Reassemble\u95ee\u9898\uff0c\u4e0b\u9762\u662f\u4e00\u4e9b\u4e0e\u6b64\u76f8\u5173\u7684\u5185\u5bb9: IP fragmentation TCP segment of a reassembled PDU\uff08\u5728 Network\\Theory\\TCPTCP-segment-of-a-reassembled-PDU.md \u4e2d\uff0c\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u8ba8\u8bba\uff09 Descend \u6d89\u53ca\u5230\u7684\u64cd\u4f5c\u6709: 1) Encapsulation of application data 2) Disassemble: \u5c06\u4e0a\u5c42\u7684\u6570\u636e\uff0c\u6309\u7167\u672c\u5c42\u7684PDU\u8fdb\u884cdisassemble\uff0c\u751f\u6210\u591a\u4e2a\u591a\u4e2a\u672c\u5c42\u7684PDU Encapsulation of application data descending through the layers described in RFC 1122 Ascend: Unpack/Expose \u81ea\u5e95\u5411\u4e0a\u7684\u8fc7\u7a0b\u548c\u81ea\u9876\u5411\u4e0b\u7684\u8fc7\u7a0b\u8f6c\u6362\u76f8\u53cd\uff0c\u5b83\u662f\u6d89\u53ca\u5230\u7684\u64cd\u4f5c\u6709: 1) Unpack/Expose 2) Reassemble: \u5c06\u591a\u4e2a\u672c\u5c42\u7684PDU\uff0c\u7ec4\u88c5\u4e3a\u4e0a\u5c42\u7684PDU","title":"Network-protocol-model"},{"location":"Network/Protocol/Network-protocol-model/#network#protocol#model","text":"\u672c\u6587\u8ba8\u8bbanetwork protocol model\uff0c\u5b83\u662f\u5178\u578b\u7684\u5c42\u6b21\u5316\u6a21\u578b/\u7ed3\u6784\uff1b\u5efa\u7acb\u8d77\u5b8c\u6574\u7684network protocol model\u975e\u5e38\u91cd\u8981\uff0c\u5b83\u8ba9\u6211\u4eec\u5b8c\u6574\u5730\u8ba4\u8bc6network\u3002 model \u7b80\u4ecb OSI model \u7406\u8bba\u6a21\u578b\uff0c\u5b9e\u9645\u5e76\u6ca1\u6709\u91c7\u7528\u5b83 Internet protocol suit \u5b9e\u9645\u91c7\u7528\u7684\u6a21\u578b","title":"Network protocol model"},{"location":"Network/Protocol/Network-protocol-model/#wikipedia#osi#model","text":"The Open Systems Interconnection model ( OSI model ) is a conceptual model that characterizes and standardizes the communication functions of a telecommunication or computing system without regard to its underlying internal structure and technology. Its goal is the interoperability of diverse communication systems with standard protocols . The model partitions a communication system into abstraction layers . The original version of the model defined seven layers. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u6700\u540e\u4e00\u53e5\u4e2d\u7684original\u8ba9\u6211\u60f3\u8d77\u6765\u4e86\u5728\u5927\u5b66\u7684\u65f6\u5019\u5b66\u4e60network\u7684\u65f6\u5019\uff0c\u5176\u4e2d\u8bf4\u660e\u8fc7**\u5b9e\u73b0**\u548c**\u7406\u8bba**\u4e4b\u95f4\u7684\u5dee\u5f02\uff1a\u5373\u5b9e\u73b0\u53ef\u80fd\u5e76\u4e0d\u4f1a\u6309\u7167\u7406\u8bba\u4e2d\u6240\u5b9a\u4e49\u7684\u6a21\u578b\u6765\u8fdb\u884c\uff0c\u5728\u5b9e\u73b0\u7684\u65f6\u5019\u53ef\u80fd\u4f1a\u8fdb\u884c\u7b80\u5316\u3002 NOTE: \u9700\u8981\u548c Internet protocol suite \u5bf9\u6bd4\u7740\u6765\u770b\u3002 A layer serves the layer above it and is served by the layer below it. For example, a layer that provides error-free communications across a network provides the path needed by applications above it, while it calls the next lower layer to send and receive packets that constitute\uff08\u7ec4\u6210\uff09 the contents of that path . Two instances at the same layer are visualized as connected by a horizontal connection in that layer. NOTE: \u8fd9\u6bb5\u8bdd\u4ece\u6a2a\u5411\u548c\u7eb5\u5411\u5bf9OSI\u7684\u5404\u5c42\u4e4b\u95f4\u7684\u5173\u7cfb\u8fdb\u884c\u4e86\u63cf\u8ff0\u3002 The model is a product of the Open Systems Interconnection project at the International Organization for Standardization (ISO). NOTE: \u5728programmer\u8fdb\u884cprogramming\u7684\u65f6\u5019\uff0c\u5f80\u5f80\u662f\u7531programmer\u6765\u81ea\u5df1\u9009\u62e9\u60f3\u8981\u4f7f\u7528\u7684protocol\uff1b\u53ef\u4ee5\u770b\u5230OSI\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u591a\u79cdprotocol\u3002 Communication in the OSI-Model (example with layers 3 to 5)","title":"wikipedia OSI model"},{"location":"Network/Protocol/Network-protocol-model/#osi#model#by#layer","text":"OSI model by layer layer name example 7. Application layer - FTP - Gopher - HTTP 6. Presentation layer - MIME - XDR 5. Session layer 4. Transport layer - TCP - UDP 3. Network layer - IP ( IPv4 IPv6 ) - ICMP 2. Data link layer - ATM - ARP 1. Physical layer","title":"OSI model by layer"},{"location":"Network/Protocol/Network-protocol-model/#wikipedia#internet#protocol#suite","text":"The Internet protocol suite is the conceptual model and set of communications protocols used in the Internet and similar computer networks . It is commonly known as TCP/IP because the foundational protocols in the suite are the Transmission Control Protocol (TCP) and the Internet Protocol (IP). It is occasionally known as the Department of Defense ( DoD ) model because the development of the networking method was funded by the United States Department of Defense through DARPA . NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c **Internet protocol suite**\u624d\u662f\u771f\u6b63\u7528\u4e8eInternet\u7684\uff0c\u800c\u4e0d\u662f OSI model \u3002 The Internet protocol suite provides end-to-end data communication specifying how data should be packetized, addressed, transmitted, routed , and received. This functionality is organized into four abstraction layers , which classify all related protocols according to the scope of networking involved.[ 1] [ 2] From lowest to highest, the layers are the link layer , containing communication methods for data that remains within a single network segment (link); the internet layer , providing internetworking between independent networks; the transport layer , handling host-to-host communication ; and the application layer , providing process-to-process data exchange for applications. The technical standards underlying the Internet protocol suite and its constituent protocols are maintained by the Internet Engineering Task Force (IETF). The Internet protocol suite predates\uff08\u65e9\u4e8e\uff09 the OSI model , a more comprehensive reference framework for general networking systems.","title":"wikipedia Internet protocol suite"},{"location":"Network/Protocol/Network-protocol-model/#internet#protocol#suite#by#layer","text":"layer name example 4 Application layer FTP HTTP NFS SMTP Telnet 3 Transport layer TCP UDP SCTP DCCP SPX 2 Network layer IP ( IPv4 IPv6 ) ICMP IPsec IGMP IPX AppleTalk X.25 PLP 1 Link layer ARP NDP OSPF Tunnels L2TP PPP MAC Ethernet Wi-Fi DSL ISDN FDDI NOTE: \u770b\u4e86\u4e0a\u9762\u7684Internet protocol suite\uff0c\u6211\u6240\u60f3\u5230\u7684\u662f\u5728\u4f7f\u7528socket\u8fdb\u884cprogramming\u7684\u65f6\u5019\uff0c\u6211\u9700\u8981\u6307\u5b9a\u7684\u5185\u5bb9\u5305\u62ec Transport layer \uff08\u4f7f\u7528\u54ea\u79cdtransport protocol\uff0c\u662fTCP\u8fd8\u662fUDP\uff0c\u8fd8\u662f\u5176\u4ed6\u7684\uff09\u548c Network layer \uff08\u4f7f\u7528\u7684\u662fIPV4\u8fd8\u662fIPV6\uff09\uff0c\u5373socket\u662f\u5efa\u7acb\u5728 Transport layer \u7684\uff1b\u6309\u7167OSI model\uff0c\u5728 Transport layer \u4e4b\u4e0a\u8fd8\u6709layer5\u548clayer6\u624d\u80fd\u591f\u5230\u8fbe Application layer \uff0c\u4f46\u662f\u5728 Internet protocol suite \u4e2d\uff0c Transport layer \u4e4b\u4e0a\u5c31\u662f Application layer \uff0c\u5e76\u4e14\u5728\u5b9e\u9645\u4e2d\uff0c\u90fd\u662f\u91c7\u7528\u7684 Internet protocol suite \uff0c\u6240\u4ee5\u6211\u4e5f\u5e94\u8be5\u6309\u7167 Internet protocol suite \u6765\u8fdb\u884c\u601d\u8003\uff1b\u6211\u4eec\u5f80\u5f80\u662f\u5728 Application layer \u8fdb\u884cprogram\uff0c\u5728application layer\u6211\u4eec\u4f7f\u7528socket\u6765\u5b9e\u73b0application layer protocol\uff0c\u4ee5\u6ee1\u8db3application\u7684\u8981\u6c42\uff1b\u5728\u6211\u4eec\u5b9e\u9645\u8fdb\u884cprogram\u7684\u65f6\u5019\uff0c\u5982\u679c\u8981\u5f00\u53d1\u4e00\u4e2anetwork application\uff0c\u6211\u4eec\u5f80\u5f80\u662f\u4ece\u4ece\u9876\u5411\u4e0b\u6765\u8fdb\u884c\u5f00\u53d1\u8bbe\u8ba1\u7684\uff0c\u6211\u4eec\u5f80\u5f80\u662f\u9996\u5148\u5f00\u53d1application protocol\uff0c\u6bd4\u5982redis\u7684 RESP \u3002port\u662f\u548capplication layer protocol\u76f8\u5173\u7684\uff1b","title":"Internet protocol suite by layer"},{"location":"Network/Protocol/Network-protocol-model/#formal#specification#and#standards","text":"The characteristic architecture of the Internet Protocol Suite is its broad division into operating scopes for the protocols that constitute its core functionality. The defining specification of the suite is RFC 1122 , which broadly outlines four abstraction layers . [1] These have stood the test of time, as the IETF has never modified this structure. As such a model of networking, the Internet Protocol Suite predates the OSI model, a more comprehensive reference framework for general networking systems. NOTE: \u6458\u5f55\u539f\u6587\u4e2d\u7684\u8fd9\u4e00\u6bb5\uff0c\u91cd\u8981\u662f\u4e3a\u4e86\u5f3a\u8c03 RFC 1122 , \u5b83\u662fInternet protocol suit\u7684formal description\uff0c\u6240\u4ee5\u5f88\u591a\u5173\u4e8eInternet protocol suit\u7684\u95ee\u9898\u90fd\u53ef\u4ee5\u5728\u5176\u4e2d\u627e\u5230\u7b54\u6848\uff0c\u5e76\u4e14\u53ef\u4ee5\u770b\u5230\u539f\u6587\u4e2d\uff0c\u6709\u591a\u5904\u662f\u5f15\u7528RFC 1122\u7684\uff0c\u6211\u5df2\u7ecf\u5c06RFC 1122\u4e0b\u8f7d\u4e86\u3002","title":"Formal specification and standards"},{"location":"Network/Protocol/Network-protocol-model/#protocol#data#unit","text":"\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u6982\u5ff5\u5c31\u662fprotocol data unit\uff0cPDU\uff0c\u5373\u201c\u534f\u8bae\u6570\u636e\u5355\u5143\u201d\uff0c\u5b83\u662f\u63cf\u8ff0\u4e0b\u4e00\u8282Mechanism\u7684\u524d\u63d0\u3002\u5b83\u7b26\u5408\u5728\u6587\u7ae0\u300aUnit\u300b\u4e2d\u63d0\u51fa\u7684\u601d\u60f3\u7684\u3002","title":"Protocol data unit"},{"location":"Network/Protocol/Network-protocol-model/#wikipedia#protocol#data#unit","text":"","title":"wikipedia Protocol data unit"},{"location":"Network/Protocol/Network-protocol-model/#example#pdu#of#layer#of#osi#model","text":"layer name PDU 4 transport layer TCP segment or UDP datagram 3 network layer packet 2 data link layer frame 1 physical layer bit or, more generally, symbol .","title":"Example: PDU of layer of OSI model"},{"location":"Network/Protocol/Network-protocol-model/#rfc#1122","text":"\u4e0b\u9762\u662f RFC 1122 \u4e2d\u7ed9\u51fa\u7684\u63cf\u8ff0 terminology explanation Segment A segment is the unit of end-to-end transmission in the TCP protocol . A segment consists of a TCP header followed by application data . A segment is transmitted by encapsulation inside an IP datagram . Message In this description of the lower-layer protocols, a message is the unit of transmission in a transport layer protocol . In particular, a TCP segment is a message. A message consists of a transport protocol header followed by application protocol data. To be transmitted end-to-end through the Internet, a message must be encapsulated inside a datagram . IP Datagram An IP datagram is the unit of end-to-end transmission in the IP protocol. An IP datagram consists of an IP header followed by transport layer data, i.e., of an IP header followed by a message. Packet A packet is the unit of data passed across the interface between the internet layer and the link layer. It includes an IP header and data. A packet may be a complete IP datagram or a fragment of an IP datagram. Frame A frame is the unit of transmission in a link layer protocol, and consists of a link-layer header followed by a packet.","title":"RFC 1122"},{"location":"Network/Protocol/Network-protocol-model/#max#length#of#pud","text":"\u524d\u9762\u4ecb\u7ecd\u4e86PUC\uff0c\u4e0e\u5b83\u76f8\u5173\u7684\u53e6\u5916\u4e00\u4e2a\u95ee\u9898\u662f\uff1a\u5b83\u7684\u6700\u5927\u957f\u5ea6\uff1b","title":"Max length of PUD"},{"location":"Network/Protocol/Network-protocol-model/#example#pdu#of#layer#of#osi#model_1","text":"layer name PDU max length 4 transport layer TCP segment or UDP datagram Maximum segment size 3 network layer packet Maximum transmission unit 2 data link layer frame 1 physical layer bit or, more generally, symbol .","title":"Example: PDU of layer of OSI model"},{"location":"Network/Protocol/Network-protocol-model/#mechanism","text":"NOTE: \u8fd9\u662f\u6211\u5728\u9605\u8bfbwikipedia Internet protocol suite \u7684 Key architectural principles \u7684\u63d2\u56fe\"Encapsulation of application data descending through the layers described in RFC 1122 \"\u65f6\uff0c\u6709\u611f\u800c\u53d1\uff0c\u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662f: \u673a\u5236\uff0cnetwork protocol model\u7684\u8fd0\u884c\u673a\u5236\u3002 \u672c\u6587\u63cf\u8ff0protocol stack\u7684\u8fd0\u884c\u673a\u5236\uff0c\u5176\u5b9e\u5b83\u7684\u8fd0\u884c\u673a\u5236\u76f8\u5bf9\u662f\u6bd4\u8f83\u7b80\u5355\u7684\uff0c\u53ef\u4ee5\u770b\u505a\u662f\u4e24\u4e2a\u65b9\u5411: Descend(\u5411\u4e0b) Ascend(\u5411\u4e0a)","title":"Mechanism"},{"location":"Network/Protocol/Network-protocol-model/#disassemble#reassemble","text":"Disassemble \u62c6\u5f00 Reassemble \u91cd\u65b0\u88c5\u914d\u3001\u91cd\u65b0\u96c6\u5408 \u663e\u7136\u4e24\u8005\u63cf\u8ff0\u7684\u662f\u76f8\u53cd\u7684\u8fc7\u7a0b\u3002 \u4e0d\u540cPUD\u7684\u6700\u5927\u957f\u5ea6\u53ef\u80fd\u4e0d\u540c\uff0c\u8fd9\u5c31\u5bfc\u81f4\u4e86Disassemble / Reassemble\u95ee\u9898\uff0c\u4e0b\u9762\u662f\u4e00\u4e9b\u4e0e\u6b64\u76f8\u5173\u7684\u5185\u5bb9: IP fragmentation TCP segment of a reassembled PDU\uff08\u5728 Network\\Theory\\TCPTCP-segment-of-a-reassembled-PDU.md \u4e2d\uff0c\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u8ba8\u8bba\uff09","title":"Disassemble / Reassemble"},{"location":"Network/Protocol/Network-protocol-model/#descend","text":"\u6d89\u53ca\u5230\u7684\u64cd\u4f5c\u6709: 1) Encapsulation of application data 2) Disassemble: \u5c06\u4e0a\u5c42\u7684\u6570\u636e\uff0c\u6309\u7167\u672c\u5c42\u7684PDU\u8fdb\u884cdisassemble\uff0c\u751f\u6210\u591a\u4e2a\u591a\u4e2a\u672c\u5c42\u7684PDU Encapsulation of application data descending through the layers described in RFC 1122","title":"Descend"},{"location":"Network/Protocol/Network-protocol-model/#ascend#unpackexpose","text":"\u81ea\u5e95\u5411\u4e0a\u7684\u8fc7\u7a0b\u548c\u81ea\u9876\u5411\u4e0b\u7684\u8fc7\u7a0b\u8f6c\u6362\u76f8\u53cd\uff0c\u5b83\u662f\u6d89\u53ca\u5230\u7684\u64cd\u4f5c\u6709: 1) Unpack/Expose 2) Reassemble: \u5c06\u591a\u4e2a\u672c\u5c42\u7684PDU\uff0c\u7ec4\u88c5\u4e3a\u4e0a\u5c42\u7684PDU","title":"Ascend: Unpack/Expose"},{"location":"Network/Protocol/RCF/","text":"RCF \u5b98\u7f51: RFCs wikipedia Request for Comments ietf IETF Documents wikipedia List of RFCs","title":"RCF"},{"location":"Network/Protocol/RCF/#rcf","text":"","title":"RCF"},{"location":"Network/Protocol/RCF/#rfcs","text":"","title":"\u5b98\u7f51: RFCs"},{"location":"Network/Protocol/RCF/#wikipedia#request#for#comments","text":"","title":"wikipedia Request for Comments"},{"location":"Network/Protocol/RCF/#ietf#ietf#documents","text":"","title":"ietf IETF Documents"},{"location":"Network/Protocol/RCF/#wikipedia#list#of#rfcs","text":"","title":"wikipedia List of RFCs"},{"location":"Network/Protocol/Application-protocol/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bba\u5e94\u7528\u5c42\u534f\u8bae\uff0c\u8fd9\u662f\u4e0e\u6211\u4eec\u5de5\u4f5c\u751f\u6d3b\u63a5\u89e6\u5f97\u66f4\u591a\u7684\u534f\u8bae\u3002\u6211\u4eec\u4f1a\u603b\u7ed3\u76ee\u524d\u5df2\u7ecf\u88ab\u5e7f\u6cdb\u91c7\u7528\u7684application protocol\uff0c\u8fd8\u4f1a\u8ba8\u8bba\u5982\u4f55\u8bbe\u8ba1\u7b26\u5408\u81ea\u5df1application\u7684protocol\u3002","title":"Introduction"},{"location":"Network/Protocol/Application-protocol/#_1","text":"\u672c\u7ae0\u8ba8\u8bba\u5e94\u7528\u5c42\u534f\u8bae\uff0c\u8fd9\u662f\u4e0e\u6211\u4eec\u5de5\u4f5c\u751f\u6d3b\u63a5\u89e6\u5f97\u66f4\u591a\u7684\u534f\u8bae\u3002\u6211\u4eec\u4f1a\u603b\u7ed3\u76ee\u524d\u5df2\u7ecf\u88ab\u5e7f\u6cdb\u91c7\u7528\u7684application protocol\uff0c\u8fd8\u4f1a\u8ba8\u8bba\u5982\u4f55\u8bbe\u8ba1\u7b26\u5408\u81ea\u5df1application\u7684protocol\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Network/Protocol/Application-protocol/Design/","text":"Application protocol design \u53cc\u65b9\u5728\u8fdb\u884c\u901a\u4fe1\u4e4b\u524d\uff0c\u9700\u8981\u9996\u5148\u7ea6\u5b9aprotocol\uff0c\u672c\u6587\u5bf9application protocol design(\u5e94\u7528\u5c42\u534f\u8bae\u7684\u8bbe\u8ba1)\u8fdb\u884c\u603b\u7ed3\u3002protocol \u6709\u65f6\u5019\u4e5f\u88ab\u79f0\u4e3adata exchange protocol\u3002 How to design application protocol \u5728\u8bbe\u8ba1application protocol\u7684\u65f6\u5019\uff0c\u9700\u8981\u8003\u8651\u7684\u95ee\u9898\u6709: 1) Protocol data format \u8fd9\u5728 ./Protocol-data-format \u7ae0\u8282\u8fdb\u884c\u8ba8\u8bba\u3002 2) \u5e95\u5c42\u534f\u8bae network protocol model\u662f\u5c42\u6b21\u5316\u7684\u7ed3\u6784\uff0c\u5728\u8bbe\u8ba1\u4e00\u4e2aapplication protocol\u7684\u65f6\u5019\uff0c\u9700\u8981\u8003\u8651\u5b83\u7684\u4e0b\u4e00\u5c42\u6240\u91c7\u7528\u7684protocol\uff0c\u76ee\u524d\u4e3b\u8981\u6709\u5982\u4e0b\u4e24\u79cd: TCP UDP 3) \u5b89\u5168\u6027 \u5b89\u5168\u6027\u662f\u5728\u8fdb\u884c\u534f\u8bae\u8bbe\u8ba1\u7684\u65f6\u5019\uff0c\u9700\u8981\u8003\u8651\u7684\u4e00\u4e2a\u91cd\u8981\u95ee\u9898\u3002 Examples \u4e0b\u9762\u7ed3\u5408\u4e00\u4e9b\u5177\u4f53\u7684\u6848\u4f8b\u6765\u8fdb\u884c\u5206\u6790\u3002 \u56fd\u5185\u4f01\u4e1a\u7684application protocol \u6052\u751fT2\u534f\u8bae T2SDK \u534e\u9510ATP\u4ea4\u6613\u6570\u636e\u63a5\u53e3\u89c4\u8303 \u53c2\u89c1: http://developer.archforce.cn/topic/1738 \u5f00\u6e90\u8f6f\u4ef6\u7684application protocol Redis: RESP \u53c2\u89c1 redis.io Redis Protocol specification \u3002","title":"Design"},{"location":"Network/Protocol/Application-protocol/Design/#application#protocol#design","text":"\u53cc\u65b9\u5728\u8fdb\u884c\u901a\u4fe1\u4e4b\u524d\uff0c\u9700\u8981\u9996\u5148\u7ea6\u5b9aprotocol\uff0c\u672c\u6587\u5bf9application protocol design(\u5e94\u7528\u5c42\u534f\u8bae\u7684\u8bbe\u8ba1)\u8fdb\u884c\u603b\u7ed3\u3002protocol \u6709\u65f6\u5019\u4e5f\u88ab\u79f0\u4e3adata exchange protocol\u3002","title":"Application protocol design"},{"location":"Network/Protocol/Application-protocol/Design/#how#to#design#application#protocol","text":"\u5728\u8bbe\u8ba1application protocol\u7684\u65f6\u5019\uff0c\u9700\u8981\u8003\u8651\u7684\u95ee\u9898\u6709:","title":"How to design application protocol"},{"location":"Network/Protocol/Application-protocol/Design/#1#protocol#data#format","text":"\u8fd9\u5728 ./Protocol-data-format \u7ae0\u8282\u8fdb\u884c\u8ba8\u8bba\u3002","title":"1) Protocol data format"},{"location":"Network/Protocol/Application-protocol/Design/#2","text":"network protocol model\u662f\u5c42\u6b21\u5316\u7684\u7ed3\u6784\uff0c\u5728\u8bbe\u8ba1\u4e00\u4e2aapplication protocol\u7684\u65f6\u5019\uff0c\u9700\u8981\u8003\u8651\u5b83\u7684\u4e0b\u4e00\u5c42\u6240\u91c7\u7528\u7684protocol\uff0c\u76ee\u524d\u4e3b\u8981\u6709\u5982\u4e0b\u4e24\u79cd: TCP UDP","title":"2) \u5e95\u5c42\u534f\u8bae"},{"location":"Network/Protocol/Application-protocol/Design/#3","text":"\u5b89\u5168\u6027\u662f\u5728\u8fdb\u884c\u534f\u8bae\u8bbe\u8ba1\u7684\u65f6\u5019\uff0c\u9700\u8981\u8003\u8651\u7684\u4e00\u4e2a\u91cd\u8981\u95ee\u9898\u3002","title":"3) \u5b89\u5168\u6027"},{"location":"Network/Protocol/Application-protocol/Design/#examples","text":"\u4e0b\u9762\u7ed3\u5408\u4e00\u4e9b\u5177\u4f53\u7684\u6848\u4f8b\u6765\u8fdb\u884c\u5206\u6790\u3002","title":"Examples"},{"location":"Network/Protocol/Application-protocol/Design/#application#protocol","text":"","title":"\u56fd\u5185\u4f01\u4e1a\u7684application protocol"},{"location":"Network/Protocol/Application-protocol/Design/#t2","text":"T2SDK","title":"\u6052\u751fT2\u534f\u8bae"},{"location":"Network/Protocol/Application-protocol/Design/#atp","text":"\u53c2\u89c1: http://developer.archforce.cn/topic/1738","title":"\u534e\u9510ATP\u4ea4\u6613\u6570\u636e\u63a5\u53e3\u89c4\u8303"},{"location":"Network/Protocol/Application-protocol/Design/#application#protocol_1","text":"","title":"\u5f00\u6e90\u8f6f\u4ef6\u7684application protocol"},{"location":"Network/Protocol/Application-protocol/Design/#redis#resp","text":"\u53c2\u89c1 redis.io Redis Protocol specification \u3002","title":"Redis: RESP"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/","text":"Protocol data format/data exchange format \u672c\u7ae0\u8ba8\u8bbaprotocol data format\u3002 How to design protocol data format Protocol data format(\u6709\u65f6\u5019\u4e5f\u88ab\u79f0\u4e3adata exchange format)\u7684\u8bbe\u8ba1\u662fapplication protocol\u7684\u4e3b\u8981\u5185\u5bb9\uff0c\u4e0b\u9762\u662f\u8bbe\u8ba1\u7684\u65f6\u5019\u9700\u8981\u8003\u8651\u7684\u4e00\u4e9b\u5185\u5bb9\uff0c\u5728 ./Protocol-data-format \u7ae0\u8282\u603b\u7ed3\u4e86\u4e00\u4e9b\u5f53\u524d\u88ab\u5e7f\u6cdb\u91c7\u7528\u7684format\u3002 Message boundary \u4f7f\u7528TCP\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5185\u5bb9\u662f: \u5982\u4f55\u63cf\u8ff0message boundary\uff1f Implementation \u5728\u8bbe\u8ba1protocol\u7684\u65f6\u5019\uff0c\u4e5f\u662f\u9700\u8981\u8003\u8651implementation\u76f8\u5173\u7684\u95ee\u9898: 1) \u6210\u672c\u7684\u3001\u96be\u6613\u7a0b\u5ea6 2) \u6027\u80fd NOTE: \u8fd9\u662f\u5728\u9605\u8bfb Redis Protocol specification \u65f6\uff0c\u5176\u4e2d\u7ed9\u51fa\u7684\u603b\u7ed3: Simple to implement. Fast to parse. \u6027\u80fd \u5f53\u8003\u8651\u5230\u6027\u80fd\u7684\u65f6\u5019\uff0c\u9700\u8981\u601d\u8003\u7684\u65b9\u9762\u662f\u975e\u5e38\u591a\u7684: 1) \u662f\u5426\u80fd\u591f\u5feb\u901f\u89e3\u6790 2) playload\u8981\u5c3d\u53ef\u80fd\u5c0f \u5f71\u54cd\u5e26\u5bbd\u3002 Human readable NOTE: \u8fd9\u662f\u5728\u9605\u8bfb Redis Protocol specification \u65f6\uff0c\u5176\u4e2d\u7ed9\u51fa\u7684\u603b\u7ed3: Human readable Language-neutral \u662f\u5426\u8bed\u8a00\u4e2d\u7acb\uff0c\u5982\u679c\u8bed\u8a00\u4e2d\u7acb\u7684\u8bdd\uff0c\u90a3\u4e48\u8de8\u8bed\u8a00\u5c31\u975e\u5e38\u5bb9\u6613\u4e86\u3002 NOTE: \u672c\u8282\u6807\u9898\u6e90\u81ea protobuf Platform-neutral \u662f\u5426\u5e73\u53f0\u4e2d\u7acb\u3002 NOTE: \u672c\u8282\u6807\u9898\u6e90\u81ea protobuf Protocol data format and file format \u5982\u679c\u4ece\"format\"\u8fdb\u884c\u8054\u60f3\u7684\u8bdd\uff0cprotocol data format\u4e0efile format\u7c7b\u4f3c\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f: \u4e00\u4e9bfile format\u53ef\u4ee5\u4f5c\u4e3aprotocol data format\uff0c\u4e00\u4e9bprotocol data format\u4e5f\u53ef\u4ee5\u4f5c\u4e3afile format\u3002\u672c\u8d28\u4e0a\u5b83\u4eec\u90fd\u662f\u5728\u63cf\u8ff0structure of stream of byte(\u53c2\u89c1 superuser What are the general differences between a format and a protocol )\u3002 Protocol data format is the interface of network service \u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662f: \u5c06protocol data format \u770b\u505a\u662f network service \u7684interface\u3002**Network service**\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2afunction\u3002 \u53c2\u89c1: 1) Remote Function Call 2) Service-oriented Architecture How to descript protocol data format? \u4e0b\u9762\u63cf\u8ff0\u5982\u4f55\u6765\u63cf\u8ff0protocol data format\u3002 cnblogs \u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u51e0\u79cd\u6570\u636e\u4ea4\u6362\u534f\u8bae # \u5982\u4f55\u9009\u62e9\u6570\u636e\u4ea4\u6362\u534f\u8bae \u9009\u62e9\u4ec0\u4e48\u6837\u7684\u534f\u8bae\u8ddf\u6211\u4eec\u7684\u5e94\u7528\u573a\u666f\u6709\u5f88\u5927\u7684\u5173\u7cfb\u3002\u6211\u4eec\u9700\u8981\u8003\u8651\u6211\u4eec\u5f00\u53d1\u662f\u5426\u65b9\u4fbf\u3001\u63a5\u53e3\u662f\u5426\u5bb9\u6613\u53d1\u5e03\u3001\u662f\u5426\u9700\u8981\u8003\u8651\u5e26\u5bbd\u5360\u7528\u6210\u672c\u3001\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u7684\u6027\u80fd\u3001\u63a5\u53e3\u534f\u8bae\u7684\u6269\u5c55\u6027\u7b49\u7b49\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e0b\u51e0\u4e2a\u6bd4\u8f83\u5e38\u7528\u7684\u4ea4\u6362\u534f\u8bae\u5b9e\u73b0\u3002 \u534f\u8bae \u5b9e\u73b0 \u8de8\u8bed\u8a00 \u6027\u80fd \u4f20\u8f93\u91cf RPC xml \u5e7f\u6cdb \u51e0\u4e4e\u6240\u6709 \u4f4e \u5f88\u5927 N\uff08\u53ef\u5b9e\u73b0\uff09 json \u5e7f\u6cdb \u5927\u91cf \u4e00\u822c \u4e00\u822c N\uff08\u53ef\u5b9e\u73b0\uff09 php serialize PHPRPC \u5927\u91cf \u4e00\u822c \u4e00\u822c Y hessian hessian \u5927\u91cf \u4e00\u822c \u5c0f Y thrift thrift \u5927\u91cf \u9ad8 \u5c0f Y protobuf protobuf \u5927\u91cf \u9ad8 \u5c0f N\uff08\u53ef\u5b9e\u73b0\uff09 ice ice \u5927\u91cf \u9ad8 \u5c0f Y avro Apache Avro \u5c11\u91cf \u9ad8 \u5c0f Y messagepack messagepack \u5927\u91cf \u9ad8 \u5c0f Y \u4f7f\u7528struct\u6765\u63cf\u8ff0 \u6bcf\u79cd\u670d\u52a1\u7684\u5165\u53c2\uff0c\u90fd\u6709\u5bf9\u5e94\u7684struct\u7c7b\u578b\uff0c\u8fd9\u6837\u8c03\u7528\u4e00\u4e2a\u670d\u52a1\u7684\u5165\u53c2\u7684\u65f6\u5019\uff0c\u4f20\u5165\u5bf9\u5e94\u7684struct\u7684object(copy\u4e00\u6b21)\uff0c\u5728server\u7aef\uff0c\u670d\u52a1\u7684\u5b9e\u73b0\u4e2d\uff0c\u76f4\u63a5\u4f7f\u7528\u8be5\u670d\u52a1\u5bf9\u5e94\u7684struct\u8fdb\u884c\u53cd\u5e8f\u5217\u5316\u5373\u53ef\uff0c\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u7684\u65b9\u5f0f\u6765\u907f\u514dcopy: struct CRequestStruct {}; const void * Request = Recv (); // \u63a5\u6536\u5f97\u5230\u7684\u8bf7\u6c42\u6570\u636e const CRequestStruct * Req = reinterpret_cast < const CRequestStruct *> ( Request ); // \u8fd9\u79cd\u65b9\u5f0f\u80fd\u591f\u4fdd\u8bc1\u907f\u514d\u591a\u6b21\u7684copy\uff0c\u4f46\u662f\u9700\u8981\u4e3a\u6bcf\u4e2a\u670d\u52a1\u90fd\u6307\u5b9a\u4e00\u4e2astruct\uff0c\u6216\u8005\u8bf4\uff0c\u9700\u8981\u4e3a\u6bcf\u4e2a\u670d\u52a1\u5236\u5b9a\u5177\u4f53\u7684protocol\uff0c\u8fd9\u5e26\u6765\u7684\u4e00\u4e2a\u95ee\u9898\u5c31\u662f: \u7ef4\u62a4\u7684\u6210\u672c\u3002 \u8fd9\u79cd\u65b9\u5f0f\u7684\u4e00\u4e2a\u7f3a\u70b9\u662f: \u65e0\u6cd5cross-language\u3002 IDL IDL\u7684\u542b\u4e49\u662f: interface description language\u3002 \u76ee\u524d\u5b9e\u73b0\u8fd9\u79cd\u65b9\u5f0f\u7684\u6709: 1) Protobuf 2) Thrift 3) Apache Avro \u5728 ./IDL \u5bf9\u5b83\u4eec\u8fdb\u884c\u63cf\u8ff0\u3002","title":"Introduction"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#protocol#data#formatdata#exchange#format","text":"\u672c\u7ae0\u8ba8\u8bbaprotocol data format\u3002","title":"Protocol data format/data exchange format"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#how#to#design#protocol#data#format","text":"Protocol data format(\u6709\u65f6\u5019\u4e5f\u88ab\u79f0\u4e3adata exchange format)\u7684\u8bbe\u8ba1\u662fapplication protocol\u7684\u4e3b\u8981\u5185\u5bb9\uff0c\u4e0b\u9762\u662f\u8bbe\u8ba1\u7684\u65f6\u5019\u9700\u8981\u8003\u8651\u7684\u4e00\u4e9b\u5185\u5bb9\uff0c\u5728 ./Protocol-data-format \u7ae0\u8282\u603b\u7ed3\u4e86\u4e00\u4e9b\u5f53\u524d\u88ab\u5e7f\u6cdb\u91c7\u7528\u7684format\u3002","title":"How to design protocol data format"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#message#boundary","text":"\u4f7f\u7528TCP\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5185\u5bb9\u662f: \u5982\u4f55\u63cf\u8ff0message boundary\uff1f","title":"Message boundary"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#implementation","text":"\u5728\u8bbe\u8ba1protocol\u7684\u65f6\u5019\uff0c\u4e5f\u662f\u9700\u8981\u8003\u8651implementation\u76f8\u5173\u7684\u95ee\u9898: 1) \u6210\u672c\u7684\u3001\u96be\u6613\u7a0b\u5ea6 2) \u6027\u80fd NOTE: \u8fd9\u662f\u5728\u9605\u8bfb Redis Protocol specification \u65f6\uff0c\u5176\u4e2d\u7ed9\u51fa\u7684\u603b\u7ed3: Simple to implement. Fast to parse.","title":"Implementation"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#_1","text":"\u5f53\u8003\u8651\u5230\u6027\u80fd\u7684\u65f6\u5019\uff0c\u9700\u8981\u601d\u8003\u7684\u65b9\u9762\u662f\u975e\u5e38\u591a\u7684: 1) \u662f\u5426\u80fd\u591f\u5feb\u901f\u89e3\u6790 2) playload\u8981\u5c3d\u53ef\u80fd\u5c0f \u5f71\u54cd\u5e26\u5bbd\u3002","title":"\u6027\u80fd"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#human#readable","text":"NOTE: \u8fd9\u662f\u5728\u9605\u8bfb Redis Protocol specification \u65f6\uff0c\u5176\u4e2d\u7ed9\u51fa\u7684\u603b\u7ed3: Human readable","title":"Human readable"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#language-neutral","text":"\u662f\u5426\u8bed\u8a00\u4e2d\u7acb\uff0c\u5982\u679c\u8bed\u8a00\u4e2d\u7acb\u7684\u8bdd\uff0c\u90a3\u4e48\u8de8\u8bed\u8a00\u5c31\u975e\u5e38\u5bb9\u6613\u4e86\u3002 NOTE: \u672c\u8282\u6807\u9898\u6e90\u81ea protobuf","title":"Language-neutral"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#platform-neutral","text":"\u662f\u5426\u5e73\u53f0\u4e2d\u7acb\u3002 NOTE: \u672c\u8282\u6807\u9898\u6e90\u81ea protobuf","title":"Platform-neutral"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#protocol#data#format#and#file#format","text":"\u5982\u679c\u4ece\"format\"\u8fdb\u884c\u8054\u60f3\u7684\u8bdd\uff0cprotocol data format\u4e0efile format\u7c7b\u4f3c\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f: \u4e00\u4e9bfile format\u53ef\u4ee5\u4f5c\u4e3aprotocol data format\uff0c\u4e00\u4e9bprotocol data format\u4e5f\u53ef\u4ee5\u4f5c\u4e3afile format\u3002\u672c\u8d28\u4e0a\u5b83\u4eec\u90fd\u662f\u5728\u63cf\u8ff0structure of stream of byte(\u53c2\u89c1 superuser What are the general differences between a format and a protocol )\u3002","title":"Protocol data format and file format"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#protocol#data#format#is#the#interface#of#network#service","text":"\u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662f: \u5c06protocol data format \u770b\u505a\u662f network service \u7684interface\u3002**Network service**\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2afunction\u3002 \u53c2\u89c1: 1) Remote Function Call 2) Service-oriented Architecture","title":"Protocol data format is the interface of network service"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#how#to#descript#protocol#data#format","text":"\u4e0b\u9762\u63cf\u8ff0\u5982\u4f55\u6765\u63cf\u8ff0protocol data format\u3002","title":"How to descript protocol data format?"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#cnblogs","text":"\u9009\u62e9\u4ec0\u4e48\u6837\u7684\u534f\u8bae\u8ddf\u6211\u4eec\u7684\u5e94\u7528\u573a\u666f\u6709\u5f88\u5927\u7684\u5173\u7cfb\u3002\u6211\u4eec\u9700\u8981\u8003\u8651\u6211\u4eec\u5f00\u53d1\u662f\u5426\u65b9\u4fbf\u3001\u63a5\u53e3\u662f\u5426\u5bb9\u6613\u53d1\u5e03\u3001\u662f\u5426\u9700\u8981\u8003\u8651\u5e26\u5bbd\u5360\u7528\u6210\u672c\u3001\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u7684\u6027\u80fd\u3001\u63a5\u53e3\u534f\u8bae\u7684\u6269\u5c55\u6027\u7b49\u7b49\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e0b\u51e0\u4e2a\u6bd4\u8f83\u5e38\u7528\u7684\u4ea4\u6362\u534f\u8bae\u5b9e\u73b0\u3002 \u534f\u8bae \u5b9e\u73b0 \u8de8\u8bed\u8a00 \u6027\u80fd \u4f20\u8f93\u91cf RPC xml \u5e7f\u6cdb \u51e0\u4e4e\u6240\u6709 \u4f4e \u5f88\u5927 N\uff08\u53ef\u5b9e\u73b0\uff09 json \u5e7f\u6cdb \u5927\u91cf \u4e00\u822c \u4e00\u822c N\uff08\u53ef\u5b9e\u73b0\uff09 php serialize PHPRPC \u5927\u91cf \u4e00\u822c \u4e00\u822c Y hessian hessian \u5927\u91cf \u4e00\u822c \u5c0f Y thrift thrift \u5927\u91cf \u9ad8 \u5c0f Y protobuf protobuf \u5927\u91cf \u9ad8 \u5c0f N\uff08\u53ef\u5b9e\u73b0\uff09 ice ice \u5927\u91cf \u9ad8 \u5c0f Y avro Apache Avro \u5c11\u91cf \u9ad8 \u5c0f Y messagepack messagepack \u5927\u91cf \u9ad8 \u5c0f Y","title":"cnblogs \u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u51e0\u79cd\u6570\u636e\u4ea4\u6362\u534f\u8bae # \u5982\u4f55\u9009\u62e9\u6570\u636e\u4ea4\u6362\u534f\u8bae"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#struct","text":"\u6bcf\u79cd\u670d\u52a1\u7684\u5165\u53c2\uff0c\u90fd\u6709\u5bf9\u5e94\u7684struct\u7c7b\u578b\uff0c\u8fd9\u6837\u8c03\u7528\u4e00\u4e2a\u670d\u52a1\u7684\u5165\u53c2\u7684\u65f6\u5019\uff0c\u4f20\u5165\u5bf9\u5e94\u7684struct\u7684object(copy\u4e00\u6b21)\uff0c\u5728server\u7aef\uff0c\u670d\u52a1\u7684\u5b9e\u73b0\u4e2d\uff0c\u76f4\u63a5\u4f7f\u7528\u8be5\u670d\u52a1\u5bf9\u5e94\u7684struct\u8fdb\u884c\u53cd\u5e8f\u5217\u5316\u5373\u53ef\uff0c\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u7684\u65b9\u5f0f\u6765\u907f\u514dcopy: struct CRequestStruct {}; const void * Request = Recv (); // \u63a5\u6536\u5f97\u5230\u7684\u8bf7\u6c42\u6570\u636e const CRequestStruct * Req = reinterpret_cast < const CRequestStruct *> ( Request ); // \u8fd9\u79cd\u65b9\u5f0f\u80fd\u591f\u4fdd\u8bc1\u907f\u514d\u591a\u6b21\u7684copy\uff0c\u4f46\u662f\u9700\u8981\u4e3a\u6bcf\u4e2a\u670d\u52a1\u90fd\u6307\u5b9a\u4e00\u4e2astruct\uff0c\u6216\u8005\u8bf4\uff0c\u9700\u8981\u4e3a\u6bcf\u4e2a\u670d\u52a1\u5236\u5b9a\u5177\u4f53\u7684protocol\uff0c\u8fd9\u5e26\u6765\u7684\u4e00\u4e2a\u95ee\u9898\u5c31\u662f: \u7ef4\u62a4\u7684\u6210\u672c\u3002 \u8fd9\u79cd\u65b9\u5f0f\u7684\u4e00\u4e2a\u7f3a\u70b9\u662f: \u65e0\u6cd5cross-language\u3002","title":"\u4f7f\u7528struct\u6765\u63cf\u8ff0"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/#idl","text":"IDL\u7684\u542b\u4e49\u662f: interface description language\u3002 \u76ee\u524d\u5b9e\u73b0\u8fd9\u79cd\u65b9\u5f0f\u7684\u6709: 1) Protobuf 2) Thrift 3) Apache Avro \u5728 ./IDL \u5bf9\u5b83\u4eec\u8fdb\u884c\u63cf\u8ff0\u3002","title":"IDL"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/","text":"Classification of protocol Type of protocol 1) Binary protocol wikipedia Binary protocol 2) Textual protocol \u4e0a\u8ff0\u4e24\u79cd\u662f\u6211\u4eec\u7ecf\u5e38\u9047\u5230\u7684\u4e24\u79cd\u8bf4\u6cd5\uff0c\u5176\u5b9e\u51c6\u786e\u5730\u6765\u8bf4\uff0c\u5b83\u4eec\u6240\u63cf\u8ff0\u7684\u662f\u6839\u636eprotocol\u7684protocol data format\u6765\u8fdb\u884c\u5206\u7c7b\u7684\u3002 \u4e0b\u9762\u662f\u5bf9\u5b83\u4eec\u7684\u533a\u5206\uff0c\u4ece\u5b83\u4eec\u7684\u533a\u5206\u4e2d\uff0c\u80fd\u591f\u5145\u5206\u7406\u89e3\u5b83\u4eec\u5404\u81ea\u7684\u542b\u4e49\uff0c\u4f18\u52bf\u3002 stackoverflow binary protocols v. text protocols Binary protocol versus text protocol isn't really about how binary blobs are encoded. The difference is really whether the protocol is oriented around data structures or around text strings . Let me give an example: HTTP. HTTP is a text protocol , even though when it sends a jpeg image, it just sends the raw bytes , not a text encoding of them. But what makes HTTP a text protocol is that the exchange to get the jpg looks like this: NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f: \u4f7fHTTP\u662f\u4e00\u4e2atext protocol\u7684\u662f\u5b83\u8bf7\u6c42*get* jpg\u7684\u65b9\u5f0f\u5982\u4e0b: Request: GET / f iles/image.jpg HTTP/ 1.0 Co nne c t io n : Keep - Alive User - Age nt : Mozilla/ 4.01 [ e n ] (Wi n 95 ; I) Hos t : hal.e t c.com.au Accep t : image/gi f , image/x - xbi t map , image/jpeg , image/pjpeg , */* Accep t - La n guage : e n Accep t - Charse t : iso -8859-1 , * , u tf -8 Response: HTTP/ 1.1 200 OK Da te : Mo n , 19 Ja n 1998 03 : 52 : 51 GMT Server : Apache/ 1.2.4 Las t - Modi f ied : Wed , 08 Oc t 1997 04 : 15 : 24 GMT ETag : \"61a85-17c3-343b08dc\" Co ntent - Le n g t h : 60830 Accep t - Ra n ges : by tes Keep - Alive : t imeou t = 15 , max= 100 Co nne c t io n : Keep - Alive Co ntent - Type : image/jpeg <bi nar y da ta goes here> NOTE: \u663e\u7136\u5728text protocol\u4e2d\uff0cfield name\u662f\u9700\u8981\u88abencode\u7684\uff0c\u4f46\u662f\u5728binary protocol\u4e2d\uff0c\u4e0d\u9700\u8981encode fieldname\uff0c\u8fd9\u662f\u4e24\u8005\u4e4b\u95f4\u7684\u4e3b\u8981\u5dee\u522b\u4e4b\u4e00\u3002\u8fd9\u5bfc\u81f4\u4e86textual protocol\u8017\u8d39\u66f4\u591a\u7684\u7a7a\u95f4\u3002 Note that this could very easily have been packed much more tightly into a structure that would look (in C) something like Request: struct request { int requestType ; int protocolVersion ; char path [ 1024 ]; char user_agent [ 1024 ]; char host [ 1024 ]; long int accept_bitmask ; long int language_bitmask ; long int charset_bitmask ; }; Response: struct response { int responseType ; int protocolVersion ; time_t date ; char host [ 1024 ]; time_t modification_date ; char etag [ 1024 ]; size_t content_length ; int keepalive_timeout ; int keepalive_max ; int connection_type ; char content_type [ 1024 ]; char data []; }; Where the field names would not have to be transmitted at all, and where, for example, the responseType in the response structure is an int with the value 200 instead of three characters '2' '0' '0'. That's what a text based protocol is: one that is designed to be communicated as a flat stream of (usually human-readable) lines of text, rather than as structured data of many different types. medium Use Binary Encoding Instead of JSON In memory, the data is kept as data structures like objects, lists, arrays, etc. But when you want to send the data over a network or store it in a file, you need to encode the data as a self-contained sequence of bytes . The translation from the in-memory representation to a byte sequence is called encoding and the inverse is called decoding . With time, the schema for data that an application handles or stores may evolve, a new field can get added, or an old one can be removed. Therefore, the encoding used needs to support both backward (new code should be able to read the data written by the old code) and forward (old code should be able to read the data written by the new code) compatibility. NOTE: \u5173\u4e8eencode\u3001decode\uff0c\u53c2\u89c1\u5de5\u7a0bprogramming-language\u7684 Theory\\Serialization \u7ae0\u8282\u3002 In this article, we will discuss different encoding formats, how binary encoding formats are better than JSON, XML, and how these support schema evolution . Types of Encoding Formats There are two types of encoding formats: Textual formats Binary formats Textual Formats Textual formats are somewhat human-readable. Some of the common formats are JSON, CSV, and XML. Textual formats are easy to use and understand but can result in different problems: 1) Textual formats can contain a lot of ambiguity . For example, in XML and CSV, you cannot distinguish between strings and numbers. JSON can distinguish between string and numbers but cannot distinguish between integers and floating numbers and doesn\u2019t specify a precision. NOTE: json\u4e2d\u7684\u5b57\u7b26\u4e32\u4f7f\u7528 \"\" \u6307\u5b9a\uff0c\u6240\u4ee5\u80fd\u591f\u533a\u5206 This becomes a problem when dealing with large numbers. An example of numbers larger than 253 occurs on Twitter, which uses a 64-bit number to identify each tweet. The JSON returned by Twitter\u2019s API includes tweet IDs twice \u2014 once as a JSON number and once as a decimal string \u2014 to work around the fact that the numbers are not correctly parsed by JavaScript applications. NOTE: \u6ca1\u6709\u7406\u89e3 2) CSV doesn\u2019t contain any schema , leaving it to the application to define the meaning of each row and column. NOTE: \u9700\u8981\u7531application\u6765\u5b9a\u4e49\u6bcf\u4e00\u884c\u7684\u542b\u4e49 3) Textual formats take more space than binary encoding. For example, as JSON and XML are schema-less , they need to contain field names as well. NOTE: \u7531\u4e8ejson\u3001XML\u90fd\u662fschema-less\u7684\uff0c\u6240\u4ee5\u9700\u8981\u5c06field\u5e26\u4e0a { \"userName\" : \"Martin\" , \"favoriteNumber\" : 1337 , \"interests\" : [ \"daydreaming\" , \"hacking\" ] } Its JSON encoding after removing all the white spaces consumes 82 bytes. Binary Encoding NOTE: \u4e0b\u9762\u4ee5Thrift\u3001 Protocol Buffers\u3001Avro\u4e3a\u4f8b\u6765\u8bba\u8ff0binary protocol\u7684\u4f18\u52bf\u3002 For data that is used only internally within your organization, you could choose a format that is more compact or faster to parse. Although JSON is less verbose than XML, they both still use a lot of space compared to binary formats. We will be discussing three different binary encoding formats in this article: 1) Thrift 2) Protocol Buffers 3) Avro All three provide efficient, cross-language serialization of data using a schema and have code generation tools . All three support schema evolution by ensuring both backward and forward compatibility. NOTE: \u7531\u4e8e\u4f7f\u7528schema\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u4e3a\u6570\u636e\u5e26\u4e0afield\uff1b \u652f\u6301**schema evolution**\u7684\u7279\u6027\u662f\u975e\u5e38\u6709\u4ef7\u503c\u7684\uff0c\u5982\u679c\u652f\u6301\uff0c\u5c06\u662f\u4e00\u79cd\u4f18\u52bf\u3002 Thrift and Protocol Buffers Thrift is developed by Facebook and Protocol Buffers by Google. Both of them require schema for data to be encoded. In Thrift, the schema is defined using Thrift\u2019s interface definition language (IDL). struct Person { 1 : string userName , 2 : optional i64 favouriteNumber , 3 : list < string > interests } The equivalent schema for Protocol Buffers is: message Person { required string user_name = 1 ; optional int64 favourite_number = 2 ; repeated string interests = 3 ; } As you can see, both define a data type and tag number (as 1 , 2 , and 3 ) for each field. Thrift has two different binary encoding formats: BinaryProtocol and CompactProtocol . The binary format is straightforward, as shown below, and takes 59 bytes to encode the data above. The compact protocol is semantically equivalent to the binary protocol but packs the same information in just 34 bytes. It does this by packing the field type and tag number in a single byte. Protocol Buffers also encode the data similarly to Thrift\u2019s compact protocol and take 33 bytes to encode the same data. Tag numbers ensure schema evolution in Thrift and Protocol Buffers. If an old code tries to read the data written with a new schema , it will simply ignore the fields with new tag numbers. Similarly, new code can read the data written by an old schema by putting the values as null for missing tag numbers. Avro Avro is different from Protocol Buffers and Thrift. Avro also uses a schema to define the data. Schema can be defined using Avro\u2019s IDL (intended for human readability): record Person { string userName ; union { null , long } favouriteNumber ; array < string > interests ; } Or JSON (more machine-readable): \"type\" : \"record\" , \"name\" : \"Person\" , \"fields\" : [ { \"name\" : \"userName\" , \"type\" : \"string\" }, { \"name\" : \"favouriteNumber\" , \"type\" : [ \"null\" , \"long\" ]}, { \"name\" : \"interests\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" }} ] } Notice that there are no tag numbers with each field. Avro encoding takes just 32 bytes to encode the same data. As you can see in the byte sequence above, there is no way to identify a field (like using a tag number in Thrift and Protocol Buffers) or its data type. The values are simply concatenated together. Does this mean any change in the schema while decoding would generate incorrect data? The key idea with Avro is that the writer and reader\u2019s schema do not need to be the same, but they do need to be compatible. When the data is decoded, Avro\u2019s library resolves the difference by looking at both schemas and translating the data from the writer\u2019s schema to reader\u2019s schema. You must be thinking about how the reader will know about the writer\u2019s schema. This depends on the use case where such encoding is used. For transferring large files or data, the writer can include their schema once at the beginning of the file. For a database with individually written records, each row can be written with a different schema. The simplest solution is to include a version number at the beginning of each record and to keep the list of schemas. For sending a record over a network, the reader and writer can negotiate the schema on connection setup. One of the main advantages of using the Avro format is it supports dynamically generated schemas. Since it doesn\u2019t use tag numbers, you can use versioning to keep different records encoded with different schemas. Conclusion In this article, we looked into textual and binary encoding formats, how the same data takes 82 bytes with JSON encoding, 33 bytes using Thrift and Protocol Buffers, and just 32 bytes using Avro encoding. Binary formats offer several compelling advantages over JSON for sending data over the wire between internal services. Resources To know more about encoding and designing data-intensive applications, I highly recommend reading Martin Kleppmann\u2019s book Designing Data-Intensive Applications . TODO \u5728\u4e0b\u9762\u8fd9\u4e9b\u6587\u7ae0\u4e2d\uff0c\u4e5f\u8bf4\u660e\u4e86binary protocol VS textual protocol: 1) williamqliu.github Data Exchange Formats (Avro, Thrift, Protocol Buffers) 2) eprosima Apache Thrift vs Protocol Buffers vs Fast Buffers","title":"Binary-VS-textual"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#classification#of#protocol","text":"","title":"Classification of protocol"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#type#of#protocol","text":"1) Binary protocol wikipedia Binary protocol 2) Textual protocol \u4e0a\u8ff0\u4e24\u79cd\u662f\u6211\u4eec\u7ecf\u5e38\u9047\u5230\u7684\u4e24\u79cd\u8bf4\u6cd5\uff0c\u5176\u5b9e\u51c6\u786e\u5730\u6765\u8bf4\uff0c\u5b83\u4eec\u6240\u63cf\u8ff0\u7684\u662f\u6839\u636eprotocol\u7684protocol data format\u6765\u8fdb\u884c\u5206\u7c7b\u7684\u3002 \u4e0b\u9762\u662f\u5bf9\u5b83\u4eec\u7684\u533a\u5206\uff0c\u4ece\u5b83\u4eec\u7684\u533a\u5206\u4e2d\uff0c\u80fd\u591f\u5145\u5206\u7406\u89e3\u5b83\u4eec\u5404\u81ea\u7684\u542b\u4e49\uff0c\u4f18\u52bf\u3002","title":"Type of protocol"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#stackoverflow#binary#protocols#v#text#protocols","text":"Binary protocol versus text protocol isn't really about how binary blobs are encoded. The difference is really whether the protocol is oriented around data structures or around text strings . Let me give an example: HTTP. HTTP is a text protocol , even though when it sends a jpeg image, it just sends the raw bytes , not a text encoding of them. But what makes HTTP a text protocol is that the exchange to get the jpg looks like this: NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f: \u4f7fHTTP\u662f\u4e00\u4e2atext protocol\u7684\u662f\u5b83\u8bf7\u6c42*get* jpg\u7684\u65b9\u5f0f\u5982\u4e0b: Request: GET / f iles/image.jpg HTTP/ 1.0 Co nne c t io n : Keep - Alive User - Age nt : Mozilla/ 4.01 [ e n ] (Wi n 95 ; I) Hos t : hal.e t c.com.au Accep t : image/gi f , image/x - xbi t map , image/jpeg , image/pjpeg , */* Accep t - La n guage : e n Accep t - Charse t : iso -8859-1 , * , u tf -8 Response: HTTP/ 1.1 200 OK Da te : Mo n , 19 Ja n 1998 03 : 52 : 51 GMT Server : Apache/ 1.2.4 Las t - Modi f ied : Wed , 08 Oc t 1997 04 : 15 : 24 GMT ETag : \"61a85-17c3-343b08dc\" Co ntent - Le n g t h : 60830 Accep t - Ra n ges : by tes Keep - Alive : t imeou t = 15 , max= 100 Co nne c t io n : Keep - Alive Co ntent - Type : image/jpeg <bi nar y da ta goes here> NOTE: \u663e\u7136\u5728text protocol\u4e2d\uff0cfield name\u662f\u9700\u8981\u88abencode\u7684\uff0c\u4f46\u662f\u5728binary protocol\u4e2d\uff0c\u4e0d\u9700\u8981encode fieldname\uff0c\u8fd9\u662f\u4e24\u8005\u4e4b\u95f4\u7684\u4e3b\u8981\u5dee\u522b\u4e4b\u4e00\u3002\u8fd9\u5bfc\u81f4\u4e86textual protocol\u8017\u8d39\u66f4\u591a\u7684\u7a7a\u95f4\u3002 Note that this could very easily have been packed much more tightly into a structure that would look (in C) something like Request: struct request { int requestType ; int protocolVersion ; char path [ 1024 ]; char user_agent [ 1024 ]; char host [ 1024 ]; long int accept_bitmask ; long int language_bitmask ; long int charset_bitmask ; }; Response: struct response { int responseType ; int protocolVersion ; time_t date ; char host [ 1024 ]; time_t modification_date ; char etag [ 1024 ]; size_t content_length ; int keepalive_timeout ; int keepalive_max ; int connection_type ; char content_type [ 1024 ]; char data []; }; Where the field names would not have to be transmitted at all, and where, for example, the responseType in the response structure is an int with the value 200 instead of three characters '2' '0' '0'. That's what a text based protocol is: one that is designed to be communicated as a flat stream of (usually human-readable) lines of text, rather than as structured data of many different types.","title":"stackoverflow binary protocols v. text protocols"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#medium#use#binary#encoding#instead#of#json","text":"In memory, the data is kept as data structures like objects, lists, arrays, etc. But when you want to send the data over a network or store it in a file, you need to encode the data as a self-contained sequence of bytes . The translation from the in-memory representation to a byte sequence is called encoding and the inverse is called decoding . With time, the schema for data that an application handles or stores may evolve, a new field can get added, or an old one can be removed. Therefore, the encoding used needs to support both backward (new code should be able to read the data written by the old code) and forward (old code should be able to read the data written by the new code) compatibility. NOTE: \u5173\u4e8eencode\u3001decode\uff0c\u53c2\u89c1\u5de5\u7a0bprogramming-language\u7684 Theory\\Serialization \u7ae0\u8282\u3002 In this article, we will discuss different encoding formats, how binary encoding formats are better than JSON, XML, and how these support schema evolution .","title":"medium Use Binary Encoding Instead of JSON"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#types#of#encoding#formats","text":"There are two types of encoding formats: Textual formats Binary formats","title":"Types of Encoding Formats"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#textual#formats","text":"Textual formats are somewhat human-readable. Some of the common formats are JSON, CSV, and XML. Textual formats are easy to use and understand but can result in different problems: 1) Textual formats can contain a lot of ambiguity . For example, in XML and CSV, you cannot distinguish between strings and numbers. JSON can distinguish between string and numbers but cannot distinguish between integers and floating numbers and doesn\u2019t specify a precision. NOTE: json\u4e2d\u7684\u5b57\u7b26\u4e32\u4f7f\u7528 \"\" \u6307\u5b9a\uff0c\u6240\u4ee5\u80fd\u591f\u533a\u5206 This becomes a problem when dealing with large numbers. An example of numbers larger than 253 occurs on Twitter, which uses a 64-bit number to identify each tweet. The JSON returned by Twitter\u2019s API includes tweet IDs twice \u2014 once as a JSON number and once as a decimal string \u2014 to work around the fact that the numbers are not correctly parsed by JavaScript applications. NOTE: \u6ca1\u6709\u7406\u89e3 2) CSV doesn\u2019t contain any schema , leaving it to the application to define the meaning of each row and column. NOTE: \u9700\u8981\u7531application\u6765\u5b9a\u4e49\u6bcf\u4e00\u884c\u7684\u542b\u4e49 3) Textual formats take more space than binary encoding. For example, as JSON and XML are schema-less , they need to contain field names as well. NOTE: \u7531\u4e8ejson\u3001XML\u90fd\u662fschema-less\u7684\uff0c\u6240\u4ee5\u9700\u8981\u5c06field\u5e26\u4e0a { \"userName\" : \"Martin\" , \"favoriteNumber\" : 1337 , \"interests\" : [ \"daydreaming\" , \"hacking\" ] } Its JSON encoding after removing all the white spaces consumes 82 bytes.","title":"Textual Formats"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#binary#encoding","text":"NOTE: \u4e0b\u9762\u4ee5Thrift\u3001 Protocol Buffers\u3001Avro\u4e3a\u4f8b\u6765\u8bba\u8ff0binary protocol\u7684\u4f18\u52bf\u3002 For data that is used only internally within your organization, you could choose a format that is more compact or faster to parse. Although JSON is less verbose than XML, they both still use a lot of space compared to binary formats. We will be discussing three different binary encoding formats in this article: 1) Thrift 2) Protocol Buffers 3) Avro All three provide efficient, cross-language serialization of data using a schema and have code generation tools . All three support schema evolution by ensuring both backward and forward compatibility. NOTE: \u7531\u4e8e\u4f7f\u7528schema\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u4e3a\u6570\u636e\u5e26\u4e0afield\uff1b \u652f\u6301**schema evolution**\u7684\u7279\u6027\u662f\u975e\u5e38\u6709\u4ef7\u503c\u7684\uff0c\u5982\u679c\u652f\u6301\uff0c\u5c06\u662f\u4e00\u79cd\u4f18\u52bf\u3002","title":"Binary Encoding"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#thrift#and#protocol#buffers","text":"Thrift is developed by Facebook and Protocol Buffers by Google. Both of them require schema for data to be encoded. In Thrift, the schema is defined using Thrift\u2019s interface definition language (IDL). struct Person { 1 : string userName , 2 : optional i64 favouriteNumber , 3 : list < string > interests } The equivalent schema for Protocol Buffers is: message Person { required string user_name = 1 ; optional int64 favourite_number = 2 ; repeated string interests = 3 ; } As you can see, both define a data type and tag number (as 1 , 2 , and 3 ) for each field. Thrift has two different binary encoding formats: BinaryProtocol and CompactProtocol . The binary format is straightforward, as shown below, and takes 59 bytes to encode the data above. The compact protocol is semantically equivalent to the binary protocol but packs the same information in just 34 bytes. It does this by packing the field type and tag number in a single byte. Protocol Buffers also encode the data similarly to Thrift\u2019s compact protocol and take 33 bytes to encode the same data. Tag numbers ensure schema evolution in Thrift and Protocol Buffers. If an old code tries to read the data written with a new schema , it will simply ignore the fields with new tag numbers. Similarly, new code can read the data written by an old schema by putting the values as null for missing tag numbers.","title":"Thrift and Protocol Buffers"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#avro","text":"Avro is different from Protocol Buffers and Thrift. Avro also uses a schema to define the data. Schema can be defined using Avro\u2019s IDL (intended for human readability): record Person { string userName ; union { null , long } favouriteNumber ; array < string > interests ; } Or JSON (more machine-readable): \"type\" : \"record\" , \"name\" : \"Person\" , \"fields\" : [ { \"name\" : \"userName\" , \"type\" : \"string\" }, { \"name\" : \"favouriteNumber\" , \"type\" : [ \"null\" , \"long\" ]}, { \"name\" : \"interests\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" }} ] } Notice that there are no tag numbers with each field. Avro encoding takes just 32 bytes to encode the same data. As you can see in the byte sequence above, there is no way to identify a field (like using a tag number in Thrift and Protocol Buffers) or its data type. The values are simply concatenated together. Does this mean any change in the schema while decoding would generate incorrect data? The key idea with Avro is that the writer and reader\u2019s schema do not need to be the same, but they do need to be compatible. When the data is decoded, Avro\u2019s library resolves the difference by looking at both schemas and translating the data from the writer\u2019s schema to reader\u2019s schema. You must be thinking about how the reader will know about the writer\u2019s schema. This depends on the use case where such encoding is used. For transferring large files or data, the writer can include their schema once at the beginning of the file. For a database with individually written records, each row can be written with a different schema. The simplest solution is to include a version number at the beginning of each record and to keep the list of schemas. For sending a record over a network, the reader and writer can negotiate the schema on connection setup. One of the main advantages of using the Avro format is it supports dynamically generated schemas. Since it doesn\u2019t use tag numbers, you can use versioning to keep different records encoded with different schemas.","title":"Avro"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#conclusion","text":"In this article, we looked into textual and binary encoding formats, how the same data takes 82 bytes with JSON encoding, 33 bytes using Thrift and Protocol Buffers, and just 32 bytes using Avro encoding. Binary formats offer several compelling advantages over JSON for sending data over the wire between internal services.","title":"Conclusion"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#resources","text":"To know more about encoding and designing data-intensive applications, I highly recommend reading Martin Kleppmann\u2019s book Designing Data-Intensive Applications .","title":"Resources"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/Binary-VS-textual/#todo","text":"\u5728\u4e0b\u9762\u8fd9\u4e9b\u6587\u7ae0\u4e2d\uff0c\u4e5f\u8bf4\u660e\u4e86binary protocol VS textual protocol: 1) williamqliu.github Data Exchange Formats (Avro, Thrift, Protocol Buffers) 2) eprosima Apache Thrift vs Protocol Buffers vs Fast Buffers","title":"TODO"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/","text":"\u5173\u4e8e\u672c\u7ae0 \u4f7f\u7528IDL\u7684\u65b9\u5f0f\uff0c\u6211\u4eec\u80fd\u591f\u5b9e\u73b0\u4ee5language-neutral\u7684\u65b9\u5f0f\u6765\u63cf\u8ff0protocol data format\uff0c\u901a\u8fc7IDL compiler\u6765\u5b9e\u73b0\u5c06IDL\u63cf\u8ff0\u7684protocol data format\u7f16\u8bd1\u4e3a\u5177\u4f53programming language implementation\uff0c\u4ece\u800c\u5b9e\u73b0\u4e86\u62bd\u8c61\uff0c\u5b9e\u73b0\u4e86cross-language\u3001cross-plateform\u3002 \u76ee\u524d\u5b9e\u73b0\u8fd9\u79cd\u65b9\u5f0f\u7684\u6709: 1) Protobuf 2) Thrift 3) Apache Avro \u65f6\u4ee3\u80cc\u666f \u4e3a\u4ec0\u4e48\u5b83\u4eec\u4f1a\u6d41\u884c\uff1f\u5176\u5b9e\u8fd9\u662f\u7531\u5f53\u524d\u7684\u65f6\u4ee3\u80cc\u666f\u6240\u51b3\u5b9a\u7684\uff0c\u4e0b\u9762\u662f\u6211\u7684\u603b\u7ed3: \u5728cloud computing\u3001distributed-computing\u3001microservice\u5927\u884c\u5176\u9053\u7684\u4eca\u5929\uff0c\u8fd9\u79cd\u65b9\u5f0f\u662f\u6781\u5177\u4ef7\u503c\u3002 \u5728\u6587\u7ae0eprosima Apache Thrift vs Protocol Buffers vs Fast Buffers \u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0: Middleware alternatives based on verbose serialization formats such as XML or JSON, used in Web Services and REST, expose very poor performance. The emergence of cloud computing and service integration in large distributed systems is driving companies and developers to consider again fast binary formats and lightweight Remote Procedure Call (RPC) frameworks. We compared Apache Thrift vs Protocol Buffers vs Fast Buffers. \u5728\u6587\u7ae0 medium Supercharge your REST APIs with Protobuf \u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0: This problem magnifies(\u653e\u5927) when you have a micro-services architecture and have 100s (if not 1000s) of services talking to each other over JSON and you accidentally change the JSON response of one of the service. \u5b9e\u73b0\u7684\u5171\u6027 \u5728\u6587\u7ae0 medium Use Binary Encoding Instead of JSON \u4e2d\uff0c\u5bf9\u5b83\u4eec\u5b9e\u73b0\u4e0a\u7684\u5171\u6027\u6709\u8f83\u597d\u7684\u5206\u6790: All three provide efficient, cross-language serialization of data using a schema and have code generation tools . All three support schema evolution by ensuring both backward and forward compatibility. NOTE: \u7531\u4e8e\u4f7f\u7528schema\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u4e3a\u6570\u636e\u5e26\u4e0afield\uff1b \u652f\u6301schema evolution\u7684\u7279\u6027\u662f\u975e\u5e38\u6709\u4ef7\u503c\u7684 \u5728 Network\\Protocol\\Application-protocol\\Protocol-data-format\\Binary-VS-textual \u4e2d\u6536\u5f55\u4e86\u8fd9\u7bc7\u6587\u7ae0\u3002 Thrift VS Protobuf stackoverflow Biggest differences of Thrift vs Protocol Buffers? What are the biggest pros and cons of Apache Thrift vs Google's Protocol Buffers ? A : They both offer many of the same features; however, there are some differences: Thrift supports 'exceptions' Protocol Buffers have much better documentation/examples Thrift has a builtin Set type Protocol Buffers allow \"extensions\" - you can extend an external proto to add extra fields, while still allowing external code to operate on the values. There is no way to do this in Thrift I find Protocol Buffers much easier to read Basically, they are fairly equivalent (with Protocol Buffers slightly more efficient from what I have read). A : RPC is another key difference. Thrift generates code to implement RPC clients and servers wheres Protocol Buffers seems mostly designed as a data-interchange format alone. eprosima Apache Thrift vs Protocol Buffers vs Fast Buffers NOTE: \u8fd9\u7bc7\u6587\u7ae0\u4eceperformance\u7684\u89d2\u5ea6\u5bf9\u5b83\u4eec\u8fdb\u884c\u4e86\u5bf9\u6bd4 williamqliu Data Exchange Formats (Avro, Thrift, Protocol Buffers) NOTE: \u8fd9\u7bc7\u6587\u7ae0\u91cd\u8981\u4eceschema evolution\u7684\u89d2\u5ea6\u5bf9\u5b83\u4eec\u8fdb\u884c\u4e86\u5bf9\u6bd4\u3002\u5173\u4e8eschema evolution\uff0c\u5c06\u5728 ./Schema-evaluation.md \u4e2d\u8fdb\u884c\u5c55\u5f00\u8bf4\u660e\u3002","title":"Introduction"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/#_1","text":"\u4f7f\u7528IDL\u7684\u65b9\u5f0f\uff0c\u6211\u4eec\u80fd\u591f\u5b9e\u73b0\u4ee5language-neutral\u7684\u65b9\u5f0f\u6765\u63cf\u8ff0protocol data format\uff0c\u901a\u8fc7IDL compiler\u6765\u5b9e\u73b0\u5c06IDL\u63cf\u8ff0\u7684protocol data format\u7f16\u8bd1\u4e3a\u5177\u4f53programming language implementation\uff0c\u4ece\u800c\u5b9e\u73b0\u4e86\u62bd\u8c61\uff0c\u5b9e\u73b0\u4e86cross-language\u3001cross-plateform\u3002 \u76ee\u524d\u5b9e\u73b0\u8fd9\u79cd\u65b9\u5f0f\u7684\u6709: 1) Protobuf 2) Thrift 3) Apache Avro","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/#_2","text":"\u4e3a\u4ec0\u4e48\u5b83\u4eec\u4f1a\u6d41\u884c\uff1f\u5176\u5b9e\u8fd9\u662f\u7531\u5f53\u524d\u7684\u65f6\u4ee3\u80cc\u666f\u6240\u51b3\u5b9a\u7684\uff0c\u4e0b\u9762\u662f\u6211\u7684\u603b\u7ed3: \u5728cloud computing\u3001distributed-computing\u3001microservice\u5927\u884c\u5176\u9053\u7684\u4eca\u5929\uff0c\u8fd9\u79cd\u65b9\u5f0f\u662f\u6781\u5177\u4ef7\u503c\u3002 \u5728\u6587\u7ae0eprosima Apache Thrift vs Protocol Buffers vs Fast Buffers \u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0: Middleware alternatives based on verbose serialization formats such as XML or JSON, used in Web Services and REST, expose very poor performance. The emergence of cloud computing and service integration in large distributed systems is driving companies and developers to consider again fast binary formats and lightweight Remote Procedure Call (RPC) frameworks. We compared Apache Thrift vs Protocol Buffers vs Fast Buffers. \u5728\u6587\u7ae0 medium Supercharge your REST APIs with Protobuf \u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0: This problem magnifies(\u653e\u5927) when you have a micro-services architecture and have 100s (if not 1000s) of services talking to each other over JSON and you accidentally change the JSON response of one of the service.","title":"\u65f6\u4ee3\u80cc\u666f"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/#_3","text":"\u5728\u6587\u7ae0 medium Use Binary Encoding Instead of JSON \u4e2d\uff0c\u5bf9\u5b83\u4eec\u5b9e\u73b0\u4e0a\u7684\u5171\u6027\u6709\u8f83\u597d\u7684\u5206\u6790: All three provide efficient, cross-language serialization of data using a schema and have code generation tools . All three support schema evolution by ensuring both backward and forward compatibility. NOTE: \u7531\u4e8e\u4f7f\u7528schema\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u4e3a\u6570\u636e\u5e26\u4e0afield\uff1b \u652f\u6301schema evolution\u7684\u7279\u6027\u662f\u975e\u5e38\u6709\u4ef7\u503c\u7684 \u5728 Network\\Protocol\\Application-protocol\\Protocol-data-format\\Binary-VS-textual \u4e2d\u6536\u5f55\u4e86\u8fd9\u7bc7\u6587\u7ae0\u3002","title":"\u5b9e\u73b0\u7684\u5171\u6027"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/#thrift#vs#protobuf","text":"","title":"Thrift VS Protobuf"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/#stackoverflow#biggest#differences#of#thrift#vs#protocol#buffers","text":"What are the biggest pros and cons of Apache Thrift vs Google's Protocol Buffers ? A : They both offer many of the same features; however, there are some differences: Thrift supports 'exceptions' Protocol Buffers have much better documentation/examples Thrift has a builtin Set type Protocol Buffers allow \"extensions\" - you can extend an external proto to add extra fields, while still allowing external code to operate on the values. There is no way to do this in Thrift I find Protocol Buffers much easier to read Basically, they are fairly equivalent (with Protocol Buffers slightly more efficient from what I have read). A : RPC is another key difference. Thrift generates code to implement RPC clients and servers wheres Protocol Buffers seems mostly designed as a data-interchange format alone.","title":"stackoverflow Biggest differences of Thrift vs Protocol Buffers?"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/#eprosima#apache#thrift#vs#protocol#buffers#vs#fast#buffers","text":"NOTE: \u8fd9\u7bc7\u6587\u7ae0\u4eceperformance\u7684\u89d2\u5ea6\u5bf9\u5b83\u4eec\u8fdb\u884c\u4e86\u5bf9\u6bd4","title":"eprosima Apache Thrift vs Protocol Buffers vs Fast Buffers"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/#williamqliu#data#exchange#formats#avro#thrift#protocol#buffers","text":"NOTE: \u8fd9\u7bc7\u6587\u7ae0\u91cd\u8981\u4eceschema evolution\u7684\u89d2\u5ea6\u5bf9\u5b83\u4eec\u8fdb\u884c\u4e86\u5bf9\u6bd4\u3002\u5173\u4e8eschema evolution\uff0c\u5c06\u5728 ./Schema-evaluation.md \u4e2d\u8fdb\u884c\u5c55\u5f00\u8bf4\u660e\u3002","title":"williamqliu Data Exchange Formats (Avro, Thrift, Protocol Buffers)"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Schema-evaluation/","text":"Schema evaluation \u652f\u6301Schema evaluation\u662f\u672c\u7ae0\u6240\u63cf\u8ff0\u7684\u51e0\u79cd\u5e93\u7684\u4f18\u52bf\uff0c\u672c\u6587\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u8fdb\u884c\u5c55\u5f00\u3002 What is schema evaluation? wikipedia Schema Evolution \u3002 askinglot What is schema evolution in hive? \u3002 williamqliu Data Exchange Formats (Avro, Thrift, Protocol Buffers) There are a lot of Data Exchange formats, each with its own use-case. Some include: JSON Protocol Buffers (Protobuf) Thrift AVRO Things to consider: Efficency - Time and Space Ease/Speed of development E.g. JSON vs Binary; Binary is very fast time and space, but hard to develop with because it is error prone If you\u2019re looking for a cross-language serialization of data using a schema (and requires schema evolution ), but not sure which one to use, then here\u2019s a comparison. schema evolution If/When you change a schema , you\u2019ll have producers and consumers with different versions at the same time. Schema evolution allows your producers and consumers to continue to work across schemas. Some concepts for schema evolution involve forward and backward compatibility. schema evolution scenarios Scenarios for forward and backward compatibility are: No change in fields Added field, old client (producer), new server (consumer) NOTE: server\u4f7f\u7528\u4e86\u65b0\u7684schema\uff0cclient\u4f7f\u7528\u7684\u662f\u65e7\u7684schema Removed field, old client (producer), new server (consumer) NOTE: server\u4f7f\u7528\u4e86\u65b0\u7684schema\uff0cclient\u4f7f\u7528\u7684\u662f\u65e7\u7684schema Added field, new client (producer), old server (consumer) Removed field, new client (producer), old server (consumer) Scenario: No change in fields - producer (client) sends a message to a consumer (server) - all good e.g. MyMsg MyMsg user_id: 123 user_id: 123 amount: 1000 amount: 1000 Scenario: Added field - producer (old client) sends an old message to a consumer (new server); new server recognizes that the field is not set, and implements default behavior for out-of-date requests - all good e.g. MyMsg MyMsg user_id: 123 user_id: 123 amount: 1000 amount: 1000 time: 15 Scenario: Added field - producer (new client) sends a new message to a consumer (old server); old server simply ignores it and processes as normal - all good e.g. MyMsg MyMsg user_id: 123 user_id: 123 amount: 1000 amount: 1000 time: 15 medium Supercharge your REST APIs with Protobuf","title":"Schema-evaluation"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Schema-evaluation/#schema#evaluation","text":"\u652f\u6301Schema evaluation\u662f\u672c\u7ae0\u6240\u63cf\u8ff0\u7684\u51e0\u79cd\u5e93\u7684\u4f18\u52bf\uff0c\u672c\u6587\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u8fdb\u884c\u5c55\u5f00\u3002","title":"Schema evaluation"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Schema-evaluation/#what#is#schema#evaluation","text":"wikipedia Schema Evolution \u3002 askinglot What is schema evolution in hive? \u3002","title":"What is schema evaluation?"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Schema-evaluation/#williamqliu#data#exchange#formats#avro#thrift#protocol#buffers","text":"There are a lot of Data Exchange formats, each with its own use-case. Some include: JSON Protocol Buffers (Protobuf) Thrift AVRO Things to consider: Efficency - Time and Space Ease/Speed of development E.g. JSON vs Binary; Binary is very fast time and space, but hard to develop with because it is error prone If you\u2019re looking for a cross-language serialization of data using a schema (and requires schema evolution ), but not sure which one to use, then here\u2019s a comparison.","title":"williamqliu Data Exchange Formats (Avro, Thrift, Protocol Buffers)"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Schema-evaluation/#schema#evolution","text":"If/When you change a schema , you\u2019ll have producers and consumers with different versions at the same time. Schema evolution allows your producers and consumers to continue to work across schemas. Some concepts for schema evolution involve forward and backward compatibility.","title":"schema evolution"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Schema-evaluation/#schema#evolution#scenarios","text":"Scenarios for forward and backward compatibility are: No change in fields Added field, old client (producer), new server (consumer) NOTE: server\u4f7f\u7528\u4e86\u65b0\u7684schema\uff0cclient\u4f7f\u7528\u7684\u662f\u65e7\u7684schema Removed field, old client (producer), new server (consumer) NOTE: server\u4f7f\u7528\u4e86\u65b0\u7684schema\uff0cclient\u4f7f\u7528\u7684\u662f\u65e7\u7684schema Added field, new client (producer), old server (consumer) Removed field, new client (producer), old server (consumer) Scenario: No change in fields - producer (client) sends a message to a consumer (server) - all good e.g. MyMsg MyMsg user_id: 123 user_id: 123 amount: 1000 amount: 1000 Scenario: Added field - producer (old client) sends an old message to a consumer (new server); new server recognizes that the field is not set, and implements default behavior for out-of-date requests - all good e.g. MyMsg MyMsg user_id: 123 user_id: 123 amount: 1000 amount: 1000 time: 15 Scenario: Added field - producer (new client) sends a new message to a consumer (old server); old server simply ignores it and processes as normal - all good e.g. MyMsg MyMsg user_id: 123 user_id: 123 amount: 1000 amount: 1000 time: 15","title":"schema evolution scenarios"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Schema-evaluation/#medium#supercharge#your#rest#apis#with#protobuf","text":"","title":"medium Supercharge your REST APIs with Protobuf"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Protobuf/","text":"Protocol Buffers developers.google Protocol Buffers Guide Binary serialization of struct vs protoc-buff \u5728ust\u9879\u76ee\u4e2d\uff0c\u76f4\u63a5\u4f7f\u7528\u7684binary serialization\uff0c\u4e3a\u6bcf\u79cd\u8bf7\u6c42\u90fd\u6d89\u53ca\u4e00\u4e2a struct \uff0c\u7136\u540eclient\u548cserver\u4e4b\u95f4\u5c31\u4f7f\u7528 struct \u6765\u4f5c\u4e3aprotocol\u3002\u663e\u7136\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u6700\u6700\u9ad8\u6548\u7684\uff0c\u4f46\u662f\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u6240\u5e26\u6765\u7684\u4e00\u4e2a\u95ee\u9898\u662f\uff1a\u6bcf\u6b21\u65b0\u589e\u4e00\u4e2a\u8bf7\u6c42\uff0c\u5c31\u6d89\u53ca\u5230client\u548cserver\u7684\u5168\u90e8\u7684\u4fee\u6539\u3002\u800c\u4e0d\u662f\u50cf\u666e\u901a\u7684\u534f\u8bae\u90a3\u6837\u3002\u4e0e\u6b64\u76f8\u5173\u7684\u662fredis\u7684\u534f\u8bae\u3001http\u534f\u8bae\u3002 https://stackoverflow.com/questions/2966500/protobuf-net-not-faster-than-binary-serialization https://theburningmonk.com/2011/08/performance-test-binaryformatter-vs-protobuf-net/","title":"Introduction"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Protobuf/#protocol#buffers","text":"","title":"Protocol Buffers"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Protobuf/#developersgoogle#protocol#buffers","text":"","title":"developers.google Protocol Buffers"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Protobuf/#guide","text":"","title":"Guide"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Protobuf/#binary#serialization#of#struct#vs#protoc-buff","text":"\u5728ust\u9879\u76ee\u4e2d\uff0c\u76f4\u63a5\u4f7f\u7528\u7684binary serialization\uff0c\u4e3a\u6bcf\u79cd\u8bf7\u6c42\u90fd\u6d89\u53ca\u4e00\u4e2a struct \uff0c\u7136\u540eclient\u548cserver\u4e4b\u95f4\u5c31\u4f7f\u7528 struct \u6765\u4f5c\u4e3aprotocol\u3002\u663e\u7136\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u6700\u6700\u9ad8\u6548\u7684\uff0c\u4f46\u662f\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u6240\u5e26\u6765\u7684\u4e00\u4e2a\u95ee\u9898\u662f\uff1a\u6bcf\u6b21\u65b0\u589e\u4e00\u4e2a\u8bf7\u6c42\uff0c\u5c31\u6d89\u53ca\u5230client\u548cserver\u7684\u5168\u90e8\u7684\u4fee\u6539\u3002\u800c\u4e0d\u662f\u50cf\u666e\u901a\u7684\u534f\u8bae\u90a3\u6837\u3002\u4e0e\u6b64\u76f8\u5173\u7684\u662fredis\u7684\u534f\u8bae\u3001http\u534f\u8bae\u3002 https://stackoverflow.com/questions/2966500/protobuf-net-not-faster-than-binary-serialization https://theburningmonk.com/2011/08/performance-test-binaryformatter-vs-protobuf-net/","title":"Binary serialization of struct vs protoc-buff"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/","text":"Apache Thrift \u5728\u9605\u8bfbcnblogs \u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u51e0\u79cd\u6570\u636e\u4ea4\u6362\u534f\u8bae \u65f6\uff0c\u5176\u4e2d\u6709\u5173\u4e8eThrift\u7684\u4ecb\u7ecd\u3002 wikipedia Apache Thrift Thrift is an interface definition language and binary communication protocol used for defining and creating services for numerous programming languages. It forms a remote procedure call framework (RPC) and was developed at Facebook for \" scalable cross-language services development \". It combines a software stack with a code generation engine to build cross-platform services which can connect applications written in a variety of languages and frameworks, including ActionScript, C, C++, C#, Cappuccino, Cocoa, Delphi, Erlang, Go, Haskell, Java, JavaScript, Objective-C, OCaml, Perl, PHP, Python, Ruby, Elixir, Rust, Smalltalk and Swift. It was developed at Facebook and it is now an open source project in the Apache Software Foundation. The implementation was described in an April 2007 technical paper released by Facebook, now hosted on Apache. NOTE: \u76f8\u6bd4\u4e8e Apache Thrift \u5b98\u7f51\u7684\u4ecb\u7ecd\uff0cWikipedia\u7684\u4ecb\u7ecd\u66f4\u52a0\u5168\u9762\u3002 Apache Thrift","title":"Introduction"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/#apache#thrift","text":"\u5728\u9605\u8bfbcnblogs \u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u51e0\u79cd\u6570\u636e\u4ea4\u6362\u534f\u8bae \u65f6\uff0c\u5176\u4e2d\u6709\u5173\u4e8eThrift\u7684\u4ecb\u7ecd\u3002","title":"Apache Thrift"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/#wikipedia#apache#thrift","text":"Thrift is an interface definition language and binary communication protocol used for defining and creating services for numerous programming languages. It forms a remote procedure call framework (RPC) and was developed at Facebook for \" scalable cross-language services development \". It combines a software stack with a code generation engine to build cross-platform services which can connect applications written in a variety of languages and frameworks, including ActionScript, C, C++, C#, Cappuccino, Cocoa, Delphi, Erlang, Go, Haskell, Java, JavaScript, Objective-C, OCaml, Perl, PHP, Python, Ruby, Elixir, Rust, Smalltalk and Swift. It was developed at Facebook and it is now an open source project in the Apache Software Foundation. The implementation was described in an April 2007 technical paper released by Facebook, now hosted on Apache. NOTE: \u76f8\u6bd4\u4e8e Apache Thrift \u5b98\u7f51\u7684\u4ecb\u7ecd\uff0cWikipedia\u7684\u4ecb\u7ecd\u66f4\u52a0\u5168\u9762\u3002","title":"wikipedia Apache Thrift"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/#apache#thrift_1","text":"","title":"Apache Thrift"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/","text":"Thrift: Scalable Cross-Language Services Implementation NOTE: \u672a\u9605\u8bfb\u5b8c\u6210 Abstract Thrift is a software library and set of code-generation tools developed at Facebook to expedite(\u4fc3\u8fdb) development and implementation of efficient and scalable backend services . Its primary goal is to enable efficient and reliable communication across programming languages by abstracting the portions of each language that tend to require the most customization into a common library that is implemented in each language. Specifically, Thrift allows developers to define datatypes and service interfaces in a single language-neutral file and generate all the necessary code to build RPC clients and servers. This paper details the motivations and design choices we made in Thrift, as well as some of the more interesting implementation details. It is not intended to be taken as research, but rather it is an exposition on what we did and why. 1 Introduction As Facebook\u2019s traffic and network structure have scaled, the resource demands of many operations on the site (i.e. search, ad selection and delivery, event logging) have presented technical requirements drastically outside the scope of the LAMP framework. \u968f\u7740Facebook\u6d41\u91cf\u548c\u7f51\u7edc\u7ed3\u6784\u7684\u6269\u5927\uff0c\u7f51\u7ad9\u4e0a\u8bb8\u591a\u64cd\u4f5c(\u5982\u641c\u7d22\u3001\u5e7f\u544a\u9009\u62e9\u548c\u53d1\u5e03\u3001\u4e8b\u4ef6\u8bb0\u5f55)\u7684\u8d44\u6e90\u9700\u6c42\u5df2\u7ecf\u5927\u5927\u8d85\u51fa\u4e86LAMP\u6846\u67b6\u7684\u8303\u56f4\u3002 In our implementation of these services, various programming languages have been selected to optimize for the right combination of performance, ease and speed of development, availability of existing libraries, etc. By and large, Facebook\u2019s engineering culture has tended towards choosing the best tools and implementations available over standardizing on any one programming language and begrudgingly(\u541d\u556c\u7684) accepting its inherent limitations. Given this design choice, we were presented with the challenge of building a transparent, high-performance bridge across many programming languages. We found that most available solutions were either too limited, did not offer sufficient datatype freedom, or suffered from subpar(\u4f4e\u4e8e\u6807\u51c6\u7684) performance. 1 The solution that we have implemented combines a language-neutral software stack implemented across numerous programming languages and an associated code generation engine that transforms a simple interface and data definition language into client and server remote procedure call libraries. Choosing static code generation over a dynamic system allows us to create validated code that can be run without the need for any advanced introspective(\u5185\u7701\u7684) run-time type checking. It is also designed to be as simple as possible for the developer, who can typically define all the necessary data structures and interfaces for a complex service in a single short file. Surprised that a robust open solution to these relatively common problems did not yet exist, we committed early on to making the Thrift implementation open source. In evaluating the challenges of cross-language interaction in a networked environment, some key components were identified: Types Types . A common type system must exist across programming languages without requiring that the application developer use custom Thrift datatypes or write their own serialization code. That is, a C++ programmer should be able to transparently exchange a strongly typed STL map for a dynamic Python dictionary. Neither programmer should be forced to write any code below the application layer to achieve this. Section 2 details the Thrift type system. Transport Transport . Each language must have a common interface to bidirectional raw data transport. The specifics of how a given transport is implemented should not matter to the service developer. The same application code should be able to run against TCP stream sockets, raw data in memory, or files on disk. Section 3 details the Thrift Transport layer. Protocol Protocol . Datatypes must have some way of using the Transport layer to encode and decode themselves. Again, the application developer need not be concerned by this layer. Whether the service uses an XML or binary protocol is immaterial(\u900f\u660e\u7684) to the application code. All that matters is that the data can be read and written in a consistent, deterministic matter. Section 4 details the Thrift Protocol layer . Versioning Versioning . For robust services, the involved datatypes must provide a mechanism for versioning themselves. Specifically, it should be possible to add or remove fields in an object or alter the argument list of a function without any interruption in service (or, worse yet, nasty segmentation faults). Section 5 details Thrift\u2019s versioning system. Processors Processors . Finally, we generate code capable of processing data streams to accomplish remote procedure calls. Section 6 details the generated code and TProcessor paradigm . Section 7 discusses implementation details, and Section 8 describes our conclusions. 2 Types 2.1 Base Types 2.2 Structs 2.3 Containers 2.4 Exceptions 2.5 Services 3 Transport The transport layer is used by the generated code to facilitate data transfer. 3.1 Interface 3.2 Implementation 3.2.1 TSocket 3.2.2 TFileTransport 3.2.3 Utilities 4 Protocol A second major abstraction in Thrift is the separation of data structure from transport representation. Thrift enforces a certain messaging structure when transporting data, but it is agnostic to the protocol encoding in use. That is, it does not matter whether data is encoded as XML, human-readable ASCII, or a dense binary format as long as the data supports a fixed set of operations that allow it to be deterministically read and written by generated code.","title":"Thrift-Scalable-Cross-Language-Services-Implementation"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#thrift#scalable#cross-language#services#implementation","text":"NOTE: \u672a\u9605\u8bfb\u5b8c\u6210","title":"Thrift: Scalable Cross-Language Services Implementation"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#abstract","text":"Thrift is a software library and set of code-generation tools developed at Facebook to expedite(\u4fc3\u8fdb) development and implementation of efficient and scalable backend services . Its primary goal is to enable efficient and reliable communication across programming languages by abstracting the portions of each language that tend to require the most customization into a common library that is implemented in each language. Specifically, Thrift allows developers to define datatypes and service interfaces in a single language-neutral file and generate all the necessary code to build RPC clients and servers. This paper details the motivations and design choices we made in Thrift, as well as some of the more interesting implementation details. It is not intended to be taken as research, but rather it is an exposition on what we did and why.","title":"Abstract"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#1#introduction","text":"As Facebook\u2019s traffic and network structure have scaled, the resource demands of many operations on the site (i.e. search, ad selection and delivery, event logging) have presented technical requirements drastically outside the scope of the LAMP framework. \u968f\u7740Facebook\u6d41\u91cf\u548c\u7f51\u7edc\u7ed3\u6784\u7684\u6269\u5927\uff0c\u7f51\u7ad9\u4e0a\u8bb8\u591a\u64cd\u4f5c(\u5982\u641c\u7d22\u3001\u5e7f\u544a\u9009\u62e9\u548c\u53d1\u5e03\u3001\u4e8b\u4ef6\u8bb0\u5f55)\u7684\u8d44\u6e90\u9700\u6c42\u5df2\u7ecf\u5927\u5927\u8d85\u51fa\u4e86LAMP\u6846\u67b6\u7684\u8303\u56f4\u3002 In our implementation of these services, various programming languages have been selected to optimize for the right combination of performance, ease and speed of development, availability of existing libraries, etc. By and large, Facebook\u2019s engineering culture has tended towards choosing the best tools and implementations available over standardizing on any one programming language and begrudgingly(\u541d\u556c\u7684) accepting its inherent limitations. Given this design choice, we were presented with the challenge of building a transparent, high-performance bridge across many programming languages. We found that most available solutions were either too limited, did not offer sufficient datatype freedom, or suffered from subpar(\u4f4e\u4e8e\u6807\u51c6\u7684) performance. 1 The solution that we have implemented combines a language-neutral software stack implemented across numerous programming languages and an associated code generation engine that transforms a simple interface and data definition language into client and server remote procedure call libraries. Choosing static code generation over a dynamic system allows us to create validated code that can be run without the need for any advanced introspective(\u5185\u7701\u7684) run-time type checking. It is also designed to be as simple as possible for the developer, who can typically define all the necessary data structures and interfaces for a complex service in a single short file. Surprised that a robust open solution to these relatively common problems did not yet exist, we committed early on to making the Thrift implementation open source. In evaluating the challenges of cross-language interaction in a networked environment, some key components were identified:","title":"1 Introduction"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#types","text":"Types . A common type system must exist across programming languages without requiring that the application developer use custom Thrift datatypes or write their own serialization code. That is, a C++ programmer should be able to transparently exchange a strongly typed STL map for a dynamic Python dictionary. Neither programmer should be forced to write any code below the application layer to achieve this. Section 2 details the Thrift type system.","title":"Types"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#transport","text":"Transport . Each language must have a common interface to bidirectional raw data transport. The specifics of how a given transport is implemented should not matter to the service developer. The same application code should be able to run against TCP stream sockets, raw data in memory, or files on disk. Section 3 details the Thrift Transport layer.","title":"Transport"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#protocol","text":"Protocol . Datatypes must have some way of using the Transport layer to encode and decode themselves. Again, the application developer need not be concerned by this layer. Whether the service uses an XML or binary protocol is immaterial(\u900f\u660e\u7684) to the application code. All that matters is that the data can be read and written in a consistent, deterministic matter. Section 4 details the Thrift Protocol layer .","title":"Protocol"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#versioning","text":"Versioning . For robust services, the involved datatypes must provide a mechanism for versioning themselves. Specifically, it should be possible to add or remove fields in an object or alter the argument list of a function without any interruption in service (or, worse yet, nasty segmentation faults). Section 5 details Thrift\u2019s versioning system.","title":"Versioning"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#processors","text":"Processors . Finally, we generate code capable of processing data streams to accomplish remote procedure calls. Section 6 details the generated code and TProcessor paradigm . Section 7 discusses implementation details, and Section 8 describes our conclusions.","title":"Processors"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#2#types","text":"","title":"2 Types"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#21#base#types","text":"","title":"2.1 Base Types"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#22#structs","text":"","title":"2.2 Structs"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#23#containers","text":"","title":"2.3 Containers"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#24#exceptions","text":"","title":"2.4 Exceptions"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#25#services","text":"","title":"2.5 Services"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#3#transport","text":"The transport layer is used by the generated code to facilitate data transfer.","title":"3 Transport"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#31#interface","text":"","title":"3.1 Interface"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#32#implementation","text":"","title":"3.2 Implementation"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#321#tsocket","text":"","title":"3.2.1 TSocket"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#322#tfiletransport","text":"","title":"3.2.2 TFileTransport"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#323#utilities","text":"","title":"3.2.3 Utilities"},{"location":"Network/Protocol/Application-protocol/Protocol-data-format/IDL/Thrift/Thrift-Scalable-Cross-Language-Services-Implementation/#4#protocol","text":"A second major abstraction in Thrift is the separation of data structure from transport representation. Thrift enforces a certain messaging structure when transporting data, but it is agnostic to the protocol encoding in use. That is, it does not matter whether data is encoded as XML, human-readable ASCII, or a dense binary format as long as the data supports a fixed set of operations that allow it to be deterministically read and written by generated code.","title":"4 Protocol"},{"location":"Network/Protocol/TCP/TCP-troubleshoot/","text":"TCP troubleshoot \u7406\u89e3\u4e86tcp\u7684\u539f\u7406\uff0c\u5bf9\u4e8etroubleshoot\u7684\u4e00\u4e9b\u95ee\u9898\u662f\u975e\u5e38\u6709\u5e2e\u52a9\u7684\u3002 \u8fde\u63a5\u4e0d\u4e0aserver \u6b65\u9aa4 \u5de5\u5177 \u80fd\u5426\u5230\u8fbehost ping \u7aef\u53e3\u662f\u5426\u5728listen telnet","title":"TCP-troubleshoot"},{"location":"Network/Protocol/TCP/TCP-troubleshoot/#tcp#troubleshoot","text":"\u7406\u89e3\u4e86tcp\u7684\u539f\u7406\uff0c\u5bf9\u4e8etroubleshoot\u7684\u4e00\u4e9b\u95ee\u9898\u662f\u975e\u5e38\u6709\u5e2e\u52a9\u7684\u3002","title":"TCP troubleshoot"},{"location":"Network/Protocol/TCP/TCP-troubleshoot/#server","text":"\u6b65\u9aa4 \u5de5\u5177 \u80fd\u5426\u5230\u8fbehost ping \u7aef\u53e3\u662f\u5426\u5728listen telnet","title":"\u8fde\u63a5\u4e0d\u4e0aserver"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/","text":"Transmission Control Protocol \u672c\u6587\u8ba8\u8bbaTCP\u534f\u8bae\uff0c\u4ee5wikipedia Transmission Control Protocol \u4e3a\u4e3b\uff0c\u53e6\u5916\u8865\u5145\u4e86\u4e00\u4e9b\u5185\u5bb9\u3002 Guide \u5728\u9605\u8bfb\u524d\uff0c\u9700\u8981\u5efa\u7acb\u8d77\u5982\u4e0b\u6982\u5ff5/\u89c2\u5ff5\uff0c\u4fbf\u4e8e\u7406\u89e3: 1) TCP\u91c7\u7528\u7684\u662f: \u8bf7\u6c42-\u54cd\u5e94 \u6a21\u578b \u539f\u6587\u4e2d\u5e76\u6ca1\u6709\u8bf4\u660e\u6b64\uff0c\u8fd9\u662f\u6211\u81ea\u5df1\u6dfb\u52a0\u7684 \u6bcf\u4e2arequest\uff0c\u90fd\u4f1a\u6536\u5230\u4e00\u4e2aresponse\uff0c\u8fd9\u4e2aresponse\u662f\u7528\u4e8eacknowledge\u7684\uff0c\u5373\u63a5\u6536\u65b9\u544a\u8bc9\u53d1\u9001\u65b9: \u6536\u5230\u4e86request\uff0c\u6211\u4eec\u5f80\u5f80\u5c06\u5176\u79f0\u4e4b\u4e3aACK response\uff0c\u8fd9\u6837\u624d\u7b97\u662f\u5b8c\u6210\u4e86\u8fd9\u4e2a\u8bf7\u6c42\uff1b \u5bf9\u4e8eACK\uff0c\u662f\u4e0d\u9700\u8981\u518dACK\u7684\uff0c\u5426\u5219\u5c31\u4f1a\u5bfc\u81f4\u65e0\u9650\u7684\u9012\u5f52\u4e0b\u53bb\uff1b 2) TCP\u662f\u5168\u53cc\u5de5\u901a\u4fe1\u6a21\u5f0f: \u53c2\u89c1 \"4.1 Connection establishment\"\u8282 \u201c\u5168\u53cc\u5de5\u201d\u610f\u5473\u7740\u4e00\u4e2aTCP session\u6709\u4e24\u4e2a\u90e8\u5206\u7ec4\u6210\uff0c\u610f\u5473\u7740\u5b58\u5728\u7740half\u7684\u95ee\u9898\uff08half close\u3001half open\uff09\u3002 3) \u6784\u5efaTCP\u7684**\u6d3b\u52a8\u56fe**(\u6d3b\u52a8\u56fe\u662f\u501f\u7528\u7684\u8f6f\u4ef6\u5de5\u7a0b\u4e2d\u7684\u6982\u5ff5): \u53ef\u4ee5\u91c7\u7528\u5982\u4e0b\u6536\u5f55\u6765\u8fdb\u884c\u6784\u5efa: TCP\u7684\u4e09\u4e2a\u9636\u6bb5: \u8fd9\u662f\u5bf9TCP\u7684lifetime\u7684\u5212\u5206\uff0c\u53c2\u89c1 \"4 Protocol operation\"; TCP\u7684\u64cd\u4f5c: \u6bcf\u4e2a\u9636\u6bb5\u7684\u4f1a\u6267\u884c\u76f8\u5e94\u7684\u64cd\u4f5c\uff0c\u53c2\u89c1 \"4 Protocol operation\"; TCP\u7684\u72b6\u6001: TCP\u662f\u6709\u4e00\u5b9a\u72b6\u6001\u7684\uff0cTCP\u64cd\u4f5c\u4f1a\u89e6\u53d1\u72b6\u6001\u7684\u8f6c\u6362\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u6784\u5efa\u72b6\u6001\u8f6c\u6362\u56fe\uff0c\u53c2\u89c1\"4 Protocol operation\"; 4) TCP\u7684\u6838\u5fc3\u7279\u6027\u4ee5\u53ca\u5bf9\u5e94\u7684\u5b9e\u73b0\u65b9\u5f0f \u5165\u95e8\u9605\u8bfb\u63a8\u8350: miami TCP in a nutshell \u975e\u5e38\u7684\u7b80\u7ec3\u3002 Terminology endpoint: \u4e00\u4e2aTCP\u6709\u4e24\u4e2aendpoint session: \u4e00\u4e2aTCP session wikipedia Transmission Control Protocol The Transmission Control Protocol ( TCP ) is one of the main protocols of the Internet protocol suite . It originated in the initial network implementation in which it complemented the Internet Protocol (IP). Therefore, the entire suite is commonly referred to as TCP/IP . TCP provides reliable , ordered, and error-checked delivery of a stream of octets (bytes) between applications running on hosts communicating via an IP network. TCP is connection-oriented , and a connection between client and server is established before data can be sent. The server must be listening (passive(\u88ab\u52a8) open) for connection requests from clients before a connection is established. Three-way handshake (active(\u4e3b\u52a8) open), retransmission , and error-detection adds to reliability but lengthens latency . NOTE: \u4e0a\u9762\u63cf\u8ff0\u4e86TCP\u7684\u7279\u6027 Major internet applications such as the World Wide Web , email , remote administration , and file transfer rely on TCP. Network function NOTE: \u672c\u8282\u8ba8\u8bba\u7684\u662fTCP\u7684\u529f\u80fd The Transmission Control Protocol provides a communication service at an intermediate level between an application program and the Internet Protocol (\u5373Internet Layer). It provides host-to-host connectivity at the transport layer of the Internet model . NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u9700\u8981\u7ed3\u5408 Network\\Theory\\Network-protocol-model.md \u4e2d\u7684\"Internet protocol suite by layer\"\u7ae0\u8282\u7684\u5185\u5bb9\u6765\u8fdb\u884c\u7406\u89e3 Abstraction NOTE: \u672c\u8282\u6807\u9898\u7684Abstraction\u6709\u5982\u4e0b\u4e24\u4e2a\u542b\u4e49: 1) \u5e95\u5c42\u5bf9\u4f20\u8f93\u7ec6\u8282\u8fdb\u884c\u4e86\u5c01\u88c5\uff0c\u63d0\u4f9b\u7ed9\u4e0a\u5c42abstraction 2) TCP network connection is an abstraction An application does not need to know the particular mechanisms for sending data via a link to another host, such as the required IP fragmentation (\u5206\u7247) to accommodate the maximum transmission unit of the transmission medium. At the transport layer, TCP handles all handshaking and transmission details and presents an abstraction of the network connection to the application typically through a network socket interface. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u6700\u540e\u4e00\u53e5\u63cf\u8ff0\u4e86TCP connecting\u7684\u672c\u8d28\uff0c\u53ef\u4ee5\u8ba4\u4e3aTCP network connection is an abstraction\uff0c\u5173\u4e8eTCP network connecting\u7684\u672c\u8d28\uff0c\u5728 ./TCP-connection \u7ae0\u8282\u4f1a\u8fdb\u884c\u8bf4\u660e\u3002 At the lower levels of the protocol stack, due to network congestion , traffic load balancing , or unpredictable network behaviour, IP packets may be lost , duplicated, or delivered out of order . TCP detects these problems, requests re-transmission of lost data, rearranges out-of-order data and even helps minimize network congestion to reduce the occurrence of the other problems. If the data still remains undelivered, the source is notified of this failure. Once the TCP receiver has reassembled the sequence of octets originally transmitted, it passes them to the receiving application. Thus, TCP abstracts the application's communication from the underlying networking details. Positive acknowledgement with re-transmission NOTE: TCP\u91c7\u7528\u7684\"The sender re-transmits a packet if the timer expires before receiving the acknowledgement\"\u3002 TCP is a reliable stream delivery service which guarantees that all bytes received will be identical and in the same order as those sent. Since packet transfer by many networks is not reliable, TCP achieves this using a technique known as positive acknowledgement with re-transmission . This requires the receiver to respond with an acknowledgement message as it receives the data. The sender keeps a record of each packet it sends and maintains a timer from when the packet was sent. The sender re-transmits a packet if the timer expires before receiving the acknowledgement. The timer is needed in case a packet gets lost or corrupted.[ 6] TCP segment structure Transmission Control Protocol accepts data from a data stream, divides it into chunks, and adds a TCP header creating a TCP segment . The TCP segment is then encapsulated into an Internet Protocol (IP) datagram , and exchanged with peers.[ 4] NOTE: \u5173\u4e8eTCP segment\u3001IP datagram\uff0c\u53c2\u89c1 Network\\Theory\\Network-protocol-model.md \u7684\u201cUnit of layer\u201d\u7ae0\u8282\u3002 A TCP segment consists of a segment header and a data section. The TCP header contains 10 mandatory fields, and an optional extension field ( Options , pink background in table). The data section follows the header. Its contents are the payload data carried for the application. The length of the data section is not specified in the TCP segment header . It can be calculated by subtracting the combined length of the TCP header and the encapsulating IP header from the total IP datagram length (specified in the IP header). NOTE: \u5728IP header\u4e2d\u6307\u5b9a\u4e86Total IP datagram length\uff0c\u6240\u4ee5: Length of the TCP segment data section = Total IP datagram length - Length of the TCP header - Length of the IP header NOTE: \u4e0b\u9762\u9010\u884c\u4ecb\u7ecd\u5404\u5b57\u6bb5 Row1 field explanation Source port (16 bits) Identifies the sending port . Destination port (16 bits) Identifies the receiving port . NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f\u5728TCP\u534f\u8bae\u7684header\u4e2d\u4ec5\u6709port\u800c\u65e0IP\uff1bIP\u662f\u5728IP\u534f\u8bae\u4e2d\u9700\u8981\u7684\uff1b Row2 Sequence number (32 bits) Has a dual role: 1) If the SYN flag is set (1), then this is the initial sequence number . The sequence number of the actual first data byte and the acknowledged number in the corresponding ACK are then this sequence number plus 1. 2) If the SYN flag is clear (0), then this is the accumulated sequence number of the first data byte of this segment for the current session. NOTE: SYN flag is clear (0)\u8868\u793a\u662f\u5728*data transfer phase* \uff1f Row3 Acknowledgment number (32 bits) If the ACK flag is set then the value of this field is the next sequence number that the sender of the ACK is expecting. This acknowledges receipt\uff08\u6536\u5230\uff09 of all prior bytes (if any). The first ACK sent by each end acknowledges the other end's initial sequence number itself, but no data. NOTE: Sequence number \u548c Acknowledgment number\u662fTCP\u5b9e\u73b0\u5728\u201d4.4 Data transfer\u201c\u4e2d\u4ecb\u7ecd\u7684\u201cReliable transmission\u201d \u7279\u6027\u7684\u5173\u952e\u3002 \u5173\u4e8esequence number\u548cacknowledgment number\uff0c\u5728 Network\\Theory\\TCP\\TCP-SEQ-number-and-ACK-number.md \u4e2d\u4f1a\u8fdb\u884c\u4e13\u95e8\u4ecb\u7ecd\u3002 Row4 Data offset (4 bits) Specifies the size of the TCP header in 32-bit words (4 byte). The minimum size header is 5 words and the maximum is 15 words thus giving the minimum size of 20 bytes and maximum of 60 bytes, allowing for up to 40 bytes of options in the header. This field gets its name from the fact that it is also the offset from the start of the TCP segment to the actual data. Reserved (3 bits) For future use and should be set to zero. Flags (9 bits) (aka Control bits) Contains 9 1-bit flags NS ECN-nonce - concealment\uff08\u9690\u85cf\uff09 protection (experimental: see RFC 3540 ). CWR Congestion Window Reduced (CWR) flag is set by the sending host to indicate that it received a TCP segment with the ECE flag set and had responded in congestion control mechanism (added to header by RFC 3168 ). ECE ECN-Echo has a dual role, depending on the value of the SYN flag. It indicates: If the SYN flag is set (1), that the TCP peer is ECN capable. If the SYN flag is clear (0), that a packet with Congestion Experienced flag set (ECN=11) in the IP header was received during normal transmission (added to header by RFC 3168 ). This serves as an indication of network congestion (or impending congestion) to the TCP sender. URG indicates that the Urgent pointer field is significant ACK indicates that the Acknowledgment field is significant. All packets after the initial SYN packet sent by the client should have this flag set. PSH Push function. Asks to push the buffered data to the receiving application. RST Reset the connection SYN Synchronize sequence numbers . Only the first packet sent from each end should have this flag set. Some other flags and fields change meaning based on this flag, and some are only valid when it is set, and others when it is clear. NOTE: \u6807\u8bc6\u5f00\u59cb\u4f20\u8f93 FIN Last packet from sender. NOTE: \u6807\u8bc6\u5b8c\u6210\u4e86\u4f20\u8f93 NOTE: \u5728packetlife Understanding TCP Sequence and Acknowledgment Numbers \u4e2d\u5bf9\u91cd\u8981\u5b57\u6bb5\u7684\u89e3\u91ca\u5982\u4e0b: SYN - (Synchronize) Initiates a connection FIN - (Final) Cleanly terminates a connection ACK - Acknowledges received data Window size (16 bits) The size of the receive window , which specifies the number of window size units (by default, bytes) (beyond the segment identified by the sequence number in the acknowledgment field) that the sender of this segment is currently willing to receive ( see Flow control and Window Scaling ). Row5 Checksum (16 bits) The 16-bit checksum field is used for error-checking of the header, the Payload and a Pseudo-Header. The Pseudo-Header consists of the Source IP Address , the Destination IP Address , the protocol number for the TCP-Protocol (0x0006) and the length of the TCP-Headers including Payload (in Bytes). Urgent pointer (16 bits) if the URG flag is set, then this 16-bit field is an offset from the sequence number indicating the last urgent data byte. Row6~Row20 Options (Variable 0\u2013320 bits, divisible by 32) Padding The TCP header padding is used to ensure that the TCP header ends, and data begins, on a 32 bit boundary. The padding is composed of zeros.[ 12] 4 Protocol operation TCP protocol operations may be divided into three phases. phase explanation connection establishment Connections must be properly established in a multi-step handshake process ( connection establishment ) before entering the data transfer phase. data transfer connection termination After data transmission is completed, the connection termination closes(\u5173\u95ed) established virtual circuits and releases all allocated resources. NOTE: \u672c\u8282\u57fa\u4e8e\u6b64\u6765\u5bf9TCP protocol\u8fdb\u884c\u63cf\u8ff0\u3001\u7ec4\u7ec7\u5185\u5bb9\u3002 A TCP connection is managed by an operating system through a programming interface that represents the local end-point for communications, the Internet socket . During the lifetime of a TCP connection the local end-point undergoes a series of state changes:[ 13] LISTEN (server) represents waiting for a connection request from any remote TCP and port. SYN-SENT (client) represents waiting for a matching connection request after having sent a connection request . SYN-RECEIVED (server) represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request . ESTABLISHED (both server and client) represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection. FIN-WAIT-1 (both server and client) represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent. FIN-WAIT-2 (both server and client) represents waiting for a connection termination request from the remote TCP. CLOSE-WAIT (both server and client) represents waiting for a connection termination request from the local user . CLOSING (both server and client) represents waiting for a connection termination request acknowledgment from the remote TCP . LAST-ACK (both server and client) represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request). TIME-WAIT (either server or client) represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request . [According to RFC 793 a connection can stay in TIME-WAIT for a maximum of four minutes known as two MSL (maximum segment lifetime).] NOTE: \u7b2c\u4e00\u53e5\u8bdd\u7684\u542b\u4e49\u662f\uff1a \u672c\u7aef**\u7b49\u5f85\u8db3\u591f\u7684\u65f6\u95f4\u4ee5\u786e\u4fddremote TCP(\u5373\u901a\u4fe1\u7684**\u5bf9\u7aef )\u63a5\u6536\u5230\u4e86\u7531**\u672c\u7aef**\u53d1\u9001\u7ed9\u5bf9\u7aef\u7684acknowledgment\uff08\u8fd9\u4e2aacknowledgment\u662f\u5bf9\u5bf9\u7aef\u53d1\u9001\u8fc7\u6765\u7684connection termination request\u7684 ACK ) \u5728\u6587\u7ae0 Network\\Theory\\TCP\\TCP-connection-termination.md \u7684 \u201c2MSL wait\u201d \u6bb5\u4e2d\u5bf9 MSL \u3001TIME-WAIT\u8fdb\u884c\u4e86\u8bf4\u660e\u3002 CLOSED (both server and client) represents no connection state at all. 4.1 Connection establishment NOTE: \u53c2\u89c1 ./TCP-connection/Connection-establishment.md \u3002 4.2 Connection termination NOTE: \u53c2\u89c1 ./TCP-connection/Connection-termination.md \u3002 4.3 Resource usage NOTE: port\u662f\u4e00\u79cdresource 4.4 Data transfer NOTE: \u53c2\u89c1 ./TCP-data-transfer \u3002 4.5 Maximum segment size 4.9 Out-of-band data 4.10 Forcing data delivery","title":"Transmission-Control-Protocol"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#transmission#control#protocol","text":"\u672c\u6587\u8ba8\u8bbaTCP\u534f\u8bae\uff0c\u4ee5wikipedia Transmission Control Protocol \u4e3a\u4e3b\uff0c\u53e6\u5916\u8865\u5145\u4e86\u4e00\u4e9b\u5185\u5bb9\u3002","title":"Transmission Control Protocol"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#guide","text":"\u5728\u9605\u8bfb\u524d\uff0c\u9700\u8981\u5efa\u7acb\u8d77\u5982\u4e0b\u6982\u5ff5/\u89c2\u5ff5\uff0c\u4fbf\u4e8e\u7406\u89e3: 1) TCP\u91c7\u7528\u7684\u662f: \u8bf7\u6c42-\u54cd\u5e94 \u6a21\u578b \u539f\u6587\u4e2d\u5e76\u6ca1\u6709\u8bf4\u660e\u6b64\uff0c\u8fd9\u662f\u6211\u81ea\u5df1\u6dfb\u52a0\u7684 \u6bcf\u4e2arequest\uff0c\u90fd\u4f1a\u6536\u5230\u4e00\u4e2aresponse\uff0c\u8fd9\u4e2aresponse\u662f\u7528\u4e8eacknowledge\u7684\uff0c\u5373\u63a5\u6536\u65b9\u544a\u8bc9\u53d1\u9001\u65b9: \u6536\u5230\u4e86request\uff0c\u6211\u4eec\u5f80\u5f80\u5c06\u5176\u79f0\u4e4b\u4e3aACK response\uff0c\u8fd9\u6837\u624d\u7b97\u662f\u5b8c\u6210\u4e86\u8fd9\u4e2a\u8bf7\u6c42\uff1b \u5bf9\u4e8eACK\uff0c\u662f\u4e0d\u9700\u8981\u518dACK\u7684\uff0c\u5426\u5219\u5c31\u4f1a\u5bfc\u81f4\u65e0\u9650\u7684\u9012\u5f52\u4e0b\u53bb\uff1b 2) TCP\u662f\u5168\u53cc\u5de5\u901a\u4fe1\u6a21\u5f0f: \u53c2\u89c1 \"4.1 Connection establishment\"\u8282 \u201c\u5168\u53cc\u5de5\u201d\u610f\u5473\u7740\u4e00\u4e2aTCP session\u6709\u4e24\u4e2a\u90e8\u5206\u7ec4\u6210\uff0c\u610f\u5473\u7740\u5b58\u5728\u7740half\u7684\u95ee\u9898\uff08half close\u3001half open\uff09\u3002 3) \u6784\u5efaTCP\u7684**\u6d3b\u52a8\u56fe**(\u6d3b\u52a8\u56fe\u662f\u501f\u7528\u7684\u8f6f\u4ef6\u5de5\u7a0b\u4e2d\u7684\u6982\u5ff5): \u53ef\u4ee5\u91c7\u7528\u5982\u4e0b\u6536\u5f55\u6765\u8fdb\u884c\u6784\u5efa: TCP\u7684\u4e09\u4e2a\u9636\u6bb5: \u8fd9\u662f\u5bf9TCP\u7684lifetime\u7684\u5212\u5206\uff0c\u53c2\u89c1 \"4 Protocol operation\"; TCP\u7684\u64cd\u4f5c: \u6bcf\u4e2a\u9636\u6bb5\u7684\u4f1a\u6267\u884c\u76f8\u5e94\u7684\u64cd\u4f5c\uff0c\u53c2\u89c1 \"4 Protocol operation\"; TCP\u7684\u72b6\u6001: TCP\u662f\u6709\u4e00\u5b9a\u72b6\u6001\u7684\uff0cTCP\u64cd\u4f5c\u4f1a\u89e6\u53d1\u72b6\u6001\u7684\u8f6c\u6362\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u6784\u5efa\u72b6\u6001\u8f6c\u6362\u56fe\uff0c\u53c2\u89c1\"4 Protocol operation\"; 4) TCP\u7684\u6838\u5fc3\u7279\u6027\u4ee5\u53ca\u5bf9\u5e94\u7684\u5b9e\u73b0\u65b9\u5f0f","title":"Guide"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#miami#tcp#in#a#nutshell","text":"\u975e\u5e38\u7684\u7b80\u7ec3\u3002","title":"\u5165\u95e8\u9605\u8bfb\u63a8\u8350: miami TCP in a nutshell"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#terminology","text":"endpoint: \u4e00\u4e2aTCP\u6709\u4e24\u4e2aendpoint session: \u4e00\u4e2aTCP session","title":"Terminology"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#wikipedia#transmission#control#protocol","text":"The Transmission Control Protocol ( TCP ) is one of the main protocols of the Internet protocol suite . It originated in the initial network implementation in which it complemented the Internet Protocol (IP). Therefore, the entire suite is commonly referred to as TCP/IP . TCP provides reliable , ordered, and error-checked delivery of a stream of octets (bytes) between applications running on hosts communicating via an IP network. TCP is connection-oriented , and a connection between client and server is established before data can be sent. The server must be listening (passive(\u88ab\u52a8) open) for connection requests from clients before a connection is established. Three-way handshake (active(\u4e3b\u52a8) open), retransmission , and error-detection adds to reliability but lengthens latency . NOTE: \u4e0a\u9762\u63cf\u8ff0\u4e86TCP\u7684\u7279\u6027 Major internet applications such as the World Wide Web , email , remote administration , and file transfer rely on TCP.","title":"wikipedia Transmission Control Protocol"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#network#function","text":"NOTE: \u672c\u8282\u8ba8\u8bba\u7684\u662fTCP\u7684\u529f\u80fd The Transmission Control Protocol provides a communication service at an intermediate level between an application program and the Internet Protocol (\u5373Internet Layer). It provides host-to-host connectivity at the transport layer of the Internet model . NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u9700\u8981\u7ed3\u5408 Network\\Theory\\Network-protocol-model.md \u4e2d\u7684\"Internet protocol suite by layer\"\u7ae0\u8282\u7684\u5185\u5bb9\u6765\u8fdb\u884c\u7406\u89e3","title":"Network function"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#abstraction","text":"NOTE: \u672c\u8282\u6807\u9898\u7684Abstraction\u6709\u5982\u4e0b\u4e24\u4e2a\u542b\u4e49: 1) \u5e95\u5c42\u5bf9\u4f20\u8f93\u7ec6\u8282\u8fdb\u884c\u4e86\u5c01\u88c5\uff0c\u63d0\u4f9b\u7ed9\u4e0a\u5c42abstraction 2) TCP network connection is an abstraction An application does not need to know the particular mechanisms for sending data via a link to another host, such as the required IP fragmentation (\u5206\u7247) to accommodate the maximum transmission unit of the transmission medium. At the transport layer, TCP handles all handshaking and transmission details and presents an abstraction of the network connection to the application typically through a network socket interface. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u6700\u540e\u4e00\u53e5\u63cf\u8ff0\u4e86TCP connecting\u7684\u672c\u8d28\uff0c\u53ef\u4ee5\u8ba4\u4e3aTCP network connection is an abstraction\uff0c\u5173\u4e8eTCP network connecting\u7684\u672c\u8d28\uff0c\u5728 ./TCP-connection \u7ae0\u8282\u4f1a\u8fdb\u884c\u8bf4\u660e\u3002 At the lower levels of the protocol stack, due to network congestion , traffic load balancing , or unpredictable network behaviour, IP packets may be lost , duplicated, or delivered out of order . TCP detects these problems, requests re-transmission of lost data, rearranges out-of-order data and even helps minimize network congestion to reduce the occurrence of the other problems. If the data still remains undelivered, the source is notified of this failure. Once the TCP receiver has reassembled the sequence of octets originally transmitted, it passes them to the receiving application. Thus, TCP abstracts the application's communication from the underlying networking details.","title":"Abstraction"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#positive#acknowledgement#with#re-transmission","text":"NOTE: TCP\u91c7\u7528\u7684\"The sender re-transmits a packet if the timer expires before receiving the acknowledgement\"\u3002 TCP is a reliable stream delivery service which guarantees that all bytes received will be identical and in the same order as those sent. Since packet transfer by many networks is not reliable, TCP achieves this using a technique known as positive acknowledgement with re-transmission . This requires the receiver to respond with an acknowledgement message as it receives the data. The sender keeps a record of each packet it sends and maintains a timer from when the packet was sent. The sender re-transmits a packet if the timer expires before receiving the acknowledgement. The timer is needed in case a packet gets lost or corrupted.[ 6]","title":"Positive acknowledgement with re-transmission"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#tcp#segment#structure","text":"Transmission Control Protocol accepts data from a data stream, divides it into chunks, and adds a TCP header creating a TCP segment . The TCP segment is then encapsulated into an Internet Protocol (IP) datagram , and exchanged with peers.[ 4] NOTE: \u5173\u4e8eTCP segment\u3001IP datagram\uff0c\u53c2\u89c1 Network\\Theory\\Network-protocol-model.md \u7684\u201cUnit of layer\u201d\u7ae0\u8282\u3002 A TCP segment consists of a segment header and a data section. The TCP header contains 10 mandatory fields, and an optional extension field ( Options , pink background in table). The data section follows the header. Its contents are the payload data carried for the application. The length of the data section is not specified in the TCP segment header . It can be calculated by subtracting the combined length of the TCP header and the encapsulating IP header from the total IP datagram length (specified in the IP header). NOTE: \u5728IP header\u4e2d\u6307\u5b9a\u4e86Total IP datagram length\uff0c\u6240\u4ee5: Length of the TCP segment data section = Total IP datagram length - Length of the TCP header - Length of the IP header NOTE: \u4e0b\u9762\u9010\u884c\u4ecb\u7ecd\u5404\u5b57\u6bb5","title":"TCP segment structure"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#row1","text":"field explanation Source port (16 bits) Identifies the sending port . Destination port (16 bits) Identifies the receiving port . NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f\u5728TCP\u534f\u8bae\u7684header\u4e2d\u4ec5\u6709port\u800c\u65e0IP\uff1bIP\u662f\u5728IP\u534f\u8bae\u4e2d\u9700\u8981\u7684\uff1b","title":"Row1"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#row2","text":"Sequence number (32 bits) Has a dual role: 1) If the SYN flag is set (1), then this is the initial sequence number . The sequence number of the actual first data byte and the acknowledged number in the corresponding ACK are then this sequence number plus 1. 2) If the SYN flag is clear (0), then this is the accumulated sequence number of the first data byte of this segment for the current session. NOTE: SYN flag is clear (0)\u8868\u793a\u662f\u5728*data transfer phase* \uff1f","title":"Row2"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#row3","text":"Acknowledgment number (32 bits) If the ACK flag is set then the value of this field is the next sequence number that the sender of the ACK is expecting. This acknowledges receipt\uff08\u6536\u5230\uff09 of all prior bytes (if any). The first ACK sent by each end acknowledges the other end's initial sequence number itself, but no data. NOTE: Sequence number \u548c Acknowledgment number\u662fTCP\u5b9e\u73b0\u5728\u201d4.4 Data transfer\u201c\u4e2d\u4ecb\u7ecd\u7684\u201cReliable transmission\u201d \u7279\u6027\u7684\u5173\u952e\u3002 \u5173\u4e8esequence number\u548cacknowledgment number\uff0c\u5728 Network\\Theory\\TCP\\TCP-SEQ-number-and-ACK-number.md \u4e2d\u4f1a\u8fdb\u884c\u4e13\u95e8\u4ecb\u7ecd\u3002","title":"Row3"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#row4","text":"Data offset (4 bits) Specifies the size of the TCP header in 32-bit words (4 byte). The minimum size header is 5 words and the maximum is 15 words thus giving the minimum size of 20 bytes and maximum of 60 bytes, allowing for up to 40 bytes of options in the header. This field gets its name from the fact that it is also the offset from the start of the TCP segment to the actual data. Reserved (3 bits) For future use and should be set to zero. Flags (9 bits) (aka Control bits) Contains 9 1-bit flags NS ECN-nonce - concealment\uff08\u9690\u85cf\uff09 protection (experimental: see RFC 3540 ). CWR Congestion Window Reduced (CWR) flag is set by the sending host to indicate that it received a TCP segment with the ECE flag set and had responded in congestion control mechanism (added to header by RFC 3168 ). ECE ECN-Echo has a dual role, depending on the value of the SYN flag. It indicates: If the SYN flag is set (1), that the TCP peer is ECN capable. If the SYN flag is clear (0), that a packet with Congestion Experienced flag set (ECN=11) in the IP header was received during normal transmission (added to header by RFC 3168 ). This serves as an indication of network congestion (or impending congestion) to the TCP sender. URG indicates that the Urgent pointer field is significant ACK indicates that the Acknowledgment field is significant. All packets after the initial SYN packet sent by the client should have this flag set. PSH Push function. Asks to push the buffered data to the receiving application. RST Reset the connection SYN Synchronize sequence numbers . Only the first packet sent from each end should have this flag set. Some other flags and fields change meaning based on this flag, and some are only valid when it is set, and others when it is clear. NOTE: \u6807\u8bc6\u5f00\u59cb\u4f20\u8f93 FIN Last packet from sender. NOTE: \u6807\u8bc6\u5b8c\u6210\u4e86\u4f20\u8f93 NOTE: \u5728packetlife Understanding TCP Sequence and Acknowledgment Numbers \u4e2d\u5bf9\u91cd\u8981\u5b57\u6bb5\u7684\u89e3\u91ca\u5982\u4e0b: SYN - (Synchronize) Initiates a connection FIN - (Final) Cleanly terminates a connection ACK - Acknowledges received data Window size (16 bits) The size of the receive window , which specifies the number of window size units (by default, bytes) (beyond the segment identified by the sequence number in the acknowledgment field) that the sender of this segment is currently willing to receive ( see Flow control and Window Scaling ).","title":"Row4"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#row5","text":"Checksum (16 bits) The 16-bit checksum field is used for error-checking of the header, the Payload and a Pseudo-Header. The Pseudo-Header consists of the Source IP Address , the Destination IP Address , the protocol number for the TCP-Protocol (0x0006) and the length of the TCP-Headers including Payload (in Bytes). Urgent pointer (16 bits) if the URG flag is set, then this 16-bit field is an offset from the sequence number indicating the last urgent data byte.","title":"Row5"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#row6row20","text":"Options (Variable 0\u2013320 bits, divisible by 32) Padding The TCP header padding is used to ensure that the TCP header ends, and data begins, on a 32 bit boundary. The padding is composed of zeros.[ 12]","title":"Row6~Row20"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#4#protocol#operation","text":"TCP protocol operations may be divided into three phases. phase explanation connection establishment Connections must be properly established in a multi-step handshake process ( connection establishment ) before entering the data transfer phase. data transfer connection termination After data transmission is completed, the connection termination closes(\u5173\u95ed) established virtual circuits and releases all allocated resources. NOTE: \u672c\u8282\u57fa\u4e8e\u6b64\u6765\u5bf9TCP protocol\u8fdb\u884c\u63cf\u8ff0\u3001\u7ec4\u7ec7\u5185\u5bb9\u3002 A TCP connection is managed by an operating system through a programming interface that represents the local end-point for communications, the Internet socket . During the lifetime of a TCP connection the local end-point undergoes a series of state changes:[ 13]","title":"4 Protocol operation"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#listen","text":"(server) represents waiting for a connection request from any remote TCP and port.","title":"LISTEN"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#syn-sent","text":"(client) represents waiting for a matching connection request after having sent a connection request .","title":"SYN-SENT"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#syn-received","text":"(server) represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request .","title":"SYN-RECEIVED"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#established","text":"(both server and client) represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection.","title":"ESTABLISHED"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#fin-wait-1","text":"(both server and client) represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.","title":"FIN-WAIT-1"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#fin-wait-2","text":"(both server and client) represents waiting for a connection termination request from the remote TCP.","title":"FIN-WAIT-2"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#close-wait","text":"(both server and client) represents waiting for a connection termination request from the local user .","title":"CLOSE-WAIT"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#closing","text":"(both server and client) represents waiting for a connection termination request acknowledgment from the remote TCP .","title":"CLOSING"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#last-ack","text":"(both server and client) represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).","title":"LAST-ACK"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#time-wait","text":"(either server or client) represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request . [According to RFC 793 a connection can stay in TIME-WAIT for a maximum of four minutes known as two MSL (maximum segment lifetime).] NOTE: \u7b2c\u4e00\u53e5\u8bdd\u7684\u542b\u4e49\u662f\uff1a \u672c\u7aef**\u7b49\u5f85\u8db3\u591f\u7684\u65f6\u95f4\u4ee5\u786e\u4fddremote TCP(\u5373\u901a\u4fe1\u7684**\u5bf9\u7aef )\u63a5\u6536\u5230\u4e86\u7531**\u672c\u7aef**\u53d1\u9001\u7ed9\u5bf9\u7aef\u7684acknowledgment\uff08\u8fd9\u4e2aacknowledgment\u662f\u5bf9\u5bf9\u7aef\u53d1\u9001\u8fc7\u6765\u7684connection termination request\u7684 ACK ) \u5728\u6587\u7ae0 Network\\Theory\\TCP\\TCP-connection-termination.md \u7684 \u201c2MSL wait\u201d \u6bb5\u4e2d\u5bf9 MSL \u3001TIME-WAIT\u8fdb\u884c\u4e86\u8bf4\u660e\u3002","title":"TIME-WAIT"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#closed","text":"(both server and client) represents no connection state at all.","title":"CLOSED"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#41#connection#establishment","text":"NOTE: \u53c2\u89c1 ./TCP-connection/Connection-establishment.md \u3002","title":"4.1 Connection establishment"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#42#connection#termination","text":"NOTE: \u53c2\u89c1 ./TCP-connection/Connection-termination.md \u3002","title":"4.2 Connection termination"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#43#resource#usage","text":"NOTE: port\u662f\u4e00\u79cdresource","title":"4.3 Resource usage"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#44#data#transfer","text":"NOTE: \u53c2\u89c1 ./TCP-data-transfer \u3002","title":"4.4 Data transfer"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#45#maximum#segment#size","text":"","title":"4.5 Maximum segment size"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#49#out-of-band#data","text":"","title":"4.9 Out-of-band data"},{"location":"Network/Protocol/TCP/Transmission-Control-Protocol/#410#forcing#data#delivery","text":"","title":"4.10 Forcing data delivery"},{"location":"Network/Protocol/TCP/man-7-TCP/","text":"","title":"man-7-TCP"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/","text":"TCP SEQ number and ACK number \u672c\u6587\u5bf9TCP\u7684SEQ number\u3001ACK number\u8fdb\u884c\u8bf4\u660e\u3002 What is SEQ number and ACK number? Purpose \u5728 Network\\Theory\\TCP\\Transmission-Control-Protocol.md \u7684\u201cRow3\u201d\u8282\uff0c\u6709\u8fd9\u6837\u7684\u8bf4\u660e: Sequence number \u548c Acknowledgment number\u662fTCP\u5b9e\u73b0\u5728\u201d4.4 Data transfer\u201c\u4e2d\u4ecb\u7ecd\u7684\u201cReliable transmission\u201d \u7279\u6027\u7684\u5173\u952e\u3002 \u5728 Network\\Theory\\TCP\\Transmission-Control-Protocol.md \u7684Guide\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053TCP\u534f\u8bae\u8981\u6c42\u6240\u6709\u7684\u901a\u4fe1\u90fd\u662frequest-response\u7684\uff0c\u5373 \u6bcf\u4e2arequest\uff0c\u90fd\u4f1a\u6536\u5230\u4e00\u4e2aresponse\uff0c\u8fd9\u4e2aresponse\u662f\u7528\u4e8eacknowledge\u7684\uff0c\u5373\u5bf9\u65b9\u544a\u8bc9\u53d1\u9001\u65b9: \u6536\u5230\u4e86request\uff0c\u6211\u4eec\u5f80\u5f80\u5c06\u5176\u79f0\u4e4b\u4e3aACK response\uff0c\u8fd9\u6837\u624d\u7b97\u662f\u5b8c\u6210\u4e86\u8fd9\u4e2a\u8bf7\u6c42\uff1b \u4e00\u4e2a\u5b8c\u6574\u7684\u8bf7\u6c42\u624d\u4f1a\u5bfc\u81f4SEQ number\u7684\u589e\u957f\uff0c\u4e5f\u5c31\u662f\u8bf4**\u53d1\u9001\u65b9**\u662f\u5728\u6536\u5230ACK response\u7684\u65f6\u5019\uff0c\u624d\u4f1a\u66f4\u65b0\u5b83\u7684SEQ number\uff0c\u6216\u8005\u8bf4SEQ number\u7684\u8ba1\u7b97\u662f\u57fa\u4e8e\u5b8c\u6574\u7684\u8bf7\u6c42\u7684\uff0c\u800c\u4e0d\u662f\u57fa\u4e8e\u5b83\u6240\u53d1\u9001\u7684TCP segment( \u5176\u4e2d\u4e5f\u5305\u62ec\u4e86ACK response)\uff0c\u8fd9\u5c31\u662f\u8bf4ACK TCP segment\u662f\u4e0d\u4f1a\u5bfc\u81f4SEQ number\u7684\u53d8\u52a8\u7684\uff0c\u4e0b\u9762\u662f\u7b80\u5355\u7684\u89c4\u5219: \u5bf9\u4e8eSYN\u3001FIN \u8bf7\u6c42\uff0cSEQ number\u589e\u957f1\uff08\u8fd9\u662f\u6bd4\u8f83\u7279\u6b8a\u7684\uff0c\u540e\u9762\u4f1a\u89e3\u91ca\u8fd9\u6837\u505a\u7684\u539f\u56e0\uff09 \u5bf9\u4e8e\u5176\u4ed6\u8bf7\u6c42\uff0cSEQ number\u589e\u957fplayload\u957f\u5ea6 \u90a3\u8be5\u534f\u8bae\u662f\u5982\u4f55\u5b9e\u73b0response A\u662frequest A\u7684response\u800c\u4e0d\u662frequest B\u7684response\u5462\uff1f\u662f\u4f7f\u7528sequence number\u548creceived sequence number\u5417\uff1f\u5bf9\u4e00\u4e2aendpoint\u800c\u8a00\uff0c\u5b83\u7684sequence number\u662f\u5355\u8c03\u9012\u589e\u7684\u5417\uff1f \u7b80\u4ecb miami TCP in a nutshell \u7684**Sequence Numbers**\u6bb5\u6709\u7740\u975e\u5e38\u597d\u7684\u4ecb\u7ecd: All bytes in a TCP connection are numbered, beginning at a randomly chosen initial sequence number ( ISN ). The SYN packets consume one sequence number , so actual data will begin at ISN+1 . The sequence number is the byte number of the first byte of data in the TCP packet sent (also called a TCP segment). The acknowledgement number is the sequence number of the next byte the receiver expects to receive. The receiver ack'ing sequence number x acknowledges receipt of all data bytes less than (but not including) byte number x . The sequence number is always valid. The acknowledgement number is only valid when the ACK flag is one. The only time the ACK flag is not set, that is, the only time there is not a valid acknowledgement number in the TCP header, is during the first packet of connection set-up. Example: packetlife Understanding TCP Sequence and Acknowledgment Numbers NOTE: \u8fd9\u7bc7\u6587\u7ae0\uff0c\u7ed3\u5408 Wireshark \u3001\u5177\u4f53\u6848\u4f8b\u6765\u8bb2\u89e3\uff0c\u975e\u5e38\u503c\u5f97\u9605\u8bfb This article aims to help you become more comfortable examining TCP sequence and acknowledgement numbers in the Wireshark packet analyzer. Before we start, be sure to open the example capture in Wireshark and play along. The example capture contains a single HTTP request to a web server, in which the client web browser requests a single image file, and the server returns an HTTP/1.1 200 (OK) response which includes the file requested. You can right-click on any of the TCP packets within this capture and select Follow TCP Stream to open the raw contents of the TCP stream in a separate window for inspection. Traffic from the client is shown in red, and traffic from the server in blue. NOTE: \u4ece\u4e0a\u8ff0\u56fe\u53ef\u4ee5\u770b\u51fa\uff0c\u5b83\u4ec5\u4ec5\u5c55\u793a\u4e86HTTP\u7684\u8bf7\u6c42\u3001\u54cd\u5e94\uff0c\u5e76\u6ca1\u6709\u5c55\u793aTCP\u7684\u7ec6\u8282\u3002 The Three-Way Handshake TCP utilizes a number of flags, or 1-bit boolean fields, in its header to control the state of a connection. The three we're most interested in here are: SYN - (Synchronize) Initiates a connection FIN - (Final) Cleanly terminates a connection ACK - Acknowledges received data As we'll see, a packet can have multiple flags set. NOTE: \u5178\u578b\u7684\u4f8b\u5b50\u5c31\u662f SYN-ACK Select packet #1 in Wireshark and expand the TCP layer analysis in the middle pane, and further expand the \"Flags\" field within the TCP header. Here we can see all of the TCP flags broken down. Note that the SYN flag is on (set to 1). Now do the same for packet #2 . Notice that it has two flags set: ACK to acknowledge the receipt of the client's SYN packet, and SYN to indicate that the server also wishes to establish a TCP connection. Packet #3 , from the client, has only the ACK flag set. These three packets complete the initial TCP three-way handshake. Sequence and Acknowledgment Numbers The client on either side of a TCP session maintains a 32-bit sequence number it uses to keep track of how much data it has sent. This sequence number is included on each transmitted packet, and acknowledged by the opposite host as an acknowledgement number to inform the sending host that the transmitted data was received successfully. NOTE: \u8fd9\u5c31\u662f\u5728\u201cWhat is SEQ number and ACK number?#Purpose\u201d\u4e2d\u6240\u4ecb\u7ecd\u7684request-response\u3002 When a host initiates a TCP session, its initial sequence number is effectively random; it may be any value between 0 and 4,294,967,295, inclusive. However, protocol analyzers like Wireshark will typically display relative sequence and acknowledgement numbers in place of the actual values. These numbers are relative to the initial sequence number of that stream. This is handy, as it is much easier to keep track of relatively small, predictable numbers rather than the actual numbers sent on the wire. For example, the initial relative sequence number shown in packet #1 is 0 (naturally), while the ASCII decode in the third pane shows that the actual sequence number is 0xf61c6cbe , or 4129057982 decimal. The display of relative sequence numbers can optionally be disabled by navigating to Edit > Preferences... and un-checking Relative sequence numbers and window scaling under TCP protocol preferences. However, be aware that the remainder of this article will reference relative sequence and acknowledgement numbers only. To better understand how sequence and acknowledgement numbers are used throughout the duration of a TCP session, we can utilize Wireshark's built-in flow graphing ability. Navigate to Statistics > Flow Graph... , select TCP flow and click OK . Wireshark automatically builds a graphical summary of the TCP flow. Each row represents a single TCP packet. The left column indicates the direction of the packet, TCP ports, segment length, and the flag(s) set. The column at right lists the relative sequence and acknowledgement numbers in decimal. Selecting a row in this column also highlights the corresponding packet in the main window. We can use this flow graph to better understand how sequence and acknowledgement numbers work. Packet #1 Each side of a TCP session starts out with a (relative) sequence number of zero. Likewise, the acknowledgement number is also zero, as there is not yet a complementary side of the conversation to acknowledge. (Note: The version of Wireshark used for this demonstration, 1.2.7, shows the acknowledgement number as an apparently random number. This believed to be a software bug; the initial acknowledgement number of a session should always be zero, as you can see from inspecting the hex dump of the packet.) NOTE: \u4ece\u201cSequence and Acknowledgment Numbers\u201d\u8282\u4e2d\u7684\u914d\u56fe\u662f\u53ef\u4ee5\u770b\u51fa\u7684\uff0cACK number\u662f\u7d27\u8ddf\u5728SEQ number\u540e\u76844\u5b57\u8282\uff0c\u53ef\u4ee5\u770b\u5230\u5b83\u662f 0x00 00 00 00 Packet #2 The server responds to the client with a sequence number of zero, as this is its first packet in this TCP session, and a relative acknowledgement number of 1. The acknowledgement number is set to 1 to indicate the receipt of the client's SYN flag in packet #1 . Notice that the acknowledgement number has been increased by 1 although no payload data has yet been sent by the client. This is because the presence of the SYN or FIN flag in a received packet triggers an increase of 1 in the sequence. (This does not interfere with the accounting of payload data, because packets with the SYN or FIN flag set do not carry a payload.) NOTE: \u7b80\u800c\u8a00\u4e4b\uff0c\u5c31\u662f\u5728\"What is SEQ number and ACK number?#\u7b80\u4ecb\"\u7ae0\u8282\u4e2d\u6240\u8ff0\u7684: The SYN packets consume one sequence number Packet #3 Like in packet #2 , the client responds to the server's sequence number of zero with an acknowledgement number of 1. The client includes its own sequence number of 1 (incremented from zero because of the SYN). At this point, the sequence number for both hosts is 1. This initial increment of 1 on both hosts' sequence numbers occurs during the establishment of all TCP sessions. Packet #4 This is the first packet in the stream which carries an actual payload (specifically, the client's HTTP request). The sequence number is left at 1, since no data has been transmitted since the last packet in this stream. The acknowledgement number is also left at 1, since no data has been received from the server, either. Note that this packet's payload is 725 bytes in length. Packet #5 This packet is sent by the server solely to acknowledge the data sent by the client in packet #4 while upper layers process the HTTP request. Notice that the acknowledgement number has increased by 725 (the length of the payload in packet #4 ) to 726; e.g., \"I have received 726 bytes so far.\" The server's sequence number remains at 1. Packet #6 This packet marks the beginning of the server's HTTP response. Its sequence number is still 1, since none of its packets prior to this one have carried a payload. This packet carries a payload of 1448 bytes. Packet #7 The sequence number of the client has been increased to 726 because of the last packet it sent. Having received 1448 bytes of data from the server, the client increases its acknowledgement number from 1 to 1449. For the majority of the capture, we will see this cycle repeat. The client's sequence number will remain steady at 726, because it has no data to transmit beyond the initial 725 byte request. The server's sequence number, in contrast, continues to grow as it sends more segments of the HTTP response. Tear-down Packet #38 After acknowledging the last segment of data from the server, the client processes the HTTP response as a whole and decides no further communication is needed. Packet #38 is sent by the client with the FIN flag set. Its acknowledgement number remains the same as in the prior packet #37 . Packet #39 The server acknowledges the client's desire to terminate the connection by increasing the acknowledgement number by one (similar to what was done in packet #2 to acknowledge the SYN flag) and setting the FIN flag as well. Packet #40 The client sends its final sequence number of 727, and acknowledges the server's FIN packet by incrementing the acknowledgement number by 1 to 22952. At this point, both hosts have terminated the session and can release the software resources dedicated to its maintenance. \u601d\u8003: \u4e3a\u4ec0\u4e48SYN\u548cFIN\u4f1a\u6d88\u8017\u4e00\u4e2a\u5e8f\u5217\u53f7? \u5728cnblogs TCP \u4e2d\u7684Sequence Number \u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u56de\u7b54: \u7ec6\u5fc3\u7684\u540c\u5b66\u53ef\u80fd\u4f1a\u53d1\u73b0\uff0c\u4e3a\u4ec0\u4e48\u5728\u5efa\u7acb\u8fde\u63a5\u7684\u65f6\u5019\uff0c\u53d1\u9001\u7684 SYN \u5305\u5927\u5c0f\uff08payload\uff09\u660e\u660e\u662f0\u5b57\u8282\uff0c\u4f46\u662f\u63a5\u6536\u7aef\u5374\u8fd4\u56de ACK = 1 \uff0c\u8fd8\u6709\u65ad\u5f00\u8fde\u63a5\u7684\u65f6\u5019 FIN \u5305\u4e5f\u88ab\u89c6\u4e3a\u542b\u67091\u5b57\u8282\u7684\u6570\u636e\u3002 \u539f\u56e0\u662f SYN \u548c FIN \u4fe1\u53f7\u90fd\u662f\u9700\u8981 acknowledgement \u7684\uff0c\u4e5f\u5c31\u662f\u4f60\u5fc5\u987b\u56de\u590d\u8fd9\u4e2a\u4fe1\u53f7\uff0c\u5982\u679c\u5b83\u4e0d\u5360\u6709\u4e00\u4e2a\u5b57\u8282\u7684\u8bdd\uff0c\u8981\u5982\u4f55\u5224\u65ad\u4f60\u662f\u56de\u590d\u8fd9\u4e2a\u4fe1\u53f7\u8fd8\u662f\u56de\u590d\u8fd9\u4e2a\u4fe1\u53f7\u4e4b\u524d\u7684\u5305\u5462\uff1f \u4f8b\u5982\uff1a\u5982\u679c FIN \u4fe1\u53f7\u4e0d\u5360\u7528\u4e00\u4e2a\u5b57\u8282\uff0c\u56de\u590d FIN \u7684 ack \u5305\u5c31\u53ef\u80fd\u88ab\u8bef\u8ba4\u4e3a\u662f\u56de\u590d\u4e4b\u524d\u7684\u6570\u636e\u5305\u88ab\u91cd\u65b0\u53d1\u9001\u4e86\u4e00\u6b21\uff0c\u7b2c\u4e8c\u6b21\u6325\u624b\u65e0\u6cd5\u5b8c\u6210\uff0c\u8fde\u63a5\u4e5f\u5c31\u65e0\u6cd5\u6b63\u5e38\u5173\u95ed\u4e86\u3002 \u601d\u8003: \u4e3a\u4ec0\u4e48SYN\u548cACK\u7684\u521d\u59cb\u503c\uff08ISN initialization sequence number\uff09\u662f\u4e00\u4e2a\u968f\u673a\u503c? \u5728cnblogs TCP \u4e2d\u7684Sequence Number \u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u56de\u7b54: \u53c2\u8003 TCP \u7684\u90a3\u4e9b\u4e8b\u513f\uff08\u4e0a\uff09 ISN\u662f\u4e0d\u80fdhard code\u7684\uff0c\u4e0d\u7136\u4f1a\u51fa\u95ee\u9898\u7684\u2014\u2014\u6bd4\u5982\uff1a\u5982\u679c\u8fde\u63a5\u5efa\u597d\u540e\u59cb\u7ec8\u75281\u6765\u505aISN\uff0c\u5982\u679cclient\u53d1\u4e8630\u4e2asegment\u8fc7\u53bb\uff0c\u4f46\u662f\u7f51\u7edc\u65ad\u4e86\uff0c\u4e8e\u662f client\u91cd\u8fde\uff0c\u53c8\u7528\u4e861\u505aISN\uff0c\u4f46\u662f\u4e4b\u524d\u8fde\u63a5\u7684\u90a3\u4e9b\u5305\u5230\u4e86\uff0c\u4e8e\u662f\u5c31\u88ab\u5f53\u6210\u4e86\u65b0\u8fde\u63a5\u7684\u5305\uff0c\u6b64\u65f6\uff0cclient\u7684Sequence Number \u53ef\u80fd\u662f3\uff0c\u800cServer\u7aef\u8ba4\u4e3aclient\u7aef\u7684\u8fd9\u4e2a\u53f7\u662f30\u4e86\u3002\u5168\u4e71\u4e86\u3002 RFC793 \u4e2d\u8bf4\uff0cISN\u4f1a\u548c\u4e00\u4e2a\u5047\u7684\u65f6\u949f\u7ed1\u5728\u4e00\u8d77\uff0c\u8fd9\u4e2a\u65f6\u949f\u4f1a\u5728\u6bcf4\u5fae\u79d2\u5bf9ISN\u505a\u52a0\u4e00\u64cd\u4f5c\uff0c\u76f4\u5230\u8d85\u8fc72^32\uff0c\u53c8\u4ece0\u5f00\u59cb\u3002\u8fd9\u6837\uff0c\u4e00\u4e2aISN\u7684\u5468\u671f\u5927\u7ea6\u662f4.55\u4e2a\u5c0f\u65f6\u3002\u56e0\u4e3a\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u7684TCP Segment\u5728\u7f51\u7edc\u4e0a\u7684\u5b58\u6d3b\u65f6\u95f4\u4e0d\u4f1a\u8d85\u8fc7Maximum Segment Lifetime\uff08\u7f29\u5199\u4e3aMSL \u2013 Wikipedia\u8bed\u6761 \uff09\uff0c\u6240\u4ee5\uff0c\u53ea\u8981MSL\u7684\u503c\u5c0f\u4e8e4.55\u5c0f\u65f6\uff0c\u90a3\u4e48\uff0c\u6211\u4eec\u5c31\u4e0d\u4f1a\u91cd\u7528\u5230ISN\u3002 TODO: \u601d\u8003: SEQ number overflow\uff1f voidcn TCP\u5e8f\u5217\u53f7\u7684\u6700\u5927\u503c See also stackoverflow TCP: How are the seq / ack numbers generated? stackoverflow TCP Sequence Number firewall TCP Sequence & Acknowledgement Numbers - Section 2","title":"Introduction"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#tcp#seq#number#and#ack#number","text":"\u672c\u6587\u5bf9TCP\u7684SEQ number\u3001ACK number\u8fdb\u884c\u8bf4\u660e\u3002","title":"TCP SEQ number and ACK number"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#what#is#seq#number#and#ack#number","text":"","title":"What is  SEQ number and ACK number?"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#purpose","text":"\u5728 Network\\Theory\\TCP\\Transmission-Control-Protocol.md \u7684\u201cRow3\u201d\u8282\uff0c\u6709\u8fd9\u6837\u7684\u8bf4\u660e: Sequence number \u548c Acknowledgment number\u662fTCP\u5b9e\u73b0\u5728\u201d4.4 Data transfer\u201c\u4e2d\u4ecb\u7ecd\u7684\u201cReliable transmission\u201d \u7279\u6027\u7684\u5173\u952e\u3002 \u5728 Network\\Theory\\TCP\\Transmission-Control-Protocol.md \u7684Guide\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053TCP\u534f\u8bae\u8981\u6c42\u6240\u6709\u7684\u901a\u4fe1\u90fd\u662frequest-response\u7684\uff0c\u5373 \u6bcf\u4e2arequest\uff0c\u90fd\u4f1a\u6536\u5230\u4e00\u4e2aresponse\uff0c\u8fd9\u4e2aresponse\u662f\u7528\u4e8eacknowledge\u7684\uff0c\u5373\u5bf9\u65b9\u544a\u8bc9\u53d1\u9001\u65b9: \u6536\u5230\u4e86request\uff0c\u6211\u4eec\u5f80\u5f80\u5c06\u5176\u79f0\u4e4b\u4e3aACK response\uff0c\u8fd9\u6837\u624d\u7b97\u662f\u5b8c\u6210\u4e86\u8fd9\u4e2a\u8bf7\u6c42\uff1b \u4e00\u4e2a\u5b8c\u6574\u7684\u8bf7\u6c42\u624d\u4f1a\u5bfc\u81f4SEQ number\u7684\u589e\u957f\uff0c\u4e5f\u5c31\u662f\u8bf4**\u53d1\u9001\u65b9**\u662f\u5728\u6536\u5230ACK response\u7684\u65f6\u5019\uff0c\u624d\u4f1a\u66f4\u65b0\u5b83\u7684SEQ number\uff0c\u6216\u8005\u8bf4SEQ number\u7684\u8ba1\u7b97\u662f\u57fa\u4e8e\u5b8c\u6574\u7684\u8bf7\u6c42\u7684\uff0c\u800c\u4e0d\u662f\u57fa\u4e8e\u5b83\u6240\u53d1\u9001\u7684TCP segment( \u5176\u4e2d\u4e5f\u5305\u62ec\u4e86ACK response)\uff0c\u8fd9\u5c31\u662f\u8bf4ACK TCP segment\u662f\u4e0d\u4f1a\u5bfc\u81f4SEQ number\u7684\u53d8\u52a8\u7684\uff0c\u4e0b\u9762\u662f\u7b80\u5355\u7684\u89c4\u5219: \u5bf9\u4e8eSYN\u3001FIN \u8bf7\u6c42\uff0cSEQ number\u589e\u957f1\uff08\u8fd9\u662f\u6bd4\u8f83\u7279\u6b8a\u7684\uff0c\u540e\u9762\u4f1a\u89e3\u91ca\u8fd9\u6837\u505a\u7684\u539f\u56e0\uff09 \u5bf9\u4e8e\u5176\u4ed6\u8bf7\u6c42\uff0cSEQ number\u589e\u957fplayload\u957f\u5ea6 \u90a3\u8be5\u534f\u8bae\u662f\u5982\u4f55\u5b9e\u73b0response A\u662frequest A\u7684response\u800c\u4e0d\u662frequest B\u7684response\u5462\uff1f\u662f\u4f7f\u7528sequence number\u548creceived sequence number\u5417\uff1f\u5bf9\u4e00\u4e2aendpoint\u800c\u8a00\uff0c\u5b83\u7684sequence number\u662f\u5355\u8c03\u9012\u589e\u7684\u5417\uff1f","title":"Purpose"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#_1","text":"miami TCP in a nutshell \u7684**Sequence Numbers**\u6bb5\u6709\u7740\u975e\u5e38\u597d\u7684\u4ecb\u7ecd: All bytes in a TCP connection are numbered, beginning at a randomly chosen initial sequence number ( ISN ). The SYN packets consume one sequence number , so actual data will begin at ISN+1 . The sequence number is the byte number of the first byte of data in the TCP packet sent (also called a TCP segment). The acknowledgement number is the sequence number of the next byte the receiver expects to receive. The receiver ack'ing sequence number x acknowledges receipt of all data bytes less than (but not including) byte number x . The sequence number is always valid. The acknowledgement number is only valid when the ACK flag is one. The only time the ACK flag is not set, that is, the only time there is not a valid acknowledgement number in the TCP header, is during the first packet of connection set-up.","title":"\u7b80\u4ecb"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#example#packetlife#understanding#tcp#sequence#and#acknowledgment#numbers","text":"NOTE: \u8fd9\u7bc7\u6587\u7ae0\uff0c\u7ed3\u5408 Wireshark \u3001\u5177\u4f53\u6848\u4f8b\u6765\u8bb2\u89e3\uff0c\u975e\u5e38\u503c\u5f97\u9605\u8bfb This article aims to help you become more comfortable examining TCP sequence and acknowledgement numbers in the Wireshark packet analyzer. Before we start, be sure to open the example capture in Wireshark and play along. The example capture contains a single HTTP request to a web server, in which the client web browser requests a single image file, and the server returns an HTTP/1.1 200 (OK) response which includes the file requested. You can right-click on any of the TCP packets within this capture and select Follow TCP Stream to open the raw contents of the TCP stream in a separate window for inspection. Traffic from the client is shown in red, and traffic from the server in blue. NOTE: \u4ece\u4e0a\u8ff0\u56fe\u53ef\u4ee5\u770b\u51fa\uff0c\u5b83\u4ec5\u4ec5\u5c55\u793a\u4e86HTTP\u7684\u8bf7\u6c42\u3001\u54cd\u5e94\uff0c\u5e76\u6ca1\u6709\u5c55\u793aTCP\u7684\u7ec6\u8282\u3002","title":"Example: packetlife Understanding TCP Sequence and Acknowledgment Numbers"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#the#three-way#handshake","text":"TCP utilizes a number of flags, or 1-bit boolean fields, in its header to control the state of a connection. The three we're most interested in here are: SYN - (Synchronize) Initiates a connection FIN - (Final) Cleanly terminates a connection ACK - Acknowledges received data As we'll see, a packet can have multiple flags set. NOTE: \u5178\u578b\u7684\u4f8b\u5b50\u5c31\u662f SYN-ACK Select packet #1 in Wireshark and expand the TCP layer analysis in the middle pane, and further expand the \"Flags\" field within the TCP header. Here we can see all of the TCP flags broken down. Note that the SYN flag is on (set to 1). Now do the same for packet #2 . Notice that it has two flags set: ACK to acknowledge the receipt of the client's SYN packet, and SYN to indicate that the server also wishes to establish a TCP connection. Packet #3 , from the client, has only the ACK flag set. These three packets complete the initial TCP three-way handshake.","title":"The Three-Way Handshake"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#sequence#and#acknowledgment#numbers","text":"The client on either side of a TCP session maintains a 32-bit sequence number it uses to keep track of how much data it has sent. This sequence number is included on each transmitted packet, and acknowledged by the opposite host as an acknowledgement number to inform the sending host that the transmitted data was received successfully. NOTE: \u8fd9\u5c31\u662f\u5728\u201cWhat is SEQ number and ACK number?#Purpose\u201d\u4e2d\u6240\u4ecb\u7ecd\u7684request-response\u3002 When a host initiates a TCP session, its initial sequence number is effectively random; it may be any value between 0 and 4,294,967,295, inclusive. However, protocol analyzers like Wireshark will typically display relative sequence and acknowledgement numbers in place of the actual values. These numbers are relative to the initial sequence number of that stream. This is handy, as it is much easier to keep track of relatively small, predictable numbers rather than the actual numbers sent on the wire. For example, the initial relative sequence number shown in packet #1 is 0 (naturally), while the ASCII decode in the third pane shows that the actual sequence number is 0xf61c6cbe , or 4129057982 decimal. The display of relative sequence numbers can optionally be disabled by navigating to Edit > Preferences... and un-checking Relative sequence numbers and window scaling under TCP protocol preferences. However, be aware that the remainder of this article will reference relative sequence and acknowledgement numbers only. To better understand how sequence and acknowledgement numbers are used throughout the duration of a TCP session, we can utilize Wireshark's built-in flow graphing ability. Navigate to Statistics > Flow Graph... , select TCP flow and click OK . Wireshark automatically builds a graphical summary of the TCP flow. Each row represents a single TCP packet. The left column indicates the direction of the packet, TCP ports, segment length, and the flag(s) set. The column at right lists the relative sequence and acknowledgement numbers in decimal. Selecting a row in this column also highlights the corresponding packet in the main window. We can use this flow graph to better understand how sequence and acknowledgement numbers work.","title":"Sequence and Acknowledgment Numbers"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#packet#1","text":"Each side of a TCP session starts out with a (relative) sequence number of zero. Likewise, the acknowledgement number is also zero, as there is not yet a complementary side of the conversation to acknowledge. (Note: The version of Wireshark used for this demonstration, 1.2.7, shows the acknowledgement number as an apparently random number. This believed to be a software bug; the initial acknowledgement number of a session should always be zero, as you can see from inspecting the hex dump of the packet.) NOTE: \u4ece\u201cSequence and Acknowledgment Numbers\u201d\u8282\u4e2d\u7684\u914d\u56fe\u662f\u53ef\u4ee5\u770b\u51fa\u7684\uff0cACK number\u662f\u7d27\u8ddf\u5728SEQ number\u540e\u76844\u5b57\u8282\uff0c\u53ef\u4ee5\u770b\u5230\u5b83\u662f 0x00 00 00 00","title":"Packet #1"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#packet#2","text":"The server responds to the client with a sequence number of zero, as this is its first packet in this TCP session, and a relative acknowledgement number of 1. The acknowledgement number is set to 1 to indicate the receipt of the client's SYN flag in packet #1 . Notice that the acknowledgement number has been increased by 1 although no payload data has yet been sent by the client. This is because the presence of the SYN or FIN flag in a received packet triggers an increase of 1 in the sequence. (This does not interfere with the accounting of payload data, because packets with the SYN or FIN flag set do not carry a payload.) NOTE: \u7b80\u800c\u8a00\u4e4b\uff0c\u5c31\u662f\u5728\"What is SEQ number and ACK number?#\u7b80\u4ecb\"\u7ae0\u8282\u4e2d\u6240\u8ff0\u7684: The SYN packets consume one sequence number","title":"Packet #2"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#packet#3","text":"Like in packet #2 , the client responds to the server's sequence number of zero with an acknowledgement number of 1. The client includes its own sequence number of 1 (incremented from zero because of the SYN). At this point, the sequence number for both hosts is 1. This initial increment of 1 on both hosts' sequence numbers occurs during the establishment of all TCP sessions.","title":"Packet #3"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#packet#4","text":"This is the first packet in the stream which carries an actual payload (specifically, the client's HTTP request). The sequence number is left at 1, since no data has been transmitted since the last packet in this stream. The acknowledgement number is also left at 1, since no data has been received from the server, either. Note that this packet's payload is 725 bytes in length.","title":"Packet #4"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#packet#5","text":"This packet is sent by the server solely to acknowledge the data sent by the client in packet #4 while upper layers process the HTTP request. Notice that the acknowledgement number has increased by 725 (the length of the payload in packet #4 ) to 726; e.g., \"I have received 726 bytes so far.\" The server's sequence number remains at 1.","title":"Packet #5"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#packet#6","text":"This packet marks the beginning of the server's HTTP response. Its sequence number is still 1, since none of its packets prior to this one have carried a payload. This packet carries a payload of 1448 bytes.","title":"Packet #6"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#packet#7","text":"The sequence number of the client has been increased to 726 because of the last packet it sent. Having received 1448 bytes of data from the server, the client increases its acknowledgement number from 1 to 1449. For the majority of the capture, we will see this cycle repeat. The client's sequence number will remain steady at 726, because it has no data to transmit beyond the initial 725 byte request. The server's sequence number, in contrast, continues to grow as it sends more segments of the HTTP response.","title":"Packet #7"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#tear-down","text":"","title":"Tear-down"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#packet#38","text":"After acknowledging the last segment of data from the server, the client processes the HTTP response as a whole and decides no further communication is needed. Packet #38 is sent by the client with the FIN flag set. Its acknowledgement number remains the same as in the prior packet #37 .","title":"Packet #38"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#packet#39","text":"The server acknowledges the client's desire to terminate the connection by increasing the acknowledgement number by one (similar to what was done in packet #2 to acknowledge the SYN flag) and setting the FIN flag as well.","title":"Packet #39"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#packet#40","text":"The client sends its final sequence number of 727, and acknowledges the server's FIN packet by incrementing the acknowledgement number by 1 to 22952. At this point, both hosts have terminated the session and can release the software resources dedicated to its maintenance.","title":"Packet #40"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#synfin","text":"\u5728cnblogs TCP \u4e2d\u7684Sequence Number \u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u56de\u7b54: \u7ec6\u5fc3\u7684\u540c\u5b66\u53ef\u80fd\u4f1a\u53d1\u73b0\uff0c\u4e3a\u4ec0\u4e48\u5728\u5efa\u7acb\u8fde\u63a5\u7684\u65f6\u5019\uff0c\u53d1\u9001\u7684 SYN \u5305\u5927\u5c0f\uff08payload\uff09\u660e\u660e\u662f0\u5b57\u8282\uff0c\u4f46\u662f\u63a5\u6536\u7aef\u5374\u8fd4\u56de ACK = 1 \uff0c\u8fd8\u6709\u65ad\u5f00\u8fde\u63a5\u7684\u65f6\u5019 FIN \u5305\u4e5f\u88ab\u89c6\u4e3a\u542b\u67091\u5b57\u8282\u7684\u6570\u636e\u3002 \u539f\u56e0\u662f SYN \u548c FIN \u4fe1\u53f7\u90fd\u662f\u9700\u8981 acknowledgement \u7684\uff0c\u4e5f\u5c31\u662f\u4f60\u5fc5\u987b\u56de\u590d\u8fd9\u4e2a\u4fe1\u53f7\uff0c\u5982\u679c\u5b83\u4e0d\u5360\u6709\u4e00\u4e2a\u5b57\u8282\u7684\u8bdd\uff0c\u8981\u5982\u4f55\u5224\u65ad\u4f60\u662f\u56de\u590d\u8fd9\u4e2a\u4fe1\u53f7\u8fd8\u662f\u56de\u590d\u8fd9\u4e2a\u4fe1\u53f7\u4e4b\u524d\u7684\u5305\u5462\uff1f \u4f8b\u5982\uff1a\u5982\u679c FIN \u4fe1\u53f7\u4e0d\u5360\u7528\u4e00\u4e2a\u5b57\u8282\uff0c\u56de\u590d FIN \u7684 ack \u5305\u5c31\u53ef\u80fd\u88ab\u8bef\u8ba4\u4e3a\u662f\u56de\u590d\u4e4b\u524d\u7684\u6570\u636e\u5305\u88ab\u91cd\u65b0\u53d1\u9001\u4e86\u4e00\u6b21\uff0c\u7b2c\u4e8c\u6b21\u6325\u624b\u65e0\u6cd5\u5b8c\u6210\uff0c\u8fde\u63a5\u4e5f\u5c31\u65e0\u6cd5\u6b63\u5e38\u5173\u95ed\u4e86\u3002","title":"\u601d\u8003: \u4e3a\u4ec0\u4e48SYN\u548cFIN\u4f1a\u6d88\u8017\u4e00\u4e2a\u5e8f\u5217\u53f7?"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#synackisn#initialization#sequence#number","text":"\u5728cnblogs TCP \u4e2d\u7684Sequence Number \u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u56de\u7b54: \u53c2\u8003 TCP \u7684\u90a3\u4e9b\u4e8b\u513f\uff08\u4e0a\uff09 ISN\u662f\u4e0d\u80fdhard code\u7684\uff0c\u4e0d\u7136\u4f1a\u51fa\u95ee\u9898\u7684\u2014\u2014\u6bd4\u5982\uff1a\u5982\u679c\u8fde\u63a5\u5efa\u597d\u540e\u59cb\u7ec8\u75281\u6765\u505aISN\uff0c\u5982\u679cclient\u53d1\u4e8630\u4e2asegment\u8fc7\u53bb\uff0c\u4f46\u662f\u7f51\u7edc\u65ad\u4e86\uff0c\u4e8e\u662f client\u91cd\u8fde\uff0c\u53c8\u7528\u4e861\u505aISN\uff0c\u4f46\u662f\u4e4b\u524d\u8fde\u63a5\u7684\u90a3\u4e9b\u5305\u5230\u4e86\uff0c\u4e8e\u662f\u5c31\u88ab\u5f53\u6210\u4e86\u65b0\u8fde\u63a5\u7684\u5305\uff0c\u6b64\u65f6\uff0cclient\u7684Sequence Number \u53ef\u80fd\u662f3\uff0c\u800cServer\u7aef\u8ba4\u4e3aclient\u7aef\u7684\u8fd9\u4e2a\u53f7\u662f30\u4e86\u3002\u5168\u4e71\u4e86\u3002 RFC793 \u4e2d\u8bf4\uff0cISN\u4f1a\u548c\u4e00\u4e2a\u5047\u7684\u65f6\u949f\u7ed1\u5728\u4e00\u8d77\uff0c\u8fd9\u4e2a\u65f6\u949f\u4f1a\u5728\u6bcf4\u5fae\u79d2\u5bf9ISN\u505a\u52a0\u4e00\u64cd\u4f5c\uff0c\u76f4\u5230\u8d85\u8fc72^32\uff0c\u53c8\u4ece0\u5f00\u59cb\u3002\u8fd9\u6837\uff0c\u4e00\u4e2aISN\u7684\u5468\u671f\u5927\u7ea6\u662f4.55\u4e2a\u5c0f\u65f6\u3002\u56e0\u4e3a\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u7684TCP Segment\u5728\u7f51\u7edc\u4e0a\u7684\u5b58\u6d3b\u65f6\u95f4\u4e0d\u4f1a\u8d85\u8fc7Maximum Segment Lifetime\uff08\u7f29\u5199\u4e3aMSL \u2013 Wikipedia\u8bed\u6761 \uff09\uff0c\u6240\u4ee5\uff0c\u53ea\u8981MSL\u7684\u503c\u5c0f\u4e8e4.55\u5c0f\u65f6\uff0c\u90a3\u4e48\uff0c\u6211\u4eec\u5c31\u4e0d\u4f1a\u91cd\u7528\u5230ISN\u3002","title":"\u601d\u8003: \u4e3a\u4ec0\u4e48SYN\u548cACK\u7684\u521d\u59cb\u503c\uff08ISN initialization sequence number\uff09\u662f\u4e00\u4e2a\u968f\u673a\u503c?"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#todo#seq#number#overflow","text":"voidcn TCP\u5e8f\u5217\u53f7\u7684\u6700\u5927\u503c","title":"TODO: \u601d\u8003: SEQ number overflow\uff1f"},{"location":"Network/Protocol/TCP/SEQ-and-ACK/#see#also","text":"stackoverflow TCP: How are the seq / ack numbers generated? stackoverflow TCP Sequence Number firewall TCP Sequence & Acknowledgement Numbers - Section 2","title":"See also"},{"location":"Network/Protocol/TCP/TCP-connection/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bbaTCP connection\u76f8\u5173\u7684\u5185\u5bb9\u3002 What is TCP connection? \u9996\u5148\u641e\u6e05\u695aTCP connection\u7684\u672c\u8d28\u3002 \u5728 wikipedia Transmission Control Protocol#Network_function \u4e2d\u5df2\u7ecf\u63cf\u8ff0\u4e86TCP connection\u7684\u672c\u8d28: At the transport layer, TCP handles all handshaking and transmission details and presents an abstraction of the network connection to the application typically through a network socket interface. \u5b83\u63cf\u8ff0\u4e86TCP connecting\u7684\u672c\u8d28\uff0c\u53ef\u4ee5\u8ba4\u4e3aTCP network connection is an abstraction\u3001 \u5728 zhihu TCP\u8fde\u63a5\u662f\u4ec0\u4e48? # \u9676\u8f89\u7684\u56de\u7b54 \u4e2d\u63cf\u8ff0\u7684\u66f4\u52a0\u660e\u786e: \u4e24\u53f0PC\u673a\u5668\u4e0a\u6709\u4e24\u4e2a\u8fdb\u7a0b\uff0c\u901a\u8fc72\u4e2a\u7aef\u53e3\u903b\u8f91\u4e0a\u5efa\u7acb\u4e86\u901a\u9053\u3002\u7531\u4e8e\u7f51\u7edc\u4e0a\u6d88\u606f\u662f\u53ef\u4ee5\u4e22\u5931\u7684\uff0c\u53ef\u4ee5\u65e0\u5e8f\u7684\uff0c\u53ef\u4ee5\u591a\u6b21\u91cd\u4f20\u7684\uff0c\u6240\u4ee5\u8fd9\u4e2a\u901a\u9053\u7684\u5fc5\u8981\u6027\u5c31\u51fa\u73b0\u4e86\uff1a\u5b83\u786e\u4fdd\u6d88\u606f\u662f\u6709\u5e8f\u7684\u3001\u4e0d\u4f1a\u4e22\u5931\u7684\u3002\u800c\u4e14TCP\u542b\u6709\u6d41\u91cf\u63a7\u5236\uff0c\u9632\u6b62\u77ac\u95f4\u7f51\u7edc\u98ce\u66b4\u5f15\u53d1\u6076\u6027\u5faa\u73af\u3002 \u800cTCP\u8fde\u63a5\u7eaf\u7cb9\u662f**\u865a\u62df**\u7684\uff0c\u5b83\u53ea\u5b58\u5728\u4e8e\u4e24\u53f0**\u4e3b\u673a**\u95f4\uff0c\u7f51\u7edc\u4e2d\u7684\u8def\u7531\u5668\u3001\u4ea4\u6362\u673a\u5e76\u4e0d\u77e5\u60c5\u3002","title":"Introduction"},{"location":"Network/Protocol/TCP/TCP-connection/#_1","text":"\u672c\u7ae0\u8ba8\u8bbaTCP connection\u76f8\u5173\u7684\u5185\u5bb9\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Network/Protocol/TCP/TCP-connection/#what#is#tcp#connection","text":"\u9996\u5148\u641e\u6e05\u695aTCP connection\u7684\u672c\u8d28\u3002 \u5728 wikipedia Transmission Control Protocol#Network_function \u4e2d\u5df2\u7ecf\u63cf\u8ff0\u4e86TCP connection\u7684\u672c\u8d28: At the transport layer, TCP handles all handshaking and transmission details and presents an abstraction of the network connection to the application typically through a network socket interface. \u5b83\u63cf\u8ff0\u4e86TCP connecting\u7684\u672c\u8d28\uff0c\u53ef\u4ee5\u8ba4\u4e3aTCP network connection is an abstraction\u3001 \u5728 zhihu TCP\u8fde\u63a5\u662f\u4ec0\u4e48? # \u9676\u8f89\u7684\u56de\u7b54 \u4e2d\u63cf\u8ff0\u7684\u66f4\u52a0\u660e\u786e: \u4e24\u53f0PC\u673a\u5668\u4e0a\u6709\u4e24\u4e2a\u8fdb\u7a0b\uff0c\u901a\u8fc72\u4e2a\u7aef\u53e3\u903b\u8f91\u4e0a\u5efa\u7acb\u4e86\u901a\u9053\u3002\u7531\u4e8e\u7f51\u7edc\u4e0a\u6d88\u606f\u662f\u53ef\u4ee5\u4e22\u5931\u7684\uff0c\u53ef\u4ee5\u65e0\u5e8f\u7684\uff0c\u53ef\u4ee5\u591a\u6b21\u91cd\u4f20\u7684\uff0c\u6240\u4ee5\u8fd9\u4e2a\u901a\u9053\u7684\u5fc5\u8981\u6027\u5c31\u51fa\u73b0\u4e86\uff1a\u5b83\u786e\u4fdd\u6d88\u606f\u662f\u6709\u5e8f\u7684\u3001\u4e0d\u4f1a\u4e22\u5931\u7684\u3002\u800c\u4e14TCP\u542b\u6709\u6d41\u91cf\u63a7\u5236\uff0c\u9632\u6b62\u77ac\u95f4\u7f51\u7edc\u98ce\u66b4\u5f15\u53d1\u6076\u6027\u5faa\u73af\u3002 \u800cTCP\u8fde\u63a5\u7eaf\u7cb9\u662f**\u865a\u62df**\u7684\uff0c\u5b83\u53ea\u5b58\u5728\u4e8e\u4e24\u53f0**\u4e3b\u673a**\u95f4\uff0c\u7f51\u7edc\u4e2d\u7684\u8def\u7531\u5668\u3001\u4ea4\u6362\u673a\u5e76\u4e0d\u77e5\u60c5\u3002","title":"What is TCP connection?"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-establishment/","text":"Connection establishment wikipedia Transmission Control Protocol # 4.1 Connection establishment To establish a connection, TCP uses a three-way handshake . Before a client attempts to connect with a server, the server must first bind to and listen at a port to open it up for connections: this is called a passive open . Once the passive open is established, a client may initiate an active open . To establish a connection , the three-way (or 3-step) handshake occurs: 1) SYN : The active open is performed by the client sending a SYN to the server. The client sets the segment's sequence number to a random value A . 2) SYN-ACK : In response, the server replies with a SYN-ACK. The acknowledgment number is set to one more than the received sequence number i.e. A+1 , and the sequence number that the server chooses for the packet is another random number, B . NOTE: SYN-ACK\u5176\u5b9e\u53ef\u4ee5\u770b\u505a\u662f\u540c\u65f6\u53d1\u9001SYN\u548cACK 3) ACK : Finally, the client sends an ACK back to the server. The sequence number is set to the received acknowledgement value i.e. A+1 , and the acknowledgement number is set to one more than the received sequence number i.e. B+1 . NOTE: \u4e3a\u4ec0\u4e48\u662fplus 1\uff1f\u5728 Network\\Theory\\TCP\\TCP-SEQ-number-and-ACK-number.md \u7684cnblogs TCP \u4e2d\u7684Sequence Number \u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u89e3\u91ca At this point, both the client and server have received an acknowledgment of the connection. The steps 1, 2 establish the connection parameter ( sequence number ) for one direction and it is acknowledged. The steps 2, 3 establish the connection parameter ( sequence number ) for the other direction and it is acknowledged. With these, a full-duplex communication is established. NOTE: full-duplex\uff0c\u6bcf\u4e2adirection\u90fd\u6709\u5bf9\u5e94\u7684connection parameter: sequence number\u3002 NOTE: \u5728\u6587\u7ae0packetlife Understanding TCP Sequence and Acknowledgment Numbers \u4e2d\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528wireshark\u6765\u89c2\u5bdfconnection establishment\u7684\u8fc7\u7a0b\uff0c\u8fd9\u7bc7\u6587\u7ae0\u6536\u5f55\u5728 Network\\Theory\\TCP\\TCP-SEQ-number-and-ACK-number.md \u4e2d\u3002","title":"Connection-establishment"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-establishment/#connection#establishment","text":"","title":"Connection establishment"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-establishment/#wikipedia#transmission#control#protocol#41#connection#establishment","text":"To establish a connection, TCP uses a three-way handshake . Before a client attempts to connect with a server, the server must first bind to and listen at a port to open it up for connections: this is called a passive open . Once the passive open is established, a client may initiate an active open . To establish a connection , the three-way (or 3-step) handshake occurs: 1) SYN : The active open is performed by the client sending a SYN to the server. The client sets the segment's sequence number to a random value A . 2) SYN-ACK : In response, the server replies with a SYN-ACK. The acknowledgment number is set to one more than the received sequence number i.e. A+1 , and the sequence number that the server chooses for the packet is another random number, B . NOTE: SYN-ACK\u5176\u5b9e\u53ef\u4ee5\u770b\u505a\u662f\u540c\u65f6\u53d1\u9001SYN\u548cACK 3) ACK : Finally, the client sends an ACK back to the server. The sequence number is set to the received acknowledgement value i.e. A+1 , and the acknowledgement number is set to one more than the received sequence number i.e. B+1 . NOTE: \u4e3a\u4ec0\u4e48\u662fplus 1\uff1f\u5728 Network\\Theory\\TCP\\TCP-SEQ-number-and-ACK-number.md \u7684cnblogs TCP \u4e2d\u7684Sequence Number \u4e2d\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u89e3\u91ca At this point, both the client and server have received an acknowledgment of the connection. The steps 1, 2 establish the connection parameter ( sequence number ) for one direction and it is acknowledged. The steps 2, 3 establish the connection parameter ( sequence number ) for the other direction and it is acknowledged. With these, a full-duplex communication is established. NOTE: full-duplex\uff0c\u6bcf\u4e2adirection\u90fd\u6709\u5bf9\u5e94\u7684connection parameter: sequence number\u3002 NOTE: \u5728\u6587\u7ae0packetlife Understanding TCP Sequence and Acknowledgment Numbers \u4e2d\u5c55\u793a\u4e86\u5982\u4f55\u4f7f\u7528wireshark\u6765\u89c2\u5bdfconnection establishment\u7684\u8fc7\u7a0b\uff0c\u8fd9\u7bc7\u6587\u7ae0\u6536\u5f55\u5728 Network\\Theory\\TCP\\TCP-SEQ-number-and-ACK-number.md \u4e2d\u3002","title":"wikipedia Transmission Control Protocol # 4.1 Connection establishment"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/","text":"TCP connection termination wikipedia Transmission Control Protocol # 4.2 Connection termination NOTE: \u5728\u6587\u7ae0 Network\\Theory\\TCP\\TCP-connection-termination.md \u4e2d\u5bf9connection termination\u8fdb\u884c\u4e86\u8865\u5145\uff0c\u5176\u4e2d\u89e3\u91ca\u672c\u6bb5\u4e2d\u5f88\u591a\u6ca1\u6709\u8bf4\u660e\u6e05\u695a\u7684\u95ee\u9898: RST \u3001 half-duplex close sequence half-open\u3001half-close 2MSL wait The connection termination phase uses a four-way handshake , with each side of the connection terminating independently. When an endpoint wishes to stop its half of the connection, it transmits a FIN packet , which the other end acknowledges with an ACK . Therefore, a typical tear-down requires a pair of FIN and ACK segments from each TCP endpoint ( four-way handshake ). After the side that (\u5f15\u5bfc\u5b9a\u8bed\u4ece\u53e5) sent the first FIN has responded with the final ACK , it waits for a timeout before finally closing the connection, during which time the local port is unavailable for new connections; this prevents confusion due to delayed packets being delivered during subsequent connections. NOTE: \u6700\u540e\u4e00\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a\u5728\u8fd9\u6bb5\u65f6\u95f4\u5185\uff0c\u8fd9\u4e2aport\u662f\u4e0d\u80fd\u591f\u7528\u4e8e\u65b0\u7684connection\u7684\uff0c\u8fd9\u6837\u505a\u7684\u539f\u56e0\u662f\uff1a\u5982\u679c\u5141\u8bb8\uff0c\u53ef\u80fd\u5bfc\u81f4delayed packet\u88ab\u540e\u7eed\u5728\u8fd9\u4e2aport\u4e0a\u7684connection\u8fdb\u884c\u4f20\u8f93\uff1b NOTE: why connection establishment\u4f7f\u7528three-way handshake\uff0c\u800cconnection termination\u4f7f\u7528four-wary handshake\uff1f\u6211\u60f3\u8fd9\u5176\u4e2d\u7684\u5dee\u522b\u5728\u4e8e\u4f20\u8f93buffer\u4e2d\u7684\u6570\u636e\uff1b A connection can be \"half-open\" , in which case one side has terminated its end, but the other has not. The side that has terminated can no longer send any data into the connection, but the other side can. The terminating side should continue reading the data until the other side terminates as well. It is also possible to terminate the connection by a 3-way handshake, when host A sends a FIN and host B replies with a FIN & ACK (merely combines 2 steps into one) and host A replies with an ACK .[ 14] Some host TCP stacks may implement a half-duplex close sequence , as Linux or HP-UX do. If such a host actively closes a connection but still has not read all the incoming data the stack already received from the link, this host sends a RST instead of a FIN (Section 4.2.2.13 in RFC 1122 ). This allows a TCP application to be sure the remote application has read all the data the former sent\u2014waiting the FIN from the remote side, when it actively closes the connection. But the remote TCP stack cannot distinguish between a Connection Aborting RST and Data Loss RST . Both cause the remote stack to lose all the data received. Some application protocols using the TCP open/close handshaking for the application protocol open/close handshaking may find the RST problem on active close. As an example: s = connect(remote); send(s, data); close(s); For a program flow like above, a TCP/IP stack like that described above does not guarantee that all the data arrives to the other application if unread data has arrived at this end. Connection termination TCP\u7684connection termination\u65b9\u5f0f \u603b\u7684\u6765\u8bf4\uff0c\u6709\u4e24\u79cdtermination\u65b9\u5f0f: Connection finish Connection reset\uff08 half-duplex\" TCP close sequence \uff09 \u5728\u4e0b\u9762\u8fd9\u4e24\u7bc7\u6587\u7ae0\u4e2d\uff0c\u90fd\u5bf9\u6b64\u8fdb\u884c\u4e86\u8be6\u7ec6\u8bf4\u660e: miami TCP in a nutshell Connection finish Connections are full duplex, that is, two distinct channels from server to client and from client to server. Either side independently closes its channel. A close is signaled by the FIN flag. The FIN packet is ACK'ed with a sequence number one higher (FIN takes a sequence number ). To close both channels takes four messages, a FIN, its ACK, then the other side's FIN, and its ACK. Here are four scenarios: Half close: Client (or server) sends FIN, and Server ACK's the FIN. Server continues to send data. Eventually the server sends a FIN. Full close: Client (or server) sends FIN, and Server immediately ACK's and informs application of client close. Server requests a close so the next packet is a FIN to the client. Client ACK's Server's FIN. Simultaneous close: Both sides simultaneously send FIN packets. Both sides will respond with ACK's and the connection is fully closed. After full closure, a TCP connection is required to wait for twice the maximum segment lifetime , called the 2MSL wait . This prevents old packets confusing new connections, if a new connection is immediately created using old port and IP numbers. It also aids in completing the close. The sender of the last ACK does not know if the ACK was recieved. The last ACK is not ACK'ed, by definition of being last. If a re-FIN is not received in 2MSL, it can be assumed that the last ACK was heard and accepted. NOTE: \u4e0a\u9762\u89e3\u91ca\u4e86\u6267\u884c 2MSL wait \u7684\u539f\u56e0\uff0c\u7b80\u800c\u8a00\u4e4b\u6709\u4e24\u70b9: prevents old packets confusing new connections aids in completing the close Connection reset A packet with RST flag set aborts (resets) the connection. A SYN to a non-listening port will be ack'ed, but the ACK packet will have the RST flag set. The initiating party will immediately abort. A packet with RST set can be sent during a communication, for example, if an invalid sequence number is received. The connection is immediately aborted by both parties. A RST is not ACK'ed. NOTE: \u201cA RST is not ACK'ed\u201d\u5176\u5b9e\u5c31\u662f\u5728freesoft 4.2.2.13 Closing a Connection: RFC-793 Section 3.5 \u4e2d\u6240\u8bf4\u7684\u201cthe connection state is immediately discarded\u201d\u3002 freesoft 4.2.2.13 Closing a Connection: RFC-793 Section 3.5 A TCP connection may terminate in two ways: (1) the normal TCP close sequence using a FIN handshake (2) an \"abort\" in which one or more RST segments are sent and the connection state is immediately discarded. If a TCP connection is closed by the remote site, the local application MUST be informed whether it closed normally or was aborted . The normal TCP close sequence delivers buffered data reliably in both directions. Since the two directions of a TCP connection are closed independently, it is possible for a connection to be \" half closed ,\" i.e., closed in only one direction, and a host is permitted to continue sending data in the open direction on a half-closed connection . A host MAY implement a \"half-duplex\" TCP close sequence , so that an application that has called(\u8c03\u7528) CLOSE cannot continue to read data from the connection. If such a host issues a CLOSE call while received data is still pending in TCP, or if new data is received after CLOSE is called, its TCP SHOULD send a RST to show that data was lost. NOTE: \u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u4e00\u4e2aendpoint\u8c03\u7528\u4e86CLOSE \u540e\uff0c\u5982\u679c\u8fd8\u6536\u5230\u4e86data\uff0c\u5219TCP\u4f1a\u53d1\u9001\u4e00\u4e2aRST\u3002\u8fd9\u4e2aRST\u662f\u4e0d\u9700\u8981ACK\u7684\uff0c\u8fd9\u5c31\u662f**\"half-duplex\" TCP close**\u7684\u542b\u4e49\u3002\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u5728wikipedia Transmission Control Protocol \u76844.2 Connection termination\u4e2d\u4e5f\u5e94\u7528\u4e86\u3002 When a connection is closed actively, it MUST linger\uff08\u5f98\u5f8a\uff09 in TIME-WAIT state for a time 2xMSL (Maximum Segment Lifetime). However, it MAY accept a new SYN from the remote TCP to reopen the connection directly from TIME-WAIT state, if it: assigns its initial sequence number for the new connection to be larger than the largest sequence number it used on the previous connection incarnation, and returns to TIME-WAIT state if the SYN turns out to be an old duplicate. DISCUSSION: TCP's full-duplex data-preserving close is a feature that is not included in the analogous ISO transport protocol TP4. Some systems have not implemented half-closed connections, presumably\uff08\u5927\u6982\uff09 because they do not fit into the I/O model of their particular operating system. On these systems, once an application has called CLOSE, it can no longer read input data from the connection; this is referred to as a \"half-duplex\" TCP close sequence . The graceful close algorithm of TCP requires that the connection state remain defined on (at least) one end of the connection, for a timeout period of 2xMSL, i.e., 4 minutes. During this period, the (remote socket, local socket) pair that defines the connection is busy and cannot be reused. To shorten the time that a given port pair is tied up, some TCPs allow a new SYN to be accepted in TIME-WAIT state. serverfault Use of TCP FIN and TCP RST A TCP is a reliable protocol. So in any case the message should not be lost in any direction, during the full life-cycle of a TCP connection. Connection termination is the last part. So TCP should make sure that all packets were delivered before closing the connection. FIN is used to close TCP connections gracefully in each direction, while TCP RST is used in a scenario where TCP connections cannot recover from errors and the connection needs to reset forcibly. As per this tcp connection termination article , RSET is used in abnormal conditions. TODO stackoverflow FIN vs RST in TCP connections stackoverflow What causes a TCP/IP reset (RST) flag to be sent? github moby half-duplex TCP FIN not working with published ports #27539 cspsprotocol Tcp Connection Termination 2MSL wait \u5728\u4e0b\u9762\u6587\u7ae0\u4e2d\uff0c\u90fd\u5bf9\u6b64\u8fdb\u884c\u4e86\u6df1\u5165\u8bf4\u660e: miami TCP in a nutshell freesoft 4.2.2.13 Closing a Connection: RFC-793 Section 3.5 wikipedia Maximum segment lifetime Maximum segment lifetime is the time a TCP segment can exist in the internetwork system. It is arbitrarily defined to be 2 minutes long.[ 1] The Maximum Segment Lifetime value is used to determine the TIME_WAIT interval (2*MSL) Half open and half close superuser what is TCP Half Open Connection and TCP half closed connection A This post expands on half closed connections. For half open connections see KContreau's correct description. What are Half Closed Connections? Or: It's Not a Bug--it's a Feature! Every TCP connection consists of two half-connection which are closed independently of each other. So if one end sends a FIN, then the other end is free to just ACK that FIN (instead of FIN+ACK-ing it), which signals the FIN-sending end that it still has data to send. So both ends end up in a stable data transfer state other than ESTABLISHED --namely FIN_WAIT_2 (for the receiving end) and CLOSE_WAIT (for the sending end). Such a connection is said to be half closed and TCP is actually designed to support those scenarios, so half closed connections is a TCP feature. The History of Half Closed Connection While RFC 793 only describes the raw mechanism without even mentioning the term \"half closed\", RFC 1122 elaborates(\u8be6\u7ec6\u63cf\u8ff0) on that matter in section 4.2.2.13. You may wonder who the hell needs that feature. The designers of TCP also implemented the TCP/IP for the Unix system and, like every Unix user, loved I/O redirection . According to W. Stevens (TCP/IP illustrated, Section 18.5) the desire to I/O-redirect TCP streams was the motivation to introduce the feature. It allows the FIN ack take the role of or be translated as EOF. So it's basically a feature that allows you to casually create impomptu request/response-style interaction on the application layer, where the FIN signals \"end of request\". wikipedia TCP half-open","title":"Connection-termination"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#tcp#connection#termination","text":"","title":"TCP connection termination"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#wikipedia#transmission#control#protocol#42#connection#termination","text":"NOTE: \u5728\u6587\u7ae0 Network\\Theory\\TCP\\TCP-connection-termination.md \u4e2d\u5bf9connection termination\u8fdb\u884c\u4e86\u8865\u5145\uff0c\u5176\u4e2d\u89e3\u91ca\u672c\u6bb5\u4e2d\u5f88\u591a\u6ca1\u6709\u8bf4\u660e\u6e05\u695a\u7684\u95ee\u9898: RST \u3001 half-duplex close sequence half-open\u3001half-close 2MSL wait The connection termination phase uses a four-way handshake , with each side of the connection terminating independently. When an endpoint wishes to stop its half of the connection, it transmits a FIN packet , which the other end acknowledges with an ACK . Therefore, a typical tear-down requires a pair of FIN and ACK segments from each TCP endpoint ( four-way handshake ). After the side that (\u5f15\u5bfc\u5b9a\u8bed\u4ece\u53e5) sent the first FIN has responded with the final ACK , it waits for a timeout before finally closing the connection, during which time the local port is unavailable for new connections; this prevents confusion due to delayed packets being delivered during subsequent connections. NOTE: \u6700\u540e\u4e00\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a\u5728\u8fd9\u6bb5\u65f6\u95f4\u5185\uff0c\u8fd9\u4e2aport\u662f\u4e0d\u80fd\u591f\u7528\u4e8e\u65b0\u7684connection\u7684\uff0c\u8fd9\u6837\u505a\u7684\u539f\u56e0\u662f\uff1a\u5982\u679c\u5141\u8bb8\uff0c\u53ef\u80fd\u5bfc\u81f4delayed packet\u88ab\u540e\u7eed\u5728\u8fd9\u4e2aport\u4e0a\u7684connection\u8fdb\u884c\u4f20\u8f93\uff1b NOTE: why connection establishment\u4f7f\u7528three-way handshake\uff0c\u800cconnection termination\u4f7f\u7528four-wary handshake\uff1f\u6211\u60f3\u8fd9\u5176\u4e2d\u7684\u5dee\u522b\u5728\u4e8e\u4f20\u8f93buffer\u4e2d\u7684\u6570\u636e\uff1b A connection can be \"half-open\" , in which case one side has terminated its end, but the other has not. The side that has terminated can no longer send any data into the connection, but the other side can. The terminating side should continue reading the data until the other side terminates as well. It is also possible to terminate the connection by a 3-way handshake, when host A sends a FIN and host B replies with a FIN & ACK (merely combines 2 steps into one) and host A replies with an ACK .[ 14] Some host TCP stacks may implement a half-duplex close sequence , as Linux or HP-UX do. If such a host actively closes a connection but still has not read all the incoming data the stack already received from the link, this host sends a RST instead of a FIN (Section 4.2.2.13 in RFC 1122 ). This allows a TCP application to be sure the remote application has read all the data the former sent\u2014waiting the FIN from the remote side, when it actively closes the connection. But the remote TCP stack cannot distinguish between a Connection Aborting RST and Data Loss RST . Both cause the remote stack to lose all the data received. Some application protocols using the TCP open/close handshaking for the application protocol open/close handshaking may find the RST problem on active close. As an example: s = connect(remote); send(s, data); close(s); For a program flow like above, a TCP/IP stack like that described above does not guarantee that all the data arrives to the other application if unread data has arrived at this end. Connection termination","title":"wikipedia Transmission Control Protocol # 4.2 Connection termination"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#tcpconnection#termination","text":"\u603b\u7684\u6765\u8bf4\uff0c\u6709\u4e24\u79cdtermination\u65b9\u5f0f: Connection finish Connection reset\uff08 half-duplex\" TCP close sequence \uff09 \u5728\u4e0b\u9762\u8fd9\u4e24\u7bc7\u6587\u7ae0\u4e2d\uff0c\u90fd\u5bf9\u6b64\u8fdb\u884c\u4e86\u8be6\u7ec6\u8bf4\u660e:","title":"TCP\u7684connection termination\u65b9\u5f0f"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#miami#tcp#in#a#nutshell","text":"","title":"miami TCP in a nutshell"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#connection#finish","text":"Connections are full duplex, that is, two distinct channels from server to client and from client to server. Either side independently closes its channel. A close is signaled by the FIN flag. The FIN packet is ACK'ed with a sequence number one higher (FIN takes a sequence number ). To close both channels takes four messages, a FIN, its ACK, then the other side's FIN, and its ACK. Here are four scenarios: Half close: Client (or server) sends FIN, and Server ACK's the FIN. Server continues to send data. Eventually the server sends a FIN. Full close: Client (or server) sends FIN, and Server immediately ACK's and informs application of client close. Server requests a close so the next packet is a FIN to the client. Client ACK's Server's FIN. Simultaneous close: Both sides simultaneously send FIN packets. Both sides will respond with ACK's and the connection is fully closed. After full closure, a TCP connection is required to wait for twice the maximum segment lifetime , called the 2MSL wait . This prevents old packets confusing new connections, if a new connection is immediately created using old port and IP numbers. It also aids in completing the close. The sender of the last ACK does not know if the ACK was recieved. The last ACK is not ACK'ed, by definition of being last. If a re-FIN is not received in 2MSL, it can be assumed that the last ACK was heard and accepted. NOTE: \u4e0a\u9762\u89e3\u91ca\u4e86\u6267\u884c 2MSL wait \u7684\u539f\u56e0\uff0c\u7b80\u800c\u8a00\u4e4b\u6709\u4e24\u70b9: prevents old packets confusing new connections aids in completing the close","title":"Connection finish"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#connection#reset","text":"A packet with RST flag set aborts (resets) the connection. A SYN to a non-listening port will be ack'ed, but the ACK packet will have the RST flag set. The initiating party will immediately abort. A packet with RST set can be sent during a communication, for example, if an invalid sequence number is received. The connection is immediately aborted by both parties. A RST is not ACK'ed. NOTE: \u201cA RST is not ACK'ed\u201d\u5176\u5b9e\u5c31\u662f\u5728freesoft 4.2.2.13 Closing a Connection: RFC-793 Section 3.5 \u4e2d\u6240\u8bf4\u7684\u201cthe connection state is immediately discarded\u201d\u3002","title":"Connection reset"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#freesoft#42213#closing#a#connection#rfc-793#section#35","text":"A TCP connection may terminate in two ways: (1) the normal TCP close sequence using a FIN handshake (2) an \"abort\" in which one or more RST segments are sent and the connection state is immediately discarded. If a TCP connection is closed by the remote site, the local application MUST be informed whether it closed normally or was aborted . The normal TCP close sequence delivers buffered data reliably in both directions. Since the two directions of a TCP connection are closed independently, it is possible for a connection to be \" half closed ,\" i.e., closed in only one direction, and a host is permitted to continue sending data in the open direction on a half-closed connection . A host MAY implement a \"half-duplex\" TCP close sequence , so that an application that has called(\u8c03\u7528) CLOSE cannot continue to read data from the connection. If such a host issues a CLOSE call while received data is still pending in TCP, or if new data is received after CLOSE is called, its TCP SHOULD send a RST to show that data was lost. NOTE: \u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u4e00\u4e2aendpoint\u8c03\u7528\u4e86CLOSE \u540e\uff0c\u5982\u679c\u8fd8\u6536\u5230\u4e86data\uff0c\u5219TCP\u4f1a\u53d1\u9001\u4e00\u4e2aRST\u3002\u8fd9\u4e2aRST\u662f\u4e0d\u9700\u8981ACK\u7684\uff0c\u8fd9\u5c31\u662f**\"half-duplex\" TCP close**\u7684\u542b\u4e49\u3002\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u5728wikipedia Transmission Control Protocol \u76844.2 Connection termination\u4e2d\u4e5f\u5e94\u7528\u4e86\u3002 When a connection is closed actively, it MUST linger\uff08\u5f98\u5f8a\uff09 in TIME-WAIT state for a time 2xMSL (Maximum Segment Lifetime). However, it MAY accept a new SYN from the remote TCP to reopen the connection directly from TIME-WAIT state, if it: assigns its initial sequence number for the new connection to be larger than the largest sequence number it used on the previous connection incarnation, and returns to TIME-WAIT state if the SYN turns out to be an old duplicate. DISCUSSION: TCP's full-duplex data-preserving close is a feature that is not included in the analogous ISO transport protocol TP4. Some systems have not implemented half-closed connections, presumably\uff08\u5927\u6982\uff09 because they do not fit into the I/O model of their particular operating system. On these systems, once an application has called CLOSE, it can no longer read input data from the connection; this is referred to as a \"half-duplex\" TCP close sequence . The graceful close algorithm of TCP requires that the connection state remain defined on (at least) one end of the connection, for a timeout period of 2xMSL, i.e., 4 minutes. During this period, the (remote socket, local socket) pair that defines the connection is busy and cannot be reused. To shorten the time that a given port pair is tied up, some TCPs allow a new SYN to be accepted in TIME-WAIT state.","title":"freesoft 4.2.2.13 Closing a Connection: RFC-793 Section 3.5"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#serverfault#use#of#tcp#fin#and#tcp#rst","text":"A TCP is a reliable protocol. So in any case the message should not be lost in any direction, during the full life-cycle of a TCP connection. Connection termination is the last part. So TCP should make sure that all packets were delivered before closing the connection. FIN is used to close TCP connections gracefully in each direction, while TCP RST is used in a scenario where TCP connections cannot recover from errors and the connection needs to reset forcibly. As per this tcp connection termination article , RSET is used in abnormal conditions.","title":"serverfault Use of TCP FIN and TCP RST"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#todo","text":"stackoverflow FIN vs RST in TCP connections stackoverflow What causes a TCP/IP reset (RST) flag to be sent? github moby half-duplex TCP FIN not working with published ports #27539 cspsprotocol Tcp Connection Termination","title":"TODO"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#2msl#wait","text":"\u5728\u4e0b\u9762\u6587\u7ae0\u4e2d\uff0c\u90fd\u5bf9\u6b64\u8fdb\u884c\u4e86\u6df1\u5165\u8bf4\u660e: miami TCP in a nutshell freesoft 4.2.2.13 Closing a Connection: RFC-793 Section 3.5","title":"2MSL wait"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#wikipedia#maximum#segment#lifetime","text":"Maximum segment lifetime is the time a TCP segment can exist in the internetwork system. It is arbitrarily defined to be 2 minutes long.[ 1] The Maximum Segment Lifetime value is used to determine the TIME_WAIT interval (2*MSL)","title":"wikipedia Maximum segment lifetime"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#half#open#and#half#close","text":"","title":"Half open and half close"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#superuser#what#is#tcp#half#open#connection#and#tcp#half#closed#connection","text":"A This post expands on half closed connections. For half open connections see KContreau's correct description.","title":"superuser what is TCP Half Open Connection and TCP half closed connection"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#what#are#half#closed#connections#or#its#not#a#bug--its#a#feature","text":"Every TCP connection consists of two half-connection which are closed independently of each other. So if one end sends a FIN, then the other end is free to just ACK that FIN (instead of FIN+ACK-ing it), which signals the FIN-sending end that it still has data to send. So both ends end up in a stable data transfer state other than ESTABLISHED --namely FIN_WAIT_2 (for the receiving end) and CLOSE_WAIT (for the sending end). Such a connection is said to be half closed and TCP is actually designed to support those scenarios, so half closed connections is a TCP feature.","title":"What are Half Closed Connections? Or: It's Not a Bug--it's a Feature!"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#the#history#of#half#closed#connection","text":"While RFC 793 only describes the raw mechanism without even mentioning the term \"half closed\", RFC 1122 elaborates(\u8be6\u7ec6\u63cf\u8ff0) on that matter in section 4.2.2.13. You may wonder who the hell needs that feature. The designers of TCP also implemented the TCP/IP for the Unix system and, like every Unix user, loved I/O redirection . According to W. Stevens (TCP/IP illustrated, Section 18.5) the desire to I/O-redirect TCP streams was the motivation to introduce the feature. It allows the FIN ack take the role of or be translated as EOF. So it's basically a feature that allows you to casually create impomptu request/response-style interaction on the application layer, where the FIN signals \"end of request\".","title":"The History of Half Closed Connection"},{"location":"Network/Protocol/TCP/TCP-connection/Connection-termination/#wikipedia#tcp#half-open","text":"","title":"wikipedia TCP half-open"},{"location":"Network/Protocol/TCP/TCP-data-transfer/","text":"TCP data transfer \u672c\u7ae0\u8ba8\u8bbaTCP\u6570\u636e\u53d1\u9001\u76f8\u5173\u5185\u5bb9\u3002 wikipedia Transmission Control Protocol # 4.4 Data transfer NOTE: TCP\u6570\u636e\u4f20\u8f93\u7684\u6838\u5fc3\u7279\u6027 The Transmission Control Protocol differs in several key features from the User Datagram Protocol : features \u6ce8\u89e3 Ordered data transfer \u5728\u4e0b\u9762\u7684\u201cReliable transmission\u201d\u4f1a\u8fdb\u884c\u8be6\u7ec6\u4ecb\u7ecd Retransmission of lost packets \u7b80\u5355\u6765\u8bf4\u5c31\u662f\u201c\u8865\u6f0f\u201d Error-free data transfer \u65e0\u9519\u4f20\u8f93 Flow control \u6d41\u63a7 Congestion control \u62e5\u585e\u63a7\u5236 NOTE: \u4e0b\u9762\u5c06\u4e0a\u8ff0Ordered data transfer\u3001Retransmission of lost packets\u3001Error-free data transfer\u7edf\u79f0\u4e3aReliable transmission\u3002 Reliable transmission NOTE: TCP\u662f\u5426\u4f1a\u7b49\u6536\u5230ACK\u540e\uff0c\u624d\u4f20\u4e0b\u4e00\u4e2asegment\uff1f Reliability is achieved by the sender detecting lost data and retransmitting it. TCP uses two primary techniques to identify loss: Retransmission timeout (abbreviated as RTO) Duplicate cumulative acknowledgements (DupAcks). Dupack-based retransmission NOTE: Timeout-based retransmission Error detection Implementation\u7efc\u8ff0 \u53c2\u8003: 1) csdn TCP\u5982\u4f55\u4fdd\u8bc1\u6d88\u606f\u987a\u5e8f\u4ee5\u53ca\u53ef\u9760\u6027\u5230\u8fbe 2) csdn \u3010\u7f51\u7edc\u3011TCP\u8fde\u63a5\u7684\u987a\u5e8f\u95ee\u9898\u3001\u4e22\u5305\u95ee\u9898\u3001\u6d41\u91cf\u63a7\u5236\u3001\u62e5\u585e\u63a7\u5236\u95ee\u9898 Ordered data transfer TCP data transfer\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684feature\u662f: ordered\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0cTCP\u53ea\u80fd\u591f\u4fdd\u8bc1\u5728\u540c\u4e00\u4e2a\u8fde\u63a5\u5185\u7684ordered\uff0c\u4e24\u4e2a\u8fde\u63a5\u4e4b\u95f4\uff0cTCP\u65e0\u6cd5\u4fdd\u8bc1\u3002 Implementation \u6211\u4eec\u9700\u8981\u8003\u8651 TCP data transfer\u7684ordered\u7279\u6027\u7684\u5b9e\u73b0\u3002 csdn TCP\u534f\u8bae\u5982\u4f55\u6765\u4fdd\u8bc1\u4f20\u8f93\u7684\u53ef\u9760\u6027\u548c\u6570\u636e\u7684\u987a\u5e8f\u6027 : \u4fdd\u8bc1\u6570\u636e\u7684\u987a\u5e8f\u6027 \uff1a \u65e2\u7136TCP\u62a5\u6587\u6bb5\u4f5c\u4e3aIP\u6570\u636e\u62a5\u6765\u4f20\u8f93\uff0c\u800cIP\u6570\u636e\u62a5\u7684\u5230\u8fbe\u53ef\u80fd\u4f1a\u5931\u5e8f\uff0c\u56e0\u6b64TCP\u62a5\u6587\u6bb5\u7684\u5230\u8fbe\u4e5f\u53ef\u80fd\u4f1a\u5931\u5e8f\u3002\u5982\u679c\u5fc5\u8981\uff0cTCP\u5c06\u5bf9\u6536\u5230\u7684\u6570\u636e\u8fdb\u884c**\u91cd\u65b0\u6392\u5e8f**\uff0c\u5c06\u6536\u5230\u7684\u6570\u636e\u4ee5\u6b63\u786e\u7684\u987a\u5e8f\u4ea4\u7ed9\u5e94\u7528\u5c42\u3002 ( \u5bf9\u5931\u5e8f\u6570\u636e\u8fdb\u884c\u91cd\u65b0\u6392\u5e8f\uff0c\u7136\u540e\u624d\u4ea4\u7ed9\u5e94\u7528\u5c42 ) See also csdn \u5173\u4e8e\u540c\u4e00\u6761TCP\u94fe\u63a5\u6570\u636e\u5305\u5230\u8fbe\u987a\u5e8f\u7684\u95ee\u9898 \u6211\u521a\u5f00\u59cb\u4e5f\u72af\u4e86\u548c\u8fd9\u7bc7\u6587\u7ae0\u7684\u4f5c\u8005\u76f8\u540c\u7684\u9519\u8bef\u3002 Reliable data transfer csdn TCP\u534f\u8bae\u5982\u4f55\u6765\u4fdd\u8bc1\u4f20\u8f93\u7684\u53ef\u9760\u6027\u548c\u6570\u636e\u7684\u987a\u5e8f\u6027 : TCP\u63d0\u4f9b\u4e00\u79cd\u9762\u5411\u8fde\u63a5\u7684\u3001\u53ef\u9760\u7684\u5b57\u8282\u6d41\u670d\u52a1\u3002 \u9762\u5411\u8fde\u63a5\uff1a\u610f\u5473\u7740\u4e24\u4e2a\u4f7f\u7528TCP\u7684\u5e94\u7528\uff08\u901a\u5e38\u662f\u4e00\u4e2a\u5ba2\u6237\u548c\u4e00\u4e2a\u670d\u52a1\u5668\uff09\u5728\u5f7c\u6b64\u4ea4\u6362\u6570\u636e\u4e4b\u524d\u5fc5\u987b\u5148\u5efa\u7acb\u4e00\u4e2aTCP\u8fde\u63a5\u3002\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e2d\uff0c\u4ec5\u6709\u4e24\u65b9\u8fdb\u884c\u5f7c\u6b64\u901a\u4fe1\u3002\u5e7f\u64ad\u548c\u591a\u64ad\u4e0d\u80fd\u7528\u4e8eTCP\u3002 \u5e94\u7528\u6570\u636e\u88ab\u5206\u5272\u6210TCP\u8ba4\u4e3a\u6700\u9002\u5408\u53d1\u9001\u7684\u5206\u7ec4\uff0cA\u4e3a\u53d1\u9001\u65b9\uff0cB\u4e3a\u63a5\u6536\u65b9\u3002**\u53ef\u9760\u4f20\u8f93\u539f\u7406**\u662f\u4ee5\u4e0b\u4e24\u4e2a\u534f\u8bae\uff1a 1\u3001 \u505c\u6b62\u7b49\u5f85\u534f\u8bae \uff1a\u6bcf\u53d1\u9001\u5b8c\u4e00\u4e2a\u5206\u7ec4\uff0c\u5c31\u505c\u6b62\u53d1\u9001\uff0c\u7b49\u5f85\u5bf9\u65b9\u7684\u786e\u8ba4\uff0c\u6536\u5230\u786e\u8ba4\u540e\u518d\u53d1\u9001\u4e0b\u4e00\u4e2a\u5206\u7ec4\u3002 (1) \u51fa\u73b0\u5dee\u9519 \uff0c\u91c7\u7528**\u8d85\u65f6\u91cd\u4f20**\u529f\u80fd\uff0c\u82e5B\u68c0\u6d4b\u5230\u6536\u5230\u7684\u5206\u7ec4\u6709\u9519\uff0c\u5c31\u4e22\u5f03\u6b64\u5206\u7ec4\uff0c\u4ec0\u4e48\u4e5f\u4e0d\u505a(TCP\u5c06\u4fdd\u6301\u5b83\u9996\u90e8\u548c\u6570\u636e\u7684\u68c0\u9a8c\u548c\u3002\u8fd9\u662f\u4e00\u4e2a\u7aef\u5230\u7aef\u7684\u68c0\u9a8c\u548c\uff0c\u76ee\u7684\u662f\u68c0\u6d4b\u6570\u636e\u5728\u4f20\u8f93\u8fc7\u7a0b\u4e2d\u7684\u4efb\u4f55\u53d8\u5316)\uff0cA\u5728\u53d1\u9001\u540e\u5c31\u8bbe\u7f6e\u4e00\u4e2a\u8d85\u65f6\u5b9a\u65f6\u5668\uff0c\u82e5\u8d85\u8fc7\u5b9a\u65f6\u5668\u65f6\u95f4\u8fd8\u6ca1\u6709\u6536\u5230\u786e\u8ba4\uff0c\u5c31\u91cd\u65b0\u53d1\u9001\u6b64\u5206\u7ec4\uff08\u6ce8\u610f\uff1aA\u53d1\u9001\u5b8c\u4e00\u4e2a\u5206\u7ec4\u540e\u5fc5\u987b\u4fdd\u7559\u526f\u672c\uff0c\u4e3a\u8d85\u65f6\u91cd\u4f20\u4f7f\u7528\uff1b\u5206\u7ec4\u548c\u786e\u8ba4\u5206\u7ec4\u90fd\u8981\u8fdb\u884c\u7f16\u53f7\uff1b\u8d85\u65f6\u91cd\u4f20\u65f6\u95f4\u5fc5\u987b\u5927\u4e8e\u4e00\u4e2a\u5f80\u8fd4\u65f6\u95f4\uff09\uff1b (2) \u786e\u8ba4\u4e22\u5931\u548c\u786e\u8ba4\u8fdf\u5230 \uff1aB\u53d1\u9001\u7684\u786e\u8ba4\u4e22\u5931\u6216\u8fdf\u5230\u540e\uff0cA\u8fc7\u4e86\u8d85\u65f6\u5b9a\u65f6\u5668\u7684\u65f6\u95f4\uff0c\u5c31\u91cd\u65b0\u53d1\u9001\u5206\u7ec4\uff0cB\u4e22\u5f03\u8fd9\u4e2a\u5206\u7ec4\uff0c\u540c\u65f6\u5411A\u53d1\u9001\u786e\u8ba4\uff1b \u4e0a\u8ff0\u7684\u786e\u8ba4\u548c\u91cd\u4f20\u673a\u5236\uff0c\u79f0\u4e3a\u81ea\u52a8\u91cd\u4f20\u8bf7\u6c42ARQ\u534f\u8bae\uff1b 2\u3001 \u8fde\u7eedARQ\u534f\u8bae \uff1a\u5229\u7528\u53d1\u9001\u7a97\u53e3\uff0c\u4f4d\u4e8e\u53d1\u9001\u7a97\u53e3\u5185\u7684\u6240\u6709\u5206\u7ec4\u90fd\u53ef\u4ee5\u8fde\u7eed\u53d1\u9001\u51fa\u53bb\uff0c\u800c\u4e0d\u9700\u8981\u7b49\u5f85\u5bf9\u65b9\u7684\u786e\u8ba4\u3002A\u6bcf\u6536\u5230\u4e00\u4e2a\u786e\u8ba4\uff0c\u5c31\u628a\u53d1\u9001\u7a97\u53e3\u5411\u524d\u6ed1\u52a8\u4e00\u4e2a\u5206\u7ec4\u7684\u4f4d\u7f6e\u3002B\u91c7\u7528\u7d2f\u79ef\u786e\u8ba4\u65b9\u5f0f\uff0c \u5bf9\u6309\u5e8f\u5230\u8fbe\u7684\u6700\u540e\u4e00\u4e2a\u5206\u7ec4\u53d1\u9001\u786e\u8ba4 \uff0c\u5c31\u8868\u793a\u5230\u8fd9\u4e2a\u5206\u7ec4\u4e4b\u524d\u7684\u6240\u6709\u5206\u7ec4\u90fd\u6536\u5230\u4e86\u3002 Flow control \u6d41\u91cf\u63a7\u5236 Congestion control \u62e5\u585e\u63a7\u5236 Stream oriented and TCP data transfer TODO: \u9700\u8981\u6dfb\u52a0\u5bf9stream\u7684\u8bf4\u660e: stream\u662f\u4e00\u79cd\u975e\u5e38\u5f3a\u5927\u7684\u62bd\u8c61\u3002 Stream-oriented\u662fTCP\u7684\u6838\u5fc3\u7279\u6027\uff0c\u5b83\u51b3\u5b9a\u4e86TCP\u7684\u901a\u4fe1\u662f\u65e0**\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c**\u7684(\u9762\u5411\u6d41\u7684\u901a\u4fe1\u662f\u65e0**\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c**\u7684)\uff0c\u8fd9\u6837\uff0c**\u63a5\u6536\u7aef**\u5fc5\u987b\u63d0\u4f9b\u79d1\u5b66\u7684\u62c6\u5305\u673a\u5236\u3002 NOTE: \u4e0a\u8ff0\"\u9762\u5411\u6d41\u7684\u901a\u4fe1\u662f\u65e0**\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c**\u7684\"\u662f\u6211\u5728\u9605\u8bfbcsdn Socket TCP\u7c98\u5305\u3001\u591a\u5305\u548c\u5c11\u5305, \u65ad\u5305 \u65f6\uff0c\u5176\u4e2d\u7684\u8bba\u8ff0\u3002 \u5173\u4e8e**\u6d88\u606f\u8fb9\u754c**\uff0c\u53c2\u89c1 Network\\Theory\\Message-boundary \u3002 zhidao tcp\u6bcf\u4e00\u6b21send\u52a8\u4f5c\uff0c\u5176\u53d1\u9001\u7684\u5b57\u8282\u90fd\u662f\u6309\u987a\u5e8f\u5230\u8fbereceive\u7aef\u7684\u5417? : \u56e0\u4e3aTCP\u8fde\u63a5\u4e3a\u53ef\u9760\u3001\u6709\u5e8f\u7684\u6d41\u5f0f\u901a\u9053\uff0cbai\u6545\u4f20\u8f93\u7684\u6570\u636e\u4e0d\u4f1a\u4e22\u5931\u6216\u4e71\u5e8f\u3002 \u4f46\u662f\uff0c\u5982\u679c\u53d1\u9001\u6bd4\u8f83\u5927\u7684\u6570\u636e\u5757\uff08\u4f8b\u598265535\u5b57\u8282\uff09\uff0c\u63a5\u6536\u7aef\u53ef\u80fd\u5206\u51e0\u6b21\u6536\u5230\u6570\u636e\uff0c\u5373\u6bcf\u6b21recv()\u6536\u5230\u4e00\u90e8\u5206\u6570\u636e\u3002\u4ea7\u751f\u8fd9\u4e00\u7279\u6027\u7684\u539f\u56e0\u662f\uff1aTCP\u534f\u8bae\u6808\u901a\u5e38\u4f7f\u7528\u6536\u53d1\u7a97\u53e3\u534f\u5546\u673a\u5236\u9ad8\u6548\u4f20\u9012\u6570\u636e\uff0c\u6bcf\u6b21\u5b9e\u9645\u53d1\u9001\u7684\u6570\u636e\u91cf\u53d7\u7a97\u53e3\u5927\u5c0f\u63a7\u5236\uff08\u7a97\u53e3\u5927\u5c0f\u4e0e\u7f51\u7edc\u72b6\u51b5\u3001\u534f\u8bae\u6808\u63a5\u6536\u7a7a\u95f4\u7b49\u56e0\u7d20\u6709\u5173\uff09\u3002 \u540c\u6837\uff0c\u5982\u679c\u8fde\u7eed\u591a\u6b21\u53d1\u9001\u51e0\u7ec4\u5c0f\u6570\u636e\uff08\u6bd4\u5982\u6bcf\u6b21\u51e0\u4e2a\u5b57\u8282\uff09\uff0c\u63a5\u6536\u7aef\u53ef\u80fd\u4e00\u6b21\u6027\u6536\u5230\u6240\u6709\u6570\u636e\u3002\u8fd9\u662fTCP\u534f\u8bae\u6808\u53e6\u5916\u4e00\u4e2a\u7279\u6027\uff0c\u5373\u5bf9\u4e0a\u5c42\u6570\u636e\u8fdb\u884c\u62fc\u63a5\uff08 \u7c98\u5305 \uff09\u4ee5\u51cf\u5c11\u7f51\u7edc\u4ea4\u6362\u6570\u636e\u62a5\u6587\u7684\u9891\u7387\uff0c\u4ee5\u51cf\u5c11\u53cc\u65b9\u4ea4\u4e92\u7b49\u5f85\u6b21\u6570\uff0c\u63d0\u9ad8\u7f51\u7edc\u541e\u5410\u6548\u7387\u3002\u867d\u7136\u8fd9\u4e2a\u7279\u6027\u53ef\u901a\u8fc7socket\u9009\u9879\u63a7\u5236\uff0c\u4f46\u5728\u6bd4\u8f83\u590d\u6742\u7684\u7f51\u7edc\u73af\u5883\u4e0b\uff0c\u53d1\u9001\u65b9\u5206\u591a\u6b21\u9001\u51fa\u7684\u5c0f\u62a5\u6587\u4ecd\u53ef\u80fd\u88ab\u4e2d\u95f4\u8def\u7531\u8bbe\u5907\u62fc\u63a5\u540e\u4e00\u6b21\u6027\u53d1\u51fa\u3002 \u9274\u4e8e\u4ee5\u4e0a\u7279\u6027\uff0c\u6210\u719f\u7684TCP\u901a\u8baf\u8bbe\u8ba1\u901a\u5e38\u8fd8\u8981\u5f15\u5165\u53e6\u5916\u7684\u6570\u636e\u5c01\u88c5\u673a\u5236\uff0c\u5728\u5e94\u7528\u5c42\u7ed9\u6570\u636e\u589e\u52a0\u5305\u5934\uff0c\u63a5\u6536\u7aef\u6839\u636e**\u5305\u5934**\u5bf9\u6570\u636e\u8fdb\u884c\u7ec4\u88c5\uff08\u53ef\u4f7f\u7528\u73af\u5f62\u961f\u5217\u7b49\u7b97\u6cd5\uff09\uff0c\u4ee5\u4fdd\u8bc1\u901a\u8baf\u6570\u636e\u7684\u903b\u8f91\u8fde\u8d2f\u6027\u3002 \u5176\u5b9e\u9664\u4e86TCP\u534f\u8bae\uff0c\u8fd8\u6709\u5176\u4ed6\u7684\u53ef\u9760\u901a\u8baf\u534f\u8bae\u3002\u8fd9\u4e9b\u534f\u8bae\u6709\u4e9b\u57fa\u4e8e\u6570\u636e\u6d41\uff08\u7c7b\u4f3cTCP\uff09\uff0c\u4e5f\u6709\u7684\u57fa\u4e8e\u6570\u636e\u5305\u5f0f\uff08\u7c7b\u4f3cUDP\uff09\u3002\u8fd9\u7c7b\u534f\u8bae\u6709\u65f6\u4f5c\u4e3a\u7cfb\u7edf\u7ea7\u7ec4\u4ef6\u63d0\u4f9b\uff0c\u4f46\u66f4\u591a\u662f\u4ee5\u5e94\u7528\u5c42\u6269\u5c55\u5e93\u5f62\u5f0f\u5b58\u5728\uff0c\u901a\u5e38\u662f\u5728UDP\u534f\u8bae\u6216\u88f8IP\u5c42\u9762\u8fdb\u884c\u5c01\u88c5\uff0c\u6709\u9700\u8981\u7684\u8bdd\u53ef\u81ea\u884c\u641c\u7d22\u8fd9\u65b9\u9762\u8d44\u6e90\u3002 stackoverflow can one call of recv() receive data from 2 consecutive send() calls? A TCP is a stream oriented protocol. Not message / record / chunk oriented. That is, all that is guaranteed is that if you send a stream, the bytes will get to the other side in the order you sent them. There is no provision(\u89c4\u5b9a) made by RFC 793 or any other document about the number of segments / packets involved. This is in stark(\u5b8c\u5168) contrast with UDP . As @R .. correctly said, in UDP an entire message is sent in one operation (notice the change in terminology: message ). Try to send a giant message (several times larger than the MTU) with TCP ? It's okay, it will split it for you. NOTE: MTU\u5373 Maximum Transmission Unit \uff0c When running on local networks or on localhost you will certainly notice that (generally) one send == one recv . Don't assume that. There are factors that change it dramatically. Among these Nagle Underlying MTU Memory usage (possibly) Timers Many others Of course, not having a correspondence between an a send and a recv is a nuisance and you can't rely on UDP . That is one of the reasons for SCTP . SCTP is a really really interesting protocol and it is message-oriented . Back to TCP , this is a common nuisance. An equally common solution is this: Establish that all packets begin with a fixed-length sequence (say 32 bytes) These 32 bytes contain (possibly among other things) the size of the message that follows When you read any amount of data from the socket, add the data to a buffer specific for that connection. When 32 bytes are reached, read the length you still need to read until you get the message. It is really important to notice how there are really no messages on the wire, only bytes. Once you understand it you will have made a giant leap towards writing network applications. csdn Socket TCP\u7c98\u5305\u3001\u591a\u5305\u548c\u5c11\u5305, \u65ad\u5305 \u63d0\u5230\u901a\u4fe1\uff0c \u6211\u4eec\u9762\u4e34\u90fd\u901a\u4fe1\u534f\u8bae\uff0c\u6570\u636e\u534f\u8bae\u7684\u9009\u62e9\u3002 \u901a\u4fe1\u534f\u8bae\u6211\u4eec\u53ef\u9009\u62e9TCP/UDP\uff1a 1) TCP\uff08transport control protocol\uff0c\u4f20\u8f93\u63a7\u5236\u534f\u8bae\uff09\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u9762\u5411\u6d41\u7684\uff0c\u63d0\u4f9b\u9ad8\u53ef\u9760\u6027\u670d\u52a1\u3002\u6536\u53d1\u4e24\u7aef\uff08\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7aef\uff09\u90fd\u8981\u6709\u4e00\u4e00\u6210\u5bf9\u7684socket\uff0c\u56e0\u6b64\uff0c\u53d1\u9001\u7aef\u4e3a\u4e86\u5c06\u591a\u4e2a\u53d1\u5f80\u63a5\u6536\u7aef\u7684\u5305\uff0c\u66f4\u6709\u6548\u7684\u53d1\u5230\u5bf9\u65b9\uff0c\u4f7f\u7528\u4e86\u4f18\u5316\u65b9\u6cd5\uff08Nagle\u7b97\u6cd5\uff09\uff0c\u5c06\u591a\u6b21\u95f4\u9694\u8f83\u5c0f\u4e14\u6570\u636e\u91cf\u5c0f\u7684\u6570\u636e\uff0c\u5408\u5e76\u6210\u4e00\u4e2a\u5927\u7684\u6570\u636e\u5757\uff0c\u7136\u540e\u8fdb\u884c\u5c01\u5305\u3002\u8fd9\u6837\uff0c\u63a5\u6536\u7aef\uff0c\u5c31\u96be\u4e8e\u5206\u8fa8\u51fa\u6765\u4e86\uff0c\u5fc5\u987b\u63d0\u4f9b\u79d1\u5b66\u7684\u62c6\u5305\u673a\u5236\u3002 \u5373\u9762\u5411\u6d41\u7684\u901a\u4fe1\u662f\u65e0\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c\u7684\u3002 UDP\uff08user datagram protocol\uff0c\u7528\u6237\u6570\u636e\u62a5\u534f\u8bae\uff09\u662f\u65e0\u8fde\u63a5\u7684\uff0c\u9762\u5411\u6d88\u606f\u7684\uff0c\u63d0\u4f9b\u9ad8\u6548\u7387\u670d\u52a1\u3002\u4e0d\u4f1a\u4f7f\u7528\u5757\u7684\u5408\u5e76\u4f18\u5316\u7b97\u6cd5\uff0c, \u7531\u4e8eUDP\u652f\u6301\u7684\u662f\u4e00\u5bf9\u591a\u7684\u6a21\u5f0f\uff0c\u6240\u4ee5\u63a5\u6536\u7aef\u7684skbuff(\u5957\u63a5\u5b57\u7f13\u51b2\u533a\uff09\u91c7\u7528\u4e86\u94fe\u5f0f\u7ed3\u6784\u6765\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u5230\u8fbe\u7684UDP\u5305\uff0c\u5728\u6bcf\u4e2aUDP\u5305\u4e2d\u5c31\u6709\u4e86\u6d88\u606f\u5934\uff08\u6d88\u606f\u6765\u6e90\u5730\u5740\uff0c\u7aef\u53e3\u7b49\u4fe1\u606f\uff09\uff0c\u8fd9\u6837\uff0c\u5bf9\u4e8e\u63a5\u6536\u7aef\u6765\u8bf4\uff0c\u5c31\u5bb9\u6613\u8fdb\u884c\u533a\u5206\u5904\u7406\u4e86\u3002 \u5373\u9762\u5411\u6d88\u606f\u7684\u901a\u4fe1\u662f\u6709\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c\u7684\u3002 csdn socket\u8fde\u63a5---\u591a\u7ebf\u7a0b \u7ebf\u7a0b\u6c60---TCP/IP\u534a\u5305\u3001\u7c98\u5305\u3001\u5206\u5305","title":"Introduction"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#tcp#data#transfer","text":"\u672c\u7ae0\u8ba8\u8bbaTCP\u6570\u636e\u53d1\u9001\u76f8\u5173\u5185\u5bb9\u3002","title":"TCP data transfer"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#wikipedia#transmission#control#protocol#44#data#transfer","text":"NOTE: TCP\u6570\u636e\u4f20\u8f93\u7684\u6838\u5fc3\u7279\u6027 The Transmission Control Protocol differs in several key features from the User Datagram Protocol : features \u6ce8\u89e3 Ordered data transfer \u5728\u4e0b\u9762\u7684\u201cReliable transmission\u201d\u4f1a\u8fdb\u884c\u8be6\u7ec6\u4ecb\u7ecd Retransmission of lost packets \u7b80\u5355\u6765\u8bf4\u5c31\u662f\u201c\u8865\u6f0f\u201d Error-free data transfer \u65e0\u9519\u4f20\u8f93 Flow control \u6d41\u63a7 Congestion control \u62e5\u585e\u63a7\u5236 NOTE: \u4e0b\u9762\u5c06\u4e0a\u8ff0Ordered data transfer\u3001Retransmission of lost packets\u3001Error-free data transfer\u7edf\u79f0\u4e3aReliable transmission\u3002","title":"wikipedia Transmission Control Protocol # 4.4 Data transfer"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#reliable#transmission","text":"NOTE: TCP\u662f\u5426\u4f1a\u7b49\u6536\u5230ACK\u540e\uff0c\u624d\u4f20\u4e0b\u4e00\u4e2asegment\uff1f Reliability is achieved by the sender detecting lost data and retransmitting it. TCP uses two primary techniques to identify loss: Retransmission timeout (abbreviated as RTO) Duplicate cumulative acknowledgements (DupAcks).","title":"Reliable transmission"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#dupack-based#retransmission","text":"NOTE:","title":"Dupack-based retransmission"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#timeout-based#retransmission","text":"","title":"Timeout-based retransmission"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#error#detection","text":"","title":"Error detection"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#implementation","text":"\u53c2\u8003: 1) csdn TCP\u5982\u4f55\u4fdd\u8bc1\u6d88\u606f\u987a\u5e8f\u4ee5\u53ca\u53ef\u9760\u6027\u5230\u8fbe 2) csdn \u3010\u7f51\u7edc\u3011TCP\u8fde\u63a5\u7684\u987a\u5e8f\u95ee\u9898\u3001\u4e22\u5305\u95ee\u9898\u3001\u6d41\u91cf\u63a7\u5236\u3001\u62e5\u585e\u63a7\u5236\u95ee\u9898","title":"Implementation\u7efc\u8ff0"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#ordered#data#transfer","text":"TCP data transfer\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684feature\u662f: ordered\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0cTCP\u53ea\u80fd\u591f\u4fdd\u8bc1\u5728\u540c\u4e00\u4e2a\u8fde\u63a5\u5185\u7684ordered\uff0c\u4e24\u4e2a\u8fde\u63a5\u4e4b\u95f4\uff0cTCP\u65e0\u6cd5\u4fdd\u8bc1\u3002","title":"Ordered data transfer"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#implementation_1","text":"\u6211\u4eec\u9700\u8981\u8003\u8651 TCP data transfer\u7684ordered\u7279\u6027\u7684\u5b9e\u73b0\u3002","title":"Implementation"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#csdn#tcp","text":"\u4fdd\u8bc1\u6570\u636e\u7684\u987a\u5e8f\u6027 \uff1a \u65e2\u7136TCP\u62a5\u6587\u6bb5\u4f5c\u4e3aIP\u6570\u636e\u62a5\u6765\u4f20\u8f93\uff0c\u800cIP\u6570\u636e\u62a5\u7684\u5230\u8fbe\u53ef\u80fd\u4f1a\u5931\u5e8f\uff0c\u56e0\u6b64TCP\u62a5\u6587\u6bb5\u7684\u5230\u8fbe\u4e5f\u53ef\u80fd\u4f1a\u5931\u5e8f\u3002\u5982\u679c\u5fc5\u8981\uff0cTCP\u5c06\u5bf9\u6536\u5230\u7684\u6570\u636e\u8fdb\u884c**\u91cd\u65b0\u6392\u5e8f**\uff0c\u5c06\u6536\u5230\u7684\u6570\u636e\u4ee5\u6b63\u786e\u7684\u987a\u5e8f\u4ea4\u7ed9\u5e94\u7528\u5c42\u3002 ( \u5bf9\u5931\u5e8f\u6570\u636e\u8fdb\u884c\u91cd\u65b0\u6392\u5e8f\uff0c\u7136\u540e\u624d\u4ea4\u7ed9\u5e94\u7528\u5c42 )","title":"csdn TCP\u534f\u8bae\u5982\u4f55\u6765\u4fdd\u8bc1\u4f20\u8f93\u7684\u53ef\u9760\u6027\u548c\u6570\u636e\u7684\u987a\u5e8f\u6027:"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#see#also","text":"csdn \u5173\u4e8e\u540c\u4e00\u6761TCP\u94fe\u63a5\u6570\u636e\u5305\u5230\u8fbe\u987a\u5e8f\u7684\u95ee\u9898 \u6211\u521a\u5f00\u59cb\u4e5f\u72af\u4e86\u548c\u8fd9\u7bc7\u6587\u7ae0\u7684\u4f5c\u8005\u76f8\u540c\u7684\u9519\u8bef\u3002","title":"See also"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#reliable#data#transfer","text":"","title":"Reliable data transfer"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#csdn#tcp_1","text":"TCP\u63d0\u4f9b\u4e00\u79cd\u9762\u5411\u8fde\u63a5\u7684\u3001\u53ef\u9760\u7684\u5b57\u8282\u6d41\u670d\u52a1\u3002 \u9762\u5411\u8fde\u63a5\uff1a\u610f\u5473\u7740\u4e24\u4e2a\u4f7f\u7528TCP\u7684\u5e94\u7528\uff08\u901a\u5e38\u662f\u4e00\u4e2a\u5ba2\u6237\u548c\u4e00\u4e2a\u670d\u52a1\u5668\uff09\u5728\u5f7c\u6b64\u4ea4\u6362\u6570\u636e\u4e4b\u524d\u5fc5\u987b\u5148\u5efa\u7acb\u4e00\u4e2aTCP\u8fde\u63a5\u3002\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e2d\uff0c\u4ec5\u6709\u4e24\u65b9\u8fdb\u884c\u5f7c\u6b64\u901a\u4fe1\u3002\u5e7f\u64ad\u548c\u591a\u64ad\u4e0d\u80fd\u7528\u4e8eTCP\u3002 \u5e94\u7528\u6570\u636e\u88ab\u5206\u5272\u6210TCP\u8ba4\u4e3a\u6700\u9002\u5408\u53d1\u9001\u7684\u5206\u7ec4\uff0cA\u4e3a\u53d1\u9001\u65b9\uff0cB\u4e3a\u63a5\u6536\u65b9\u3002**\u53ef\u9760\u4f20\u8f93\u539f\u7406**\u662f\u4ee5\u4e0b\u4e24\u4e2a\u534f\u8bae\uff1a 1\u3001 \u505c\u6b62\u7b49\u5f85\u534f\u8bae \uff1a\u6bcf\u53d1\u9001\u5b8c\u4e00\u4e2a\u5206\u7ec4\uff0c\u5c31\u505c\u6b62\u53d1\u9001\uff0c\u7b49\u5f85\u5bf9\u65b9\u7684\u786e\u8ba4\uff0c\u6536\u5230\u786e\u8ba4\u540e\u518d\u53d1\u9001\u4e0b\u4e00\u4e2a\u5206\u7ec4\u3002 (1) \u51fa\u73b0\u5dee\u9519 \uff0c\u91c7\u7528**\u8d85\u65f6\u91cd\u4f20**\u529f\u80fd\uff0c\u82e5B\u68c0\u6d4b\u5230\u6536\u5230\u7684\u5206\u7ec4\u6709\u9519\uff0c\u5c31\u4e22\u5f03\u6b64\u5206\u7ec4\uff0c\u4ec0\u4e48\u4e5f\u4e0d\u505a(TCP\u5c06\u4fdd\u6301\u5b83\u9996\u90e8\u548c\u6570\u636e\u7684\u68c0\u9a8c\u548c\u3002\u8fd9\u662f\u4e00\u4e2a\u7aef\u5230\u7aef\u7684\u68c0\u9a8c\u548c\uff0c\u76ee\u7684\u662f\u68c0\u6d4b\u6570\u636e\u5728\u4f20\u8f93\u8fc7\u7a0b\u4e2d\u7684\u4efb\u4f55\u53d8\u5316)\uff0cA\u5728\u53d1\u9001\u540e\u5c31\u8bbe\u7f6e\u4e00\u4e2a\u8d85\u65f6\u5b9a\u65f6\u5668\uff0c\u82e5\u8d85\u8fc7\u5b9a\u65f6\u5668\u65f6\u95f4\u8fd8\u6ca1\u6709\u6536\u5230\u786e\u8ba4\uff0c\u5c31\u91cd\u65b0\u53d1\u9001\u6b64\u5206\u7ec4\uff08\u6ce8\u610f\uff1aA\u53d1\u9001\u5b8c\u4e00\u4e2a\u5206\u7ec4\u540e\u5fc5\u987b\u4fdd\u7559\u526f\u672c\uff0c\u4e3a\u8d85\u65f6\u91cd\u4f20\u4f7f\u7528\uff1b\u5206\u7ec4\u548c\u786e\u8ba4\u5206\u7ec4\u90fd\u8981\u8fdb\u884c\u7f16\u53f7\uff1b\u8d85\u65f6\u91cd\u4f20\u65f6\u95f4\u5fc5\u987b\u5927\u4e8e\u4e00\u4e2a\u5f80\u8fd4\u65f6\u95f4\uff09\uff1b (2) \u786e\u8ba4\u4e22\u5931\u548c\u786e\u8ba4\u8fdf\u5230 \uff1aB\u53d1\u9001\u7684\u786e\u8ba4\u4e22\u5931\u6216\u8fdf\u5230\u540e\uff0cA\u8fc7\u4e86\u8d85\u65f6\u5b9a\u65f6\u5668\u7684\u65f6\u95f4\uff0c\u5c31\u91cd\u65b0\u53d1\u9001\u5206\u7ec4\uff0cB\u4e22\u5f03\u8fd9\u4e2a\u5206\u7ec4\uff0c\u540c\u65f6\u5411A\u53d1\u9001\u786e\u8ba4\uff1b \u4e0a\u8ff0\u7684\u786e\u8ba4\u548c\u91cd\u4f20\u673a\u5236\uff0c\u79f0\u4e3a\u81ea\u52a8\u91cd\u4f20\u8bf7\u6c42ARQ\u534f\u8bae\uff1b 2\u3001 \u8fde\u7eedARQ\u534f\u8bae \uff1a\u5229\u7528\u53d1\u9001\u7a97\u53e3\uff0c\u4f4d\u4e8e\u53d1\u9001\u7a97\u53e3\u5185\u7684\u6240\u6709\u5206\u7ec4\u90fd\u53ef\u4ee5\u8fde\u7eed\u53d1\u9001\u51fa\u53bb\uff0c\u800c\u4e0d\u9700\u8981\u7b49\u5f85\u5bf9\u65b9\u7684\u786e\u8ba4\u3002A\u6bcf\u6536\u5230\u4e00\u4e2a\u786e\u8ba4\uff0c\u5c31\u628a\u53d1\u9001\u7a97\u53e3\u5411\u524d\u6ed1\u52a8\u4e00\u4e2a\u5206\u7ec4\u7684\u4f4d\u7f6e\u3002B\u91c7\u7528\u7d2f\u79ef\u786e\u8ba4\u65b9\u5f0f\uff0c \u5bf9\u6309\u5e8f\u5230\u8fbe\u7684\u6700\u540e\u4e00\u4e2a\u5206\u7ec4\u53d1\u9001\u786e\u8ba4 \uff0c\u5c31\u8868\u793a\u5230\u8fd9\u4e2a\u5206\u7ec4\u4e4b\u524d\u7684\u6240\u6709\u5206\u7ec4\u90fd\u6536\u5230\u4e86\u3002","title":"csdn TCP\u534f\u8bae\u5982\u4f55\u6765\u4fdd\u8bc1\u4f20\u8f93\u7684\u53ef\u9760\u6027\u548c\u6570\u636e\u7684\u987a\u5e8f\u6027:"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#flow#control","text":"\u6d41\u91cf\u63a7\u5236","title":"Flow control"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#congestion#control","text":"\u62e5\u585e\u63a7\u5236","title":"Congestion control"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#stream#oriented#and#tcp#data#transfer","text":"TODO: \u9700\u8981\u6dfb\u52a0\u5bf9stream\u7684\u8bf4\u660e: stream\u662f\u4e00\u79cd\u975e\u5e38\u5f3a\u5927\u7684\u62bd\u8c61\u3002 Stream-oriented\u662fTCP\u7684\u6838\u5fc3\u7279\u6027\uff0c\u5b83\u51b3\u5b9a\u4e86TCP\u7684\u901a\u4fe1\u662f\u65e0**\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c**\u7684(\u9762\u5411\u6d41\u7684\u901a\u4fe1\u662f\u65e0**\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c**\u7684)\uff0c\u8fd9\u6837\uff0c**\u63a5\u6536\u7aef**\u5fc5\u987b\u63d0\u4f9b\u79d1\u5b66\u7684\u62c6\u5305\u673a\u5236\u3002 NOTE: \u4e0a\u8ff0\"\u9762\u5411\u6d41\u7684\u901a\u4fe1\u662f\u65e0**\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c**\u7684\"\u662f\u6211\u5728\u9605\u8bfbcsdn Socket TCP\u7c98\u5305\u3001\u591a\u5305\u548c\u5c11\u5305, \u65ad\u5305 \u65f6\uff0c\u5176\u4e2d\u7684\u8bba\u8ff0\u3002 \u5173\u4e8e**\u6d88\u606f\u8fb9\u754c**\uff0c\u53c2\u89c1 Network\\Theory\\Message-boundary \u3002","title":"Stream oriented and TCP data transfer"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#zhidao#tcpsendreceive","text":"\u56e0\u4e3aTCP\u8fde\u63a5\u4e3a\u53ef\u9760\u3001\u6709\u5e8f\u7684\u6d41\u5f0f\u901a\u9053\uff0cbai\u6545\u4f20\u8f93\u7684\u6570\u636e\u4e0d\u4f1a\u4e22\u5931\u6216\u4e71\u5e8f\u3002 \u4f46\u662f\uff0c\u5982\u679c\u53d1\u9001\u6bd4\u8f83\u5927\u7684\u6570\u636e\u5757\uff08\u4f8b\u598265535\u5b57\u8282\uff09\uff0c\u63a5\u6536\u7aef\u53ef\u80fd\u5206\u51e0\u6b21\u6536\u5230\u6570\u636e\uff0c\u5373\u6bcf\u6b21recv()\u6536\u5230\u4e00\u90e8\u5206\u6570\u636e\u3002\u4ea7\u751f\u8fd9\u4e00\u7279\u6027\u7684\u539f\u56e0\u662f\uff1aTCP\u534f\u8bae\u6808\u901a\u5e38\u4f7f\u7528\u6536\u53d1\u7a97\u53e3\u534f\u5546\u673a\u5236\u9ad8\u6548\u4f20\u9012\u6570\u636e\uff0c\u6bcf\u6b21\u5b9e\u9645\u53d1\u9001\u7684\u6570\u636e\u91cf\u53d7\u7a97\u53e3\u5927\u5c0f\u63a7\u5236\uff08\u7a97\u53e3\u5927\u5c0f\u4e0e\u7f51\u7edc\u72b6\u51b5\u3001\u534f\u8bae\u6808\u63a5\u6536\u7a7a\u95f4\u7b49\u56e0\u7d20\u6709\u5173\uff09\u3002 \u540c\u6837\uff0c\u5982\u679c\u8fde\u7eed\u591a\u6b21\u53d1\u9001\u51e0\u7ec4\u5c0f\u6570\u636e\uff08\u6bd4\u5982\u6bcf\u6b21\u51e0\u4e2a\u5b57\u8282\uff09\uff0c\u63a5\u6536\u7aef\u53ef\u80fd\u4e00\u6b21\u6027\u6536\u5230\u6240\u6709\u6570\u636e\u3002\u8fd9\u662fTCP\u534f\u8bae\u6808\u53e6\u5916\u4e00\u4e2a\u7279\u6027\uff0c\u5373\u5bf9\u4e0a\u5c42\u6570\u636e\u8fdb\u884c\u62fc\u63a5\uff08 \u7c98\u5305 \uff09\u4ee5\u51cf\u5c11\u7f51\u7edc\u4ea4\u6362\u6570\u636e\u62a5\u6587\u7684\u9891\u7387\uff0c\u4ee5\u51cf\u5c11\u53cc\u65b9\u4ea4\u4e92\u7b49\u5f85\u6b21\u6570\uff0c\u63d0\u9ad8\u7f51\u7edc\u541e\u5410\u6548\u7387\u3002\u867d\u7136\u8fd9\u4e2a\u7279\u6027\u53ef\u901a\u8fc7socket\u9009\u9879\u63a7\u5236\uff0c\u4f46\u5728\u6bd4\u8f83\u590d\u6742\u7684\u7f51\u7edc\u73af\u5883\u4e0b\uff0c\u53d1\u9001\u65b9\u5206\u591a\u6b21\u9001\u51fa\u7684\u5c0f\u62a5\u6587\u4ecd\u53ef\u80fd\u88ab\u4e2d\u95f4\u8def\u7531\u8bbe\u5907\u62fc\u63a5\u540e\u4e00\u6b21\u6027\u53d1\u51fa\u3002 \u9274\u4e8e\u4ee5\u4e0a\u7279\u6027\uff0c\u6210\u719f\u7684TCP\u901a\u8baf\u8bbe\u8ba1\u901a\u5e38\u8fd8\u8981\u5f15\u5165\u53e6\u5916\u7684\u6570\u636e\u5c01\u88c5\u673a\u5236\uff0c\u5728\u5e94\u7528\u5c42\u7ed9\u6570\u636e\u589e\u52a0\u5305\u5934\uff0c\u63a5\u6536\u7aef\u6839\u636e**\u5305\u5934**\u5bf9\u6570\u636e\u8fdb\u884c\u7ec4\u88c5\uff08\u53ef\u4f7f\u7528\u73af\u5f62\u961f\u5217\u7b49\u7b97\u6cd5\uff09\uff0c\u4ee5\u4fdd\u8bc1\u901a\u8baf\u6570\u636e\u7684\u903b\u8f91\u8fde\u8d2f\u6027\u3002 \u5176\u5b9e\u9664\u4e86TCP\u534f\u8bae\uff0c\u8fd8\u6709\u5176\u4ed6\u7684\u53ef\u9760\u901a\u8baf\u534f\u8bae\u3002\u8fd9\u4e9b\u534f\u8bae\u6709\u4e9b\u57fa\u4e8e\u6570\u636e\u6d41\uff08\u7c7b\u4f3cTCP\uff09\uff0c\u4e5f\u6709\u7684\u57fa\u4e8e\u6570\u636e\u5305\u5f0f\uff08\u7c7b\u4f3cUDP\uff09\u3002\u8fd9\u7c7b\u534f\u8bae\u6709\u65f6\u4f5c\u4e3a\u7cfb\u7edf\u7ea7\u7ec4\u4ef6\u63d0\u4f9b\uff0c\u4f46\u66f4\u591a\u662f\u4ee5\u5e94\u7528\u5c42\u6269\u5c55\u5e93\u5f62\u5f0f\u5b58\u5728\uff0c\u901a\u5e38\u662f\u5728UDP\u534f\u8bae\u6216\u88f8IP\u5c42\u9762\u8fdb\u884c\u5c01\u88c5\uff0c\u6709\u9700\u8981\u7684\u8bdd\u53ef\u81ea\u884c\u641c\u7d22\u8fd9\u65b9\u9762\u8d44\u6e90\u3002","title":"zhidao tcp\u6bcf\u4e00\u6b21send\u52a8\u4f5c\uff0c\u5176\u53d1\u9001\u7684\u5b57\u8282\u90fd\u662f\u6309\u987a\u5e8f\u5230\u8fbereceive\u7aef\u7684\u5417?:"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#stackoverflow#can#one#call#of#recv#receive#data#from#2#consecutive#send#calls","text":"A TCP is a stream oriented protocol. Not message / record / chunk oriented. That is, all that is guaranteed is that if you send a stream, the bytes will get to the other side in the order you sent them. There is no provision(\u89c4\u5b9a) made by RFC 793 or any other document about the number of segments / packets involved. This is in stark(\u5b8c\u5168) contrast with UDP . As @R .. correctly said, in UDP an entire message is sent in one operation (notice the change in terminology: message ). Try to send a giant message (several times larger than the MTU) with TCP ? It's okay, it will split it for you. NOTE: MTU\u5373 Maximum Transmission Unit \uff0c When running on local networks or on localhost you will certainly notice that (generally) one send == one recv . Don't assume that. There are factors that change it dramatically. Among these Nagle Underlying MTU Memory usage (possibly) Timers Many others Of course, not having a correspondence between an a send and a recv is a nuisance and you can't rely on UDP . That is one of the reasons for SCTP . SCTP is a really really interesting protocol and it is message-oriented . Back to TCP , this is a common nuisance. An equally common solution is this: Establish that all packets begin with a fixed-length sequence (say 32 bytes) These 32 bytes contain (possibly among other things) the size of the message that follows When you read any amount of data from the socket, add the data to a buffer specific for that connection. When 32 bytes are reached, read the length you still need to read until you get the message. It is really important to notice how there are really no messages on the wire, only bytes. Once you understand it you will have made a giant leap towards writing network applications.","title":"stackoverflow can one call of recv() receive data from 2 consecutive send() calls?"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#csdn#socket#tcp","text":"\u63d0\u5230\u901a\u4fe1\uff0c \u6211\u4eec\u9762\u4e34\u90fd\u901a\u4fe1\u534f\u8bae\uff0c\u6570\u636e\u534f\u8bae\u7684\u9009\u62e9\u3002 \u901a\u4fe1\u534f\u8bae\u6211\u4eec\u53ef\u9009\u62e9TCP/UDP\uff1a 1) TCP\uff08transport control protocol\uff0c\u4f20\u8f93\u63a7\u5236\u534f\u8bae\uff09\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u9762\u5411\u6d41\u7684\uff0c\u63d0\u4f9b\u9ad8\u53ef\u9760\u6027\u670d\u52a1\u3002\u6536\u53d1\u4e24\u7aef\uff08\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7aef\uff09\u90fd\u8981\u6709\u4e00\u4e00\u6210\u5bf9\u7684socket\uff0c\u56e0\u6b64\uff0c\u53d1\u9001\u7aef\u4e3a\u4e86\u5c06\u591a\u4e2a\u53d1\u5f80\u63a5\u6536\u7aef\u7684\u5305\uff0c\u66f4\u6709\u6548\u7684\u53d1\u5230\u5bf9\u65b9\uff0c\u4f7f\u7528\u4e86\u4f18\u5316\u65b9\u6cd5\uff08Nagle\u7b97\u6cd5\uff09\uff0c\u5c06\u591a\u6b21\u95f4\u9694\u8f83\u5c0f\u4e14\u6570\u636e\u91cf\u5c0f\u7684\u6570\u636e\uff0c\u5408\u5e76\u6210\u4e00\u4e2a\u5927\u7684\u6570\u636e\u5757\uff0c\u7136\u540e\u8fdb\u884c\u5c01\u5305\u3002\u8fd9\u6837\uff0c\u63a5\u6536\u7aef\uff0c\u5c31\u96be\u4e8e\u5206\u8fa8\u51fa\u6765\u4e86\uff0c\u5fc5\u987b\u63d0\u4f9b\u79d1\u5b66\u7684\u62c6\u5305\u673a\u5236\u3002 \u5373\u9762\u5411\u6d41\u7684\u901a\u4fe1\u662f\u65e0\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c\u7684\u3002 UDP\uff08user datagram protocol\uff0c\u7528\u6237\u6570\u636e\u62a5\u534f\u8bae\uff09\u662f\u65e0\u8fde\u63a5\u7684\uff0c\u9762\u5411\u6d88\u606f\u7684\uff0c\u63d0\u4f9b\u9ad8\u6548\u7387\u670d\u52a1\u3002\u4e0d\u4f1a\u4f7f\u7528\u5757\u7684\u5408\u5e76\u4f18\u5316\u7b97\u6cd5\uff0c, \u7531\u4e8eUDP\u652f\u6301\u7684\u662f\u4e00\u5bf9\u591a\u7684\u6a21\u5f0f\uff0c\u6240\u4ee5\u63a5\u6536\u7aef\u7684skbuff(\u5957\u63a5\u5b57\u7f13\u51b2\u533a\uff09\u91c7\u7528\u4e86\u94fe\u5f0f\u7ed3\u6784\u6765\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u5230\u8fbe\u7684UDP\u5305\uff0c\u5728\u6bcf\u4e2aUDP\u5305\u4e2d\u5c31\u6709\u4e86\u6d88\u606f\u5934\uff08\u6d88\u606f\u6765\u6e90\u5730\u5740\uff0c\u7aef\u53e3\u7b49\u4fe1\u606f\uff09\uff0c\u8fd9\u6837\uff0c\u5bf9\u4e8e\u63a5\u6536\u7aef\u6765\u8bf4\uff0c\u5c31\u5bb9\u6613\u8fdb\u884c\u533a\u5206\u5904\u7406\u4e86\u3002 \u5373\u9762\u5411\u6d88\u606f\u7684\u901a\u4fe1\u662f\u6709\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c\u7684\u3002","title":"csdn Socket TCP\u7c98\u5305\u3001\u591a\u5305\u548c\u5c11\u5305, \u65ad\u5305"},{"location":"Network/Protocol/TCP/TCP-data-transfer/#csdn#socket---#---tcpip","text":"","title":"csdn socket\u8fde\u63a5---\u591a\u7ebf\u7a0b \u7ebf\u7a0b\u6c60---TCP/IP\u534a\u5305\u3001\u7c98\u5305\u3001\u5206\u5305"},{"location":"Network/Protocol/TCP/TCP-data-transfer/Nagle%27s-algorithm/","text":"Nagle's algorithm \u5728csdn Socket TCP\u7c98\u5305\u3001\u591a\u5305\u548c\u5c11\u5305, \u65ad\u5305#\u4e3a\u4ec0\u4e48TCP \u4f1a\u7c98\u5305 \u4e2d\u63d0\u53ca\u4e86Nagle's algorithm: TCP\uff08transport control protocol\uff0c\u4f20\u8f93\u63a7\u5236\u534f\u8bae\uff09\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u9762\u5411\u6d41\u7684\uff0c\u63d0\u4f9b\u9ad8\u53ef\u9760\u6027\u670d\u52a1\u3002\u6536\u53d1\u4e24\u7aef\uff08\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7aef\uff09\u90fd\u8981\u6709\u4e00\u4e00\u6210\u5bf9\u7684socket\uff0c\u56e0\u6b64\uff0c\u53d1\u9001\u7aef\u4e3a\u4e86\u5c06\u591a\u4e2a\u53d1\u5f80\u63a5\u6536\u7aef\u7684\u5305\uff0c\u66f4\u6709\u6548\u7684\u53d1\u5230\u5bf9\u65b9\uff0c\u4f7f\u7528\u4e86\u4f18\u5316\u65b9\u6cd5\uff08 Nagle\u7b97\u6cd5 \uff09\uff0c\u5c06\u591a\u6b21\u95f4\u9694\u8f83\u5c0f\u4e14\u6570\u636e\u91cf\u5c0f\u7684\u6570\u636e\uff0c\u5408\u5e76\u6210\u4e00\u4e2a\u5927\u7684\u6570\u636e\u5757\uff0c\u7136\u540e\u8fdb\u884c\u5c01\u5305\u3002\u8fd9\u6837\uff0c\u63a5\u6536\u7aef\uff0c\u5c31\u96be\u4e8e\u5206\u8fa8\u51fa\u6765\u4e86\uff0c\u5fc5\u987b\u63d0\u4f9b\u79d1\u5b66\u7684\u62c6\u5305\u673a\u5236\u3002 \u5373**\u9762\u5411\u6d41\u7684\u901a\u4fe1\u662f\u65e0\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c\u7684**\u3002 \u7ef4\u57fa\u767e\u79d1 Nagle's algorithm","title":"Nagle's-algorithm"},{"location":"Network/Protocol/TCP/TCP-data-transfer/Nagle%27s-algorithm/#nagles#algorithm","text":"\u5728csdn Socket TCP\u7c98\u5305\u3001\u591a\u5305\u548c\u5c11\u5305, \u65ad\u5305#\u4e3a\u4ec0\u4e48TCP \u4f1a\u7c98\u5305 \u4e2d\u63d0\u53ca\u4e86Nagle's algorithm: TCP\uff08transport control protocol\uff0c\u4f20\u8f93\u63a7\u5236\u534f\u8bae\uff09\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u9762\u5411\u6d41\u7684\uff0c\u63d0\u4f9b\u9ad8\u53ef\u9760\u6027\u670d\u52a1\u3002\u6536\u53d1\u4e24\u7aef\uff08\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7aef\uff09\u90fd\u8981\u6709\u4e00\u4e00\u6210\u5bf9\u7684socket\uff0c\u56e0\u6b64\uff0c\u53d1\u9001\u7aef\u4e3a\u4e86\u5c06\u591a\u4e2a\u53d1\u5f80\u63a5\u6536\u7aef\u7684\u5305\uff0c\u66f4\u6709\u6548\u7684\u53d1\u5230\u5bf9\u65b9\uff0c\u4f7f\u7528\u4e86\u4f18\u5316\u65b9\u6cd5\uff08 Nagle\u7b97\u6cd5 \uff09\uff0c\u5c06\u591a\u6b21\u95f4\u9694\u8f83\u5c0f\u4e14\u6570\u636e\u91cf\u5c0f\u7684\u6570\u636e\uff0c\u5408\u5e76\u6210\u4e00\u4e2a\u5927\u7684\u6570\u636e\u5757\uff0c\u7136\u540e\u8fdb\u884c\u5c01\u5305\u3002\u8fd9\u6837\uff0c\u63a5\u6536\u7aef\uff0c\u5c31\u96be\u4e8e\u5206\u8fa8\u51fa\u6765\u4e86\uff0c\u5fc5\u987b\u63d0\u4f9b\u79d1\u5b66\u7684\u62c6\u5305\u673a\u5236\u3002 \u5373**\u9762\u5411\u6d41\u7684\u901a\u4fe1\u662f\u65e0\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c\u7684**\u3002","title":"Nagle's algorithm"},{"location":"Network/Protocol/TCP/TCP-data-transfer/Nagle%27s-algorithm/#nagles#algorithm_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Nagle's algorithm"},{"location":"Network/Protocol/TCP/TCP-data-transfer/TCP-segment-of-a-reassembled-PDU/","text":"TCP segment of a reassembled PDU \u5728\u9605\u8bfbcnblogs TCP \u4e2d\u7684Sequence Number \u65f6\uff0c\u5176\u4e2d\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u95ee\u9898: \u5982\u56fe\u6240\u793a\uff0c\u5728\u6293\u5305\u7684\u65f6\u5019\uff0c\u7ecf\u5e38\u4f1a\u770b\u5230[TCP segment of a reassembled PDU ] \u5b57\u6837\u7684\u5305\uff0c\u8fd9\u4e2a\u4ee3\u8868\u6570\u636e\u5728\u4f20\u8f93\u5c42\u88ab\u5206\u5305\u4e86\u3002\u4e5f\u5c31\u662f\u4ee3\u8868\u5305\u5927\u5c0f\u5927\u4e8eMTU\uff0c\u6b64\u5904\u653e\u4e00\u4e0bMTU\u4e0eMSS\u533a\u522b\uff1a MTU\uff08 Maximum Transmission Unit \uff09\u6700\u5927\u4f20\u8f93\u5355\u5143\uff0c\u5728TCP/IP\u534f\u8bae\u65cf\u4e2d\uff0c\u6307\u7684\u662fIP\u6570\u636e\u62a5\u80fd\u7ecf\u8fc7\u4e00\u4e2a\u7269\u7406\u7f51\u7edc\u7684\u6700\u5927\u62a5\u6587\u957f\u5ea6\uff0c\u5176\u4e2d\u5305\u62ec\u4e86IP\u9996\u90e8(\u4ece20\u4e2a\u5b57\u8282\u523060\u4e2a\u5b57\u8282\u4e0d\u7b49)\uff0c\u4e00\u822c\u4ee5\u592a\u7f51\u7684MTU\u8bbe\u4e3a1500\u5b57\u8282\uff0c\u52a0\u4e0a\u4ee5\u592a\u5e27\u9996\u90e8\u7684\u957f\u5ea614\u5b57\u8282\uff0c\u4e5f\u5c31\u662f\u4e00\u4e2a\u4ee5\u592a\u5e27\u4e0d\u4f1a\u8d85\u8fc71500+14 = 1514\u5b57\u8282\u3002 MSS\uff08 Maximum Segment Size \uff0c\u6700\u5927\u62a5\u6587\u6bb5\u5927\u5c0f\uff0c\u6307\u7684\u662fTCP\u62a5\u6587\uff08\u4e00\u79cdIP\u534f\u8bae\u7684\u4e0a\u5c42\u534f\u8bae\uff09\u7684\u6700\u5927\u6570\u636e\u62a5\u957f\u5ea6\uff0c\u5176\u4e2d\u4e0d\u5305\u62ecTCP\u9996\u90e8\u957f\u5ea6\u3002MSS\u7531TCP\u94fe\u63a5\u7684\u8fc7\u7a0b\u4e2d\u7531\u53cc\u65b9\u534f\u5546\u5f97\u51fa\uff0c\u5176\u4e2dSYN\u5b57\u6bb5\u4e2d\u7684\u9009\u9879\u90e8\u5206\u5305\u62ec\u4e86\u8fd9\u4e2a\u4fe1\u606f\u3002\u5982\u679c**MSS+TCP\u9996\u90e8+IP\u9996\u90e8\u5927\u4e8eMTU**\uff0c\u90a3\u4e48IP\u62a5\u6587\u5c31\u4f1a\u5b58\u5728\u5206\u7247\uff0c\u5982\u679c\u5c0f\u4e8e\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u4e0d\u9700\u8981\u5206\u7247\u6b63\u5e38\u53d1\u9001\u3002 \u56e0\u6b64\uff0c\u51fa\u73b0\u8fd9\u79cd\u73b0\u8c61\u7684\u539f\u56e0\u5c31\u662f\u4f60\u8c03\u7528\u4e00\u6b21send\u7684\u65f6\u5019\uff0csend\u7684\u6570\u636e\u6bd4 MSS \u8fd8\u8981\u6253\uff0c\u56e0\u6b64\u5c31\u88ab\u534f\u8bae\u6808\u8fdb\u884c\u4e86\u5206\u5305\u3002 \u987a\u4fbf\u8bf4\u4e00\u4e0b\uff0cIP\u6570\u636e\u5305\u7684\u5206\u7247\u662f\u901a\u8fc7flag\u5b57\u6bb5\u548coffset\u5b57\u6bb5\u5171\u540c\u5b8c\u6210\u7684\u3002 \u4ece\u56fe\u4e2d\u53ef\u4ee5\u770b\u5230\uff0c\u7b2c6\u4e2a\u548c\u7b2c5\u4e2a\u5305\u662f\u540c\u4e00\u4e2aTCP\u62a5\u6587\u88ab\u5206\u6210\u4e86\u4e24\u4e2a\u5305\u3002\u5982\u679c\u6211\u4eec\u70b9\u5f00\u770b\u7684\u8bdd\uff0c\u53ef\u4ee5\u770b\u5230\u4e24\u4e2a\u62a5\u6587\u7684ACK\u5e8f\u53f7\u90fd\u4e00\u6837\uff0c\u5e76\u4e14\u8fd9\u4e9b\u62a5\u6587\u7684Sequence Number\u90fd\u4e0d\u4e00\u6837\uff0c\u5e76\u4e14\u540e\u4e00\u4e2aSequence Number\u4e3a\u524d\u4e00\u4e2aSequence Number\u52a0\u4e0a\u524d\u4e00\u4e2a\u62a5\u6587\u5927\u5c0f\u518d\u52a0\u4e0a1 \u3002\u8fd9\u4e5f\u662f\u5224\u65adreassembled \u7684\u65b9\u5f0f\u3002 \u70b9\u5f00\u7b2c6\u4e2a\u5305\uff0c\u53ef\u4ee5\u770b\u5230\u5b83\u5c065\u548c6\u7684\u6570\u636e\u6574\u5408\u8d77\u6765\u4e86\u3002 \u5173\u4e8eIP\u62a5\u6587\u7684\u5206\u7247\uff0c\u53c2\u89c1 IP fragmentation \u3002 \u5728\u4e0b\u9762\u6587\u7ae0\u4e2d\uff0c\u4e5f\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u63a2\u8ba8: superuser TCP segment of a reassembled PDU # A A \"PDU\" is a \"Protocol Data Unit.\" One unit of information being transferred in accordance with a given protocol (e.g., \"login USERNAME very-long-base64-encoded-authentication-data\" then wait for server to respond) will be disassembled into many packets (smaller pieces) if it's too large to fit in one packet (or segment in this case). This is normal and is just TCP/IP working as designed. osqa-ask.wireshark TCP segment of a reassembled PDU ? # A It means that Wireshark/TShark thinks it knows what protocol is running atop TCP in that TCP segment; that TCP segment doesn't contain all of a \"protocol data unit\" (PDU) for that higher-level protocol, i.e. a packet or protocol message for that higher-level protocol, and doesn't contain the last part of that PDU, so it's trying to reassemble the multiple TCP segments containing that higher-level PDU. For example, an HTTP response with a lot of data in it won't fit in a single TCP segment on most networks, so it'll be split over multiple TCP segments; all but the last TCP segment will be marked as \"TCP segment of a What is PDU? \u53c2\u89c1 Network\\Theory\\Network-protocol-model.md \u3002","title":"TCP-segment-of-a-reassembled-PDU"},{"location":"Network/Protocol/TCP/TCP-data-transfer/TCP-segment-of-a-reassembled-PDU/#tcp#segment#of#a#reassembled#pdu","text":"\u5728\u9605\u8bfbcnblogs TCP \u4e2d\u7684Sequence Number \u65f6\uff0c\u5176\u4e2d\u63cf\u8ff0\u4e86\u8fd9\u4e2a\u95ee\u9898: \u5982\u56fe\u6240\u793a\uff0c\u5728\u6293\u5305\u7684\u65f6\u5019\uff0c\u7ecf\u5e38\u4f1a\u770b\u5230[TCP segment of a reassembled PDU ] \u5b57\u6837\u7684\u5305\uff0c\u8fd9\u4e2a\u4ee3\u8868\u6570\u636e\u5728\u4f20\u8f93\u5c42\u88ab\u5206\u5305\u4e86\u3002\u4e5f\u5c31\u662f\u4ee3\u8868\u5305\u5927\u5c0f\u5927\u4e8eMTU\uff0c\u6b64\u5904\u653e\u4e00\u4e0bMTU\u4e0eMSS\u533a\u522b\uff1a MTU\uff08 Maximum Transmission Unit \uff09\u6700\u5927\u4f20\u8f93\u5355\u5143\uff0c\u5728TCP/IP\u534f\u8bae\u65cf\u4e2d\uff0c\u6307\u7684\u662fIP\u6570\u636e\u62a5\u80fd\u7ecf\u8fc7\u4e00\u4e2a\u7269\u7406\u7f51\u7edc\u7684\u6700\u5927\u62a5\u6587\u957f\u5ea6\uff0c\u5176\u4e2d\u5305\u62ec\u4e86IP\u9996\u90e8(\u4ece20\u4e2a\u5b57\u8282\u523060\u4e2a\u5b57\u8282\u4e0d\u7b49)\uff0c\u4e00\u822c\u4ee5\u592a\u7f51\u7684MTU\u8bbe\u4e3a1500\u5b57\u8282\uff0c\u52a0\u4e0a\u4ee5\u592a\u5e27\u9996\u90e8\u7684\u957f\u5ea614\u5b57\u8282\uff0c\u4e5f\u5c31\u662f\u4e00\u4e2a\u4ee5\u592a\u5e27\u4e0d\u4f1a\u8d85\u8fc71500+14 = 1514\u5b57\u8282\u3002 MSS\uff08 Maximum Segment Size \uff0c\u6700\u5927\u62a5\u6587\u6bb5\u5927\u5c0f\uff0c\u6307\u7684\u662fTCP\u62a5\u6587\uff08\u4e00\u79cdIP\u534f\u8bae\u7684\u4e0a\u5c42\u534f\u8bae\uff09\u7684\u6700\u5927\u6570\u636e\u62a5\u957f\u5ea6\uff0c\u5176\u4e2d\u4e0d\u5305\u62ecTCP\u9996\u90e8\u957f\u5ea6\u3002MSS\u7531TCP\u94fe\u63a5\u7684\u8fc7\u7a0b\u4e2d\u7531\u53cc\u65b9\u534f\u5546\u5f97\u51fa\uff0c\u5176\u4e2dSYN\u5b57\u6bb5\u4e2d\u7684\u9009\u9879\u90e8\u5206\u5305\u62ec\u4e86\u8fd9\u4e2a\u4fe1\u606f\u3002\u5982\u679c**MSS+TCP\u9996\u90e8+IP\u9996\u90e8\u5927\u4e8eMTU**\uff0c\u90a3\u4e48IP\u62a5\u6587\u5c31\u4f1a\u5b58\u5728\u5206\u7247\uff0c\u5982\u679c\u5c0f\u4e8e\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u4e0d\u9700\u8981\u5206\u7247\u6b63\u5e38\u53d1\u9001\u3002 \u56e0\u6b64\uff0c\u51fa\u73b0\u8fd9\u79cd\u73b0\u8c61\u7684\u539f\u56e0\u5c31\u662f\u4f60\u8c03\u7528\u4e00\u6b21send\u7684\u65f6\u5019\uff0csend\u7684\u6570\u636e\u6bd4 MSS \u8fd8\u8981\u6253\uff0c\u56e0\u6b64\u5c31\u88ab\u534f\u8bae\u6808\u8fdb\u884c\u4e86\u5206\u5305\u3002 \u987a\u4fbf\u8bf4\u4e00\u4e0b\uff0cIP\u6570\u636e\u5305\u7684\u5206\u7247\u662f\u901a\u8fc7flag\u5b57\u6bb5\u548coffset\u5b57\u6bb5\u5171\u540c\u5b8c\u6210\u7684\u3002 \u4ece\u56fe\u4e2d\u53ef\u4ee5\u770b\u5230\uff0c\u7b2c6\u4e2a\u548c\u7b2c5\u4e2a\u5305\u662f\u540c\u4e00\u4e2aTCP\u62a5\u6587\u88ab\u5206\u6210\u4e86\u4e24\u4e2a\u5305\u3002\u5982\u679c\u6211\u4eec\u70b9\u5f00\u770b\u7684\u8bdd\uff0c\u53ef\u4ee5\u770b\u5230\u4e24\u4e2a\u62a5\u6587\u7684ACK\u5e8f\u53f7\u90fd\u4e00\u6837\uff0c\u5e76\u4e14\u8fd9\u4e9b\u62a5\u6587\u7684Sequence Number\u90fd\u4e0d\u4e00\u6837\uff0c\u5e76\u4e14\u540e\u4e00\u4e2aSequence Number\u4e3a\u524d\u4e00\u4e2aSequence Number\u52a0\u4e0a\u524d\u4e00\u4e2a\u62a5\u6587\u5927\u5c0f\u518d\u52a0\u4e0a1 \u3002\u8fd9\u4e5f\u662f\u5224\u65adreassembled \u7684\u65b9\u5f0f\u3002 \u70b9\u5f00\u7b2c6\u4e2a\u5305\uff0c\u53ef\u4ee5\u770b\u5230\u5b83\u5c065\u548c6\u7684\u6570\u636e\u6574\u5408\u8d77\u6765\u4e86\u3002 \u5173\u4e8eIP\u62a5\u6587\u7684\u5206\u7247\uff0c\u53c2\u89c1 IP fragmentation \u3002 \u5728\u4e0b\u9762\u6587\u7ae0\u4e2d\uff0c\u4e5f\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u63a2\u8ba8: superuser TCP segment of a reassembled PDU # A A \"PDU\" is a \"Protocol Data Unit.\" One unit of information being transferred in accordance with a given protocol (e.g., \"login USERNAME very-long-base64-encoded-authentication-data\" then wait for server to respond) will be disassembled into many packets (smaller pieces) if it's too large to fit in one packet (or segment in this case). This is normal and is just TCP/IP working as designed. osqa-ask.wireshark TCP segment of a reassembled PDU ? # A It means that Wireshark/TShark thinks it knows what protocol is running atop TCP in that TCP segment; that TCP segment doesn't contain all of a \"protocol data unit\" (PDU) for that higher-level protocol, i.e. a packet or protocol message for that higher-level protocol, and doesn't contain the last part of that PDU, so it's trying to reassemble the multiple TCP segments containing that higher-level PDU. For example, an HTTP response with a lot of data in it won't fit in a single TCP segment on most networks, so it'll be split over multiple TCP segments; all but the last TCP segment will be marked as \"TCP segment of a","title":"TCP segment of a reassembled PDU"},{"location":"Network/Protocol/TCP/TCP-data-transfer/TCP-segment-of-a-reassembled-PDU/#what#is#pdu","text":"\u53c2\u89c1 Network\\Theory\\Network-protocol-model.md \u3002","title":"What is PDU?"},{"location":"Network/Protocol/TCP-VS-UDP/","text":"TCP VS UDP \u7efc\u8ff0 TCP UDP \u6709\u65e0\u8fde\u63a5 \u9762\u5411\u8fde\u63a5 \u975e\u8fde\u63a5 \u4f20\u8f93\u901f\u5ea6 \u6162 \u5feb \u6709\u5e8f\u6027 \u4fdd\u8bc1\u6570\u636e\u987a\u5e8f \u4e0d\u4fdd\u8bc1 \u53ef\u9760\u6027 \u4fdd\u8bc1\u6570\u636e\u6b63\u786e\u6027 \u53ef\u80fd\u4e22\u5305 \u8d44\u6e90\u5360\u7528 \u8981\u6c42\u591a \u8981\u6c42\u5c11 stream-oriented message-oriented \u53c2\u8003: 1) csdn TCP\u534f\u8bae\u548cUDP\u534f\u8bae\u7684\u533a\u522b (\u6709\u65e0\u94fe\u63a5\uff0c\u4f20\u8f93\u901f\u5ea6\uff0c\u6709\u5e8f\u65e0\u5e8f\uff0c\u53ef\u9760\u6027\uff0c\u5bf9\u8d44\u6e90\u7684\u5360\u7528) 2) networking-forum What does stream-oriented and message oriented terms mean? csdn Socket TCP\u7c98\u5305\u3001\u591a\u5305\u548c\u5c11\u5305, \u65ad\u5305#\u4e3a\u4ec0\u4e48TCP \u4f1a\u7c98\u5305 TCP\uff08transport control protocol\uff0c\u4f20\u8f93\u63a7\u5236\u534f\u8bae\uff09\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u9762\u5411\u6d41\u7684\uff0c\u63d0\u4f9b\u9ad8\u53ef\u9760\u6027\u670d\u52a1\u3002\u6536\u53d1\u4e24\u7aef\uff08\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7aef\uff09\u90fd\u8981\u6709\u4e00\u4e00\u6210\u5bf9\u7684socket\uff0c\u56e0\u6b64\uff0c\u53d1\u9001\u7aef\u4e3a\u4e86\u5c06\u591a\u4e2a\u53d1\u5f80\u63a5\u6536\u7aef\u7684\u5305\uff0c\u66f4\u6709\u6548\u7684\u53d1\u5230\u5bf9\u65b9\uff0c\u4f7f\u7528\u4e86\u4f18\u5316\u65b9\u6cd5\uff08Nagle\u7b97\u6cd5\uff09\uff0c\u5c06\u591a\u6b21\u95f4\u9694\u8f83\u5c0f\u4e14\u6570\u636e\u91cf\u5c0f\u7684\u6570\u636e\uff0c\u5408\u5e76\u6210\u4e00\u4e2a\u5927\u7684\u6570\u636e\u5757\uff0c\u7136\u540e\u8fdb\u884c\u5c01\u5305\u3002\u8fd9\u6837\uff0c\u63a5\u6536\u7aef\uff0c\u5c31\u96be\u4e8e\u5206\u8fa8\u51fa\u6765\u4e86\uff0c\u5fc5\u987b\u63d0\u4f9b\u79d1\u5b66\u7684\u62c6\u5305\u673a\u5236\u3002 \u5373\u9762\u5411\u6d41\u7684\u901a\u4fe1\u662f\u65e0\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c\u7684\u3002 UDP\uff08user datagram protocol\uff0c\u7528\u6237\u6570\u636e\u62a5\u534f\u8bae\uff09\u662f\u65e0\u8fde\u63a5\u7684\uff0c\u9762\u5411\u6d88\u606f\u7684\uff0c\u63d0\u4f9b\u9ad8\u6548\u7387\u670d\u52a1\u3002\u4e0d\u4f1a\u4f7f\u7528\u5757\u7684\u5408\u5e76\u4f18\u5316\u7b97\u6cd5\uff0c, \u7531\u4e8eUDP\u652f\u6301\u7684\u662f\u4e00\u5bf9\u591a\u7684\u6a21\u5f0f\uff0c\u6240\u4ee5\u63a5\u6536\u7aef\u7684skbuff(\u5957\u63a5\u5b57\u7f13\u51b2\u533a\uff09\u91c7\u7528\u4e86\u94fe\u5f0f\u7ed3\u6784\u6765\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u5230\u8fbe\u7684UDP\u5305\uff0c\u5728\u6bcf\u4e2aUDP\u5305\u4e2d\u5c31\u6709\u4e86\u6d88\u606f\u5934\uff08\u6d88\u606f\u6765\u6e90\u5730\u5740\uff0c\u7aef\u53e3\u7b49\u4fe1\u606f\uff09\uff0c\u8fd9\u6837\uff0c\u5bf9\u4e8e\u63a5\u6536\u7aef\u6765\u8bf4\uff0c\u5c31\u5bb9\u6613\u8fdb\u884c\u533a\u5206\u5904\u7406\u4e86\u3002 \u5373\u9762\u5411\u6d88\u606f\u7684\u901a\u4fe1\u662f\u6709\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c\u7684\u3002 TCP stream-oriented VS UDP message-oriented networking-forum. What does stream-oriented and message oriented terms mean? Hi, As we know TCP is a stream oriented protocol and UDP is a message-oriented protocol I want to know what that really means ? What are the advantages of both ? Someone pls explain these terms. A1 http://en.wikipedia.org/wiki/Stream_Con ... -streaming explains it all A2 So, TCP receives the stream of bytes from application layer protocols and divide it in to segments and pass it to IP . But UDP receives already divided or grouped bytes of data from application protocols and add UDP headers which will become Datagram and send it to IP Is that correct ? If it is correct, then application layers has the burden of dividing the streams of data in to messages when they run on top of UDP. APUE 16.2 Socket Descriptors \u5728APUE\u768416.2 Socket Descriptors\u4e2d\uff0c\u5bf9TCP\u548cUDP\u4e4b\u95f4\u5dee\u5f02\u7684\u89e3\u91ca\u662f\u975e\u5e38\u5230\u4f4d\u7684\uff0c\u662f\u975e\u5e38\u5177\u6709\u53c2\u8003\u4ef7\u503c\u7684\uff1b","title":"Introduction"},{"location":"Network/Protocol/TCP-VS-UDP/#tcp#vs#udp","text":"","title":"TCP VS UDP"},{"location":"Network/Protocol/TCP-VS-UDP/#_1","text":"TCP UDP \u6709\u65e0\u8fde\u63a5 \u9762\u5411\u8fde\u63a5 \u975e\u8fde\u63a5 \u4f20\u8f93\u901f\u5ea6 \u6162 \u5feb \u6709\u5e8f\u6027 \u4fdd\u8bc1\u6570\u636e\u987a\u5e8f \u4e0d\u4fdd\u8bc1 \u53ef\u9760\u6027 \u4fdd\u8bc1\u6570\u636e\u6b63\u786e\u6027 \u53ef\u80fd\u4e22\u5305 \u8d44\u6e90\u5360\u7528 \u8981\u6c42\u591a \u8981\u6c42\u5c11 stream-oriented message-oriented \u53c2\u8003: 1) csdn TCP\u534f\u8bae\u548cUDP\u534f\u8bae\u7684\u533a\u522b (\u6709\u65e0\u94fe\u63a5\uff0c\u4f20\u8f93\u901f\u5ea6\uff0c\u6709\u5e8f\u65e0\u5e8f\uff0c\u53ef\u9760\u6027\uff0c\u5bf9\u8d44\u6e90\u7684\u5360\u7528) 2) networking-forum What does stream-oriented and message oriented terms mean?","title":"\u7efc\u8ff0"},{"location":"Network/Protocol/TCP-VS-UDP/#csdn#socket#tcp#tcp","text":"TCP\uff08transport control protocol\uff0c\u4f20\u8f93\u63a7\u5236\u534f\u8bae\uff09\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u9762\u5411\u6d41\u7684\uff0c\u63d0\u4f9b\u9ad8\u53ef\u9760\u6027\u670d\u52a1\u3002\u6536\u53d1\u4e24\u7aef\uff08\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7aef\uff09\u90fd\u8981\u6709\u4e00\u4e00\u6210\u5bf9\u7684socket\uff0c\u56e0\u6b64\uff0c\u53d1\u9001\u7aef\u4e3a\u4e86\u5c06\u591a\u4e2a\u53d1\u5f80\u63a5\u6536\u7aef\u7684\u5305\uff0c\u66f4\u6709\u6548\u7684\u53d1\u5230\u5bf9\u65b9\uff0c\u4f7f\u7528\u4e86\u4f18\u5316\u65b9\u6cd5\uff08Nagle\u7b97\u6cd5\uff09\uff0c\u5c06\u591a\u6b21\u95f4\u9694\u8f83\u5c0f\u4e14\u6570\u636e\u91cf\u5c0f\u7684\u6570\u636e\uff0c\u5408\u5e76\u6210\u4e00\u4e2a\u5927\u7684\u6570\u636e\u5757\uff0c\u7136\u540e\u8fdb\u884c\u5c01\u5305\u3002\u8fd9\u6837\uff0c\u63a5\u6536\u7aef\uff0c\u5c31\u96be\u4e8e\u5206\u8fa8\u51fa\u6765\u4e86\uff0c\u5fc5\u987b\u63d0\u4f9b\u79d1\u5b66\u7684\u62c6\u5305\u673a\u5236\u3002 \u5373\u9762\u5411\u6d41\u7684\u901a\u4fe1\u662f\u65e0\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c\u7684\u3002 UDP\uff08user datagram protocol\uff0c\u7528\u6237\u6570\u636e\u62a5\u534f\u8bae\uff09\u662f\u65e0\u8fde\u63a5\u7684\uff0c\u9762\u5411\u6d88\u606f\u7684\uff0c\u63d0\u4f9b\u9ad8\u6548\u7387\u670d\u52a1\u3002\u4e0d\u4f1a\u4f7f\u7528\u5757\u7684\u5408\u5e76\u4f18\u5316\u7b97\u6cd5\uff0c, \u7531\u4e8eUDP\u652f\u6301\u7684\u662f\u4e00\u5bf9\u591a\u7684\u6a21\u5f0f\uff0c\u6240\u4ee5\u63a5\u6536\u7aef\u7684skbuff(\u5957\u63a5\u5b57\u7f13\u51b2\u533a\uff09\u91c7\u7528\u4e86\u94fe\u5f0f\u7ed3\u6784\u6765\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u5230\u8fbe\u7684UDP\u5305\uff0c\u5728\u6bcf\u4e2aUDP\u5305\u4e2d\u5c31\u6709\u4e86\u6d88\u606f\u5934\uff08\u6d88\u606f\u6765\u6e90\u5730\u5740\uff0c\u7aef\u53e3\u7b49\u4fe1\u606f\uff09\uff0c\u8fd9\u6837\uff0c\u5bf9\u4e8e\u63a5\u6536\u7aef\u6765\u8bf4\uff0c\u5c31\u5bb9\u6613\u8fdb\u884c\u533a\u5206\u5904\u7406\u4e86\u3002 \u5373\u9762\u5411\u6d88\u606f\u7684\u901a\u4fe1\u662f\u6709\u6d88\u606f\u4fdd\u62a4\u8fb9\u754c\u7684\u3002","title":"csdn Socket TCP\u7c98\u5305\u3001\u591a\u5305\u548c\u5c11\u5305, \u65ad\u5305#\u4e3a\u4ec0\u4e48TCP \u4f1a\u7c98\u5305"},{"location":"Network/Protocol/TCP-VS-UDP/#tcp#stream-oriented#vs#udp#message-oriented","text":"","title":"TCP stream-oriented VS  UDP message-oriented"},{"location":"Network/Protocol/TCP-VS-UDP/#networking-forum#what#does#stream-oriented#and#message#oriented#terms#mean","text":"Hi, As we know TCP is a stream oriented protocol and UDP is a message-oriented protocol I want to know what that really means ? What are the advantages of both ? Someone pls explain these terms.","title":"networking-forum. What does stream-oriented and message oriented terms mean?"},{"location":"Network/Protocol/TCP-VS-UDP/#a1","text":"http://en.wikipedia.org/wiki/Stream_Con ... -streaming explains it all","title":"A1"},{"location":"Network/Protocol/TCP-VS-UDP/#a2","text":"So, TCP receives the stream of bytes from application layer protocols and divide it in to segments and pass it to IP . But UDP receives already divided or grouped bytes of data from application protocols and add UDP headers which will become Datagram and send it to IP Is that correct ? If it is correct, then application layers has the burden of dividing the streams of data in to messages when they run on top of UDP.","title":"A2"},{"location":"Network/Protocol/TCP-VS-UDP/#apue#162#socket#descriptors","text":"\u5728APUE\u768416.2 Socket Descriptors\u4e2d\uff0c\u5bf9TCP\u548cUDP\u4e4b\u95f4\u5dee\u5f02\u7684\u89e3\u91ca\u662f\u975e\u5e38\u5230\u4f4d\u7684\uff0c\u662f\u975e\u5e38\u5177\u6709\u53c2\u8003\u4ef7\u503c\u7684\uff1b","title":"APUE 16.2 Socket Descriptors"},{"location":"Network/Protocol/TODO-UDP/","text":"","title":"Introduction"},{"location":"Network/Tools/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u603b\u7ed3network tools\uff0c\u4e0b\u9762\u662f\u672c\u7ae0\u4ecb\u7ecd\u7684\u5de5\u5177\u7684\u603b\u89c8: TODO: \u8865\u5145\u5de5\u5177\u603b\u89c8\u3002 Network utility wikipedia Network utility pandorafms Basic Network Commands that every administrator should know (updated 2020)","title":"Introduction"},{"location":"Network/Tools/#_1","text":"\u672c\u7ae0\u603b\u7ed3network tools\uff0c\u4e0b\u9762\u662f\u672c\u7ae0\u4ecb\u7ecd\u7684\u5de5\u5177\u7684\u603b\u89c8: TODO: \u8865\u5145\u5de5\u5177\u603b\u89c8\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Network/Tools/#network#utility","text":"","title":"Network utility"},{"location":"Network/Tools/#wikipedia#network#utility","text":"","title":"wikipedia Network utility"},{"location":"Network/Tools/#pandorafms#basic#network#commands#that#every#administrator#should#know#updated#2020","text":"","title":"pandorafms Basic Network Commands that every administrator should know (updated 2020)"},{"location":"Network/Tools/Port-in-use/","text":"How to check if port is in use on Linux or Unix \u53c2\u8003: How to check if port is in use on Linux or Unix lsof \u53c2\u89c1: Programming\\IO\\Tools\\lsof.md ss \u53c2\u89c1: Network\\Tools\\iproute2 netstat \u53c2\u89c1: Network\\Tools\\netstat.md nmap \u53c2\u89c1 Network\\Tools\\nmap.md","title":"Port-in-use"},{"location":"Network/Tools/Port-in-use/#how#to#check#if#port#is#in#use#on#linux#or#unix","text":"\u53c2\u8003: How to check if port is in use on Linux or Unix","title":"How to check if port is in use on Linux or Unix"},{"location":"Network/Tools/Port-in-use/#lsof","text":"\u53c2\u89c1: Programming\\IO\\Tools\\lsof.md","title":"lsof"},{"location":"Network/Tools/Port-in-use/#ss","text":"\u53c2\u89c1: Network\\Tools\\iproute2","title":"ss"},{"location":"Network/Tools/Port-in-use/#netstat","text":"\u53c2\u89c1: Network\\Tools\\netstat.md","title":"netstat"},{"location":"Network/Tools/Port-in-use/#nmap","text":"\u53c2\u89c1 Network\\Tools\\nmap.md","title":"nmap"},{"location":"Network/Tools/Port-opened-by-process/","text":"How to find ports opened by process ID in Linux? A netstat --all --program | grep '3265' --all show listening and non-listening sockets. --program show the PID and name of the program to which socket belongs. You could also use a port scanner such as Nmap. A You can use the command below: lsof -i -P | grep pid","title":"Port-opened-by-process"},{"location":"Network/Tools/Port-opened-by-process/#how#to#find#ports#opened#by#process#id#in#linux","text":"A netstat --all --program | grep '3265' --all show listening and non-listening sockets. --program show the PID and name of the program to which socket belongs. You could also use a port scanner such as Nmap. A You can use the command below: lsof -i -P | grep pid","title":"How to find ports opened by process ID in Linux?"},{"location":"Network/Tools/TODO-Troubleshoot-local-network/","text":"Troubleshoot local network linuxjournal Hack and / - Linux Troubleshooting, Part II: Local Network","title":"TODO-Troubleshoot-local-network"},{"location":"Network/Tools/TODO-Troubleshoot-local-network/#troubleshoot#local#network","text":"","title":"Troubleshoot local network"},{"location":"Network/Tools/TODO-Troubleshoot-local-network/#linuxjournal#hack#and#-#linux#troubleshooting#part#ii#local#network","text":"","title":"linuxjournal Hack and / - Linux Troubleshooting, Part II: Local Network"},{"location":"Network/Tools/TODO-Troubleshoot-packet-loss/","text":"Troubleshoot packet loss \u672c\u6587\u6807\u9898\u7684\u542b\u4e49\u662f: \u5982\u4f55\u6392\u9664\u4e22\u5305\u95ee\u9898\u3002 Google: Linux packet loss troubleshooting How to check packet loss in Linux TODO serverfault How do you diagnose packet loss? serverfault How passively monitor for tcp packet loss? (Linux)","title":"TODO-Troubleshoot-packet-loss"},{"location":"Network/Tools/TODO-Troubleshoot-packet-loss/#troubleshoot#packet#loss","text":"\u672c\u6587\u6807\u9898\u7684\u542b\u4e49\u662f: \u5982\u4f55\u6392\u9664\u4e22\u5305\u95ee\u9898\u3002 Google: Linux packet loss troubleshooting How to check packet loss in Linux","title":"Troubleshoot packet loss"},{"location":"Network/Tools/TODO-Troubleshoot-packet-loss/#todo","text":"serverfault How do you diagnose packet loss? serverfault How passively monitor for tcp packet loss? (Linux)","title":"TODO"},{"location":"Network/Tools/TODO-Troubleshoot-remote-network/","text":"Troubleshoot remote network linuxjournal Hack and / - Linux Troubleshooting, Part III: Remote Networks","title":"TODO-Troubleshoot-remote-network"},{"location":"Network/Tools/TODO-Troubleshoot-remote-network/#troubleshoot#remote#network","text":"","title":"Troubleshoot remote network"},{"location":"Network/Tools/TODO-Troubleshoot-remote-network/#linuxjournal#hack#and#-#linux#troubleshooting#part#iii#remote#networks","text":"","title":"linuxjournal Hack and / - Linux Troubleshooting, Part III: Remote Networks"},{"location":"Network/Tools/netstat/","text":"netstat wikipedia netstat On Linux this program is mostly obsolete, although still included in many distributions. On Linux, netstat (part of \"net-tools\") is superseded by ss (part of iproute2 ). The replacement for netstat -r is ip route ; The replacement for netstat -i is ip -s link ; The replacement for netstat -g is ip maddr , all of which are recommended instead.[ 2] [ 3] [ 4] [ 5] NOTE: \u4ece\u4e0a\u9762\u7684\u63cf\u8ff0\u53ef\u4ee5\u770b\u51fa\uff0c netstat \u662fobsolete\uff0c\u5b83\u7684successor\u662f iproute2 \u3002 netstat(8) - Linux man page","title":"netstat"},{"location":"Network/Tools/netstat/#netstat","text":"","title":"netstat"},{"location":"Network/Tools/netstat/#wikipedia#netstat","text":"On Linux this program is mostly obsolete, although still included in many distributions. On Linux, netstat (part of \"net-tools\") is superseded by ss (part of iproute2 ). The replacement for netstat -r is ip route ; The replacement for netstat -i is ip -s link ; The replacement for netstat -g is ip maddr , all of which are recommended instead.[ 2] [ 3] [ 4] [ 5] NOTE: \u4ece\u4e0a\u9762\u7684\u63cf\u8ff0\u53ef\u4ee5\u770b\u51fa\uff0c netstat \u662fobsolete\uff0c\u5b83\u7684successor\u662f iproute2 \u3002","title":"wikipedia netstat"},{"location":"Network/Tools/netstat/#netstat8#-#linux#man#page","text":"","title":"netstat(8) - Linux man page"},{"location":"Network/Tools/nmap/","text":"nmap wikipedia Nmap website nmap","title":"nmap"},{"location":"Network/Tools/nmap/#nmap","text":"","title":"nmap"},{"location":"Network/Tools/nmap/#wikipedia#nmap","text":"","title":"wikipedia Nmap"},{"location":"Network/Tools/nmap/#website#nmap","text":"","title":"website nmap"},{"location":"Network/Tools/Packet-analyzer/Packet-analyzer/","text":"Packet analyzer \u5728\u5f00\u53d1\u4e0e\u7f51\u7edc\u76f8\u5173\u7684application\u7684\u65f6\u5019\uff0c\u4f7f\u7528\u5305\u5206\u6790\u5de5\u5177\u662f\u4e00\u79cd\u975e\u5e38\u5feb\u901f\u7684\u6392\u67e5\u65b9\u6cd5\uff0c\u5c24\u5176\u662f\u6293\u5305\u5de5\u5177\u3002 wikipedia Packet analyzer NOTE: \u5305\u5206\u6790\u5de5\u5177 A packet analyzer or packet sniffer is a computer program , or computer hardware such as a packet capture appliance , that can intercept and log traffic that passes over a computer network or part of a network. Notable packet analyzers For a more comprehensive list, see Comparison of packet analyzers . NOTE: \u539f\u6587\u7ed9\u51fa\u4e86\u6bd4\u8f83\u597d\u7684\u603b\u7ed3\uff0c\u53ef\u4ee5\u4f5c\u4e3a\u540e\u7eed\u5bfb\u627e\u5de5\u5177\u7684\u5165\u53e3 Packet capture Packet capture\u5373\u6293\u5305\uff0c\u5b83\u662f\u6700\u6700\u5e38\u89c1\u7684\u4e00\u79cdpacket analysis\u65b9\u5f0f\uff0c\u672c\u8282\u5bf9\u5b83\u8fdb\u884c\u63cf\u8ff0\u3002 wikipedia Packet capture appliance NOTE: appliance\u7684\u610f\u601d\u662f \u8bbe\u5907 wikipedia pcap NOTE: \u975e\u5e38\u91cd\u8981\u7684API\uff0c\u5f88\u591a\u7684tool\u90fd\u662f\u5728\u5b83\u7684\u57fa\u7840\u4e0a\u521b\u5efa\u7684 In the field of computer network administration , pcap is an application programming interface (API) for capturing network traffic . OS implementation Unix-like systems libpcap library Windows Npcap for Windows 7 NOTE: how to parse Programs that use libpcap NOTE: \u4e0b\u9762\u662f\u76ee\u524d\u6211\u63a5\u89e6\u8fc7\u7684\u5de5\u5177 ngrep Wireshark tcpdump pcap file pcap file\u662f\u6293\u5305\u7684\u4ea7\u7269\uff0c\u5982\u4f55\u6765\u5206\u6790\u5462\uff1f \u6b63\u5982wikipedia pcap \u4e2d\u6240\u8ff0: A capture file saved in the format that libpcap, WinPcap, and Npcap use can be read by applications that understand that format, such as tcpdump , Wireshark , CA NetMaster , or Microsoft Network Monitor 3.x. \u663e\u7136\uff0c\u4e0a\u9762\u63d0\u5230\u7684\u8fd9\u4e9b\u5de5\u5177\u90fd\u53ef\u4ee5\u89e3\u6790\uff0c\u4e00\u822c\u4f7f\u7528 Wireshark \u6765\u8fdb\u884c\u89e3\u6790\u3002\u5982\u4f55\u4f7f\u7528 tcpdump \u6765\u89e3\u6790\u5462\uff1f\u53c2\u89c1 Network\\Tools\\Packet-analyzer\\tcpdump \u3002","title":"Packet-analyzer"},{"location":"Network/Tools/Packet-analyzer/Packet-analyzer/#packet#analyzer","text":"\u5728\u5f00\u53d1\u4e0e\u7f51\u7edc\u76f8\u5173\u7684application\u7684\u65f6\u5019\uff0c\u4f7f\u7528\u5305\u5206\u6790\u5de5\u5177\u662f\u4e00\u79cd\u975e\u5e38\u5feb\u901f\u7684\u6392\u67e5\u65b9\u6cd5\uff0c\u5c24\u5176\u662f\u6293\u5305\u5de5\u5177\u3002","title":"Packet analyzer"},{"location":"Network/Tools/Packet-analyzer/Packet-analyzer/#wikipedia#packet#analyzer","text":"NOTE: \u5305\u5206\u6790\u5de5\u5177 A packet analyzer or packet sniffer is a computer program , or computer hardware such as a packet capture appliance , that can intercept and log traffic that passes over a computer network or part of a network.","title":"wikipedia Packet analyzer"},{"location":"Network/Tools/Packet-analyzer/Packet-analyzer/#notable#packet#analyzers","text":"For a more comprehensive list, see Comparison of packet analyzers . NOTE: \u539f\u6587\u7ed9\u51fa\u4e86\u6bd4\u8f83\u597d\u7684\u603b\u7ed3\uff0c\u53ef\u4ee5\u4f5c\u4e3a\u540e\u7eed\u5bfb\u627e\u5de5\u5177\u7684\u5165\u53e3","title":"Notable packet analyzers"},{"location":"Network/Tools/Packet-analyzer/Packet-analyzer/#packet#capture","text":"Packet capture\u5373\u6293\u5305\uff0c\u5b83\u662f\u6700\u6700\u5e38\u89c1\u7684\u4e00\u79cdpacket analysis\u65b9\u5f0f\uff0c\u672c\u8282\u5bf9\u5b83\u8fdb\u884c\u63cf\u8ff0\u3002","title":"Packet capture"},{"location":"Network/Tools/Packet-analyzer/Packet-analyzer/#wikipedia#packet#capture#appliance","text":"NOTE: appliance\u7684\u610f\u601d\u662f \u8bbe\u5907","title":"wikipedia Packet capture appliance"},{"location":"Network/Tools/Packet-analyzer/Packet-analyzer/#wikipedia#pcap","text":"NOTE: \u975e\u5e38\u91cd\u8981\u7684API\uff0c\u5f88\u591a\u7684tool\u90fd\u662f\u5728\u5b83\u7684\u57fa\u7840\u4e0a\u521b\u5efa\u7684 In the field of computer network administration , pcap is an application programming interface (API) for capturing network traffic . OS implementation Unix-like systems libpcap library Windows Npcap for Windows 7 NOTE: how to parse","title":"wikipedia pcap"},{"location":"Network/Tools/Packet-analyzer/Packet-analyzer/#programs#that#use#libpcap","text":"NOTE: \u4e0b\u9762\u662f\u76ee\u524d\u6211\u63a5\u89e6\u8fc7\u7684\u5de5\u5177 ngrep Wireshark tcpdump","title":"Programs that use libpcap"},{"location":"Network/Tools/Packet-analyzer/Packet-analyzer/#pcap#file","text":"pcap file\u662f\u6293\u5305\u7684\u4ea7\u7269\uff0c\u5982\u4f55\u6765\u5206\u6790\u5462\uff1f \u6b63\u5982wikipedia pcap \u4e2d\u6240\u8ff0: A capture file saved in the format that libpcap, WinPcap, and Npcap use can be read by applications that understand that format, such as tcpdump , Wireshark , CA NetMaster , or Microsoft Network Monitor 3.x. \u663e\u7136\uff0c\u4e0a\u9762\u63d0\u5230\u7684\u8fd9\u4e9b\u5de5\u5177\u90fd\u53ef\u4ee5\u89e3\u6790\uff0c\u4e00\u822c\u4f7f\u7528 Wireshark \u6765\u8fdb\u884c\u89e3\u6790\u3002\u5982\u4f55\u4f7f\u7528 tcpdump \u6765\u89e3\u6790\u5462\uff1f\u53c2\u89c1 Network\\Tools\\Packet-analyzer\\tcpdump \u3002","title":"pcap file"},{"location":"Network/Tools/Packet-analyzer/TODO-ngrep/","text":"ngrep wikipedia ngrep Using ngrep ngrep -l -q -d eth0 -i \"^GET |^POST \" tcp and port 80","title":"TODO-ngrep"},{"location":"Network/Tools/Packet-analyzer/TODO-ngrep/#ngrep","text":"","title":"ngrep"},{"location":"Network/Tools/Packet-analyzer/TODO-ngrep/#wikipedia#ngrep","text":"","title":"wikipedia ngrep"},{"location":"Network/Tools/Packet-analyzer/TODO-ngrep/#using#ngrep","text":"ngrep -l -q -d eth0 -i \"^GET |^POST \" tcp and port 80","title":"Using ngrep"},{"location":"Network/Tools/Packet-analyzer/Wireshark/","text":"Wireshark wikipedia Wireshark Website wireshark Git repository: wireshark TODO wireshark tutorial https://www.howtogeek.com/104278/how-to-use-wireshark-to-capture-filter-and-inspect-packets/ https://www.varonis.com/blog/how-to-use-wireshark/ wireshark inspect packets https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/ https://resources.infosecinstitute.com/pcap-analysis-basics-with-wireshark/ \u6293\u5305\u5206\u6790 csdn wireshark\u6293\u5305\u5206\u6790\u2014\u2014TCP/IP\u534f\u8bae csdn WireShark\u6293\u5305\u5206\u6790","title":"Introduction"},{"location":"Network/Tools/Packet-analyzer/Wireshark/#wireshark","text":"","title":"Wireshark"},{"location":"Network/Tools/Packet-analyzer/Wireshark/#wikipedia#wireshark","text":"","title":"wikipedia Wireshark"},{"location":"Network/Tools/Packet-analyzer/Wireshark/#website#wireshark","text":"","title":"Website wireshark"},{"location":"Network/Tools/Packet-analyzer/Wireshark/#git#repository#wireshark","text":"","title":"Git repository: wireshark"},{"location":"Network/Tools/Packet-analyzer/Wireshark/#todo","text":"","title":"TODO"},{"location":"Network/Tools/Packet-analyzer/Wireshark/#wireshark#tutorial","text":"https://www.howtogeek.com/104278/how-to-use-wireshark-to-capture-filter-and-inspect-packets/ https://www.varonis.com/blog/how-to-use-wireshark/","title":"wireshark tutorial"},{"location":"Network/Tools/Packet-analyzer/Wireshark/#wireshark#inspect#packets","text":"https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/ https://resources.infosecinstitute.com/pcap-analysis-basics-with-wireshark/","title":"wireshark inspect packets"},{"location":"Network/Tools/Packet-analyzer/Wireshark/#_1","text":"csdn wireshark\u6293\u5305\u5206\u6790\u2014\u2014TCP/IP\u534f\u8bae csdn WireShark\u6293\u5305\u5206\u6790","title":"\u6293\u5305\u5206\u6790"},{"location":"Network/Tools/Packet-analyzer/tcpdump/tcpdump/","text":"tcpdump tcpdump -i any port 11507 or port 11508 or port 11510 -s 0 -w front-arb1.pcap opensource An introduction to using tcpdump at the Linux command line Tcpdump is a command line utility that allows you to capture and analyze network traffic going through your system. It is often used to help troubleshoot network issues, as well as a security tool. NOTE: network traffic\u5373 \u201c\u7f51\u7edc\u901a\u4fe1\u201d 2. Capturing packets with tcpdump To begin, use the command tcpdump --list-interfaces (or -D for short) to see which interfaces are available for capture: $ sudo tcpdump -D 1 .eth0 2 .virbr0 3 .eth1 4 .any ( Pseudo-device that captures on all interfaces ) 5 .lo [ Loopback ] In the example above, you can see all the interfaces available in my machine. The special interface any allows capturing in any active interface. NOTE: Let's use it to start capturing some packets. Capture all packets in any interface by running this command: tcpdump --interface any NOTE: \u539f\u6587\u7ed9\u51fa\u7684command\u662f official website: tcpdump wikipedia tcpdump man 1 tcpdump Parse pcap file tcpdump \u662f\u53ef\u4ee5\u76f4\u63a5parse pcap file\u7684\uff0c\u53c2\u89c1\u4e0b\u9762\u8fd9\u4e9b\u6587\u7ae0\uff1a serverfault How can I read pcap files in a friendly format? : tcpdump -ttttnnr tcp_dump.pcap tcpdump -qns 0 -A -r blah.pcap tcpick -C -yP -r tcp_dump.pcap A Wireshark is probably the best, but if you want/need to look at the payload without loading up a GUI you can use the -X or -A options tcpdump -qns 0 -X -r serverfault_request.pcap tcpdump -qns 0 -A -r serverfault_request.pcap There are many other tools for reading and getting stats, extracting payloads and so on. A quick look on the number of things that depend on libpcap in the debian package repository gives a list of 50+ tools that can be used to slice, dice, view, and manipulate captures in various ways. For example. tcpick tcpxtract A tshark -r file.pcap -V A You can use wireshark which is a gui app or you can use tshark which is it's cli counterpart. Besides, you can visualize the pcap using several visualization tools: tnv - The Network Visualizer or Time-based Network Visualizer afterglow - A collection of scripts which facilitate the process of generating graphs INAV - Interactive Network Active-traffic Visualization If you want to analyze the pcap file you can use the excelent nsm-console . Last, but not least, you can upload your pcap to pcapr.net and watch it there. pcapr.net is a kind of social website to analyze and comment to traffic captures.","title":"tcpdump"},{"location":"Network/Tools/Packet-analyzer/tcpdump/tcpdump/#tcpdump","text":"tcpdump -i any port 11507 or port 11508 or port 11510 -s 0 -w front-arb1.pcap","title":"tcpdump"},{"location":"Network/Tools/Packet-analyzer/tcpdump/tcpdump/#opensource#an#introduction#to#using#tcpdump#at#the#linux#command#line","text":"Tcpdump is a command line utility that allows you to capture and analyze network traffic going through your system. It is often used to help troubleshoot network issues, as well as a security tool. NOTE: network traffic\u5373 \u201c\u7f51\u7edc\u901a\u4fe1\u201d","title":"opensource An introduction to using tcpdump at the Linux command line"},{"location":"Network/Tools/Packet-analyzer/tcpdump/tcpdump/#2#capturing#packets#with#tcpdump","text":"To begin, use the command tcpdump --list-interfaces (or -D for short) to see which interfaces are available for capture: $ sudo tcpdump -D 1 .eth0 2 .virbr0 3 .eth1 4 .any ( Pseudo-device that captures on all interfaces ) 5 .lo [ Loopback ] In the example above, you can see all the interfaces available in my machine. The special interface any allows capturing in any active interface. NOTE: Let's use it to start capturing some packets. Capture all packets in any interface by running this command: tcpdump --interface any NOTE: \u539f\u6587\u7ed9\u51fa\u7684command\u662f","title":"2. Capturing packets with tcpdump"},{"location":"Network/Tools/Packet-analyzer/tcpdump/tcpdump/#official#website#tcpdump","text":"","title":"official website: tcpdump"},{"location":"Network/Tools/Packet-analyzer/tcpdump/tcpdump/#wikipedia#tcpdump","text":"","title":"wikipedia tcpdump"},{"location":"Network/Tools/Packet-analyzer/tcpdump/tcpdump/#man#1#tcpdump","text":"","title":"man 1 tcpdump"},{"location":"Network/Tools/Packet-analyzer/tcpdump/tcpdump/#parse#pcap#file","text":"tcpdump \u662f\u53ef\u4ee5\u76f4\u63a5parse pcap file\u7684\uff0c\u53c2\u89c1\u4e0b\u9762\u8fd9\u4e9b\u6587\u7ae0\uff1a serverfault How can I read pcap files in a friendly format? : tcpdump -ttttnnr tcp_dump.pcap tcpdump -qns 0 -A -r blah.pcap tcpick -C -yP -r tcp_dump.pcap A Wireshark is probably the best, but if you want/need to look at the payload without loading up a GUI you can use the -X or -A options tcpdump -qns 0 -X -r serverfault_request.pcap tcpdump -qns 0 -A -r serverfault_request.pcap There are many other tools for reading and getting stats, extracting payloads and so on. A quick look on the number of things that depend on libpcap in the debian package repository gives a list of 50+ tools that can be used to slice, dice, view, and manipulate captures in various ways. For example. tcpick tcpxtract A tshark -r file.pcap -V A You can use wireshark which is a gui app or you can use tshark which is it's cli counterpart. Besides, you can visualize the pcap using several visualization tools: tnv - The Network Visualizer or Time-based Network Visualizer afterglow - A collection of scripts which facilitate the process of generating graphs INAV - Interactive Network Active-traffic Visualization If you want to analyze the pcap file you can use the excelent nsm-console . Last, but not least, you can upload your pcap to pcapr.net and watch it there. pcapr.net is a kind of social website to analyze and comment to traffic captures.","title":"Parse pcap file"},{"location":"Network/Tools/iproute2/","text":"iproute2 \u662f\u5728\u9605\u8bfbwikipedia netstat \u65f6\uff0c\u53d1\u73b0\u7684iproute2\u3002 wikipedia iproute2 iproute2 collection contains the following command-line utilities : ip , ss , bridge , rtacct , rtmon , tc , ctstat , lnstat , nstat , routef , routel , rtstat , tipc , arpd and devlink .[ 3] tc is used for traffic control . iproute2 utilities communicate with the Linux kernel using the netlink protocol. Some of the iproute2 utilities are often recommended over now-obsolete net-tools utilities that provide the same functionality.[ 4] [ 5] ss ss(8) - Linux man page ss is used to dump socket statistics. It allows showing information similar to netstat . It can display more TCP and state informations than other tools. NOTE: \u770b\u4e86\u4e00\u4e0b\uff0c\u8fd9\u4e2acommand\u7684\u4e00\u4e2a\u4f18\u52bf\u5b83\u80fd\u591f\u8ba9\u6211\u4eec\u67e5\u770bTCP\u7684\u5e95\u5c42\u5b9e\u73b0\u4fe1\u606f\uff0c\u6bd4\u5982state\u3001socket table\u7b49\u3002 Example TODO tecmint 12 ss Command Examples to Monitor Network Connections","title":"Introduction"},{"location":"Network/Tools/iproute2/#iproute2","text":"\u662f\u5728\u9605\u8bfbwikipedia netstat \u65f6\uff0c\u53d1\u73b0\u7684iproute2\u3002","title":"iproute2"},{"location":"Network/Tools/iproute2/#wikipedia#iproute2","text":"iproute2 collection contains the following command-line utilities : ip , ss , bridge , rtacct , rtmon , tc , ctstat , lnstat , nstat , routef , routel , rtstat , tipc , arpd and devlink .[ 3] tc is used for traffic control . iproute2 utilities communicate with the Linux kernel using the netlink protocol. Some of the iproute2 utilities are often recommended over now-obsolete net-tools utilities that provide the same functionality.[ 4] [ 5]","title":"wikipedia iproute2"},{"location":"Network/Tools/iproute2/#ss","text":"","title":"ss"},{"location":"Network/Tools/iproute2/#ss8#-#linux#man#page","text":"ss is used to dump socket statistics. It allows showing information similar to netstat . It can display more TCP and state informations than other tools. NOTE: \u770b\u4e86\u4e00\u4e0b\uff0c\u8fd9\u4e2acommand\u7684\u4e00\u4e2a\u4f18\u52bf\u5b83\u80fd\u591f\u8ba9\u6211\u4eec\u67e5\u770bTCP\u7684\u5e95\u5c42\u5b9e\u73b0\u4fe1\u606f\uff0c\u6bd4\u5982state\u3001socket table\u7b49\u3002","title":"ss(8) - Linux man page"},{"location":"Network/Tools/iproute2/#example","text":"TODO tecmint 12 ss Command Examples to Monitor Network Connections","title":"Example"},{"location":"Operating-system/","text":"Operating system Operating system\uff08\u7b80\u79f0OS\uff09\u662f\u4e00\u4e2a\u975e\u5e38\u5b8f\u5927\u7684\u4e3b\u9898\uff0c\u6d89\u53ca\u7684\u5185\u5bb9\u975e\u5e38\u591a\u3002\u4f5c\u4e3a\u4e00\u540dsoftware engineer\uff0c\u638c\u63e1operating system\u7684\u57fa\u7840\u77e5\u8bc6\u662f\u5fc5\u987b\u7684\u3002\u672c\u8282\u662f\u5bf9OS\u7684\u6982\u8ff0\uff0c\u53c2\u8003\u7684\u662f\u7ef4\u57fa\u767e\u79d1 Operating system \u3002 \u7ef4\u57fa\u767e\u79d1 Operating system An operating system ( OS ) is system software that manages computer hardware and software resources and provides common services for computer programs . Types of operating systems NOTE: \u4e0b\u9762\u7f57\u5217\u4e86\u591a\u79cd\u5206\u7c7b\u65b9\u6cd5\uff0c\u6bcf\u79cd\u5206\u7c7b\u65b9\u6cd5\u5176\u5b9e\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u79cd**\u7279\u6027**\u3002\u663e\u7136\u6709\u5f88\u591a\u7684operating system\u53ef\u4ee5\u517c\u5177\u591a\u79cd\u7279\u6027\uff0c\u6bd4\u5982linux\uff0c\u5b83\u5177\u5907multi-tasking\u3001 multi-user\u7b49\u7279\u6027 Single-tasking and multi-tasking single-tasking operating system multi-tasking operating system Single- and multi-user single-user operating system multi-user operating system Distributed distributed operating system Templated templating Embedded embedded operating systems Real-time real-time operating system Examples Unix and Unix-like operating systems Main article: Unix Unix Unix-like System V BSD Linux . Unix interoperability was sought by establishing the POSIX standard. The POSIX standard can be applied to any operating system, although it was originally created for various Unix variants. BSD and its descendants Main article: Berkeley Software Distribution FreeBSD NetBSD OpenBSD macOS Main article: macOS Linux Main articles: Linux and Linux kernel The Linux kernel is used in some popular distributions, such as Red Hat , Debian , Ubuntu , Linux Mint and Google 's Android , Chrome OS , and Chromium OS . Microsoft Windows Main article: Microsoft Windows Components The components of an operating system all exist in order to make the different parts of a computer work together. All user software needs to go through the operating system in order to use any of the hardware, whether it be as simple as a mouse or keyboard or as complex as an Internet component. Kernel NOTE: \u6700\u6838\u5fc3\u7684\u90e8\u5206 A kernel connects the application software to the hardware of a computer. Main article: Kernel (computing) Main article Program execution Process (computing) Interrupts Interrupt Modes User mode and Supervisor mode Memory management Memory management Virtual memory Virtual memory Page fault Multitasking Computer multitasking Process management (computing) Context switch Preemptive multitasking Cooperative multitasking Disk access and file systems Virtual file system Device drivers Device driver Networking Main article: Computer network Security Main article: Computer security User interface Main article: Operating system user interface Concrete OS structure \u672c\u8282\u7684\u6807\u9898\u662f\u201c\u5177\u4f53\u7684OS\u7684\u7ed3\u6784\": \u4e0a\u9762\u662f\u7ef4\u57fa\u767e\u79d1 Operating system \u6240\u603b\u7ed3\u7684OS\u7684\u5185\u5bb9\u3002 wikipedia Diversity of operating systems and portability wikipedia Market share NOTE: OS\u7684\u5e02\u573a\u4efd\u989d Further information: Usage share of operating systems","title":"Introduction"},{"location":"Operating-system/#operating#system","text":"Operating system\uff08\u7b80\u79f0OS\uff09\u662f\u4e00\u4e2a\u975e\u5e38\u5b8f\u5927\u7684\u4e3b\u9898\uff0c\u6d89\u53ca\u7684\u5185\u5bb9\u975e\u5e38\u591a\u3002\u4f5c\u4e3a\u4e00\u540dsoftware engineer\uff0c\u638c\u63e1operating system\u7684\u57fa\u7840\u77e5\u8bc6\u662f\u5fc5\u987b\u7684\u3002\u672c\u8282\u662f\u5bf9OS\u7684\u6982\u8ff0\uff0c\u53c2\u8003\u7684\u662f\u7ef4\u57fa\u767e\u79d1 Operating system \u3002","title":"Operating system"},{"location":"Operating-system/#operating#system_1","text":"An operating system ( OS ) is system software that manages computer hardware and software resources and provides common services for computer programs .","title":"\u7ef4\u57fa\u767e\u79d1 Operating system"},{"location":"Operating-system/#types#of#operating#systems","text":"NOTE: \u4e0b\u9762\u7f57\u5217\u4e86\u591a\u79cd\u5206\u7c7b\u65b9\u6cd5\uff0c\u6bcf\u79cd\u5206\u7c7b\u65b9\u6cd5\u5176\u5b9e\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u79cd**\u7279\u6027**\u3002\u663e\u7136\u6709\u5f88\u591a\u7684operating system\u53ef\u4ee5\u517c\u5177\u591a\u79cd\u7279\u6027\uff0c\u6bd4\u5982linux\uff0c\u5b83\u5177\u5907multi-tasking\u3001 multi-user\u7b49\u7279\u6027","title":"Types of operating systems"},{"location":"Operating-system/#single-tasking#and#multi-tasking","text":"single-tasking operating system multi-tasking operating system","title":"Single-tasking and multi-tasking"},{"location":"Operating-system/#single-#and#multi-user","text":"single-user operating system multi-user operating system","title":"Single- and multi-user"},{"location":"Operating-system/#distributed","text":"distributed operating system","title":"Distributed"},{"location":"Operating-system/#templated","text":"templating","title":"Templated"},{"location":"Operating-system/#embedded","text":"embedded operating systems","title":"Embedded"},{"location":"Operating-system/#real-time","text":"real-time operating system","title":"Real-time"},{"location":"Operating-system/#examples","text":"","title":"Examples"},{"location":"Operating-system/#unix#and#unix-like#operating#systems","text":"Main article: Unix Unix Unix-like System V BSD Linux . Unix interoperability was sought by establishing the POSIX standard. The POSIX standard can be applied to any operating system, although it was originally created for various Unix variants.","title":"Unix and Unix-like operating systems"},{"location":"Operating-system/#bsd#and#its#descendants","text":"Main article: Berkeley Software Distribution FreeBSD NetBSD OpenBSD","title":"BSD and its descendants"},{"location":"Operating-system/#macos","text":"Main article: macOS","title":"macOS"},{"location":"Operating-system/#linux","text":"Main articles: Linux and Linux kernel The Linux kernel is used in some popular distributions, such as Red Hat , Debian , Ubuntu , Linux Mint and Google 's Android , Chrome OS , and Chromium OS .","title":"Linux"},{"location":"Operating-system/#microsoft#windows","text":"Main article: Microsoft Windows","title":"Microsoft Windows"},{"location":"Operating-system/#components","text":"The components of an operating system all exist in order to make the different parts of a computer work together. All user software needs to go through the operating system in order to use any of the hardware, whether it be as simple as a mouse or keyboard or as complex as an Internet component.","title":"Components"},{"location":"Operating-system/#kernel","text":"NOTE: \u6700\u6838\u5fc3\u7684\u90e8\u5206 A kernel connects the application software to the hardware of a computer. Main article: Kernel (computing) Main article Program execution Process (computing) Interrupts Interrupt Modes User mode and Supervisor mode Memory management Memory management Virtual memory Virtual memory Page fault Multitasking Computer multitasking Process management (computing) Context switch Preemptive multitasking Cooperative multitasking Disk access and file systems Virtual file system Device drivers Device driver","title":"Kernel"},{"location":"Operating-system/#networking","text":"Main article: Computer network","title":"Networking"},{"location":"Operating-system/#security","text":"Main article: Computer security","title":"Security"},{"location":"Operating-system/#user#interface","text":"Main article: Operating system user interface","title":"User interface"},{"location":"Operating-system/#concrete#os#structure","text":"\u672c\u8282\u7684\u6807\u9898\u662f\u201c\u5177\u4f53\u7684OS\u7684\u7ed3\u6784\": \u4e0a\u9762\u662f\u7ef4\u57fa\u767e\u79d1 Operating system \u6240\u603b\u7ed3\u7684OS\u7684\u5185\u5bb9\u3002","title":"Concrete OS structure"},{"location":"Operating-system/#wikipedia#diversity#of#operating#systems#and#portability","text":"","title":"wikipedia Diversity of operating systems and portability"},{"location":"Operating-system/#wikipedia#market#share","text":"NOTE: OS\u7684\u5e02\u573a\u4efd\u989d Further information: Usage share of operating systems","title":"wikipedia Market share"},{"location":"Programming/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u4e3b\u8981\u8ba8\u8bbaprogramming in Linux OS\uff0c\u6240\u4ee5\u4e3b\u8981\u5173\u6ce8\u7684\u662fLinux OS\u63d0\u4f9b\u7684interface\u3002 Interface \u5728\u7406\u8bba\u90e8\u5206\uff0c\u6211\u4eec\u5df2\u7ecf\u5b66\u4e60\u4e86Linux OS\u7684\u5404\u4e2a\u5c42\u6b21\uff0cLinux OS\u5728\u5404\u4e2a\u5c42\u6b21\u90fd\u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684\u3001\u529f\u80fd\u5b8c\u5907\u7684interface\uff0c\u751a\u81f3\u6709\u4e9b\u5c42\u6b21\u7684interface\u7684\u540d\u79f0\u5b8c\u5168\u76f8\u540c\uff0c\u8fd9\u589e\u52a0\u4e86\u7528\u6237\u4f7f\u7528\u7684\u4fbf\u5229\u3001\u964d\u4f4e\u4e86\u5b66\u4e60\u6210\u672c\u3002 \u5bf9interface\u7684\u5b66\u4e60\u662f\u638c\u63e1Linux OS\u7684\u5173\u952e\uff0c\u5728\u672c\u5de5\u7a0b\u4e2d\uff0c\u4f1a\u5c06command line interface\u653e\u5230 Tools \u76ee\u5f55\u4e0b\u3002 interface man page \u8bf4\u660e system call man(2) \u3001 man(3) library function pthread command line interface man(1) \u3001 man(8) Linux\u7684CLI\u975e\u5e38\u5f3a\u5927 command line interface\u5176\u5b9e\u4e5f\u662fkernel\u7684interface man TODO: \u5bf9Linux OS\u7684man\u8fdb\u884c\u4ecb\u7ecd","title":"Introduction"},{"location":"Programming/#_1","text":"\u672c\u7ae0\u4e3b\u8981\u8ba8\u8bbaprogramming in Linux OS\uff0c\u6240\u4ee5\u4e3b\u8981\u5173\u6ce8\u7684\u662fLinux OS\u63d0\u4f9b\u7684interface\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/#interface","text":"\u5728\u7406\u8bba\u90e8\u5206\uff0c\u6211\u4eec\u5df2\u7ecf\u5b66\u4e60\u4e86Linux OS\u7684\u5404\u4e2a\u5c42\u6b21\uff0cLinux OS\u5728\u5404\u4e2a\u5c42\u6b21\u90fd\u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684\u3001\u529f\u80fd\u5b8c\u5907\u7684interface\uff0c\u751a\u81f3\u6709\u4e9b\u5c42\u6b21\u7684interface\u7684\u540d\u79f0\u5b8c\u5168\u76f8\u540c\uff0c\u8fd9\u589e\u52a0\u4e86\u7528\u6237\u4f7f\u7528\u7684\u4fbf\u5229\u3001\u964d\u4f4e\u4e86\u5b66\u4e60\u6210\u672c\u3002 \u5bf9interface\u7684\u5b66\u4e60\u662f\u638c\u63e1Linux OS\u7684\u5173\u952e\uff0c\u5728\u672c\u5de5\u7a0b\u4e2d\uff0c\u4f1a\u5c06command line interface\u653e\u5230 Tools \u76ee\u5f55\u4e0b\u3002 interface man page \u8bf4\u660e system call man(2) \u3001 man(3) library function pthread command line interface man(1) \u3001 man(8) Linux\u7684CLI\u975e\u5e38\u5f3a\u5927 command line interface\u5176\u5b9e\u4e5f\u662fkernel\u7684interface","title":"Interface"},{"location":"Programming/#man","text":"TODO: \u5bf9Linux OS\u7684man\u8fdb\u884c\u4ecb\u7ecd","title":"man"},{"location":"Programming/Book-APUE/","text":"","title":"Introduction"},{"location":"Programming/Book-APUE/10-Signals/10.6-Reentrant-Functions/","text":"","title":"10.6-Reentrant-Functions"},{"location":"Programming/Book-APUE/Race-condition/","text":"Race condition APUE\u7684\u4e0b\u5217\u7ae0\u8282\u5305\u542b\u4e86race condition\u76f8\u5173\u7684\u5185\u5bb9\uff1a 8.9 Race Conditions 11.6 Thread Synchronization 3.10 File Sharing 3.11 Atomic Operations 3.3 open and openat Functions time-of-check-to-time-of-use 12.5 Reentrancy 10.6 Reentrant Functions 8.9 Race Conditions For our purposes, a race condition occurs when multiple processes are trying to do something with shared data and the final outcome depends on the order in which the processes run. The fork function is a lively breeding ground for race conditions , if any of the logic after the fork either explicitly or implicitly depends on whether the parent or child runs first after the fork . In general, we cannot predict which process runs first. Even if we knew which process would run first, what happens after that process starts running depends on the system load and the kernel\u2019s scheduling algorithm .","title":"Introduction"},{"location":"Programming/Book-APUE/Race-condition/#race#condition","text":"APUE\u7684\u4e0b\u5217\u7ae0\u8282\u5305\u542b\u4e86race condition\u76f8\u5173\u7684\u5185\u5bb9\uff1a 8.9 Race Conditions 11.6 Thread Synchronization 3.10 File Sharing 3.11 Atomic Operations 3.3 open and openat Functions time-of-check-to-time-of-use 12.5 Reentrancy 10.6 Reentrant Functions","title":"Race condition"},{"location":"Programming/Book-APUE/Race-condition/#89#race#conditions","text":"For our purposes, a race condition occurs when multiple processes are trying to do something with shared data and the final outcome depends on the order in which the processes run. The fork function is a lively breeding ground for race conditions , if any of the logic after the fork either explicitly or implicitly depends on whether the parent or child runs first after the fork . In general, we cannot predict which process runs first. Even if we knew which process would run first, what happens after that process starts running depends on the system load and the kernel\u2019s scheduling algorithm .","title":"8.9  Race Conditions"},{"location":"Programming/Book-APUE/Reentrant-and-async-signal-safety-and-thread-safety/","text":"Reentrant and async-signal safe and thread-safe \u54ea\u4e9b\u60c5\u51b5\u4e0b\u4f1a\u51fa\u73b0\u91cd\u5165\uff1f \u2013 \u8c03\u7528signal handler\uff0c\u800c\u4e2d\u65ad\u6b63\u5728\u6267\u884c\u7684\u51fd\u6570\uff0c\u5728signal handler\u4e2d\u8c03\u7528\u4e0e\u88ab\u4e2d\u65ad\u51fd\u6570\u76f8\u540c\u7684\u51fd\u6570\uff0c\u8fd9\u5c31\u662f\u91cd\u5165 \u2013 \u591a\u4e2a\u7ebf\u7a0b\u5728\u76f8\u540c\u7684\u65f6\u523b\uff0c\u8c03\u7528\u540c\u4e00\u4e2a\u51fd\u6570 APUE 12.5 Reentrancy\u7ed9\u51fa\u7684definition\u5982\u4e0b\uff1a If a function is reentrant with respect to multiple threads, we say that it is thread-safe . This doesn\u2019t tell us, however, whether the function is reentrant with respect to signal handlers. We say that a function that is safe to be reentered from an asynchronous signal handler is async-signal safe . We saw the async-signal safe functions in Figure 10.4 when we discussed reentrant functions in Section 10.6. APUE 10.6 Reentrant Functions\u7ed9\u51fa\u7684definition\u5982\u4e0b\uff1a The Single UNIX Specification specifies the functions that are guaranteed to be safe to call from within a signal handler. These functions are reentrant and are called async-signal safe by the Single UNIX Specification. Besides being reentrant, they block any signals during operation if delivery of a signal might cause inconsistencies.","title":"Introduction"},{"location":"Programming/Book-APUE/Reentrant-and-async-signal-safety-and-thread-safety/#reentrant#and#async-signal#safe#and#thread-safe","text":"\u54ea\u4e9b\u60c5\u51b5\u4e0b\u4f1a\u51fa\u73b0\u91cd\u5165\uff1f \u2013 \u8c03\u7528signal handler\uff0c\u800c\u4e2d\u65ad\u6b63\u5728\u6267\u884c\u7684\u51fd\u6570\uff0c\u5728signal handler\u4e2d\u8c03\u7528\u4e0e\u88ab\u4e2d\u65ad\u51fd\u6570\u76f8\u540c\u7684\u51fd\u6570\uff0c\u8fd9\u5c31\u662f\u91cd\u5165 \u2013 \u591a\u4e2a\u7ebf\u7a0b\u5728\u76f8\u540c\u7684\u65f6\u523b\uff0c\u8c03\u7528\u540c\u4e00\u4e2a\u51fd\u6570 APUE 12.5 Reentrancy\u7ed9\u51fa\u7684definition\u5982\u4e0b\uff1a If a function is reentrant with respect to multiple threads, we say that it is thread-safe . This doesn\u2019t tell us, however, whether the function is reentrant with respect to signal handlers. We say that a function that is safe to be reentered from an asynchronous signal handler is async-signal safe . We saw the async-signal safe functions in Figure 10.4 when we discussed reentrant functions in Section 10.6. APUE 10.6 Reentrant Functions\u7ed9\u51fa\u7684definition\u5982\u4e0b\uff1a The Single UNIX Specification specifies the functions that are guaranteed to be safe to call from within a signal handler. These functions are reentrant and are called async-signal safe by the Single UNIX Specification. Besides being reentrant, they block any signals during operation if delivery of a signal might cause inconsistencies.","title":"Reentrant and async-signal safe and thread-safe"},{"location":"Programming/Common/Conventions/","text":"Unix handler and start_rtn \u524d\u8a00 \u4eca\u5929\u5728\u9605\u8bfbAPUE\u7684chapter 7.3 Process Termination\uff0c\u770b\u5176 atexit Function\uff0c\u901a\u8fc7\u6b64\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u6765\u6ce8\u518c exit handlers \uff0c\u8fd9\u79cd\u901a\u8fc7\u4f7f\u7528\u51fd\u6570\u6307\u9488\u6765\u4f5c\u4e3a\u53c2\u6570\u7684\u65b9\u5f0f\u5728Unix-like OS\u7684system call\u4e2d\u975e\u5e38\u5e38\u89c1\uff0c\u5e76\u4e14\uff0c\u5b83\u4eec\u7684\u547d\u540d\u5f80\u5f80\u4e5f\u662f\u7c7b\u4f3c\u7684\uff0c\u6bd4\u5982\u5e38\u5e38\u5e26handler\u7b49\uff1b\u6240\u4ee5\u6211\u51b3\u5b9a\u8fdb\u884c\u6574\u7406\uff1b atexit and exit handler \u53c2\u89c1 APUE chapter 7.3 Process Termination sigaction Function and signal handler \u53c2\u89c1APUE 10.14 sigaction Function signal Function and signal handler \u53c2\u89c1APUE 10.3 signal Function pthread_create and start_rtn \u53c2\u89c1APUE 11.4 Thread Creation","title":"Unix handler and `start_rtn`"},{"location":"Programming/Common/Conventions/#unix#handler#and#start_rtn","text":"","title":"Unix handler and start_rtn"},{"location":"Programming/Common/Conventions/#_1","text":"\u4eca\u5929\u5728\u9605\u8bfbAPUE\u7684chapter 7.3 Process Termination\uff0c\u770b\u5176 atexit Function\uff0c\u901a\u8fc7\u6b64\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u6765\u6ce8\u518c exit handlers \uff0c\u8fd9\u79cd\u901a\u8fc7\u4f7f\u7528\u51fd\u6570\u6307\u9488\u6765\u4f5c\u4e3a\u53c2\u6570\u7684\u65b9\u5f0f\u5728Unix-like OS\u7684system call\u4e2d\u975e\u5e38\u5e38\u89c1\uff0c\u5e76\u4e14\uff0c\u5b83\u4eec\u7684\u547d\u540d\u5f80\u5f80\u4e5f\u662f\u7c7b\u4f3c\u7684\uff0c\u6bd4\u5982\u5e38\u5e38\u5e26handler\u7b49\uff1b\u6240\u4ee5\u6211\u51b3\u5b9a\u8fdb\u884c\u6574\u7406\uff1b","title":"\u524d\u8a00"},{"location":"Programming/Common/Conventions/#atexit#and#exit#handler","text":"\u53c2\u89c1 APUE chapter 7.3 Process Termination","title":"atexit and exit handler"},{"location":"Programming/Common/Conventions/#sigaction#function#and#signal#handler","text":"\u53c2\u89c1APUE 10.14 sigaction Function","title":"sigaction Function and  signal handler"},{"location":"Programming/Common/Conventions/#signal#function#and#signal#handler","text":"\u53c2\u89c1APUE 10.3 signal Function","title":"signal Function and  signal handler"},{"location":"Programming/Common/Conventions/#pthread_create#and#start_rtn","text":"\u53c2\u89c1APUE 11.4 Thread Creation","title":"pthread_create  and start_rtn"},{"location":"Programming/Common/Path-resolution/","text":"PATH_RESOLUTION(7)","title":"Path-resolution"},{"location":"Programming/Common/Path-resolution/#path_resolution7","text":"","title":"PATH_RESOLUTION(7)"},{"location":"Programming/Common/Time-and-space/","text":"\u65f6\u95f4\u4e0e\u7a7a\u95f4 \u65f6\u95f4\u4e0e\u7a7a\u95f4\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u662f\u7ecf\u5e38\u9700\u8981\u8003\u8651\u7684\u95ee\u9898\uff0c\u5728\u8fdb\u884c\u7cfb\u7edfprogram\u7684\u65f6\u5019\uff0c\u9700\u8981\u4ecetime\u548cspace\u7684\u89d2\u5ea6\u6765\u8fdb\u884c\u8003\u8651\u3002 space\u89d2\u5ea6\u7684\u8bdd\uff0c\u5c31\u6d89\u53ca\u5230\u4e86race condition\u3002 time\u89d2\u5ea6\u7684\u8bdd\uff0c\u5c31\u6d89\u53ca\u5230\u4e86\u51fd\u6570\u6267\u884c\u7684\u65f6\u95f4\uff0c\u7cfb\u7edf\u8c03\u7528\u963b\u585e\u7684\u65f6\u5019\u3002\u5e76\u4e14\u5f88\u591a\u7684\u7cfb\u7edf\u8c03\u7528\u90fd\u6b63\u5e38\u8bbe\u7f6emax blocked time\u3002 \u6bd4\u5982\u5728multiple thread\u73af\u5883\u4e2d\u8fdb\u884cprogram\u7684\u65f6\u5019\uff0c\u4ece\u7a7a\u95f4\u7684\u89d2\u5ea6\u8fdb\u884c\u8003\u8651\u7684\u8bdd\uff0c\u5c31\u6d89\u53ca\u9632\u6b62thread\u4e4b\u95f4\u7684race condition\u3002\u5c31\u6d89\u53ca\u5230\u539f\u5b50\u64cd\u4f5c\u3002 \u539f\u5b50\u64cd\u4f5c\u7684\u8bdd\uff0c\u6709\u4e9bprogramming language\u63d0\u4f9b\u4e86\u539f\u5b50\u64cd\u4f5c\u5e93\uff0cOS\u4e5f\u63d0\u4f9b\u4e86\u539f\u5b50\u51fd\u6570\uff0c\u5982APUE\u7684chapter12.10\u4e2d\u6240\u63d0\u53ca\u7684 pread \uff0c pwrite \u7b49\u3002 time-of-check-to-time-of-use\u5c31\u5c5e\u4e8etime\u7684\u89d2\u5ea6\u4e86","title":"Time-and-space"},{"location":"Programming/Common/Time-and-space/#_1","text":"\u65f6\u95f4\u4e0e\u7a7a\u95f4\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u662f\u7ecf\u5e38\u9700\u8981\u8003\u8651\u7684\u95ee\u9898\uff0c\u5728\u8fdb\u884c\u7cfb\u7edfprogram\u7684\u65f6\u5019\uff0c\u9700\u8981\u4ecetime\u548cspace\u7684\u89d2\u5ea6\u6765\u8fdb\u884c\u8003\u8651\u3002 space\u89d2\u5ea6\u7684\u8bdd\uff0c\u5c31\u6d89\u53ca\u5230\u4e86race condition\u3002 time\u89d2\u5ea6\u7684\u8bdd\uff0c\u5c31\u6d89\u53ca\u5230\u4e86\u51fd\u6570\u6267\u884c\u7684\u65f6\u95f4\uff0c\u7cfb\u7edf\u8c03\u7528\u963b\u585e\u7684\u65f6\u5019\u3002\u5e76\u4e14\u5f88\u591a\u7684\u7cfb\u7edf\u8c03\u7528\u90fd\u6b63\u5e38\u8bbe\u7f6emax blocked time\u3002 \u6bd4\u5982\u5728multiple thread\u73af\u5883\u4e2d\u8fdb\u884cprogram\u7684\u65f6\u5019\uff0c\u4ece\u7a7a\u95f4\u7684\u89d2\u5ea6\u8fdb\u884c\u8003\u8651\u7684\u8bdd\uff0c\u5c31\u6d89\u53ca\u9632\u6b62thread\u4e4b\u95f4\u7684race condition\u3002\u5c31\u6d89\u53ca\u5230\u539f\u5b50\u64cd\u4f5c\u3002 \u539f\u5b50\u64cd\u4f5c\u7684\u8bdd\uff0c\u6709\u4e9bprogramming language\u63d0\u4f9b\u4e86\u539f\u5b50\u64cd\u4f5c\u5e93\uff0cOS\u4e5f\u63d0\u4f9b\u4e86\u539f\u5b50\u51fd\u6570\uff0c\u5982APUE\u7684chapter12.10\u4e2d\u6240\u63d0\u53ca\u7684 pread \uff0c pwrite \u7b49\u3002 time-of-check-to-time-of-use\u5c31\u5c5e\u4e8etime\u7684\u89d2\u5ea6\u4e86","title":"\u65f6\u95f4\u4e0e\u7a7a\u95f4"},{"location":"Programming/Common/safety/","text":"SIGNAL-SAFETY(7) Reentrancy (computing) Async-cancel-safe functions Thread-safe functions Thread safety race condition","title":"[SIGNAL-SAFETY(7)](http://man7.org/linux/man-pages/man7/signal-safety.7.html)"},{"location":"Programming/Common/safety/#signal-safety7","text":"Reentrancy (computing)","title":"SIGNAL-SAFETY(7)"},{"location":"Programming/Common/safety/#async-cancel-safe#functions","text":"","title":"Async-cancel-safe functions"},{"location":"Programming/Common/safety/#thread-safe#functions","text":"Thread safety","title":"Thread-safe functions"},{"location":"Programming/Common/safety/#race#condition","text":"","title":"race condition"},{"location":"Programming/Common/Attribute-of-function/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u63cf\u8ff0\u51fd\u6570\u7684\u4e00\u4e9b\u6027\u8d28\u3002 Reentrancy Thread-safe","title":"Introduction"},{"location":"Programming/Common/Attribute-of-function/#_1","text":"\u672c\u7ae0\u63cf\u8ff0\u51fd\u6570\u7684\u4e00\u4e9b\u6027\u8d28\u3002 Reentrancy Thread-safe","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Common/Attribute-of-function/Idempotence/","text":"Idempotence stackoverflow What is an idempotent operation? A NOTE: \u6700\u6700\u7cbe\u7b80\u7684\u56de\u7b54 No matter how many times you call the operation, the result will be the same. A NOTE: \u4eceRESTful\u7684\u89d2\u5ea6\u6765\u5206\u6790\uff0c\u8fd9\u4e00\u6bb5\u5173\u4e8erestful\u7684\u4ecb\u7ecd\u975e\u5e38\u597d 1\u3001\u9610\u8ff0\u4e86RESTful\u7684\u5185\u6db5\uff0c\u975e\u5e38\u7cbe\u7b80 An idempotent operation can be repeated an arbitrary number of times and the result will be the same as if it had been done only once. In arithmetic, adding zero to a number is idempotent. Idempotence is talked about a lot in the context of \"RESTful\" web services . REST seeks to maximally leverage HTTP to give programs access to web content, and is usually set in contrast to SOAP-based web services , which just tunnel(\u6253\u5f00\u901a\u9053) remote procedure call style services inside HTTP requests and responses. REST organizes a web application into \"resources\" (like a Twitter user, or a Flickr image) and then uses the HTTP verbs of POST, PUT, GET, and DELETE to create, update, read, and delete those resources. Idempotence plays an important role in REST. If you GET a representation of a REST resource (eg, GET a jpeg image from Flickr), and the operation fails, you can just repeat the GET again and again until the operation succeeds. To the web service, it doesn't matter how many times the image is gotten. Likewise, if you use a RESTful web service to update your Twitter account information, you can PUT the new information as many times as it takes in order to get confirmation from the web service. PUT-ing it a thousand times is the same as PUT-ing it once. Similarly DELETE-ing a REST resource a thousand times is the same as deleting it once. Idempotence thus makes it a lot easier to construct a web service that's resilient(\u53ef\u8fc5\u901f\u6062\u590d\u7684) to communication errors. Further reading: RESTful Web Services , by Richardson and Ruby (idempotence is discussed on page 103-104), and Roy Fielding's PhD dissertation on REST . Fielding was one of the authors of HTTP 1.1, RFC-2616, which talks about idempotence in section 9.1.2 . A In computing, an idempotent operation is one that has no additional effect if it is called more than once with the same input parameters. For example, removing an item from a set can be considered an idempotent operation on the set. In mathematics, an idempotent operation is one where f(f(x)) = f(x) . For example, the abs() function is idempotent because abs(abs(x)) = abs(x) for all x . These slightly different definitions can be reconciled by considering that x in the mathematical definition represents the state of an object, and f is an operation that may mutate that object. For example, consider the Python set and its discard method. The discard method removes an element from a set, and does nothing if the element does not exist. So: my_set . discard ( x ) has exactly the same effect as doing the same operation twice: my_set . discard ( x ) my_set . discard ( x ) Idempotent operations are often used in the design of network protocols, where a request to perform an operation is guaranteed to happen at least once, but might also happen more than once. If the operation is idempotent, then there is no harm in performing the operation two or more times. See the Wikipedia article on idempotence for more information. wikipedia Idempotence Example celery tasks hiredis redisAsyncContext hiredis\u7684 async.h \u4e2d\u7684 struct redisAsyncContext \u5c31\u6709\u5982\u4e0b\u5b9a\u4e49\uff1a /* Context for an async connection to Redis */ typedef struct redisAsyncContext { /* Hold the regular context, so it can be realloc'ed. */ redisContext c ; /* Setup error flags so they can be used directly. */ int err ; char * errstr ; /* Not used by hiredis */ void * data ; /* Event library data and hooks */ struct { void * data ; /* Hooks that are called when the library expects to start * reading/writing. These functions should be idempotent. */ void ( * addRead )( void * privdata ); void ( * delRead )( void * privdata ); void ( * addWrite )( void * privdata ); void ( * delWrite )( void * privdata ); void ( * cleanup )( void * privdata ); } ev ;","title":"Introduction"},{"location":"Programming/Common/Attribute-of-function/Idempotence/#idempotence","text":"","title":"Idempotence"},{"location":"Programming/Common/Attribute-of-function/Idempotence/#stackoverflow#what#is#an#idempotent#operation","text":"","title":"stackoverflow What is an idempotent operation?"},{"location":"Programming/Common/Attribute-of-function/Idempotence/#a","text":"NOTE: \u6700\u6700\u7cbe\u7b80\u7684\u56de\u7b54 No matter how many times you call the operation, the result will be the same.","title":"A"},{"location":"Programming/Common/Attribute-of-function/Idempotence/#a_1","text":"NOTE: \u4eceRESTful\u7684\u89d2\u5ea6\u6765\u5206\u6790\uff0c\u8fd9\u4e00\u6bb5\u5173\u4e8erestful\u7684\u4ecb\u7ecd\u975e\u5e38\u597d 1\u3001\u9610\u8ff0\u4e86RESTful\u7684\u5185\u6db5\uff0c\u975e\u5e38\u7cbe\u7b80 An idempotent operation can be repeated an arbitrary number of times and the result will be the same as if it had been done only once. In arithmetic, adding zero to a number is idempotent. Idempotence is talked about a lot in the context of \"RESTful\" web services . REST seeks to maximally leverage HTTP to give programs access to web content, and is usually set in contrast to SOAP-based web services , which just tunnel(\u6253\u5f00\u901a\u9053) remote procedure call style services inside HTTP requests and responses. REST organizes a web application into \"resources\" (like a Twitter user, or a Flickr image) and then uses the HTTP verbs of POST, PUT, GET, and DELETE to create, update, read, and delete those resources. Idempotence plays an important role in REST. If you GET a representation of a REST resource (eg, GET a jpeg image from Flickr), and the operation fails, you can just repeat the GET again and again until the operation succeeds. To the web service, it doesn't matter how many times the image is gotten. Likewise, if you use a RESTful web service to update your Twitter account information, you can PUT the new information as many times as it takes in order to get confirmation from the web service. PUT-ing it a thousand times is the same as PUT-ing it once. Similarly DELETE-ing a REST resource a thousand times is the same as deleting it once. Idempotence thus makes it a lot easier to construct a web service that's resilient(\u53ef\u8fc5\u901f\u6062\u590d\u7684) to communication errors. Further reading: RESTful Web Services , by Richardson and Ruby (idempotence is discussed on page 103-104), and Roy Fielding's PhD dissertation on REST . Fielding was one of the authors of HTTP 1.1, RFC-2616, which talks about idempotence in section 9.1.2 .","title":"A"},{"location":"Programming/Common/Attribute-of-function/Idempotence/#a_2","text":"In computing, an idempotent operation is one that has no additional effect if it is called more than once with the same input parameters. For example, removing an item from a set can be considered an idempotent operation on the set. In mathematics, an idempotent operation is one where f(f(x)) = f(x) . For example, the abs() function is idempotent because abs(abs(x)) = abs(x) for all x . These slightly different definitions can be reconciled by considering that x in the mathematical definition represents the state of an object, and f is an operation that may mutate that object. For example, consider the Python set and its discard method. The discard method removes an element from a set, and does nothing if the element does not exist. So: my_set . discard ( x ) has exactly the same effect as doing the same operation twice: my_set . discard ( x ) my_set . discard ( x ) Idempotent operations are often used in the design of network protocols, where a request to perform an operation is guaranteed to happen at least once, but might also happen more than once. If the operation is idempotent, then there is no harm in performing the operation two or more times. See the Wikipedia article on idempotence for more information.","title":"A"},{"location":"Programming/Common/Attribute-of-function/Idempotence/#wikipedia#idempotence","text":"","title":"wikipedia Idempotence"},{"location":"Programming/Common/Attribute-of-function/Idempotence/#example","text":"","title":"Example"},{"location":"Programming/Common/Attribute-of-function/Idempotence/#celery#tasks","text":"","title":"celery tasks"},{"location":"Programming/Common/Attribute-of-function/Idempotence/#hiredis#redisasynccontext","text":"hiredis\u7684 async.h \u4e2d\u7684 struct redisAsyncContext \u5c31\u6709\u5982\u4e0b\u5b9a\u4e49\uff1a /* Context for an async connection to Redis */ typedef struct redisAsyncContext { /* Hold the regular context, so it can be realloc'ed. */ redisContext c ; /* Setup error flags so they can be used directly. */ int err ; char * errstr ; /* Not used by hiredis */ void * data ; /* Event library data and hooks */ struct { void * data ; /* Hooks that are called when the library expects to start * reading/writing. These functions should be idempotent. */ void ( * addRead )( void * privdata ); void ( * delRead )( void * privdata ); void ( * addWrite )( void * privdata ); void ( * delWrite )( void * privdata ); void ( * cleanup )( void * privdata ); } ev ;","title":"hiredis redisAsyncContext"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bbareentrancy\u3002 TODO microchip Sharing global variables with multiple Interrupt Service Routines Drafts 1 \u5178\u578b\u7684\u4f8b\u5b50\u662f\uff1a\u51fd\u6570\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\uff0c\u4ee5\u4e0d\u53ef\u9884\u77e5\u7684\u65b9\u5f0f\u88abinterrupt\uff0c\u7136\u540e\u6539\u51fd\u6570\u53c8\u518d\u6b21\u88ab\u6267\u884c\u3002 2 Reentrant\uff1a OS book\u76841.6.3. Reentrant Kernels\u4e2d\u7684\u201cReentrant\u201d\u548cReentrant function\u4e2d\u7684Reentrant\u7684\u542b\u4e49\u662f\u4e0d\u540c\u7684 \u5173\u4e8eReentrant function\uff0c\u7ef4\u57fa\u767e\u79d1\u7684\u4ecb\u7ecd\u662f\u975e\u5e38\u597d\u7684 3 https://www.gnu.org/software/libc/manual/html_node/Nonreentrancy.html https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant https://stackoverflow.com/questions/855763/is-malloc-thread-safe 4 \u5728 https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf \u4e2d\uff0c\u63d0\u53ca\u4e86 Unfortunately, this implementation is not reliable in a multithreaded environment. Suppose that Thread A enters the instance function, executes through Line 14, and is then suspended. At the point where it is suspended, it has just determined that pInstance is null, i.e., that no Singleton object has yet been created","title":"Introduction"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/#_1","text":"\u672c\u7ae0\u8ba8\u8bbareentrancy\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/#todo","text":"microchip Sharing global variables with multiple Interrupt Service Routines","title":"TODO"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/#drafts","text":"1 \u5178\u578b\u7684\u4f8b\u5b50\u662f\uff1a\u51fd\u6570\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\uff0c\u4ee5\u4e0d\u53ef\u9884\u77e5\u7684\u65b9\u5f0f\u88abinterrupt\uff0c\u7136\u540e\u6539\u51fd\u6570\u53c8\u518d\u6b21\u88ab\u6267\u884c\u3002 2 Reentrant\uff1a OS book\u76841.6.3. Reentrant Kernels\u4e2d\u7684\u201cReentrant\u201d\u548cReentrant function\u4e2d\u7684Reentrant\u7684\u542b\u4e49\u662f\u4e0d\u540c\u7684 \u5173\u4e8eReentrant function\uff0c\u7ef4\u57fa\u767e\u79d1\u7684\u4ecb\u7ecd\u662f\u975e\u5e38\u597d\u7684 3 https://www.gnu.org/software/libc/manual/html_node/Nonreentrancy.html https://stackoverflow.com/questions/3941271/why-are-malloc-and-printf-said-as-non-reentrant https://stackoverflow.com/questions/855763/is-malloc-thread-safe 4 \u5728 https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf \u4e2d\uff0c\u63d0\u53ca\u4e86 Unfortunately, this implementation is not reliable in a multithreaded environment. Suppose that Thread A enters the instance function, executes through Line 14, and is then suspended. At the point where it is suspended, it has just determined that pInstance is null, i.e., that no Singleton object has yet been created","title":"Drafts"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/Reentrancy-VS-thread-safety/","text":"Reentrancy VS thread safety \u4e24\u8005\u662f\u6b63\u4ea4\u7684\u6982\u5ff5\uff0c\u63cf\u8ff0\u7684\u662f\u4e0d\u540c\u7684\u6027\u8d28\uff1b \u5171\u540c\u70b9 \u4e24\u8005\u7684\u6df1\u5c42\u539f\u56e0\u6709\u4e9b\u7c7b\u4f3c\uff0c\u4e00\u53e5\u8bdd\u6765\u6982\u62ec\u5c31\u662f\"race condition\"\uff0c\u4e0b\u9762\u662f\u8be6\u7ec6\u7684\u5206\u6790: 1\u3001execution flow\u4f1a\u4e0d\u53d7\u63a7\u5236\u5730\u88absuspend/preempt/interrupt 2\u3001\u53ef\u4ee5\u4f7f\u7528multiple model\u8fdb\u884c\u5206\u6790\uff0c\u5b58\u5728race condition: many to one \u56e0\u6b64\uff0c\u4ecemany to one\u6765\u51fa\u53d1\uff0c\u7ed3\u5408\u5404\u81ea\u53ef\u80fd\u7684\u573a\u666f\uff0c\u5c31\u53ef\u4ee5\u975e\u5e38\u5bb9\u6613\u7684\u8fa8\u660e\u662f\u5426Reentrancy\u3001\u662f\u5426thread safety\u3002 3\u3001\u4e24\u8005\u90fd\u662freentrant\uff0c\u53c2\u89c1 Programming\\Book-APUE\\APUE-Reentrant-and-async-signal-safe-and-thread-safe \u7ae0\u8282 \u5dee\u5f02\u70b9 \u4e24\u79cd\u672c\u8d28\u7684\u5dee\u5f02\u5728\u4e8e: 1\u3001Reentrancy\u662f\u975emultitasking\u65f6\u4ee3\u7684\u4ea7\u7269\uff0c\u5b83\u7684function\u4e0d\u662f\u7531\u591a\u4e2athread\u540c\u65f6\u6267\u884c\u7684\uff0cISR\u662f\u7531kernel\u6267\u884c\u7684\uff1b\u800cthread safety\u662fmultitasking\u65f6\u4ee3\u7684\u4ea7\u7269\uff0c\u5b83\u7684function\u662f\u7531\u591a\u4e2athread\u540c\u65f6\u6267\u884c\u7684 NOTE: \u5173\u4e8e\u8fd9\u4e00\u70b9\uff0c\u53c2\u89c1 wikipedia Reentrancy (computing) # Background # Reentrancy VS thread-safety \u6bb5\u3002 2\u3001\u7531\u4e8e\u4e24\u8005\u7684\u4e0a\u8ff0\u672c\u8d28\u7684\u5dee\u5f02\uff0c\u56e0\u6b64\u5b9e\u73b0\u4fdd\u62a4\"the one\"\u7684\u624b\u6bb5\u4e5f\u662f\u4e0d\u540c\u7684 a\u3001mutex\u53ef\u4ee5\u7528\u4e8e\u5b9e\u73b0thread safety\uff0c\u4f46\u662f\u65e0\u6cd5\u5b9e\u73b0Reentrancy(\u4e0d\u80fd\u7528\u4e8eISR) b\u3001\u4f7f\u7528thread local\u6765\u5c06the one\u53d8\u4e3aprivate\uff0c\u53ef\u4ee5\u80fd\u591f\u5b9e\u73b0thread safety\uff0c\u4f46\u662f\u65e0\u6cd5\u5b9e\u73b0Reentrancy \u5177\u4f53\u6848\u4f8b\u53c2\u89c1: wikipedia Reentrancy (computing) # Thread-safe but not reentrant \u3002 c\u3001\u4e24\u8005\u90fd\u53ef\u4ee5\u4f7f\u7528atomicity\u6765\u4fdd\u62a4\"the one\" \u5728 wikipedia Reentrancy (computing) \u4e2d\u7684\u51e0\u4e2aexample\u662f\u975e\u5e38\u597d\u7684\u3002","title":"Reentrancy-VS-thread-safety"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/Reentrancy-VS-thread-safety/#reentrancy#vs#thread#safety","text":"\u4e24\u8005\u662f\u6b63\u4ea4\u7684\u6982\u5ff5\uff0c\u63cf\u8ff0\u7684\u662f\u4e0d\u540c\u7684\u6027\u8d28\uff1b","title":"Reentrancy VS thread safety"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/Reentrancy-VS-thread-safety/#_1","text":"\u4e24\u8005\u7684\u6df1\u5c42\u539f\u56e0\u6709\u4e9b\u7c7b\u4f3c\uff0c\u4e00\u53e5\u8bdd\u6765\u6982\u62ec\u5c31\u662f\"race condition\"\uff0c\u4e0b\u9762\u662f\u8be6\u7ec6\u7684\u5206\u6790: 1\u3001execution flow\u4f1a\u4e0d\u53d7\u63a7\u5236\u5730\u88absuspend/preempt/interrupt 2\u3001\u53ef\u4ee5\u4f7f\u7528multiple model\u8fdb\u884c\u5206\u6790\uff0c\u5b58\u5728race condition: many to one \u56e0\u6b64\uff0c\u4ecemany to one\u6765\u51fa\u53d1\uff0c\u7ed3\u5408\u5404\u81ea\u53ef\u80fd\u7684\u573a\u666f\uff0c\u5c31\u53ef\u4ee5\u975e\u5e38\u5bb9\u6613\u7684\u8fa8\u660e\u662f\u5426Reentrancy\u3001\u662f\u5426thread safety\u3002 3\u3001\u4e24\u8005\u90fd\u662freentrant\uff0c\u53c2\u89c1 Programming\\Book-APUE\\APUE-Reentrant-and-async-signal-safe-and-thread-safe \u7ae0\u8282","title":"\u5171\u540c\u70b9"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/Reentrancy-VS-thread-safety/#_2","text":"\u4e24\u79cd\u672c\u8d28\u7684\u5dee\u5f02\u5728\u4e8e: 1\u3001Reentrancy\u662f\u975emultitasking\u65f6\u4ee3\u7684\u4ea7\u7269\uff0c\u5b83\u7684function\u4e0d\u662f\u7531\u591a\u4e2athread\u540c\u65f6\u6267\u884c\u7684\uff0cISR\u662f\u7531kernel\u6267\u884c\u7684\uff1b\u800cthread safety\u662fmultitasking\u65f6\u4ee3\u7684\u4ea7\u7269\uff0c\u5b83\u7684function\u662f\u7531\u591a\u4e2athread\u540c\u65f6\u6267\u884c\u7684 NOTE: \u5173\u4e8e\u8fd9\u4e00\u70b9\uff0c\u53c2\u89c1 wikipedia Reentrancy (computing) # Background # Reentrancy VS thread-safety \u6bb5\u3002 2\u3001\u7531\u4e8e\u4e24\u8005\u7684\u4e0a\u8ff0\u672c\u8d28\u7684\u5dee\u5f02\uff0c\u56e0\u6b64\u5b9e\u73b0\u4fdd\u62a4\"the one\"\u7684\u624b\u6bb5\u4e5f\u662f\u4e0d\u540c\u7684 a\u3001mutex\u53ef\u4ee5\u7528\u4e8e\u5b9e\u73b0thread safety\uff0c\u4f46\u662f\u65e0\u6cd5\u5b9e\u73b0Reentrancy(\u4e0d\u80fd\u7528\u4e8eISR) b\u3001\u4f7f\u7528thread local\u6765\u5c06the one\u53d8\u4e3aprivate\uff0c\u53ef\u4ee5\u80fd\u591f\u5b9e\u73b0thread safety\uff0c\u4f46\u662f\u65e0\u6cd5\u5b9e\u73b0Reentrancy \u5177\u4f53\u6848\u4f8b\u53c2\u89c1: wikipedia Reentrancy (computing) # Thread-safe but not reentrant \u3002 c\u3001\u4e24\u8005\u90fd\u53ef\u4ee5\u4f7f\u7528atomicity\u6765\u4fdd\u62a4\"the one\" \u5728 wikipedia Reentrancy (computing) \u4e2d\u7684\u51e0\u4e2aexample\u662f\u975e\u5e38\u597d\u7684\u3002","title":"\u5dee\u5f02\u70b9"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/","text":"ibm Use reentrant functions for safer signal handling How and when to employ reentrancy to keep your code bug free In the early days of programming, non-reentrancy was not a threat to programmers; functions did not have concurrent access and there were no interrupts. In many older implementations of the C language, functions were expected to work in an environment of single-threaded processes. Now, however, concurrent programming is common practice, and you need to be aware of the pitfalls. This article describes some potential problems due to non-reentrancy of the function in parallel and concurrent programming. Signal generation and handling in particular add extra complexity. Due to the asynchronous nature of signals, it is difficult to point out the bug caused when a signal-handling function triggers a non-reentrant function. This article: Defines reentrancy and includes a POSIX listing of a reentrant function Provides examples to show problems caused by non-reentrancy Suggests ways to ensure reentrancy of the underlying function Discusses dealing with reentrancy at the compiler level What is reentrancy? A reentrant function is one that can be used by more than one task concurrently without fear of data corruption . Conversely, a non-reentrant function is one that cannot be shared by more than one task unless mutual exclusion to the function is ensured either by using a semaphore or by disabling interrupts during critical sections of code. A reentrant function can be interrupted at any time and resumed at a later time without loss of data. Reentrant functions either use local variables or protect their data when global variables are used. A reentrant function: Does not hold static data over successive calls Does not return a pointer to static data; all data is provided by the caller of the function Uses local data or ensures protection of global data by making a local copy of it Must not call any non-reentrant functions Don't confuse reentrance with thread-safety . From the programmer perspective, these two are separate concepts: a function can be reentrant, thread-safe, both, or neither. Non-reentrant functions cannot be used by multiple threads( SUMMARY :because in multi-threaded environments,a thread may be interrupted by other thread). Moreover, it may be impossible to make a non-reentrant function thread-safe. IEEE Std 1003.1 lists 118 reentrant UNIX\u00ae functions, which aren't duplicated here. See Related topics for a link to the list at unix.org. The rest of the functions are non-reentrant because of any of the following: They call malloc or free They are known to use static data structures They are part of the standard I/O library SUMMARY :it is important to distinguish static and global. Signals and non-reentrant functions A signal is a software interrupt . It empowers a programmer to handle an asynchronous event. To send a signal to a process, the kernel sets a bit in the signal field of the process table entry , corresponding to the type of signal received. The ANSI C prototype of a signal function is: ` void ( * signal ( int sigNum , void ( * sigHandler )( int ))) ( int ); ` Or, in another representation: ` typedef void sigHandler ( int ); `` SigHandler * signal ( int , sigHandler * ); ` When a signal that is being caught is handled by a process, the normal sequence of instructions being executed by the process is temporarily interrupted by the signal handler . The process then continues executing, but the instructions in the signal handler are now executed( SUMMARY :Similar to jump). If the signal handler returns, the process continues executing the normal sequence of instructions it was executing when the signal was caught. Now, in the signal handler you can't tell what the process was executing when the signal was caught. What if the process was in the middle of allocating additional memory on its heap using malloc , and you call malloc from the signal handler? Or, you call some function that was in the middle of the manipulation of the global data structure and you call the same function from the signal handler . In the case of malloc , havoc can result for the process, because malloc usually maintains a linked list of all its allocated area and it may have been in the middle of changing this list. An interrupt can even be delivered between the beginning and end of a C operator that requires multiple instructions . At the programmer level, the instruction may appear atomic (that is, cannot be divided into smaller operations), but it might actually take more than one processor instruction to complete the operation. For example, take this piece of C code: `temp += 1;` On an x86 processor, that statement might compile to: `mov ax,[temp]``inc ax``mov [temp],ax` This is clearly not an atomic operation. This example shows what can happen if a signal handler runs in the middle of modifying a variable: Listing 1. Running a signal handler while modifying a variable `# include < `` signal . h `` > ``# include < `` stdio . h `` > ` ` struct two_int { int a , b ; } data ; ` ` void signal_handler ( int signum ){ `` `` printf ( \"%d, %d \\n \" , data . a , data . b ); `` `` alarm ( 1 ); `` } ` ` int main ( void ){ `` `` static struct two_int zeros = { 0 , 0 }, ones = { 1 , 1 }; ` ` `` signal ( SIGALRM , signal_handler ); ` ` `` data = zeros ; ` ` `` alarm ( 1 ); ` ` while ( 1 ) `` `` { data = zeros ; data = ones ;} `` } ` This program fills data with zeros, ones, zeros, ones, and so on, alternating forever. Meanwhile, once per second, the alarm signal handler prints the current contents. (Calling printf in the handler is safe in this program, because it is certainly not being called outside the handler when the signal happens.) What output do you expect from this program? It should print either 0, 0 or 1, 1. But the actual output is as follows: ` 0 , 0 `` 1 , 1 ` ` ( Skipping some output... ) ` ` 0 , 1 `` 1 , 1 `` 1 , 0 `` 1 , 0 `` ... ` On most machines, it takes several instructions to store a new value in data , and the value is stored one word at a time. If the signal is delivered between these instructions, the handler might find that data.a is 0 and data.b is 1, or vice versa. On the other hand, if we compile and run this code on a machine where it is possible to store an object's value in one instruction that cannot be interrupted, then the handler will always print 0, 0 or 1, 1. Another complication with signals is that, just by running test cases you can't be sure that your code is signal-bug free. This complication is due to the asynchronous nature of signal generation. Non-reentrant functions and static variables Suppose that the signal handler uses gethostbyname , which is non-reentrant. This function returns its value in a static object: ` static struct hostent host ; /* result stored here*/ ` And it reuses the same object each time. In the following example, if the signal happens to arrive during a call to gethostbyname in main , or even after a call while the program is still using the value, it will clobber the value that the program asked for. Listing 2. Risky use of gethostbyname ` main (){ `` `` struct hostent * hostPtr ; `` `` ... `` `` signal ( SIGALRM , sig_handler ); `` `` ... `` `` hostPtr = gethostbyname ( hostNameOne ); `` `` ... `` } ` ` void sig_handler (){ `` `` struct hostent * hostPtr ; `` `` ... `` `` /* call to gethostbyname may clobber the value stored during the call`` ``inside the main() */ `` `` hostPtr = gethostbyname ( hostNameTwo ); `` `` ... `` } ` However, if the program does not use gethostbyname or any other function that returns information in the same object, or if it always blocks signals around each use, you're safe. Many library functions return values in a fixed object , always reusing the same object, and they can all cause the same problem. If a function uses and modifies an object that you supply, it is potentially non-reentrant; two calls can interfere if they use the same object. A similar case arises when you do I/O using streams. Suppose the signal handler prints a message with fprintf and the program was in the middle of an fprintf call using the same stream when the signal was delivered. Both the signal handler's message and the program's data could be corrupted, because both calls operate on the same data structure: the stream itself. Things become even more complicated when you're using a third-party library, because you never know which parts of the library are reentrant and which are not. As with the standard library, there can be many library functions that return values in fixed objects, always reusing the same objects, which causes the functions to be non-reentrant. The good news is, these days many vendors have taken the initiative to provide reentrant versions of the standard C library. You'll need to go through the documentation provided with any given library to know if there is any change in the prototypes and therefore in the usage of the standard library functions. Practices to ensure reentrancy Sticking to these five best practices will help you maintain reentrancy in your programs. Practice 1 Returning a pointer to static data may cause a function to be non-reentrant. For example, a strToUpper function, converting a string to uppercase, could be implemented as follows: Listing 3. Non-reentrant version of strToUpper ` char * strToUpper ( char * str ) `` { `` `` /*Returning pointer to static data makes it non-reentrant */ `` `` static char buffer [ STRING_SIZE_LIMIT ]; `` `` int index ; ` ` `` for ( index = 0 ; str [ index ]; index ++ ) `` `` buffer [ index ] = toupper ( str [ index ]); `` `` buffer [ index ] = '\\0' ; `` `` return buffer ; `` } ` You can implement the reentrant version of this function by changing the prototype of the function. This listing provides storage for the output string: Listing 4. Reentrant version of strToUpper ` char * strToUpper_r ( char * in_str , char * out_str ) `` { `` `` int index ; ` ` `` for ( index = 0 ; in_str [ index ] != '\\0' ; index ++ ) `` `` out_str [ index ] = toupper ( in_str [ index ]); `` `` out_str [ index ] = '\\0' ; ` ` `` return out_str ; `` } ` Providing output storage by the calling function ensures the reentrancy of the function. Note that this follows a standard convention for the naming of reentrant function by suffixing the function name with \"_r\". Practice 2 Remembering the state of the data makes the function non-reentrant. Different threads can successively call the function and modify the data without informing the other threads that are using the data. If a function needs to maintain the state of some data over successive calls, such as a working buffer or a pointer, the caller should provide this data. In the following example, a function returns the successive lowercase characters of a string. The string is provided only on the first call, as with the strtok subroutine. The function returns \\0 when it reaches the end of the string. The function could be implemented as follows: Listing 5. Non-reentrant version of getLowercaseChar ` char getLowercaseChar ( char * str ) `` { `` `` static char * buffer ; `` `` static int index ; `` `` char c = '\\0' ; `` `` /* stores the working string on first call only */ `` `` if ( string != NULL ) { `` `` buffer = str ; `` `` index = 0 ; `` `` } ` ` `` /* searches a lowercase character */ `` `` while ( c = buff [ index ]){ `` `` if ( islower ( c )) `` `` { `` `` index ++ ; `` `` break ; `` `` } `` `` index ++ ; `` `` } ` ` `` return c ; `` } ` This function is not reentrant, because it stores the state of the variables. To make it reentrant, the static data, the index variable, needs to be maintained by the caller. The reentrant version of the function could be implemented like this: Listing 6. Reentrant version of getLowercaseChar ` char getLowercaseChar_r ( char * str , int * pIndex ) `` { ` ` `` char c = '\\0' ; ` ` `` /* no initialization - the caller should have done it */ ` ` `` /* searches a lowercase character */ ` ` `` while ( c = buff [ * pIndex ]){ `` `` if ( islower ( c )) `` `` { `` `` ( * pIndex ) ++ ; break ; `` `` } `` `` ( * pIndex ) ++ ; `` `` } `` `` return c ; `` } ` Practice 3 On most systems, malloc and free are not reentrant, because they use a static data structure that records which memory blocks are free. As a result, no library functions that allocate or free memory are reentrant. This includes functions that allocate space to store a result. The best way to avoid the need to allocate memory in a handler is to allocate, in advance, space for signal handlers to use. The best way to avoid freeing memory in a handler is to flag or record the objects to be freed and have the program check from time to time whether anything is waiting to be freed. But this must be done with care, because placing an object on a chain is not atomic, and if it is interrupted by another signal handler that does the same thing, you could \"lose\" one of the objects. However, if you know that the program cannot possibly use the stream that the handler uses at a time when signals can arrive, you are safe. There is no problem if the program uses some other stream. Practice 4 To write bug-free code, practice care in handling process-wide global variables like errno and h_errno . Consider the following code: Listing 7. Risky use of errno ` if ( close ( fd ) < 0 ) { `` `` fprintf ( stderr , \"Error in close, errno: %d\" , errno ); `` `` exit ( 1 ); `` } ` Suppose a signal is generated during the very small time gap between setting the errno variable by the close system call and its return. The generated signal can change the value of errno , and the program behaves unexpectedly. Saving and restoring the value of errno in the signal handler , as follows, can resolve the problem: Listing 8. Saving and restoring the value of errno ` void signalHandler ( int signo ){ `` `` int errno_saved ; ` ` `` /* Save the error no. */ `` `` errno_saved = errno ; ` ` `` /* Let the signal handler complete its job */ `` `` ... `` `` ... ` ` `` /* Restore the errno*/ `` `` errno = errno_saved ; `` } ` Practice 5 If the underlying function is in the middle of a critical section and a signal is generated and handled, this can cause the function to be non-reentrant. By using signal sets and a signal mask , the critical region of code can be protected from a specific set of signals, as follows: Save the current set of signals. Mask the signal set with the unwanted signals. Let the critical section of code complete its job. Finally, reset the signal set. Here is an outline of this practice: Listing 9. Using signal sets and signal masks ` sigset_t newmask , oldmask , zeromask ; `` ... `` /* Register the signal handler */ `` signal ( SIGALRM , sig_handler ); ` ` /* Initialize the signal sets */ `` sigemtyset ( & newmask ); sigemtyset ( & zeromask ); ` ` /* Add the signal to the set */ `` sigaddset ( & newmask , SIGALRM ); ` ` /* Block SIGALRM and save current signal mask in set variable 'oldmask'``*/ `` sigprocmask ( SIG_BLOCK , & newmask , & oldmask ); ` ` /* The protected code goes here``...``...``*/ ` ` /* Now allow all signals and pause */ `` sigsuspend ( & zeromask ); ` ` /* Resume to the original signal mask */ `` sigprocmask ( SIG_SETMASK , & oldmask , NULL ); ` ` /* Continue with other parts of the code */ ` Skipping sigsuspend(&zeromask); can cause a problem. There has to be some gap of clock cycles between the unblocking of signals and the next instruction carried by the process, and any occurrence of a signal in this window of time is lost. The function call sigsuspend resolves this problem by resetting the signal mask and putting the process to sleep in a single atomic operation. If you are sure that signal generation in this window of time won't have any adverse effects, you can skip sigsuspend and go directly to resetting the signal. Dealing with reentrancy at the compiler level I would like to propose a model for dealing with reentrant functions at the compiler level. A new keyword, reentrant , can be introduced for the high-level language, and functions can be given a reentrant specifier that will ensure that the functions are reentrant, like so: ` reentrant int foo (); ` This directive instructs the compiler to give special treatment to that particular function. The compiler can store this directive in its symbol table and use it during the intermediate code generation phase. To accomplish this, some design changes are required in the compiler's front end. This reentrant specifier follows these guidelines: Does not hold static data over successive calls Protects global data by making a local copy of it Must not call non-reentrant functions Does not return a reference to static data, and all data is provided by the caller of the function Guideline 1 can be ensured by type checking and throwing an error message if there is any static storage declaration in the function. This can be done during the semantic analysis phase of the compilation. Guideline 2, protection of global data, can be ensured in two ways. The primitive way is by throwing an error message if the function modifies global data. A more sophisticated technique is to generate intermediate code in such a way that the global data doesn't get mangled. An approach similar to Practice 4, above, can be implemented at the compiler level. On entering the function, the compiler can store the to-be-manipulated global data using a compiler-generated temporary name, then restore the data upon exiting the function. Storing data using a compiler-generated temporary name is normal practice for the compiler. Ensuring guideline 3 requires the compiler to have prior knowledge of all the reentrant functions, including the libraries used by the application. This additional information about the function can be stored in the symbol table. Finally, guideline 4 is already guaranteed by guideline 2. There is no question of returning a reference to static data if the function doesn't have one. This proposed model would make the programmer's job easier in following the guidelines for reentrant functions, and by using this model, code would be protected against the unintentional reentrancy bug.","title":"ibm [Use reentrant functions for safer signal handling](https://www.ibm.com/developerworks/library/l-reent/)"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#ibm#use#reentrant#functions#for#safer#signal#handling","text":"How and when to employ reentrancy to keep your code bug free In the early days of programming, non-reentrancy was not a threat to programmers; functions did not have concurrent access and there were no interrupts. In many older implementations of the C language, functions were expected to work in an environment of single-threaded processes. Now, however, concurrent programming is common practice, and you need to be aware of the pitfalls. This article describes some potential problems due to non-reentrancy of the function in parallel and concurrent programming. Signal generation and handling in particular add extra complexity. Due to the asynchronous nature of signals, it is difficult to point out the bug caused when a signal-handling function triggers a non-reentrant function. This article: Defines reentrancy and includes a POSIX listing of a reentrant function Provides examples to show problems caused by non-reentrancy Suggests ways to ensure reentrancy of the underlying function Discusses dealing with reentrancy at the compiler level","title":"ibm Use reentrant functions for safer signal handling"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#what#is#reentrancy","text":"A reentrant function is one that can be used by more than one task concurrently without fear of data corruption . Conversely, a non-reentrant function is one that cannot be shared by more than one task unless mutual exclusion to the function is ensured either by using a semaphore or by disabling interrupts during critical sections of code. A reentrant function can be interrupted at any time and resumed at a later time without loss of data. Reentrant functions either use local variables or protect their data when global variables are used. A reentrant function: Does not hold static data over successive calls Does not return a pointer to static data; all data is provided by the caller of the function Uses local data or ensures protection of global data by making a local copy of it Must not call any non-reentrant functions Don't confuse reentrance with thread-safety . From the programmer perspective, these two are separate concepts: a function can be reentrant, thread-safe, both, or neither. Non-reentrant functions cannot be used by multiple threads( SUMMARY :because in multi-threaded environments,a thread may be interrupted by other thread). Moreover, it may be impossible to make a non-reentrant function thread-safe. IEEE Std 1003.1 lists 118 reentrant UNIX\u00ae functions, which aren't duplicated here. See Related topics for a link to the list at unix.org. The rest of the functions are non-reentrant because of any of the following: They call malloc or free They are known to use static data structures They are part of the standard I/O library SUMMARY :it is important to distinguish static and global.","title":"What is reentrancy?"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#signals#and#non-reentrant#functions","text":"A signal is a software interrupt . It empowers a programmer to handle an asynchronous event. To send a signal to a process, the kernel sets a bit in the signal field of the process table entry , corresponding to the type of signal received. The ANSI C prototype of a signal function is: ` void ( * signal ( int sigNum , void ( * sigHandler )( int ))) ( int ); ` Or, in another representation: ` typedef void sigHandler ( int ); `` SigHandler * signal ( int , sigHandler * ); ` When a signal that is being caught is handled by a process, the normal sequence of instructions being executed by the process is temporarily interrupted by the signal handler . The process then continues executing, but the instructions in the signal handler are now executed( SUMMARY :Similar to jump). If the signal handler returns, the process continues executing the normal sequence of instructions it was executing when the signal was caught. Now, in the signal handler you can't tell what the process was executing when the signal was caught. What if the process was in the middle of allocating additional memory on its heap using malloc , and you call malloc from the signal handler? Or, you call some function that was in the middle of the manipulation of the global data structure and you call the same function from the signal handler . In the case of malloc , havoc can result for the process, because malloc usually maintains a linked list of all its allocated area and it may have been in the middle of changing this list. An interrupt can even be delivered between the beginning and end of a C operator that requires multiple instructions . At the programmer level, the instruction may appear atomic (that is, cannot be divided into smaller operations), but it might actually take more than one processor instruction to complete the operation. For example, take this piece of C code: `temp += 1;` On an x86 processor, that statement might compile to: `mov ax,[temp]``inc ax``mov [temp],ax` This is clearly not an atomic operation. This example shows what can happen if a signal handler runs in the middle of modifying a variable:","title":"Signals and non-reentrant functions"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#listing#1#running#a#signal#handler#while#modifying#a#variable","text":"`# include < `` signal . h `` > ``# include < `` stdio . h `` > ` ` struct two_int { int a , b ; } data ; ` ` void signal_handler ( int signum ){ `` `` printf ( \"%d, %d \\n \" , data . a , data . b ); `` `` alarm ( 1 ); `` } ` ` int main ( void ){ `` `` static struct two_int zeros = { 0 , 0 }, ones = { 1 , 1 }; ` ` `` signal ( SIGALRM , signal_handler ); ` ` `` data = zeros ; ` ` `` alarm ( 1 ); ` ` while ( 1 ) `` `` { data = zeros ; data = ones ;} `` } ` This program fills data with zeros, ones, zeros, ones, and so on, alternating forever. Meanwhile, once per second, the alarm signal handler prints the current contents. (Calling printf in the handler is safe in this program, because it is certainly not being called outside the handler when the signal happens.) What output do you expect from this program? It should print either 0, 0 or 1, 1. But the actual output is as follows: ` 0 , 0 `` 1 , 1 ` ` ( Skipping some output... ) ` ` 0 , 1 `` 1 , 1 `` 1 , 0 `` 1 , 0 `` ... ` On most machines, it takes several instructions to store a new value in data , and the value is stored one word at a time. If the signal is delivered between these instructions, the handler might find that data.a is 0 and data.b is 1, or vice versa. On the other hand, if we compile and run this code on a machine where it is possible to store an object's value in one instruction that cannot be interrupted, then the handler will always print 0, 0 or 1, 1. Another complication with signals is that, just by running test cases you can't be sure that your code is signal-bug free. This complication is due to the asynchronous nature of signal generation.","title":"Listing 1. Running a signal handler while modifying a variable"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#non-reentrant#functions#and#static#variables","text":"Suppose that the signal handler uses gethostbyname , which is non-reentrant. This function returns its value in a static object: ` static struct hostent host ; /* result stored here*/ ` And it reuses the same object each time. In the following example, if the signal happens to arrive during a call to gethostbyname in main , or even after a call while the program is still using the value, it will clobber the value that the program asked for.","title":"Non-reentrant functions and static variables"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#listing#2#risky#use#of#gethostbyname","text":"` main (){ `` `` struct hostent * hostPtr ; `` `` ... `` `` signal ( SIGALRM , sig_handler ); `` `` ... `` `` hostPtr = gethostbyname ( hostNameOne ); `` `` ... `` } ` ` void sig_handler (){ `` `` struct hostent * hostPtr ; `` `` ... `` `` /* call to gethostbyname may clobber the value stored during the call`` ``inside the main() */ `` `` hostPtr = gethostbyname ( hostNameTwo ); `` `` ... `` } ` However, if the program does not use gethostbyname or any other function that returns information in the same object, or if it always blocks signals around each use, you're safe. Many library functions return values in a fixed object , always reusing the same object, and they can all cause the same problem. If a function uses and modifies an object that you supply, it is potentially non-reentrant; two calls can interfere if they use the same object. A similar case arises when you do I/O using streams. Suppose the signal handler prints a message with fprintf and the program was in the middle of an fprintf call using the same stream when the signal was delivered. Both the signal handler's message and the program's data could be corrupted, because both calls operate on the same data structure: the stream itself. Things become even more complicated when you're using a third-party library, because you never know which parts of the library are reentrant and which are not. As with the standard library, there can be many library functions that return values in fixed objects, always reusing the same objects, which causes the functions to be non-reentrant. The good news is, these days many vendors have taken the initiative to provide reentrant versions of the standard C library. You'll need to go through the documentation provided with any given library to know if there is any change in the prototypes and therefore in the usage of the standard library functions.","title":"Listing 2. Risky use of gethostbyname"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#practices#to#ensure#reentrancy","text":"Sticking to these five best practices will help you maintain reentrancy in your programs.","title":"Practices to ensure reentrancy"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#practice#1","text":"Returning a pointer to static data may cause a function to be non-reentrant. For example, a strToUpper function, converting a string to uppercase, could be implemented as follows:","title":"Practice 1"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#listing#3#non-reentrant#version#of#strtoupper","text":"` char * strToUpper ( char * str ) `` { `` `` /*Returning pointer to static data makes it non-reentrant */ `` `` static char buffer [ STRING_SIZE_LIMIT ]; `` `` int index ; ` ` `` for ( index = 0 ; str [ index ]; index ++ ) `` `` buffer [ index ] = toupper ( str [ index ]); `` `` buffer [ index ] = '\\0' ; `` `` return buffer ; `` } ` You can implement the reentrant version of this function by changing the prototype of the function. This listing provides storage for the output string:","title":"Listing 3. Non-reentrant version of strToUpper"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#listing#4#reentrant#version#of#strtoupper","text":"` char * strToUpper_r ( char * in_str , char * out_str ) `` { `` `` int index ; ` ` `` for ( index = 0 ; in_str [ index ] != '\\0' ; index ++ ) `` `` out_str [ index ] = toupper ( in_str [ index ]); `` `` out_str [ index ] = '\\0' ; ` ` `` return out_str ; `` } ` Providing output storage by the calling function ensures the reentrancy of the function. Note that this follows a standard convention for the naming of reentrant function by suffixing the function name with \"_r\".","title":"Listing 4. Reentrant version of strToUpper"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#practice#2","text":"Remembering the state of the data makes the function non-reentrant. Different threads can successively call the function and modify the data without informing the other threads that are using the data. If a function needs to maintain the state of some data over successive calls, such as a working buffer or a pointer, the caller should provide this data. In the following example, a function returns the successive lowercase characters of a string. The string is provided only on the first call, as with the strtok subroutine. The function returns \\0 when it reaches the end of the string. The function could be implemented as follows:","title":"Practice 2"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#listing#5#non-reentrant#version#of#getlowercasechar","text":"` char getLowercaseChar ( char * str ) `` { `` `` static char * buffer ; `` `` static int index ; `` `` char c = '\\0' ; `` `` /* stores the working string on first call only */ `` `` if ( string != NULL ) { `` `` buffer = str ; `` `` index = 0 ; `` `` } ` ` `` /* searches a lowercase character */ `` `` while ( c = buff [ index ]){ `` `` if ( islower ( c )) `` `` { `` `` index ++ ; `` `` break ; `` `` } `` `` index ++ ; `` `` } ` ` `` return c ; `` } ` This function is not reentrant, because it stores the state of the variables. To make it reentrant, the static data, the index variable, needs to be maintained by the caller. The reentrant version of the function could be implemented like this:","title":"Listing 5. Non-reentrant version of getLowercaseChar"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#listing#6#reentrant#version#of#getlowercasechar","text":"` char getLowercaseChar_r ( char * str , int * pIndex ) `` { ` ` `` char c = '\\0' ; ` ` `` /* no initialization - the caller should have done it */ ` ` `` /* searches a lowercase character */ ` ` `` while ( c = buff [ * pIndex ]){ `` `` if ( islower ( c )) `` `` { `` `` ( * pIndex ) ++ ; break ; `` `` } `` `` ( * pIndex ) ++ ; `` `` } `` `` return c ; `` } `","title":"Listing 6. Reentrant version of getLowercaseChar"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#practice#3","text":"On most systems, malloc and free are not reentrant, because they use a static data structure that records which memory blocks are free. As a result, no library functions that allocate or free memory are reentrant. This includes functions that allocate space to store a result. The best way to avoid the need to allocate memory in a handler is to allocate, in advance, space for signal handlers to use. The best way to avoid freeing memory in a handler is to flag or record the objects to be freed and have the program check from time to time whether anything is waiting to be freed. But this must be done with care, because placing an object on a chain is not atomic, and if it is interrupted by another signal handler that does the same thing, you could \"lose\" one of the objects. However, if you know that the program cannot possibly use the stream that the handler uses at a time when signals can arrive, you are safe. There is no problem if the program uses some other stream.","title":"Practice 3"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#practice#4","text":"To write bug-free code, practice care in handling process-wide global variables like errno and h_errno . Consider the following code:","title":"Practice 4"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#listing#7#risky#use#of#errno","text":"` if ( close ( fd ) < 0 ) { `` `` fprintf ( stderr , \"Error in close, errno: %d\" , errno ); `` `` exit ( 1 ); `` } ` Suppose a signal is generated during the very small time gap between setting the errno variable by the close system call and its return. The generated signal can change the value of errno , and the program behaves unexpectedly. Saving and restoring the value of errno in the signal handler , as follows, can resolve the problem:","title":"Listing 7. Risky use of errno"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#listing#8#saving#and#restoring#the#value#of#errno","text":"` void signalHandler ( int signo ){ `` `` int errno_saved ; ` ` `` /* Save the error no. */ `` `` errno_saved = errno ; ` ` `` /* Let the signal handler complete its job */ `` `` ... `` `` ... ` ` `` /* Restore the errno*/ `` `` errno = errno_saved ; `` } `","title":"Listing 8. Saving and restoring the value of errno"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#practice#5","text":"If the underlying function is in the middle of a critical section and a signal is generated and handled, this can cause the function to be non-reentrant. By using signal sets and a signal mask , the critical region of code can be protected from a specific set of signals, as follows: Save the current set of signals. Mask the signal set with the unwanted signals. Let the critical section of code complete its job. Finally, reset the signal set. Here is an outline of this practice:","title":"Practice 5"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#listing#9#using#signal#sets#and#signal#masks","text":"` sigset_t newmask , oldmask , zeromask ; `` ... `` /* Register the signal handler */ `` signal ( SIGALRM , sig_handler ); ` ` /* Initialize the signal sets */ `` sigemtyset ( & newmask ); sigemtyset ( & zeromask ); ` ` /* Add the signal to the set */ `` sigaddset ( & newmask , SIGALRM ); ` ` /* Block SIGALRM and save current signal mask in set variable 'oldmask'``*/ `` sigprocmask ( SIG_BLOCK , & newmask , & oldmask ); ` ` /* The protected code goes here``...``...``*/ ` ` /* Now allow all signals and pause */ `` sigsuspend ( & zeromask ); ` ` /* Resume to the original signal mask */ `` sigprocmask ( SIG_SETMASK , & oldmask , NULL ); ` ` /* Continue with other parts of the code */ ` Skipping sigsuspend(&zeromask); can cause a problem. There has to be some gap of clock cycles between the unblocking of signals and the next instruction carried by the process, and any occurrence of a signal in this window of time is lost. The function call sigsuspend resolves this problem by resetting the signal mask and putting the process to sleep in a single atomic operation. If you are sure that signal generation in this window of time won't have any adverse effects, you can skip sigsuspend and go directly to resetting the signal.","title":"Listing 9. Using signal sets and signal masks"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/draft/IBM-Use-reentrant-functions-for-safer-signal-handling/#dealing#with#reentrancy#at#the#compiler#level","text":"I would like to propose a model for dealing with reentrant functions at the compiler level. A new keyword, reentrant , can be introduced for the high-level language, and functions can be given a reentrant specifier that will ensure that the functions are reentrant, like so: ` reentrant int foo (); ` This directive instructs the compiler to give special treatment to that particular function. The compiler can store this directive in its symbol table and use it during the intermediate code generation phase. To accomplish this, some design changes are required in the compiler's front end. This reentrant specifier follows these guidelines: Does not hold static data over successive calls Protects global data by making a local copy of it Must not call non-reentrant functions Does not return a reference to static data, and all data is provided by the caller of the function Guideline 1 can be ensured by type checking and throwing an error message if there is any static storage declaration in the function. This can be done during the semantic analysis phase of the compilation. Guideline 2, protection of global data, can be ensured in two ways. The primitive way is by throwing an error message if the function modifies global data. A more sophisticated technique is to generate intermediate code in such a way that the global data doesn't get mangled. An approach similar to Practice 4, above, can be implemented at the compiler level. On entering the function, the compiler can store the to-be-manipulated global data using a compiler-generated temporary name, then restore the data upon exiting the function. Storing data using a compiler-generated temporary name is normal practice for the compiler. Ensuring guideline 3 requires the compiler to have prior knowledge of all the reentrant functions, including the libraries used by the application. This additional information about the function can be stored in the symbol table. Finally, guideline 4 is already guaranteed by guideline 2. There is no question of returning a reference to static data if the function doesn't have one. This proposed model would make the programmer's job easier in following the guidelines for reentrant functions, and by using this model, code would be protected against the unintentional reentrancy bug.","title":"Dealing with reentrancy at the compiler level"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/","text":"wikipedia Reentrancy (computing) NOTE: \"Reentrancy\"\u5373\"\u53ef\u91cd\u5165\" In computing , a computer program or subroutine is called reentrant if it can be interrupted in the middle of its execution and then safely be called again (\"re-entered\") before its previous invocations complete execution. The interruption could be caused by an internal action such as a jump or call, or by an external action such as an interrupt or signal . Once the reentered invocation completes, the previous invocations will resume correct execution. This definition originates from single-threaded programming environments where the flow of control could be interrupted by an interrupt and transferred to an interrupt service routine (ISR). Any subroutine used by the ISR that could potentially have been executing when the interrupt was triggered should be reentrant . Often, subroutines accessible via the operating system kernel are not reentrant . Hence, interrupt service routines are limited in the actions they can perform; for instance, they are usually restricted from accessing the file system and sometimes even from allocating memory. NOTE: \u610f\u601d\u662f:\u5f53\u4e2d\u65ad\u88ab\u89e6\u53d1\u65f6\uff0cISR\u4f7f\u7528\u7684\u4efb\u4f55\u53ef\u80fd\u6b63\u5728\u6267\u884c\u7684subroutine\u90fd\u5e94\u8be5\u662f\u53ef\u91cd\u5165\u7684\u3002\u901a\u5e38\uff0c\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u8bbf\u95ee\u7684\u5b50\u4f8b\u7a0b\u662f\u4e0d\u53ef\u91cd\u5165\u7684\u3002\u56e0\u6b64\uff0c\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\u6240\u80fd\u6267\u884c\u7684\u64cd\u4f5c\u662f\u6709\u9650\u7684; \u4f8b\u5982\uff0c\u5b83\u4eec\u901a\u5e38\u4e0d\u80fd\u8bbf\u95ee\u6587\u4ef6\u7cfb\u7edf\uff0c\u6709\u65f6\u751a\u81f3\u4e0d\u80fd\u5206\u914d\u5185\u5b58\u3002 \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\"subroutines accessible via the operating system kernel are not reentrant \"\u662f\u4ec0\u4e48\u610f\u601d\uff1f \u5728\"APUE 10.6 Reentrant Functions\"\u7ae0\u8282\u4e2d\u4ecb\u7ecd\u4e86Reentrant Function\u7684\u5185\u5bb9\uff0c\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u63cf\u8ff0\u7684\u601d\u60f3\u4e0eAPUE\u4e2d\u7684\u662f\u4e00\u81f4\u7684\u3002 Thread-safety and reentrancy This definition of reentrancy differs from that of thread-safety in multi-threaded environments. A reentrant subroutine can achieve thread-safety ,[ 1] but being reentrant alone might not be sufficient to be thread-safe in all situations. Conversely, thread-safe code does not necessarily have to be reentrant (see below for examples). Other terms used for reentrant programs include \"pure procedure\" or \"sharable code\".[ 2] NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684pure procedure\uff0c\u8ba9\u6211\u60f3\u5230\u4e86functional programming\u4e2d\u7684pure function \u4eceatomicity\u7684\u89d2\u5ea6\u6765\u5206\u6790 Reentrancy of a subroutine that operates on operating-system resources or non-local data depends on the atomicity of the respective operations. For example, if the subroutine modifies a 64-bit global variable on a 32-bit machine, the operation may be split into two 32-bit operations, and thus, if the subroutine is interrupted while executing, and called again from the interrupt handler , the global variable may be in a state where only 32 bits have been updated. The programming language might provide atomicity guarantees for interruption caused by an internal action such as a jump or call. Then the function f in an expression like (global:=1) + (f()) , where the order of evaluation of the subexpressions might be arbitrary in a programming language, would see the global variable either set to 1 or to its previous value, but not in an intermediate state where only part has been updated. (The latter can happen in C , because the expression has no sequence point .) The operating system might provide atomicity guarantees for signals , such as a system call interrupted by a signal not having a partial effect. The processor hardware might provide atomicity guarantees for interrupts , such as interrupted processor instructions not having partial effects . NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\uff0c\u4eceatomicity\u7684\u89d2\u5ea6\u5206\u6790\u4e86reentrancy\u3002 Background Reentrancy VS thread-safety Reentrancy is distinct from, but closely related to, thread-safety . A function can be thread-safe and still not reentrant. For example, a function could be wrapped all around with a mutex (which avoids problems in multithreading environments), but, if that function were used in an interrupt service routine, it could starve waiting for the first execution to release the mutex. The key for avoiding confusion is that reentrant refers to only one thread executing. It is a concept from the time when no multitasking operating systems existed. NOTE: \u6700\u540e\u4e00\u6bb5\u8bdd\u662f\u4ece\u65f6\u95f4\u53d1\u5c55\u7684\u89d2\u5ea6\u7684\u603b\u7ed3: Reentrancy \u662f\u5728\u65e0 multitasking \u65f6\u4ee3\u53d1\u5c55\u51fa\u7684\u6982\u5ff5\uff0c\u56e0\u6b64\u5b83\u53ea\u80fd\u591f\u7531\u4e00\u4e2athread\u6267\u884c Thread-safety \u662f\u5728 multitasking \u65f6\u4ee3\u53d1\u5c55\u51fa\u7684\u6982\u5ff5 Rules for reentrancy NOTE: \u539f\u6587\u7684\u8fd9\u4e00\u6bb5\u662f\u4e0d\u5bb9\u6613\u7406\u89e3\u7684\uff0c\u6bd4\u8f83\u6666\u6da9\uff0c\u76f8\u6bd4\u4e4b\u4e0b\uff0cAPUE 10.6 Reentrant Functions \u5bb9\u6613\u7406\u89e3\u5730\u591a\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u8003\u5176\u4e2d\u7684\u603b\u7ed3 Reentrant code may not hold any static or global non-constant data. NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f: static local \u4e5f\u662f\u4e0d\u5141\u8bb8\u7684\uff0c\u5b83\u540c\u6837\u4f1a\u89e6\u53d1 many to one Reentrant code may not modify itself . NOTE: \u6ca1\u6709\u8bfb\u61c2\u8fd9\u4e00\u6bb5 Reentrant code may not call non-reentrant computer programs or routines . Examples To illustrate reentrancy, this article uses as an example a C utility function, swap() , that takes two pointers and transposes their values, and an interrupt-handling routine that also calls the swap function. Neither reentrant nor thread-safe This is an example swap function that fails to be reentrant or thread-safe . As such, it should not have been used in the interrupt service routine isr() : int tmp ; void swap ( int * x , int * y ) { tmp = * x ; * x = * y ; * y = tmp ; /* Hardware interrupt might invoke isr() here. */ } void isr () { int x = 1 , y = 2 ; swap ( & x , & y ); } NOTE: 1\u3001 tmp \u662f**global variable**\uff0c\u5982\u679c\u572832\u4e3aOS\u4e2d\uff0c\u5219 *y = tmp \u5c31\u88ab\u7f16\u8bd1\u4e3a\u4e24\u6761\u6307\u4ee4\uff0c\u4e5f\u5c31\u662f\u8bf4\u5b83\u8fd9\u6761\u8bed\u53e5\u5e76\u4e0d\u662f\u539f\u5b50\u7684 2\u3001\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\uff0c\u4fdd\u5b58\u5728**global variable** tmp \u4e2d\u7684\u503c\uff0c\u53ef\u80fd\u4f1a\u88ab\u7b2c\u4e8c\u6b21\u6267\u884c\u7684\u65f6\u5019overwrite Thread-safe but not reentrant The function swap() in the preceding example can be made thread-safe by making tmp thread-local . It still fails to be reentrant, and this will continue to cause problems if isr() is called in the same context as a thread already executing swap() : NOTE: 1\u3001reentrancy\u7684function\u7684\u6267\u884c\uff0c\u53ef\u80fd\u662f\u540c\u4e00\u4e2athread\u7684data\uff0c\u56e0\u6b64 _Thread_local \u65e0\u6cd5\u4fdd\u8bc1reentrancy _Thread_local int tmp ; void swap ( int * x , int * y ) { tmp = * x ; * x = * y ; * y = tmp ; /* Hardware interrupt might invoke isr() here. */ } void isr () { int x = 1 , y = 2 ; swap ( & x , & y ); } Reentrant but not thread-safe The following (somewhat contrived(\u4eba\u4e3a\u7684)) modification of the swap function, which is careful to leave the global data in a consistent state at the time it exits, is reentrant; however, it is not thread-safe, since there are no locks employed, it can be interrupted at any time: NOTE: 1\u3001\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u8ba9\u6211\u60f3\u5230\u4e86context switch 2\u3001\u4ed4\u7ec6\u770b\u4e86\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u53d1\u73b0\u5b83\u80fd\u591f\u4fdd\u8bc1Reentrant: a\u3001\u7b2c\u4e00\u4e2a invokation \u6267\u884c\u5230 s = tmp; \u7684\u65f6\u5019\uff0c\u5b83\u53ef\u80fd\u662fpartial read b\u3001\u7b2c\u4e8c\u4e2a Invokation \u6267\u884c\u4e86\u4e4b\u540e\uff0c\u5b83\u662f\u4f1a\u6062\u590d tmp \u7684\uff0c\u56e0\u6b64\u7b2c\u4e00\u4e2ainvokation\u80fd\u591f\u63a5\u7740\u4e0a\u6b21\u7684\u5730\u65b9\u7ee7\u7eed\u8fd0\u884c int tmp ; void swap ( int * x , int * y ) { /* Save global variable. */ int s ; s = tmp ; tmp = * x ; * x = * y ; * y = tmp ; /* Hardware interrupt might invoke isr() here. */ /* Restore global variable. */ tmp = s ; } void isr () { int x = 1 , y = 2 ; swap ( & x , & y ); } Reentrant and thread-safe An implementation of swap() that allocates tmp on the stack instead of globally and that is called only with unshared variables as parameters is both thread-safe and reentrant. Thread-safe because the stack is local to a thread and a function acting just on local data will always produce the expected result. There is no access to shared data therefore no data race. void swap ( int * x , int * y ) { int tmp ; tmp = * x ; * x = * y ; * y = tmp ; /* Hardware interrupt might invoke isr() here. */ } void isr () { int x = 1 , y = 2 ; swap ( & x , & y ); } Further examples In the following code, neither f nor g functions are reentrant. int v = 1 ; int f () { v += 2 ; return v ; } int g () { return f () + 2 ; } In the above, f() depends on a non-constant global variable v ; thus, if f() is interrupted during execution by an ISR which modifies v , then reentry into f() will return the wrong value of v . The value of v and, therefore, the return value of f , cannot be predicted with confidence: they will vary depending on whether an interrupt modified v during f 's execution. Hence, f is not reentrant. Neither is g , because it calls f , which is not reentrant. These slightly altered versions are reentrant: int f ( int i ) { return i + 2 ; } int g ( int i ) { return f ( i ) + 2 ; } Thread-safe, but not reentrant: mutex In the following, the function is thread-safe, but not reentrant: int function () { mutex_lock (); // ... // function body // ... mutex_unlock (); } In the above, function() can be called by different threads without any problem. But, if the function is used in a reentrant interrupt handler and a second interrupt arises inside the function, the second routine will hang forever. As interrupt servicing can disable other interrupts, the whole system could suffer.","title":"Introduction"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#wikipedia#reentrancy#computing","text":"NOTE: \"Reentrancy\"\u5373\"\u53ef\u91cd\u5165\" In computing , a computer program or subroutine is called reentrant if it can be interrupted in the middle of its execution and then safely be called again (\"re-entered\") before its previous invocations complete execution. The interruption could be caused by an internal action such as a jump or call, or by an external action such as an interrupt or signal . Once the reentered invocation completes, the previous invocations will resume correct execution. This definition originates from single-threaded programming environments where the flow of control could be interrupted by an interrupt and transferred to an interrupt service routine (ISR). Any subroutine used by the ISR that could potentially have been executing when the interrupt was triggered should be reentrant . Often, subroutines accessible via the operating system kernel are not reentrant . Hence, interrupt service routines are limited in the actions they can perform; for instance, they are usually restricted from accessing the file system and sometimes even from allocating memory. NOTE: \u610f\u601d\u662f:\u5f53\u4e2d\u65ad\u88ab\u89e6\u53d1\u65f6\uff0cISR\u4f7f\u7528\u7684\u4efb\u4f55\u53ef\u80fd\u6b63\u5728\u6267\u884c\u7684subroutine\u90fd\u5e94\u8be5\u662f\u53ef\u91cd\u5165\u7684\u3002\u901a\u5e38\uff0c\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u8bbf\u95ee\u7684\u5b50\u4f8b\u7a0b\u662f\u4e0d\u53ef\u91cd\u5165\u7684\u3002\u56e0\u6b64\uff0c\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\u6240\u80fd\u6267\u884c\u7684\u64cd\u4f5c\u662f\u6709\u9650\u7684; \u4f8b\u5982\uff0c\u5b83\u4eec\u901a\u5e38\u4e0d\u80fd\u8bbf\u95ee\u6587\u4ef6\u7cfb\u7edf\uff0c\u6709\u65f6\u751a\u81f3\u4e0d\u80fd\u5206\u914d\u5185\u5b58\u3002 \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\"subroutines accessible via the operating system kernel are not reentrant \"\u662f\u4ec0\u4e48\u610f\u601d\uff1f \u5728\"APUE 10.6 Reentrant Functions\"\u7ae0\u8282\u4e2d\u4ecb\u7ecd\u4e86Reentrant Function\u7684\u5185\u5bb9\uff0c\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u63cf\u8ff0\u7684\u601d\u60f3\u4e0eAPUE\u4e2d\u7684\u662f\u4e00\u81f4\u7684\u3002","title":"wikipedia Reentrancy (computing)"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#thread-safety#and#reentrancy","text":"This definition of reentrancy differs from that of thread-safety in multi-threaded environments. A reentrant subroutine can achieve thread-safety ,[ 1] but being reentrant alone might not be sufficient to be thread-safe in all situations. Conversely, thread-safe code does not necessarily have to be reentrant (see below for examples). Other terms used for reentrant programs include \"pure procedure\" or \"sharable code\".[ 2] NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684pure procedure\uff0c\u8ba9\u6211\u60f3\u5230\u4e86functional programming\u4e2d\u7684pure function","title":"Thread-safety and reentrancy"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#atomicity","text":"Reentrancy of a subroutine that operates on operating-system resources or non-local data depends on the atomicity of the respective operations. For example, if the subroutine modifies a 64-bit global variable on a 32-bit machine, the operation may be split into two 32-bit operations, and thus, if the subroutine is interrupted while executing, and called again from the interrupt handler , the global variable may be in a state where only 32 bits have been updated. The programming language might provide atomicity guarantees for interruption caused by an internal action such as a jump or call. Then the function f in an expression like (global:=1) + (f()) , where the order of evaluation of the subexpressions might be arbitrary in a programming language, would see the global variable either set to 1 or to its previous value, but not in an intermediate state where only part has been updated. (The latter can happen in C , because the expression has no sequence point .) The operating system might provide atomicity guarantees for signals , such as a system call interrupted by a signal not having a partial effect. The processor hardware might provide atomicity guarantees for interrupts , such as interrupted processor instructions not having partial effects . NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\uff0c\u4eceatomicity\u7684\u89d2\u5ea6\u5206\u6790\u4e86reentrancy\u3002","title":"\u4eceatomicity\u7684\u89d2\u5ea6\u6765\u5206\u6790"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#background","text":"","title":"Background"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#reentrancy#vs#thread-safety","text":"Reentrancy is distinct from, but closely related to, thread-safety . A function can be thread-safe and still not reentrant. For example, a function could be wrapped all around with a mutex (which avoids problems in multithreading environments), but, if that function were used in an interrupt service routine, it could starve waiting for the first execution to release the mutex. The key for avoiding confusion is that reentrant refers to only one thread executing. It is a concept from the time when no multitasking operating systems existed. NOTE: \u6700\u540e\u4e00\u6bb5\u8bdd\u662f\u4ece\u65f6\u95f4\u53d1\u5c55\u7684\u89d2\u5ea6\u7684\u603b\u7ed3: Reentrancy \u662f\u5728\u65e0 multitasking \u65f6\u4ee3\u53d1\u5c55\u51fa\u7684\u6982\u5ff5\uff0c\u56e0\u6b64\u5b83\u53ea\u80fd\u591f\u7531\u4e00\u4e2athread\u6267\u884c Thread-safety \u662f\u5728 multitasking \u65f6\u4ee3\u53d1\u5c55\u51fa\u7684\u6982\u5ff5","title":"Reentrancy VS thread-safety"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#rules#for#reentrancy","text":"NOTE: \u539f\u6587\u7684\u8fd9\u4e00\u6bb5\u662f\u4e0d\u5bb9\u6613\u7406\u89e3\u7684\uff0c\u6bd4\u8f83\u6666\u6da9\uff0c\u76f8\u6bd4\u4e4b\u4e0b\uff0cAPUE 10.6 Reentrant Functions \u5bb9\u6613\u7406\u89e3\u5730\u591a\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u8003\u5176\u4e2d\u7684\u603b\u7ed3 Reentrant code may not hold any static or global non-constant data. NOTE: \u9700\u8981\u6ce8\u610f\u7684\u662f: static local \u4e5f\u662f\u4e0d\u5141\u8bb8\u7684\uff0c\u5b83\u540c\u6837\u4f1a\u89e6\u53d1 many to one Reentrant code may not modify itself . NOTE: \u6ca1\u6709\u8bfb\u61c2\u8fd9\u4e00\u6bb5 Reentrant code may not call non-reentrant computer programs or routines .","title":"Rules for reentrancy"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#examples","text":"To illustrate reentrancy, this article uses as an example a C utility function, swap() , that takes two pointers and transposes their values, and an interrupt-handling routine that also calls the swap function.","title":"Examples"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#neither#reentrant#nor#thread-safe","text":"This is an example swap function that fails to be reentrant or thread-safe . As such, it should not have been used in the interrupt service routine isr() : int tmp ; void swap ( int * x , int * y ) { tmp = * x ; * x = * y ; * y = tmp ; /* Hardware interrupt might invoke isr() here. */ } void isr () { int x = 1 , y = 2 ; swap ( & x , & y ); } NOTE: 1\u3001 tmp \u662f**global variable**\uff0c\u5982\u679c\u572832\u4e3aOS\u4e2d\uff0c\u5219 *y = tmp \u5c31\u88ab\u7f16\u8bd1\u4e3a\u4e24\u6761\u6307\u4ee4\uff0c\u4e5f\u5c31\u662f\u8bf4\u5b83\u8fd9\u6761\u8bed\u53e5\u5e76\u4e0d\u662f\u539f\u5b50\u7684 2\u3001\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\uff0c\u4fdd\u5b58\u5728**global variable** tmp \u4e2d\u7684\u503c\uff0c\u53ef\u80fd\u4f1a\u88ab\u7b2c\u4e8c\u6b21\u6267\u884c\u7684\u65f6\u5019overwrite","title":"Neither reentrant nor thread-safe"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#thread-safe#but#not#reentrant","text":"The function swap() in the preceding example can be made thread-safe by making tmp thread-local . It still fails to be reentrant, and this will continue to cause problems if isr() is called in the same context as a thread already executing swap() : NOTE: 1\u3001reentrancy\u7684function\u7684\u6267\u884c\uff0c\u53ef\u80fd\u662f\u540c\u4e00\u4e2athread\u7684data\uff0c\u56e0\u6b64 _Thread_local \u65e0\u6cd5\u4fdd\u8bc1reentrancy _Thread_local int tmp ; void swap ( int * x , int * y ) { tmp = * x ; * x = * y ; * y = tmp ; /* Hardware interrupt might invoke isr() here. */ } void isr () { int x = 1 , y = 2 ; swap ( & x , & y ); }","title":"Thread-safe but not reentrant"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#reentrant#but#not#thread-safe","text":"The following (somewhat contrived(\u4eba\u4e3a\u7684)) modification of the swap function, which is careful to leave the global data in a consistent state at the time it exits, is reentrant; however, it is not thread-safe, since there are no locks employed, it can be interrupted at any time: NOTE: 1\u3001\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u8ba9\u6211\u60f3\u5230\u4e86context switch 2\u3001\u4ed4\u7ec6\u770b\u4e86\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u53d1\u73b0\u5b83\u80fd\u591f\u4fdd\u8bc1Reentrant: a\u3001\u7b2c\u4e00\u4e2a invokation \u6267\u884c\u5230 s = tmp; \u7684\u65f6\u5019\uff0c\u5b83\u53ef\u80fd\u662fpartial read b\u3001\u7b2c\u4e8c\u4e2a Invokation \u6267\u884c\u4e86\u4e4b\u540e\uff0c\u5b83\u662f\u4f1a\u6062\u590d tmp \u7684\uff0c\u56e0\u6b64\u7b2c\u4e00\u4e2ainvokation\u80fd\u591f\u63a5\u7740\u4e0a\u6b21\u7684\u5730\u65b9\u7ee7\u7eed\u8fd0\u884c int tmp ; void swap ( int * x , int * y ) { /* Save global variable. */ int s ; s = tmp ; tmp = * x ; * x = * y ; * y = tmp ; /* Hardware interrupt might invoke isr() here. */ /* Restore global variable. */ tmp = s ; } void isr () { int x = 1 , y = 2 ; swap ( & x , & y ); }","title":"Reentrant but not thread-safe"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#reentrant#and#thread-safe","text":"An implementation of swap() that allocates tmp on the stack instead of globally and that is called only with unshared variables as parameters is both thread-safe and reentrant. Thread-safe because the stack is local to a thread and a function acting just on local data will always produce the expected result. There is no access to shared data therefore no data race. void swap ( int * x , int * y ) { int tmp ; tmp = * x ; * x = * y ; * y = tmp ; /* Hardware interrupt might invoke isr() here. */ } void isr () { int x = 1 , y = 2 ; swap ( & x , & y ); }","title":"Reentrant and thread-safe"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#further#examples","text":"In the following code, neither f nor g functions are reentrant. int v = 1 ; int f () { v += 2 ; return v ; } int g () { return f () + 2 ; } In the above, f() depends on a non-constant global variable v ; thus, if f() is interrupted during execution by an ISR which modifies v , then reentry into f() will return the wrong value of v . The value of v and, therefore, the return value of f , cannot be predicted with confidence: they will vary depending on whether an interrupt modified v during f 's execution. Hence, f is not reentrant. Neither is g , because it calls f , which is not reentrant. These slightly altered versions are reentrant: int f ( int i ) { return i + 2 ; } int g ( int i ) { return f ( i ) + 2 ; }","title":"Further examples"},{"location":"Programming/Common/Attribute-of-function/Reentrancy/wikipedia-Reentrancy/#thread-safe#but#not#reentrant#mutex","text":"In the following, the function is thread-safe, but not reentrant: int function () { mutex_lock (); // ... // function body // ... mutex_unlock (); } In the above, function() can be called by different threads without any problem. But, if the function is used in a reentrant interrupt handler and a second interrupt arises inside the function, the second routine will hang forever. As interrupt servicing can disable other interrupts, the whole system could suffer.","title":"Thread-safe, but not reentrant: mutex"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/","text":"Classification of system call \u603b\u7ed3system call\u7684\u5206\u7c7b\u6cd5\u3002 \u4eceblocking\u7684\u89d2\u5ea6\u6765\u5bf9system call\u8fdb\u884c\u5206\u7c7b \u5728APUE\u768410.5 Interrupted System Calls\u4e2d\u4ecb\u7ecd\u4e86slow system call\uff0c\u8fd9\u63d0\u793a\u6709\u5fc5\u8981\u5bf9linux\u7684system call\u8fdb\u884c\u4e00\u4e0b\u603b\u7ed3\uff1b APUE 10.5 Interrupted System Calls A characteristic of earlier UNIX systems was that if a process caught a signal while the process was blocked in a \u2018\u2018 slow \u2019\u2019 system call, the system call was interrupted. The system call returned an error and errno was set to EINTR . This was done under the assumption that since a signal occurred and the process caught it, there is a good chance that something has happened that should wake up the blocked system call. To support this feature, the system calls are divided into two categories: the \u2018\u2018slow\u2019\u2019 system calls and all the others. The slow system calls are those that can block forever . Included in this category are \u2022 Reads that can block the caller forever if data isn\u2019t present with certain file types (pipes, terminal devices, and network devices) \u2022 Writes that can block the caller forever if the data can\u2019t be accepted immediately by these same file types \u2022 Opens on certain file types that block the caller until some condition occurs (such as a terminal device open waiting until an attached modem answers the phone) \u2022 The pause function (which by definition puts the calling process to sleep until a signal is caught) and the wait function \u2022 Certain ioctl operations \u2022 Some of the interprocess communication functions (Chapter 15) The notable exception to these slow system calls is anything related to disk I/O. Although a read or a write of a disk file can block the caller temporarily (while the disk driver queues the request and then the request is executed), unless a hardware error occurs, the I/O operation always returns and unblocks the caller quickly. SUMMARY : \u663e\u7136\uff0c\u4e0a\u8ff0\u5bf9system call\u7684\u5206\u7c7b\u65b9\u6cd5\u662f\u6839\u636e\u8fd9\u4e2asystem call\u662f\u5426\u53ef\u80fd\u4f1a\u5c06process **block forever**\u7684\uff0c\u77ed\u6682\u7684block\u662f\u4e0d\u7b97slow\u7684\uff0c\u8fd9\u4e2a\u77ed\u6682\u7684block\u5c31\u662fa read or a write of a disk file\u3002\u5e76\u4e14slow system call\u662f\u548csignal\u5bc6\u5207\u76f8\u5173\u7684\uff1b \u4e0a\u8ff0\u63cf\u8ff0\u7684\u662f\u5728Unix system\u4e2d\u7684\u60c5\u51b5\uff0c\u90a3\u4e48linux\u4e2d\u7684\u60c5\u51b5\u662f\u600e\u6837\u7684\u5462\uff1f\u53c2\u89c1 man SIGNAL(7) \uff0c\u5176\u4e2d\u5bf9linux\u4e2d\u7684\u60c5\u51b5\u8fdb\u884c\u4e86\u975e\u5e38\u8be6\u7ec6\u7684\u8bf4\u660e\uff1b man SIGNAL(7) Difference between slow system calls and fast system calls \u901a\u8fc7Nonblocking I/O\u6765\u8f6c\u6362slow system call \u524d\u8a00 \u4ece\u4e0a\u9762\u7684\u4ecb\u7ecd\u6765\u770b\uff0c\u5176\u5b9e\u6240\u8c13\u7684slow system call\u662f\u8ddf\u5b83\u6240\u64cd\u4f5c\u7684device\u5bc6\u5207\u76f8\u5173\u7684\uff0c\u800cUnix OS\u7684everything in Unix is file\u7684philosophy\uff0c\u5c06\u5f88\u591adevice\u90fd\u62bd\u8c61\u6210\u4e86file\uff0c\u6211\u4eec\u901a\u8fc7\u5bf9\u8fd9\u4e9bfile\u7684file descriptor\u8fdb\u884c\u64cd\u4f5c\u6765\u5b9e\u73b0\u5bf9device\u7684\u64cd\u4f5c\uff0c\u56e0\u6b64\u5f88\u591a\u64cd\u4f5c\u90fd\u662f\u7c7b\u4f3c\u4e8eIO\uff1b\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5f53\u6211\u4eec\u5bf9slow device\u6267\u884csystem call\u7684\u65f6\u5019\uff0c\u5c31\u975e\u5e38\u53ef\u80fd\u51fa\u73b0slow system call\u7684\u60c5\u51b5\uff1bUnix OS\u662f\u975e\u5e38\u7075\u6d3b\u7684\uff0c\u5b83\u662f\u6709\u63d0\u4f9bsystem call\u6765\u5141\u8bb8\u7528\u6237\u6539\u53d8\u8fd9\u79cd\u9ed8\u8ba4\u884c\u4e3a\u7684\uff1a\u8fd9\u5c31\u662fUnix\u4e2d\u7684nonblocking I/O\uff0c\u901a\u8fc7\u5728\u6307\u5b9a\u7684file descriptor\u4e0a\u8bbe\u7f6enonblocking\u6807\u5fd7\uff0c\u6765\u544a\u8bc9kernel\u4e0d\u8981block\u5bf9\u8be5file descriptor\u8fdb\u884c\u64cd\u4f5c\u7684thread\uff1b APUE 14.2 Nonblocking I/O \u5728\u8fd9\u4e00\u8282\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u7684\u5185\u5bb9\u8fdb\u884c\u4e86\u6df1\u5165\u7684\u4ecb\u7ecd\uff1b \u5e26\u6709max blocking time\u7684system call\u975e\u5e38\u91cd\u8981\uff0c\u6709\u5fc5\u8981\u8fdb\u884c\u603b\u7ed3\uff1a pthread_mutex_timedlock pthread_rwlock_timedrdlock pthread_cond_timedwait select poll epoll_wait \u548c\u963b\u585e\u76f8\u5173\u95ee\u9898 \u5982\u4f55\u53d6\u6d88\u963b\u585e\u7684\u7cfb\u7edf\u8c03\u7528\uff08\u53ef\u4ee5\u4f7f\u7528\u4fe1\u53f7\uff09 sleep \u662f\u5426\u662f\u963b\u585e\uff0c\u5982\u679c\u4e0d\u662f\uff0c\u5b83\u548c\u963b\u585e\u6709\u4ec0\u4e48\u5f02\u540c\uff1f \u975e\u963b\u585eI\u4e0e\u5f02\u6b65IO \u975e\u963b\u585eIO\u53c2\u89c1APUE 14.2 \u901a\u8fc7\u8bbe\u7f6e\u6807\u5fd7\u6765\u5b9e\u73b0\u975e\u963b\u585e \u5f02\u6b65IO\u53c2\u89c114.5 socket\u662f\u5982\u4f55\u5b9e\u73b0\u7684IO with timeout\uff1f Polling and non-polling Polling \u7ef4\u57fa\u767e\u79d1 Polling (computer science) Busy-waiting \u7ef4\u57fa\u767e\u79d1 Busy waiting https://practice.geeksforgeeks.org/problems/what-is-busy-wait https://dev.to/rinsama77/process-synchronization-with-busy-waiting-4gho https://stackoverflow.com/questions/1107593/what-are-trade-offs-for-busy-wait-vs-sleep https://www.auto.tuwien.ac.at/~blieb/papers/busywait.pdf Examples \u7ef4\u57fa\u767e\u79d1 Spinlock polling sleep Non-polling blocking\u3001waiting\u3001sleep TO READ what's different between the Blocked and Busy Waiting?","title":"Classification-of-system-call"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#classification#of#system#call","text":"\u603b\u7ed3system call\u7684\u5206\u7c7b\u6cd5\u3002","title":"Classification of system call"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#blockingsystem#call","text":"\u5728APUE\u768410.5 Interrupted System Calls\u4e2d\u4ecb\u7ecd\u4e86slow system call\uff0c\u8fd9\u63d0\u793a\u6709\u5fc5\u8981\u5bf9linux\u7684system call\u8fdb\u884c\u4e00\u4e0b\u603b\u7ed3\uff1b","title":"\u4eceblocking\u7684\u89d2\u5ea6\u6765\u5bf9system call\u8fdb\u884c\u5206\u7c7b"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#apue#105#interrupted#system#calls","text":"A characteristic of earlier UNIX systems was that if a process caught a signal while the process was blocked in a \u2018\u2018 slow \u2019\u2019 system call, the system call was interrupted. The system call returned an error and errno was set to EINTR . This was done under the assumption that since a signal occurred and the process caught it, there is a good chance that something has happened that should wake up the blocked system call. To support this feature, the system calls are divided into two categories: the \u2018\u2018slow\u2019\u2019 system calls and all the others. The slow system calls are those that can block forever . Included in this category are \u2022 Reads that can block the caller forever if data isn\u2019t present with certain file types (pipes, terminal devices, and network devices) \u2022 Writes that can block the caller forever if the data can\u2019t be accepted immediately by these same file types \u2022 Opens on certain file types that block the caller until some condition occurs (such as a terminal device open waiting until an attached modem answers the phone) \u2022 The pause function (which by definition puts the calling process to sleep until a signal is caught) and the wait function \u2022 Certain ioctl operations \u2022 Some of the interprocess communication functions (Chapter 15) The notable exception to these slow system calls is anything related to disk I/O. Although a read or a write of a disk file can block the caller temporarily (while the disk driver queues the request and then the request is executed), unless a hardware error occurs, the I/O operation always returns and unblocks the caller quickly. SUMMARY : \u663e\u7136\uff0c\u4e0a\u8ff0\u5bf9system call\u7684\u5206\u7c7b\u65b9\u6cd5\u662f\u6839\u636e\u8fd9\u4e2asystem call\u662f\u5426\u53ef\u80fd\u4f1a\u5c06process **block forever**\u7684\uff0c\u77ed\u6682\u7684block\u662f\u4e0d\u7b97slow\u7684\uff0c\u8fd9\u4e2a\u77ed\u6682\u7684block\u5c31\u662fa read or a write of a disk file\u3002\u5e76\u4e14slow system call\u662f\u548csignal\u5bc6\u5207\u76f8\u5173\u7684\uff1b \u4e0a\u8ff0\u63cf\u8ff0\u7684\u662f\u5728Unix system\u4e2d\u7684\u60c5\u51b5\uff0c\u90a3\u4e48linux\u4e2d\u7684\u60c5\u51b5\u662f\u600e\u6837\u7684\u5462\uff1f\u53c2\u89c1 man SIGNAL(7) \uff0c\u5176\u4e2d\u5bf9linux\u4e2d\u7684\u60c5\u51b5\u8fdb\u884c\u4e86\u975e\u5e38\u8be6\u7ec6\u7684\u8bf4\u660e\uff1b","title":"APUE 10.5 Interrupted System Calls"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#man#signal7","text":"","title":"man SIGNAL(7)"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#difference#between#slow#system#calls#and#fast#system#calls","text":"","title":"Difference between slow system calls and fast system calls"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#nonblocking#ioslow#system#call","text":"","title":"\u901a\u8fc7Nonblocking I/O\u6765\u8f6c\u6362slow system call"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#_1","text":"\u4ece\u4e0a\u9762\u7684\u4ecb\u7ecd\u6765\u770b\uff0c\u5176\u5b9e\u6240\u8c13\u7684slow system call\u662f\u8ddf\u5b83\u6240\u64cd\u4f5c\u7684device\u5bc6\u5207\u76f8\u5173\u7684\uff0c\u800cUnix OS\u7684everything in Unix is file\u7684philosophy\uff0c\u5c06\u5f88\u591adevice\u90fd\u62bd\u8c61\u6210\u4e86file\uff0c\u6211\u4eec\u901a\u8fc7\u5bf9\u8fd9\u4e9bfile\u7684file descriptor\u8fdb\u884c\u64cd\u4f5c\u6765\u5b9e\u73b0\u5bf9device\u7684\u64cd\u4f5c\uff0c\u56e0\u6b64\u5f88\u591a\u64cd\u4f5c\u90fd\u662f\u7c7b\u4f3c\u4e8eIO\uff1b\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5f53\u6211\u4eec\u5bf9slow device\u6267\u884csystem call\u7684\u65f6\u5019\uff0c\u5c31\u975e\u5e38\u53ef\u80fd\u51fa\u73b0slow system call\u7684\u60c5\u51b5\uff1bUnix OS\u662f\u975e\u5e38\u7075\u6d3b\u7684\uff0c\u5b83\u662f\u6709\u63d0\u4f9bsystem call\u6765\u5141\u8bb8\u7528\u6237\u6539\u53d8\u8fd9\u79cd\u9ed8\u8ba4\u884c\u4e3a\u7684\uff1a\u8fd9\u5c31\u662fUnix\u4e2d\u7684nonblocking I/O\uff0c\u901a\u8fc7\u5728\u6307\u5b9a\u7684file descriptor\u4e0a\u8bbe\u7f6enonblocking\u6807\u5fd7\uff0c\u6765\u544a\u8bc9kernel\u4e0d\u8981block\u5bf9\u8be5file descriptor\u8fdb\u884c\u64cd\u4f5c\u7684thread\uff1b","title":"\u524d\u8a00"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#apue#142#nonblocking#io","text":"\u5728\u8fd9\u4e00\u8282\u5bf9\u8fd9\u4e2a\u4e3b\u9898\u7684\u5185\u5bb9\u8fdb\u884c\u4e86\u6df1\u5165\u7684\u4ecb\u7ecd\uff1b","title":"APUE 14.2 Nonblocking I/O"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#max#blocking#timesystem#call","text":"pthread_mutex_timedlock pthread_rwlock_timedrdlock pthread_cond_timedwait select poll epoll_wait","title":"\u5e26\u6709max blocking time\u7684system call\u975e\u5e38\u91cd\u8981\uff0c\u6709\u5fc5\u8981\u8fdb\u884c\u603b\u7ed3\uff1a"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#_2","text":"\u5982\u4f55\u53d6\u6d88\u963b\u585e\u7684\u7cfb\u7edf\u8c03\u7528\uff08\u53ef\u4ee5\u4f7f\u7528\u4fe1\u53f7\uff09 sleep \u662f\u5426\u662f\u963b\u585e\uff0c\u5982\u679c\u4e0d\u662f\uff0c\u5b83\u548c\u963b\u585e\u6709\u4ec0\u4e48\u5f02\u540c\uff1f","title":"\u548c\u963b\u585e\u76f8\u5173\u95ee\u9898"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#iio","text":"\u975e\u963b\u585eIO\u53c2\u89c1APUE 14.2 \u901a\u8fc7\u8bbe\u7f6e\u6807\u5fd7\u6765\u5b9e\u73b0\u975e\u963b\u585e \u5f02\u6b65IO\u53c2\u89c114.5","title":"\u975e\u963b\u585eI\u4e0e\u5f02\u6b65IO"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#socketio#with#timeout","text":"","title":"socket\u662f\u5982\u4f55\u5b9e\u73b0\u7684IO with timeout\uff1f"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#polling#and#non-polling","text":"","title":"Polling and non-polling"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#polling","text":"\u7ef4\u57fa\u767e\u79d1 Polling (computer science)","title":"Polling"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#busy-waiting","text":"\u7ef4\u57fa\u767e\u79d1 Busy waiting https://practice.geeksforgeeks.org/problems/what-is-busy-wait https://dev.to/rinsama77/process-synchronization-with-busy-waiting-4gho https://stackoverflow.com/questions/1107593/what-are-trade-offs-for-busy-wait-vs-sleep https://www.auto.tuwien.ac.at/~blieb/papers/busywait.pdf","title":"Busy-waiting"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#examples","text":"\u7ef4\u57fa\u767e\u79d1 Spinlock polling sleep","title":"Examples"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#non-polling","text":"blocking\u3001waiting\u3001sleep","title":"Non-polling"},{"location":"Programming/Common/Classification-of-system-call/Classification-of-system-call/#to#read","text":"what's different between the Blocked and Busy Waiting?","title":"TO READ"},{"location":"Programming/Common/Classification-of-system-call/Polling-%28computer-science%29/","text":"Polling (computer science) Polling , or polled operation, in computer science , refers to actively sampling the status of an external device by a client program as a synchronous activity. Polling is most often used in terms of input/output (I/O), and is also referred to as polled I/O or software-driven I/O . keyword \uff1asample\uff1bsynchronous\uff1b Description Polling is the process where the computer or controlling device waits for an external device to check for its readiness or state, often with low-level hardware. For example, when a printer is connected via a parallel port , the computer waits until the printer has received the next character. These processes can be as minute as only reading one bit . \u03a4his is sometimes used synonymously\uff08\u540c\u4e49\uff09 with busy-wait polling. In this situation, when an I/O operation is required, the computer does nothing other than check the status of the I/O device until it is ready, at which point the device is accessed. In other words, the computer waits until the device is ready. Polling also refers to the situation where a device is repeatedly checked for readiness, and if it is not, the computer returns to a different task. Although not as wasteful of CPU cycles as busy waiting, this is generally not as efficient as the alternative to polling, interrupt -driven I/O. SUMMARY :\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u63cf\u8ff0\u4e86\u4e24\u79cd**polling**\uff0c\u7b2c\u4e00\u79cd\u4e3a busy-wait polling\uff0c\u7b2c\u4e8c\u79cd\u7684\u505a\u6cd5\u4e0e busy-wait polling\u4e0d\u540c\uff0c\u5b83\u4e0d\u4f1a\u4e00\u76f4loop\uff1b\u6700\u540e\u4e00\u6bb5\u8bdd\u5219\u5c06polling\u4e0e interrupt -driven I/O\u8fdb\u884c\u4e86\u5bf9\u6bd4\uff0c\u4f5c\u8005\u76f4\u63a5\u6307\u51fa\u8fd9\u4e24\u79cdpolling\u5728\u6027\u80fd\u4e0a\u90fd\u4e0d\u53ca interrupt -driven I/O\u3002 In a simple single-purpose system, even busy-wait is perfectly appropriate if no action is possible until the I/O access, but more often than not this was traditionally a consequence of simple hardware or non- multitasking operating systems . SUMMARY :\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u6307\u51fapolling\u5728simple single-purpose system\u4e2d\u7684\u4f7f\u7528\u3002 Polling is often intimately\uff08\u5bc6\u5207\u5730\uff09 involved with very low-level hardware . For example, polling a parallel printer port to check whether it is ready for another character involves examining as little as one bit of a byte . That bit represents, at the time of reading, whether a single wire in the printer cable is at low or high voltage. The I/O instruction that reads this byte directly transfers the voltage state of eight real world wires to the eight circuits ( flip flops ) that make up one byte of a CPU register. SUMMARY :\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u70b9\u51fa\u4e86polling\u5728 low-level hardware \u4e2d\u7684\u7528\u9014\u3002 Polling has the disadvantage that if there are too many devices to check, the time required to poll them can exceed the time available to service the I/O device. SUMMARY :\u4e0a\u9762\u8fd9\u6bb5\u6307\u51fa\u4e86polling\u7684\u52a3\u52bf\u6240\u5728\u3002 Algorithm Polling can be described in the following steps (add a pic): Host actions: The host repeatedly reads the busy bit of the controller until it becomes clear. When clear, the host writes in the command register and writes a byte into the data-out register. The host sets the command-ready bit (set to 1). Controller actions: When the controller senses command-ready bit is set, it sets busy bit. The controller reads the command register and since write bit is set, it performs necessary I/O operations on the device. If the read bit is set to one instead of write bit, data from device is loaded into data-in register, which is further read by the host. The controller clears the command-ready bit once everything is over, it clears error bit to show successful operation and reset busy bit (0). SUMMARY :\u4e0a\u9762\u8fd9\u4e2aalgorithm\u5e76\u6ca1\u6709\u9605\u8bfb Types A polling cycle is the time in which each element is monitored once. The optimal\uff08\u6700\u4f18\u7684\uff09 polling cycle will vary according to several factors, including the desired speed of response and the overhead (e.g., processor time and bandwidth) of the polling. In roll call polling \uff08\u6eda\u52a8\u8c03\u7528\u8f6e\u8be2\uff09, the polling device or process queries each element on a list in a fixed sequence. Because it waits for a response from each element, a timing mechanism is necessary to prevent lock-ups caused by non-responding elements. Roll call polling can be inefficient if the overhead for the polling messages is high, there are numerous elements to be polled in each polling cycle and only a few elements are active. In hub polling \uff08\u96c6\u7ebf\u5668\u8f6e\u8be2\uff09, also referred to as token polling (\u4ee4\u724c\u8f6e\u8be2), each element polls the next element in some fixed sequence. This continues until the first element is reached, at which time the polling cycle starts all over again. Polling can be employed in various computing contexts in order to control the execution or transmission sequence of the elements involved. For example, in multitasking operating systems , polling can be used to allocate processor time and other resources to the various competing processes. SUMMARY :polling\u5728\u5206\u65f6\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u5e94\u7528\u3002 In networks, polling is used to determine which nodes want to access the network. It is also used by routing protocols to retrieve routing information, as is the case with EGP (exterior gateway protocol). An alternative to polling is the use of interrupts , which are signals generated by devices or processes to indicate that they need attention, want to communicate, etc. Although polling can be very simple, in many situations (e.g., multitasking operating systems) it is more efficient to use interrupts because it can reduce processor usage and/or bandwidth consumption. Poll message A poll message is a control-acknowledgment message(\u63a7\u5236\u786e\u8ba4\u6d88\u606f). In a multidrop line arrangement (a central computer and different terminals in which the terminals share a single communication line to and from the computer), the system uses a master/slave polling arrangement whereby the central computer sends message (called polling message ) to a specific terminal on the outgoing line. All terminals listen to the outgoing line, but only the terminal that is polled replies by sending any information that it has ready for transmission on the incoming line.[ 1] In star networks , which, in its simplest form, consists of one central switch , hub , or computer that acts as a conduit to transmit messages, polling is not required to avoid chaos on the lines, but it is often used to allow the master to acquire input in an orderly fashion. These poll messages differ from those of the multidrop lines case because there are no site addresses needed, and each terminal only receives those polls that are directed to it.[ 1]","title":"Polling-(computer-science)"},{"location":"Programming/Common/Classification-of-system-call/Polling-%28computer-science%29/#polling#computer#science","text":"Polling , or polled operation, in computer science , refers to actively sampling the status of an external device by a client program as a synchronous activity. Polling is most often used in terms of input/output (I/O), and is also referred to as polled I/O or software-driven I/O . keyword \uff1asample\uff1bsynchronous\uff1b","title":"Polling (computer science)"},{"location":"Programming/Common/Classification-of-system-call/Polling-%28computer-science%29/#description","text":"Polling is the process where the computer or controlling device waits for an external device to check for its readiness or state, often with low-level hardware. For example, when a printer is connected via a parallel port , the computer waits until the printer has received the next character. These processes can be as minute as only reading one bit . \u03a4his is sometimes used synonymously\uff08\u540c\u4e49\uff09 with busy-wait polling. In this situation, when an I/O operation is required, the computer does nothing other than check the status of the I/O device until it is ready, at which point the device is accessed. In other words, the computer waits until the device is ready. Polling also refers to the situation where a device is repeatedly checked for readiness, and if it is not, the computer returns to a different task. Although not as wasteful of CPU cycles as busy waiting, this is generally not as efficient as the alternative to polling, interrupt -driven I/O. SUMMARY :\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u63cf\u8ff0\u4e86\u4e24\u79cd**polling**\uff0c\u7b2c\u4e00\u79cd\u4e3a busy-wait polling\uff0c\u7b2c\u4e8c\u79cd\u7684\u505a\u6cd5\u4e0e busy-wait polling\u4e0d\u540c\uff0c\u5b83\u4e0d\u4f1a\u4e00\u76f4loop\uff1b\u6700\u540e\u4e00\u6bb5\u8bdd\u5219\u5c06polling\u4e0e interrupt -driven I/O\u8fdb\u884c\u4e86\u5bf9\u6bd4\uff0c\u4f5c\u8005\u76f4\u63a5\u6307\u51fa\u8fd9\u4e24\u79cdpolling\u5728\u6027\u80fd\u4e0a\u90fd\u4e0d\u53ca interrupt -driven I/O\u3002 In a simple single-purpose system, even busy-wait is perfectly appropriate if no action is possible until the I/O access, but more often than not this was traditionally a consequence of simple hardware or non- multitasking operating systems . SUMMARY :\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u6307\u51fapolling\u5728simple single-purpose system\u4e2d\u7684\u4f7f\u7528\u3002 Polling is often intimately\uff08\u5bc6\u5207\u5730\uff09 involved with very low-level hardware . For example, polling a parallel printer port to check whether it is ready for another character involves examining as little as one bit of a byte . That bit represents, at the time of reading, whether a single wire in the printer cable is at low or high voltage. The I/O instruction that reads this byte directly transfers the voltage state of eight real world wires to the eight circuits ( flip flops ) that make up one byte of a CPU register. SUMMARY :\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u70b9\u51fa\u4e86polling\u5728 low-level hardware \u4e2d\u7684\u7528\u9014\u3002 Polling has the disadvantage that if there are too many devices to check, the time required to poll them can exceed the time available to service the I/O device. SUMMARY :\u4e0a\u9762\u8fd9\u6bb5\u6307\u51fa\u4e86polling\u7684\u52a3\u52bf\u6240\u5728\u3002","title":"Description"},{"location":"Programming/Common/Classification-of-system-call/Polling-%28computer-science%29/#algorithm","text":"Polling can be described in the following steps (add a pic): Host actions: The host repeatedly reads the busy bit of the controller until it becomes clear. When clear, the host writes in the command register and writes a byte into the data-out register. The host sets the command-ready bit (set to 1). Controller actions: When the controller senses command-ready bit is set, it sets busy bit. The controller reads the command register and since write bit is set, it performs necessary I/O operations on the device. If the read bit is set to one instead of write bit, data from device is loaded into data-in register, which is further read by the host. The controller clears the command-ready bit once everything is over, it clears error bit to show successful operation and reset busy bit (0). SUMMARY :\u4e0a\u9762\u8fd9\u4e2aalgorithm\u5e76\u6ca1\u6709\u9605\u8bfb","title":"Algorithm"},{"location":"Programming/Common/Classification-of-system-call/Polling-%28computer-science%29/#types","text":"A polling cycle is the time in which each element is monitored once. The optimal\uff08\u6700\u4f18\u7684\uff09 polling cycle will vary according to several factors, including the desired speed of response and the overhead (e.g., processor time and bandwidth) of the polling. In roll call polling \uff08\u6eda\u52a8\u8c03\u7528\u8f6e\u8be2\uff09, the polling device or process queries each element on a list in a fixed sequence. Because it waits for a response from each element, a timing mechanism is necessary to prevent lock-ups caused by non-responding elements. Roll call polling can be inefficient if the overhead for the polling messages is high, there are numerous elements to be polled in each polling cycle and only a few elements are active. In hub polling \uff08\u96c6\u7ebf\u5668\u8f6e\u8be2\uff09, also referred to as token polling (\u4ee4\u724c\u8f6e\u8be2), each element polls the next element in some fixed sequence. This continues until the first element is reached, at which time the polling cycle starts all over again. Polling can be employed in various computing contexts in order to control the execution or transmission sequence of the elements involved. For example, in multitasking operating systems , polling can be used to allocate processor time and other resources to the various competing processes. SUMMARY :polling\u5728\u5206\u65f6\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u5e94\u7528\u3002 In networks, polling is used to determine which nodes want to access the network. It is also used by routing protocols to retrieve routing information, as is the case with EGP (exterior gateway protocol). An alternative to polling is the use of interrupts , which are signals generated by devices or processes to indicate that they need attention, want to communicate, etc. Although polling can be very simple, in many situations (e.g., multitasking operating systems) it is more efficient to use interrupts because it can reduce processor usage and/or bandwidth consumption.","title":"Types"},{"location":"Programming/Common/Classification-of-system-call/Polling-%28computer-science%29/#poll#message","text":"A poll message is a control-acknowledgment message(\u63a7\u5236\u786e\u8ba4\u6d88\u606f). In a multidrop line arrangement (a central computer and different terminals in which the terminals share a single communication line to and from the computer), the system uses a master/slave polling arrangement whereby the central computer sends message (called polling message ) to a specific terminal on the outgoing line. All terminals listen to the outgoing line, but only the terminal that is polled replies by sending any information that it has ready for transmission on the incoming line.[ 1] In star networks , which, in its simplest form, consists of one central switch , hub , or computer that acts as a conduit to transmit messages, polling is not required to avoid chaos on the lines, but it is often used to allow the master to acquire input in an orderly fashion. These poll messages differ from those of the multidrop lines case because there are no site addresses needed, and each terminal only receives those polls that are directed to it.[ 1]","title":"Poll message"},{"location":"Programming/Computer-errors/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u603b\u7ed3\u5e38\u89c1\u7684program error\uff0c\u8fd9\u4e9berror\u5e38\u5e38\u5bfc\u81f4process\u88abOS\u7ec8\u6b62\uff08\u5f80\u5f80\u662f\u901a\u8fc7signal\u6765\u901a\u77e5process\uff09\uff0c\u8fdb\u800c\u5bfc\u81f4out of service\uff08unavailability\uff09\uff0c\u663e\u7136\u5305\u542b\u8fd9\u4e9berror\u7684program\u662fweak\u7684\uff0c\u4e3a\u4e86\u6784\u9020robust program\uff0c\u5fc5\u987b\u8981\u6d88\u9664\u8fd9\u4e9berror\uff0c\u6240\u4ee5\u4e86\u89e3\u8fd9\u4e9berror\u975e\u5e38\u91cd\u8981\u3002 \u53c2\u8003\u5185\u5bb9 \u7f51\u7ad9 CWE \u8fd9\u4e2a\u7f51\u7ad9\u4e2d\u7684\u5185\u5bb9\u975e\u5e38\u4e0d\u9519\u3002 \u7f51\u7ad9 OWASP","title":"Introduction"},{"location":"Programming/Computer-errors/#_1","text":"\u672c\u7ae0\u603b\u7ed3\u5e38\u89c1\u7684program error\uff0c\u8fd9\u4e9berror\u5e38\u5e38\u5bfc\u81f4process\u88abOS\u7ec8\u6b62\uff08\u5f80\u5f80\u662f\u901a\u8fc7signal\u6765\u901a\u77e5process\uff09\uff0c\u8fdb\u800c\u5bfc\u81f4out of service\uff08unavailability\uff09\uff0c\u663e\u7136\u5305\u542b\u8fd9\u4e9berror\u7684program\u662fweak\u7684\uff0c\u4e3a\u4e86\u6784\u9020robust program\uff0c\u5fc5\u987b\u8981\u6d88\u9664\u8fd9\u4e9berror\uff0c\u6240\u4ee5\u4e86\u89e3\u8fd9\u4e9berror\u975e\u5e38\u91cd\u8981\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Computer-errors/#_2","text":"","title":"\u53c2\u8003\u5185\u5bb9"},{"location":"Programming/Computer-errors/#cwe","text":"\u8fd9\u4e2a\u7f51\u7ad9\u4e2d\u7684\u5185\u5bb9\u975e\u5e38\u4e0d\u9519\u3002","title":"\u7f51\u7ad9CWE"},{"location":"Programming/Computer-errors/#owasp","text":"","title":"\u7f51\u7ad9OWASP"},{"location":"Programming/Computer-errors/CWE/CWE/","text":"CWE \u8fd9\u4e2a\u7f51\u7ad9\u7684\u5185\u5bb9\u975e\u5e38\u4e0d\u9519\u3002 CWE","title":"CWE"},{"location":"Programming/Computer-errors/CWE/CWE/#cwe","text":"\u8fd9\u4e2a\u7f51\u7ad9\u7684\u5185\u5bb9\u975e\u5e38\u4e0d\u9519\u3002","title":"CWE"},{"location":"Programming/Computer-errors/CWE/CWE/#cwe_1","text":"","title":"CWE"},{"location":"Programming/Computer-errors/Memory-access-error/","text":"\u5173\u4e8e\u672c\u7ae0 \u8fd9\u90e8\u5206\u5185\u5bb9\u79fb\u5230\u4e86\u5de5\u7a0bprogramming language\u7684 C-family-language\\C-and-C++\\Resource-management\\Memory-management\\Memory-access\\Memory-access-error \u7ae0\u8282\u3002","title":"Introduction"},{"location":"Programming/Computer-errors/Memory-access-error/#_1","text":"\u8fd9\u90e8\u5206\u5185\u5bb9\u79fb\u5230\u4e86\u5de5\u7a0bprogramming language\u7684 C-family-language\\C-and-C++\\Resource-management\\Memory-management\\Memory-access\\Memory-access-error \u7ae0\u8282\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Errorno/Errorno-EAGAIN/","text":"What does EAGAIN mean? A EAGAIN is often raised when performing non-blocking I/O . It means \"there is no data available right now, try again later\" . It might (or might not ) be the same as EWOULDBLOCK , which means \"your thread would have to block in order to do that\" .","title":"[What does EAGAIN mean?](https://stackoverflow.com/questions/4058368/what-does-eagain-mean)"},{"location":"Programming/Errorno/Errorno-EAGAIN/#what#does#eagain#mean","text":"","title":"What does EAGAIN mean?"},{"location":"Programming/Errorno/Errorno-EAGAIN/#a","text":"EAGAIN is often raised when performing non-blocking I/O . It means \"there is no data available right now, try again later\" . It might (or might not ) be the same as EWOULDBLOCK , which means \"your thread would have to block in order to do that\" .","title":"A"},{"location":"Programming/Errorno/Errorno-EEXIST/","text":"","title":"Errorno EEXIST"},{"location":"Programming/Errorno/man-3-errorno/","text":"","title":"Man 3 errorno"},{"location":"Programming/IO/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u4ecb\u7ecdIO\u76f8\u5173\u77e5\u8bc6\u3002","title":"Introduction"},{"location":"Programming/IO/#_1","text":"\u672c\u7ae0\u4ecb\u7ecdIO\u76f8\u5173\u77e5\u8bc6\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/IO/Input-output/","text":"Input output \u4ec0\u4e48\u662fIO\uff0c\u770b\u770b\u7ef4\u57fa\u767e\u79d1 Input/output \u7684\u89e3\u91ca\u5427\u3002 \u7ef4\u57fa\u767e\u79d1 Input/output In computing , input/output or I/O (or, informally, io or IO ) is the communication between an information processing system , such as a computer , and the outside world, possibly a human or another information processing system . Inputs are the signals or data received by the system and outputs are the signals or data sent from it. The term can also be used as part of an action; to \"perform I/O\" is to perform an input or output operation . I/O devices are the pieces of hardware used by a human (or other system) to communicate with a computer. For instance, a keyboard or computer mouse is an input device for a computer, while monitors and printers are output devices. Devices for communication between computers, such as modems and network cards , typically perform both input and output operations. In computer architecture, the combination of the CPU and main memory , to which the CPU can read or write directly using individual instructions , is considered the brain of a computer. Any transfer of information to or from the CPU/memory combo, for example by reading data from a disk drive , is considered I/O. The CPU and its supporting circuitry may provide memory-mapped I/O that is used in low-level computer programming , such as in the implementation of device drivers , or may provide access to I/O channels . An I/O algorithm is one designed to exploit locality and perform efficiently when exchanging data with a secondary storage device, such as a disk drive. NOTE: \u8fd9\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u6240\u8bf4\u7684IO\u3002 Interface Higher-level implementation Higher-level operating system and programming facilities employ separate, more abstract I/O concepts and primitives . For example, most operating systems provide application programs with the concept of files . The C and C++ programming languages, and operating systems in the Unix family, traditionally abstract files and devices as streams , which can be read or written, or sometimes both. The C standard library provides functions for manipulating streams for input and output. NOTE: \u62bd\u8c61\u4e3a stream \u662f\u975e\u5e38\u91cd\u8981\uff0c\u4e0b\u7bc7\u4f1a\u5bf9\u6b64\u8fdb\u884c\u8be6\u7ec6\u63cf\u8ff0\u3002 An alternative to special primitive functions is the I/O monad , which permits programs to just describe I/O, and the actions are carried out outside the program. This is notable because the I/O functions would introduce side-effects to any programming language, but this allows purely functional programming to be practical. IO\u53ef\u4ee5\u770b\u505a\u662fdata exchange \u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662fIO\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u79cddata exchange\uff0c\u5373\u53cc\u65b9**\u4ea4\u6362\u6570\u636e**\uff0c\u5173\u4e8edata exchange\uff0c\u53c2\u89c1: wikipedia Data exchange IO\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u79cd\u901a\u4fe1 IO\u4e5f\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u79cd\u901a\u4fe1\uff0c\u56e0\u6b64\uff0c\u53cc\u65b9\u9700\u8981\u7ea6\u5b9a\u597d\u534f\u8bae\u3002","title":"IO"},{"location":"Programming/IO/Input-output/#input#output","text":"\u4ec0\u4e48\u662fIO\uff0c\u770b\u770b\u7ef4\u57fa\u767e\u79d1 Input/output \u7684\u89e3\u91ca\u5427\u3002","title":"Input output"},{"location":"Programming/IO/Input-output/#inputoutput","text":"In computing , input/output or I/O (or, informally, io or IO ) is the communication between an information processing system , such as a computer , and the outside world, possibly a human or another information processing system . Inputs are the signals or data received by the system and outputs are the signals or data sent from it. The term can also be used as part of an action; to \"perform I/O\" is to perform an input or output operation . I/O devices are the pieces of hardware used by a human (or other system) to communicate with a computer. For instance, a keyboard or computer mouse is an input device for a computer, while monitors and printers are output devices. Devices for communication between computers, such as modems and network cards , typically perform both input and output operations. In computer architecture, the combination of the CPU and main memory , to which the CPU can read or write directly using individual instructions , is considered the brain of a computer. Any transfer of information to or from the CPU/memory combo, for example by reading data from a disk drive , is considered I/O. The CPU and its supporting circuitry may provide memory-mapped I/O that is used in low-level computer programming , such as in the implementation of device drivers , or may provide access to I/O channels . An I/O algorithm is one designed to exploit locality and perform efficiently when exchanging data with a secondary storage device, such as a disk drive. NOTE: \u8fd9\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u6240\u8bf4\u7684IO\u3002","title":"\u7ef4\u57fa\u767e\u79d1 Input/output"},{"location":"Programming/IO/Input-output/#interface","text":"","title":"Interface"},{"location":"Programming/IO/Input-output/#higher-level#implementation","text":"Higher-level operating system and programming facilities employ separate, more abstract I/O concepts and primitives . For example, most operating systems provide application programs with the concept of files . The C and C++ programming languages, and operating systems in the Unix family, traditionally abstract files and devices as streams , which can be read or written, or sometimes both. The C standard library provides functions for manipulating streams for input and output. NOTE: \u62bd\u8c61\u4e3a stream \u662f\u975e\u5e38\u91cd\u8981\uff0c\u4e0b\u7bc7\u4f1a\u5bf9\u6b64\u8fdb\u884c\u8be6\u7ec6\u63cf\u8ff0\u3002 An alternative to special primitive functions is the I/O monad , which permits programs to just describe I/O, and the actions are carried out outside the program. This is notable because the I/O functions would introduce side-effects to any programming language, but this allows purely functional programming to be practical.","title":"Higher-level implementation"},{"location":"Programming/IO/Input-output/#iodata#exchange","text":"\u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662fIO\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u79cddata exchange\uff0c\u5373\u53cc\u65b9**\u4ea4\u6362\u6570\u636e**\uff0c\u5173\u4e8edata exchange\uff0c\u53c2\u89c1: wikipedia Data exchange","title":"IO\u53ef\u4ee5\u770b\u505a\u662fdata exchange"},{"location":"Programming/IO/Input-output/#io","text":"IO\u4e5f\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u79cd\u901a\u4fe1\uff0c\u56e0\u6b64\uff0c\u53cc\u65b9\u9700\u8981\u7ea6\u5b9a\u597d\u534f\u8bae\u3002","title":"IO\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u79cd\u901a\u4fe1"},{"location":"Programming/IO/File-IO/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u4ecb\u7ecd\u4e0efile\u76f8\u5173\u7684IO\u3002","title":"Introduction"},{"location":"Programming/IO/File-IO/#_1","text":"\u672c\u7ae0\u4ecb\u7ecd\u4e0efile\u76f8\u5173\u7684IO\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/IO/File-IO/File-format/","text":"File format \u5728\u8fdb\u884cIO\u4e4b\u524d\uff0c\u5fc5\u987b\u9996\u5148\u5b9a\u4e49file format\uff0c\u8fd9\u662fIO\u7684\u524d\u63d0\u3002 What is file format? file format\u662f\u4e00\u79cdschema\uff0c\u5b83\u63cf\u8ff0\u4e86data\u7684structure\u3002\u5728superuser What are the general differences between a format and a protocol \u4e2d\uff0c\u6709\u8fd9\u6837\u7684\u63cf\u8ff0: A format describes the structure of some data Examples protobuf SQLite \u5728 About SQLite \u4e2d\uff0c\u6709\u8fd9\u6837\u7684\u4ecb\u7ecd: A complete SQL database with multiple tables, indices, triggers, and views, is contained in a single disk file. The database file format is cross-platform - you can freely copy a database between 32-bit and 64-bit systems or between big-endian and little-endian architectures. These features make SQLite a popular choice as an Application File Format . SQLite database files are a recommended storage format by the US Library of Congress. Think of SQLite not as a replacement for Oracle but as a replacement for fopen() SQLite Database File Format This document describes and defines the on-disk database file format used by all releases of SQLite since version 3.0.0 (2004-06-18). SQLite As An Application File Format Json MessagePack NOTE: \u8fd9\u662f\u6211\u5728\u9605\u8bfbcnblogs \u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u51e0\u79cd\u6570\u636e\u4ea4\u6362\u534f\u8bae \u65f6\uff0c\u5176\u4e2d\u63d0\u53ca\u7684\u4e00\u79cd Redis Redis RDB Dump File Format","title":"File-format"},{"location":"Programming/IO/File-IO/File-format/#file#format","text":"\u5728\u8fdb\u884cIO\u4e4b\u524d\uff0c\u5fc5\u987b\u9996\u5148\u5b9a\u4e49file format\uff0c\u8fd9\u662fIO\u7684\u524d\u63d0\u3002","title":"File format"},{"location":"Programming/IO/File-IO/File-format/#what#is#file#format","text":"file format\u662f\u4e00\u79cdschema\uff0c\u5b83\u63cf\u8ff0\u4e86data\u7684structure\u3002\u5728superuser What are the general differences between a format and a protocol \u4e2d\uff0c\u6709\u8fd9\u6837\u7684\u63cf\u8ff0: A format describes the structure of some data","title":"What is file format?"},{"location":"Programming/IO/File-IO/File-format/#examples","text":"","title":"Examples"},{"location":"Programming/IO/File-IO/File-format/#protobuf","text":"","title":"protobuf"},{"location":"Programming/IO/File-IO/File-format/#sqlite","text":"\u5728 About SQLite \u4e2d\uff0c\u6709\u8fd9\u6837\u7684\u4ecb\u7ecd: A complete SQL database with multiple tables, indices, triggers, and views, is contained in a single disk file. The database file format is cross-platform - you can freely copy a database between 32-bit and 64-bit systems or between big-endian and little-endian architectures. These features make SQLite a popular choice as an Application File Format . SQLite database files are a recommended storage format by the US Library of Congress. Think of SQLite not as a replacement for Oracle but as a replacement for fopen()","title":"SQLite"},{"location":"Programming/IO/File-IO/File-format/#sqlite#database#file#format","text":"This document describes and defines the on-disk database file format used by all releases of SQLite since version 3.0.0 (2004-06-18).","title":"SQLite Database File Format"},{"location":"Programming/IO/File-IO/File-format/#sqlite#as#an#application#file#format","text":"","title":"SQLite As An Application File Format"},{"location":"Programming/IO/File-IO/File-format/#json","text":"","title":"Json"},{"location":"Programming/IO/File-IO/File-format/#messagepack","text":"NOTE: \u8fd9\u662f\u6211\u5728\u9605\u8bfbcnblogs \u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u51e0\u79cd\u6570\u636e\u4ea4\u6362\u534f\u8bae \u65f6\uff0c\u5176\u4e2d\u63d0\u53ca\u7684\u4e00\u79cd","title":"MessagePack"},{"location":"Programming/IO/File-IO/File-format/#redis","text":"Redis RDB Dump File Format","title":"Redis"},{"location":"Programming/IO/File-IO/File-system/File-type/","text":"Unix file types For normal files in the file system, Unix does not impose or provide any internal file structure . This implies that from the point of view of the operating system , there is only one file type. The structure and interpretation thereof is entirely dependent on how the file is interpreted by software. SUMMARY : \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u6240\u63cf\u8ff0\u7684internal file structure\u6240\u6307\u7684\u662f\u6587\u4ef6\u5728disk\u4e2d\u5b58\u50a8\u7684\u7ed3\u6784\u8fd8\u662f\u5728\u5f53\u5b83\u4eec\u8bfb\u5165\u5230\u5185\u5b58\u4e2d\u7684\u7ed3\u6784\u5462\uff1f\u663e\u7136\u6587\u4ef6\u5728disk\u4e2d\u5b58\u50a8\u7684\u7ed3\u6784\u662f\u9759\u6001\u7ed3\u6784\uff0c\u800c\u5f53\u8fdb\u7a0b\u8bfb\u5165\u6587\u4ef6\u5230\u5185\u5b58\u4e2d\uff0c\u5219\u6b64\u65f6\u5c31\u9700\u8981\u4f7f\u7528runtime structure\u4e86\uff1b\u5173\u4e8e\u6587\u4ef6\u7684runtime structure\uff0c\u5728\u300aAPUE-3.10-File-Sharing\u300b\u4e2d\u8fdb\u884c\u4e86\u63cf\u8ff0\uff1b\u5176\u4e2d\u6240\u6d89\u53ca\u7684\u76f8\u5173\u6982\u5ff5\uff0c\u5728Wikipedia\u4e2d\u90fd\u6709\u8bf4\u660e\uff1b Unix does however have some special files. These special files can be identified by the ls -l command which displays the type of the file in the first alphabetic letter of the file system permissions field. A normal (regular) file is indicated by a hyphen-minus ' - '. Examples of implementations Different OS-specific implementations allow more types than what POSIX requires (e.g. Solaris doors). The GNU coreutils version of ls uses a call to filemode() , a glibc function (exposed in the gnulib library[ 3] ) to get the mode string . FreeBSD uses a simpler approach[ 4] but allows a smaller number of file types . Regular file Main article: Computer file Files are also called \"regular files\" to distinguish them from \"special files\". They show up in ls -l without a specific character in the mode field: $ ls -l /etc/passwd -rw-r--r-- ... /etc/passwd Directory Main article: Directory (computing) The most common special file is the directory. The layout of a directory file is defined by the filesystem used. As several filesystems , both native and non-native, are available under Unix, there is not one directory file layout. A directory is marked with a d as the first letter in the mode field in the output of ls -dl or stat , e.g. $ ls -dl / drwxr-xr-x 26 root root 4096 Sep 22 09 :29 / $ stat / File: \"/\" Size: 4096 Blocks: 8 IO Block: 4096 directory Device: 802h/2050d Inode: 128 Links: 26 Access: ( 0755 /drwxr-xr-x ) Uid: ( 0 / root ) Gid: ( 0 / root ) ... Symbolic link Main article: Symbolic link A symbolic link is a reference to another file. This special file is stored as a textual representation of the referenced file's path (which means the destination may be a relative path, or may not exist at all). A symbolic link is marked with an **l** (lower case L ) as the first letter of the mode string, e.g. lrwxrwxrwx ... termcap -> /usr/share/misc/termcap lrwxrwxrwx ... S03xinetd -> ../init.d/xinetd Named pipe Main article: Named pipe One of the strengths of Unix has always been inter-process communication . Among the facilities provided by the OS are pipes . Pipes connect the output of one process to the input of another. This is fine if both processes exist in the same parent process space , started by the same user. There are, however, circumstances where the communicating processes must use named pipes. One such circumstance occurs when the processes must be executed under different user names and permissions. Named pipes are special files that can exist anywhere in the file system. Named pipe special files are created with the command mkfifo as in mkfifo mypipe . A named pipe is marked with a **p** as the first letter of the mode string, e.g. prw-rw---- ... mypipe Socket Main article: Unix domain socket A socket is a special file used for inter-process communication . These enable communication between two processes. In addition to sending data, processes can send file descriptors across a Unix domain socket connection using the sendmsg() and recvmsg() system. Unlike named pipes which allow only unidirectional data flow, sockets are fully duplex-capable . A socket is marked with an **s** as the first letter of the mode string, e.g. srwxrwxrwx /tmp/.X11-unix/X0 Device file Main article: Device file In Unix, almost all things are handled as files and have a location in the file system; even hardware devices like hard drives. The great exception for devices and the files that represent them are network devices that do not turn up in the file system but are handled separately. Device files are used to apply access rights and to direct operations on the files to the appropriate device drivers . SUMMARY : \u8fd9\u662fUnix\u7684everything is a file \u54f2\u5b66\uff1b Unix makes a distinction between character devices and block devices . The distinction is roughly as follows: character devices provide only a serial stream of input or accept a serial stream of output; block devices are randomly accessible; although, for example, disk partitions may have both character devices that provide un-buffered random access to blocks on the partition and block devices that provide buffered random access to blocks on the partition. A character device is marked with a **c** as the first letter of the mode string. Likewise, a block device is marked with a **b** , e.g. crw------- ... /dev/null brw-rw---- ... /dev/sda Door Main article: Doors (computing) A door is a special file for inter-process communication between a client and server, currently implemented only in Solaris . A door is marked with a **D** (upper case) as the first letter of the mode string, e.g. Dr--r--r-- ... name_service_door","title":"File-type"},{"location":"Programming/IO/File-IO/File-system/File-type/#unix#file#types","text":"For normal files in the file system, Unix does not impose or provide any internal file structure . This implies that from the point of view of the operating system , there is only one file type. The structure and interpretation thereof is entirely dependent on how the file is interpreted by software. SUMMARY : \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u6240\u63cf\u8ff0\u7684internal file structure\u6240\u6307\u7684\u662f\u6587\u4ef6\u5728disk\u4e2d\u5b58\u50a8\u7684\u7ed3\u6784\u8fd8\u662f\u5728\u5f53\u5b83\u4eec\u8bfb\u5165\u5230\u5185\u5b58\u4e2d\u7684\u7ed3\u6784\u5462\uff1f\u663e\u7136\u6587\u4ef6\u5728disk\u4e2d\u5b58\u50a8\u7684\u7ed3\u6784\u662f\u9759\u6001\u7ed3\u6784\uff0c\u800c\u5f53\u8fdb\u7a0b\u8bfb\u5165\u6587\u4ef6\u5230\u5185\u5b58\u4e2d\uff0c\u5219\u6b64\u65f6\u5c31\u9700\u8981\u4f7f\u7528runtime structure\u4e86\uff1b\u5173\u4e8e\u6587\u4ef6\u7684runtime structure\uff0c\u5728\u300aAPUE-3.10-File-Sharing\u300b\u4e2d\u8fdb\u884c\u4e86\u63cf\u8ff0\uff1b\u5176\u4e2d\u6240\u6d89\u53ca\u7684\u76f8\u5173\u6982\u5ff5\uff0c\u5728Wikipedia\u4e2d\u90fd\u6709\u8bf4\u660e\uff1b Unix does however have some special files. These special files can be identified by the ls -l command which displays the type of the file in the first alphabetic letter of the file system permissions field. A normal (regular) file is indicated by a hyphen-minus ' - '.","title":"Unix file types"},{"location":"Programming/IO/File-IO/File-system/File-type/#examples#of#implementations","text":"Different OS-specific implementations allow more types than what POSIX requires (e.g. Solaris doors). The GNU coreutils version of ls uses a call to filemode() , a glibc function (exposed in the gnulib library[ 3] ) to get the mode string . FreeBSD uses a simpler approach[ 4] but allows a smaller number of file types .","title":"Examples of implementations"},{"location":"Programming/IO/File-IO/File-system/File-type/#regular#file","text":"Main article: Computer file Files are also called \"regular files\" to distinguish them from \"special files\". They show up in ls -l without a specific character in the mode field: $ ls -l /etc/passwd -rw-r--r-- ... /etc/passwd","title":"Regular file"},{"location":"Programming/IO/File-IO/File-system/File-type/#directory","text":"Main article: Directory (computing) The most common special file is the directory. The layout of a directory file is defined by the filesystem used. As several filesystems , both native and non-native, are available under Unix, there is not one directory file layout. A directory is marked with a d as the first letter in the mode field in the output of ls -dl or stat , e.g. $ ls -dl / drwxr-xr-x 26 root root 4096 Sep 22 09 :29 / $ stat / File: \"/\" Size: 4096 Blocks: 8 IO Block: 4096 directory Device: 802h/2050d Inode: 128 Links: 26 Access: ( 0755 /drwxr-xr-x ) Uid: ( 0 / root ) Gid: ( 0 / root ) ...","title":"Directory"},{"location":"Programming/IO/File-IO/File-system/File-type/#symbolic#link","text":"Main article: Symbolic link A symbolic link is a reference to another file. This special file is stored as a textual representation of the referenced file's path (which means the destination may be a relative path, or may not exist at all). A symbolic link is marked with an **l** (lower case L ) as the first letter of the mode string, e.g. lrwxrwxrwx ... termcap -> /usr/share/misc/termcap lrwxrwxrwx ... S03xinetd -> ../init.d/xinetd","title":"Symbolic link"},{"location":"Programming/IO/File-IO/File-system/File-type/#named#pipe","text":"Main article: Named pipe One of the strengths of Unix has always been inter-process communication . Among the facilities provided by the OS are pipes . Pipes connect the output of one process to the input of another. This is fine if both processes exist in the same parent process space , started by the same user. There are, however, circumstances where the communicating processes must use named pipes. One such circumstance occurs when the processes must be executed under different user names and permissions. Named pipes are special files that can exist anywhere in the file system. Named pipe special files are created with the command mkfifo as in mkfifo mypipe . A named pipe is marked with a **p** as the first letter of the mode string, e.g. prw-rw---- ... mypipe","title":"Named pipe"},{"location":"Programming/IO/File-IO/File-system/File-type/#socket","text":"Main article: Unix domain socket A socket is a special file used for inter-process communication . These enable communication between two processes. In addition to sending data, processes can send file descriptors across a Unix domain socket connection using the sendmsg() and recvmsg() system. Unlike named pipes which allow only unidirectional data flow, sockets are fully duplex-capable . A socket is marked with an **s** as the first letter of the mode string, e.g. srwxrwxrwx /tmp/.X11-unix/X0","title":"Socket"},{"location":"Programming/IO/File-IO/File-system/File-type/#device#file","text":"Main article: Device file In Unix, almost all things are handled as files and have a location in the file system; even hardware devices like hard drives. The great exception for devices and the files that represent them are network devices that do not turn up in the file system but are handled separately. Device files are used to apply access rights and to direct operations on the files to the appropriate device drivers . SUMMARY : \u8fd9\u662fUnix\u7684everything is a file \u54f2\u5b66\uff1b Unix makes a distinction between character devices and block devices . The distinction is roughly as follows: character devices provide only a serial stream of input or accept a serial stream of output; block devices are randomly accessible; although, for example, disk partitions may have both character devices that provide un-buffered random access to blocks on the partition and block devices that provide buffered random access to blocks on the partition. A character device is marked with a **c** as the first letter of the mode string. Likewise, a block device is marked with a **b** , e.g. crw------- ... /dev/null brw-rw---- ... /dev/sda","title":"Device file"},{"location":"Programming/IO/File-IO/File-system/File-type/#door","text":"Main article: Doors (computing) A door is a special file for inter-process communication between a client and server, currently implemented only in Solaris . A door is marked with a **D** (upper case) as the first letter of the mode string, e.g. Dr--r--r-- ... name_service_door","title":"Door"},{"location":"Programming/IO/File-IO/File-system/Inode/","text":"Inode \u7ef4\u57fa\u767e\u79d1 inode The inode (index node) is a data structure in a Unix-style file system that describes a file-system object such as a file or a directory . Each inode stores the attributes and disk block location (s) of the object's data.[ 1] File-system object attributes may include metadata (times of last change,[ 2] access, modification), as well as owner and permission data.[ 3] NOTE: \u6839\u636e3.10 File Sharing\u4e2d\u7684\u63cf\u8ff0\uff1aThis information is read from disk when the file is opened, so that all the pertinent\uff08\u76f8\u5173\u7684\uff09 information about the file is readily available. Directories are lists of names assigned to inodes. A directory contains an entry for itself, its parent, and each of its children. Details A file system relies on data structures about the files, beside the file content. The former are called metadata \u2014data that describes data. Each file is associated with an inode , which is identified by an integer number , often referred to as an i-number or inode number . Inodes store information about files and directories (folders), such as file ownership , access mode (read, write, execute permissions), and file type . On many types of file system implementations, the maximum number of inodes is fixed at file system creation, limiting the maximum number of files the file system can hold. A typical allocation heuristic for inodes in a file system is one percent of total size. The inode number indexes a table of inodes in a known location on the device. From the inode number, the kernel's file system driver can access the inode contents, including the location of the file - thus allowing access to the file. A file's inode number can be found using the ls -i command. The ls -i command prints the i-node number in the first column of the report. Some Unix-style file systems such as ReiserFS omit an inode table, but must store equivalent data in order to provide equivalent capabilities. The data may be called stat data , in reference to the stat system call that provides the data to programs. File names and directory implications: Inodes do not contain its hardlink names, only other file metadata. Unix directories are lists of association structures, each of which contains one filename and one inode number . The file system driver must search a directory looking for a particular filename and then convert the filename to the correct corresponding inode number. The operating system kernel's in-memory representation of this data is called struct inode in Linux . Systems derived from BSD use the term vnode , with the v of vnode referring to the kernel's virtual file system layer. INODE(7)","title":"Inode"},{"location":"Programming/IO/File-IO/File-system/Inode/#inode","text":"","title":"Inode"},{"location":"Programming/IO/File-IO/File-system/Inode/#inode_1","text":"The inode (index node) is a data structure in a Unix-style file system that describes a file-system object such as a file or a directory . Each inode stores the attributes and disk block location (s) of the object's data.[ 1] File-system object attributes may include metadata (times of last change,[ 2] access, modification), as well as owner and permission data.[ 3] NOTE: \u6839\u636e3.10 File Sharing\u4e2d\u7684\u63cf\u8ff0\uff1aThis information is read from disk when the file is opened, so that all the pertinent\uff08\u76f8\u5173\u7684\uff09 information about the file is readily available. Directories are lists of names assigned to inodes. A directory contains an entry for itself, its parent, and each of its children.","title":"\u7ef4\u57fa\u767e\u79d1inode"},{"location":"Programming/IO/File-IO/File-system/Inode/#details","text":"A file system relies on data structures about the files, beside the file content. The former are called metadata \u2014data that describes data. Each file is associated with an inode , which is identified by an integer number , often referred to as an i-number or inode number . Inodes store information about files and directories (folders), such as file ownership , access mode (read, write, execute permissions), and file type . On many types of file system implementations, the maximum number of inodes is fixed at file system creation, limiting the maximum number of files the file system can hold. A typical allocation heuristic for inodes in a file system is one percent of total size. The inode number indexes a table of inodes in a known location on the device. From the inode number, the kernel's file system driver can access the inode contents, including the location of the file - thus allowing access to the file. A file's inode number can be found using the ls -i command. The ls -i command prints the i-node number in the first column of the report. Some Unix-style file systems such as ReiserFS omit an inode table, but must store equivalent data in order to provide equivalent capabilities. The data may be called stat data , in reference to the stat system call that provides the data to programs. File names and directory implications: Inodes do not contain its hardlink names, only other file metadata. Unix directories are lists of association structures, each of which contains one filename and one inode number . The file system driver must search a directory looking for a particular filename and then convert the filename to the correct corresponding inode number. The operating system kernel's in-memory representation of this data is called struct inode in Linux . Systems derived from BSD use the term vnode , with the v of vnode referring to the kernel's virtual file system layer.","title":"Details"},{"location":"Programming/IO/File-IO/File-system/Inode/#inode7","text":"","title":"INODE(7)"},{"location":"Programming/IO/File-IO/File-system/Unix-filesystem/","text":"Unix-filesystem","title":"Unix-filesystem"},{"location":"Programming/IO/File-IO/File-system/Unix-filesystem/#unix-filesystem","text":"","title":"Unix-filesystem"},{"location":"Programming/IO/File-IO/File-system/man-2-stat/","text":"STAT(2)","title":"man-2-stat"},{"location":"Programming/IO/File-IO/File-system/man-2-stat/#stat2","text":"","title":"STAT(2)"},{"location":"Programming/IO/File-IO/File-system/man-7-file-hierarchy/","text":"FILE-HIERARCHY(7)","title":"man-7-file-hierarchy"},{"location":"Programming/IO/File-IO/File-system/man-7-file-hierarchy/#file-hierarchy7","text":"","title":"FILE-HIERARCHY(7)"},{"location":"Programming/IO/File-IO/File-system/Tools/","text":"File system command \u4e0b\u9762\u662f\u7ef4\u57fa\u767e\u79d1\u603b\u7ed3\u7684 Unix command-line interface programs and shell builtins \u4e2d**File system** commands\uff08\u94fe\u63a5: https://en.wikipedia.org/wiki/Df_(Unix ) \uff09: command \u7b80\u4ecb cat chmod chown chgrp cksum cmp cp dd du df file fuser ln ls mkdir mv pax pwd rm rmdir split tee touch type umask du du(1) - Linux man page Summarize disk usage of each FILE, recursively for directories. NOTE: \u5bf9\u8c61\u662ffile Example: \u67e5\u770b\u6587\u4ef6\u5939\u5927\u5c0f-\u5e76\u6309\u5927\u5c0f\u8fdb\u884c\u6392\u5e8f cnblogs du-\u67e5\u770b\u6587\u4ef6\u5939\u5927\u5c0f-\u5e76\u6309\u5927\u5c0f\u8fdb\u884c\u6392\u5e8f : * \u53ef\u4ee5\u5c06\u5f53\u524d\u76ee\u5f55\u4e0b\u6240\u6709\u6587\u4ef6\u7684\u5927\u5c0f\u7ed9\u5217\u51fa\u6765\u3002\u90a3\u8981\u5c06\u8fd9\u4e9b\u5217\u51fa\u6765\u7684\u6587\u4ef6\u6309\u7167\u4ece\u5927\u5230\u5c0f\u7684\u65b9\u5f0f\u6392\u5e8f\u5462\uff1f jack@jiaobuchong:~$ du -sh * | sort -nr 833M installed-software 452K Documents 284K learngit 170M Desktop 161M Downloads 112K session NOTE: \u53ef\u4ee5\u770b\u51fa\uff0c\u4e0a\u8ff0\u6392\u5e8f\u662f\u9519\u8bef\u7684\uff0c\u56e0\u4e3a\u5b83\u6ca1\u6709\u8003\u8651 \u5355\u4f4d \u627esort \u6765\u5e2e\u4e2a\u5fd9\u5c31\u53ef\u4ee5\u4e86\u3002\u5475\u5475\uff01\u8fd9\u4e2a\u6392\u5e8f\u4e0d\u6b63\u5e38\u54e6\uff0c\u90fd\u662f\u56e0\u4e3a -h \u53c2\u6570\u7684\u539f\u56e0: jack@jiaobuchong:~$ du -s * | sort -nr 852756 installed-software 173868 Desktop 164768 Downloads 4724 Pictures 3236 program_pratice NOTE: \u6392\u5e8f\u652f\u6301\uff0c\u76f8\u5f53\u4e8e\u7edf\u4e00\u4e86\u91cf\u7eb2 du -s * | sort -nr | head \u9009\u51fa\u6392\u5728\u524d\u9762\u768410\u4e2a\uff0c du -s * | sort -nr | tail \u9009\u51fa\u6392\u5728\u540e\u9762\u768410\u4e2a\u3002 Example: Finding largest file cyberciti Finding largest file recursively on Linux bash shell using find : One can only list files and skip the directories with the find command instead of using the du command, sort command and NA command combination: $ sudo find / -type f -printf \"%s\\t%p\\n\" | sort -n | tail -1 $ find $HOME -type f -printf '%s %p\\n' | sort -nr | head -10 How do I get the size of a directory on the command line? A1 du -sh file_path df df(1) - Linux man page df - report file system disk space usage NOTE: \u5bf9\u8c61\u662fdisk","title":"Introduction"},{"location":"Programming/IO/File-IO/File-system/Tools/#file#system#command","text":"\u4e0b\u9762\u662f\u7ef4\u57fa\u767e\u79d1\u603b\u7ed3\u7684 Unix command-line interface programs and shell builtins \u4e2d**File system** commands\uff08\u94fe\u63a5: https://en.wikipedia.org/wiki/Df_(Unix ) \uff09: command \u7b80\u4ecb cat chmod chown chgrp cksum cmp cp dd du df file fuser ln ls mkdir mv pax pwd rm rmdir split tee touch type umask","title":"File system command"},{"location":"Programming/IO/File-IO/File-system/Tools/#du","text":"","title":"du"},{"location":"Programming/IO/File-IO/File-system/Tools/#du1#-#linux#man#page","text":"Summarize disk usage of each FILE, recursively for directories. NOTE: \u5bf9\u8c61\u662ffile","title":"du(1) - Linux man page"},{"location":"Programming/IO/File-IO/File-system/Tools/#example#-","text":"cnblogs du-\u67e5\u770b\u6587\u4ef6\u5939\u5927\u5c0f-\u5e76\u6309\u5927\u5c0f\u8fdb\u884c\u6392\u5e8f : * \u53ef\u4ee5\u5c06\u5f53\u524d\u76ee\u5f55\u4e0b\u6240\u6709\u6587\u4ef6\u7684\u5927\u5c0f\u7ed9\u5217\u51fa\u6765\u3002\u90a3\u8981\u5c06\u8fd9\u4e9b\u5217\u51fa\u6765\u7684\u6587\u4ef6\u6309\u7167\u4ece\u5927\u5230\u5c0f\u7684\u65b9\u5f0f\u6392\u5e8f\u5462\uff1f jack@jiaobuchong:~$ du -sh * | sort -nr 833M installed-software 452K Documents 284K learngit 170M Desktop 161M Downloads 112K session NOTE: \u53ef\u4ee5\u770b\u51fa\uff0c\u4e0a\u8ff0\u6392\u5e8f\u662f\u9519\u8bef\u7684\uff0c\u56e0\u4e3a\u5b83\u6ca1\u6709\u8003\u8651 \u5355\u4f4d \u627esort \u6765\u5e2e\u4e2a\u5fd9\u5c31\u53ef\u4ee5\u4e86\u3002\u5475\u5475\uff01\u8fd9\u4e2a\u6392\u5e8f\u4e0d\u6b63\u5e38\u54e6\uff0c\u90fd\u662f\u56e0\u4e3a -h \u53c2\u6570\u7684\u539f\u56e0: jack@jiaobuchong:~$ du -s * | sort -nr 852756 installed-software 173868 Desktop 164768 Downloads 4724 Pictures 3236 program_pratice NOTE: \u6392\u5e8f\u652f\u6301\uff0c\u76f8\u5f53\u4e8e\u7edf\u4e00\u4e86\u91cf\u7eb2 du -s * | sort -nr | head \u9009\u51fa\u6392\u5728\u524d\u9762\u768410\u4e2a\uff0c du -s * | sort -nr | tail \u9009\u51fa\u6392\u5728\u540e\u9762\u768410\u4e2a\u3002","title":"Example: \u67e5\u770b\u6587\u4ef6\u5939\u5927\u5c0f-\u5e76\u6309\u5927\u5c0f\u8fdb\u884c\u6392\u5e8f"},{"location":"Programming/IO/File-IO/File-system/Tools/#example#finding#largest#file","text":"cyberciti Finding largest file recursively on Linux bash shell using find : One can only list files and skip the directories with the find command instead of using the du command, sort command and NA command combination: $ sudo find / -type f -printf \"%s\\t%p\\n\" | sort -n | tail -1 $ find $HOME -type f -printf '%s %p\\n' | sort -nr | head -10","title":"Example: Finding largest file"},{"location":"Programming/IO/File-IO/File-system/Tools/#how#do#i#get#the#size#of#a#directory#on#the#command#line","text":"A1 du -sh file_path","title":"How do I get the size of a directory on the command line?"},{"location":"Programming/IO/File-IO/File-system/Tools/#df","text":"","title":"df"},{"location":"Programming/IO/File-IO/File-system/Tools/#df1#-#linux#man#page","text":"df - report file system disk space usage NOTE: \u5bf9\u8c61\u662fdisk","title":"df(1) - Linux man page"},{"location":"Programming/IO/File-IO/Interface/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bbaOS\u63d0\u4f9b\u7684\u5404\u79cdfile IO\u7684\u63a5\u53e3\u3002","title":"Introduction"},{"location":"Programming/IO/File-IO/Interface/#_1","text":"\u672c\u7ae0\u8ba8\u8bbaOS\u63d0\u4f9b\u7684\u5404\u79cdfile IO\u7684\u63a5\u53e3\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/IO/File-IO/Interface/Fcntl/","text":"FCNTL(2)","title":"Fcntl"},{"location":"Programming/IO/File-IO/Interface/Fcntl/#fcntl2","text":"","title":"FCNTL(2)"},{"location":"Programming/IO/File-IO/Interface/Open/","text":"OPEN(2)","title":"Open"},{"location":"Programming/IO/File-IO/Interface/Open/#open2","text":"","title":"OPEN(2)"},{"location":"Programming/IO/File-IO/Interface/Read/","text":"READ(2)","title":"Read"},{"location":"Programming/IO/File-IO/Interface/Read/#read2","text":"","title":"READ(2)"},{"location":"Programming/IO/File-IO/Interface/Lock/File-Locking%28Advisory-Mandatory-Lock-Examples%29/","text":"2 Types of Linux File Locking (Advisory, Mandatory Lock Examples) File locking is a mechanism which allows only one process to access a file at any specific time. By using file locking mechanism, many processes can read/write a single file in a safer way. In this article we\u2019ll explore the different types of Linux file locking and understand their differences using an example program. We will take the following example to understand why file locking is required. Process \u201cA\u201d opens and reads a file which contains account related information. Process \u201cB\u201d also opens the file and reads the information in it. Now Process \u201cA\u201d changes the account balance of a record in its copy, and writes it back to the file. Process \u201cB\u201d which has no way of knowing that the file is changed since its last read, has the stale original value. It then changes the account balance of the same record, and writes back into the file. Now the file will have only the changes done by process \u201cB\u201d. To avoid such issues locking is used to ensure \u201cserialization\u201d. The following are the two types of Linux file locking: Advisory locking Mandatory locking 1. Advisory Locking Advisory locking requires cooperation from the participating processes. Suppose process \u201cA\u201d acquires an WRITE lock, and it started writing into the file, and process \u201cB\u201d, without trying to acquire a lock, it can open the file and write into it. Here process \u201cB\u201d is the non-cooperating process. If process \u201cB\u201d, tries to acquire a lock, then it means this process is co-operating to ensure the \u201cserialization\u201d. Advisory locking will work, only if the participating process are cooperative. Advisory locking sometimes also called as \u201cunenforced\u201d locking. 2. Mandatory Locking Mandatory locking doesn\u2019t require cooperation from the participating processes. Mandatory locking causes the kernel to check every open, read, and write to verify that the calling process isn\u2019t violating a lock on the given file. More information about mandatory locking can be found at kernal.org To enable mandatory locking in Linux, you need to enable it on a file system level, and also on the individual files. The steps to be followed are: Mount the file system with \u201c-o mand\u201d option For the lock_file, turn on the set-group-ID bit and turn off the group-execute bit, to enable mandatory locking on that particular file. (This way has been chosen because when you turn off the group-execute bit, set-group-ID has no real meaning to it ) Linux File Locking Examples To understand how this works, crate the following file_lock.c program: #include <stdio.h> #include <fcntl.h> int main ( int argc , char ** argv ) { if ( argc > 1 ) { int fd = open ( argv [ 1 ], O_WRONLY ); if ( fd == -1 ) { printf ( \"Unable to open the file \\n \" ); exit ( 1 ); } static struct flock lock ; lock . l_type = F_WRLCK ; lock . l_start = 0 ; lock . l_whence = SEEK_SET ; lock . l_len = 0 ; lock . l_pid = getpid (); int ret = fcntl ( fd , F_SETLKW , & lock ); printf ( \"Return value of fcntl:%d \\n \" , ret ); if ( ret == 0 ) { while ( 1 ) { scanf ( \"%c\" , NULL ); } } } } Compile the program using gcc. # cc -o file_lock file_lock.c Remount the root filesystem with \u201cmand\u201d option using the mount command as shown below. This will enable mandatory locking at the file system level. Note: You need to be root to execute the below command. # mount -oremount,mand / Create 2 files named \u201cadvisory.txt\u201d and \u201cmandatory.txt\u201d in the directory where the executable (file_lock) is located. Enable the Set-Group-ID and disable the Group-Execute-Bit for \u201cmandatory.txt\u201d as follows # touch advisory.txt # touch mandatory.txt # chmod g+s,g-x mandatory.txt Test Advisory Locking: Now execute the sample program with \u2018advisory.txt\u2019 as the argument. # ./file_lock advisory.txt The program will wait to get input from the user. From another terminal, or console, try the following # ls >>advisory.txt In the above example, ls command will write its output to advisory.txt file. Even though we acquire a write lock, still some other process ( Non Cooperating ) can write into the file. This is termed as \u201cAdvisory\u201d locking. Test Mandatory Locking: Once again execute the sample program with \u2018mandatory.txt\u2019 as the argument. # ./file_lock mandatory.txt From another terminal or console, try the following: # ls >>mandatory.txt In the above example, ls command will wait for the lock to be removed before writing its output to the mandatory.txt file. It is still a non-cooperative process, but locking is achieved using mandatory locking.","title":"File-Locking(Advisory-Mandatory-Lock-Examples)"},{"location":"Programming/IO/File-IO/Interface/Lock/File-Locking%28Advisory-Mandatory-Lock-Examples%29/#2#types#of#linux#file#locking#advisory#mandatory#lock#examples","text":"File locking is a mechanism which allows only one process to access a file at any specific time. By using file locking mechanism, many processes can read/write a single file in a safer way. In this article we\u2019ll explore the different types of Linux file locking and understand their differences using an example program. We will take the following example to understand why file locking is required. Process \u201cA\u201d opens and reads a file which contains account related information. Process \u201cB\u201d also opens the file and reads the information in it. Now Process \u201cA\u201d changes the account balance of a record in its copy, and writes it back to the file. Process \u201cB\u201d which has no way of knowing that the file is changed since its last read, has the stale original value. It then changes the account balance of the same record, and writes back into the file. Now the file will have only the changes done by process \u201cB\u201d. To avoid such issues locking is used to ensure \u201cserialization\u201d. The following are the two types of Linux file locking: Advisory locking Mandatory locking","title":"2 Types of Linux File Locking (Advisory, Mandatory Lock Examples)"},{"location":"Programming/IO/File-IO/Interface/Lock/File-Locking%28Advisory-Mandatory-Lock-Examples%29/#1#advisory#locking","text":"Advisory locking requires cooperation from the participating processes. Suppose process \u201cA\u201d acquires an WRITE lock, and it started writing into the file, and process \u201cB\u201d, without trying to acquire a lock, it can open the file and write into it. Here process \u201cB\u201d is the non-cooperating process. If process \u201cB\u201d, tries to acquire a lock, then it means this process is co-operating to ensure the \u201cserialization\u201d. Advisory locking will work, only if the participating process are cooperative. Advisory locking sometimes also called as \u201cunenforced\u201d locking.","title":"1. Advisory Locking"},{"location":"Programming/IO/File-IO/Interface/Lock/File-Locking%28Advisory-Mandatory-Lock-Examples%29/#2#mandatory#locking","text":"Mandatory locking doesn\u2019t require cooperation from the participating processes. Mandatory locking causes the kernel to check every open, read, and write to verify that the calling process isn\u2019t violating a lock on the given file. More information about mandatory locking can be found at kernal.org To enable mandatory locking in Linux, you need to enable it on a file system level, and also on the individual files. The steps to be followed are: Mount the file system with \u201c-o mand\u201d option For the lock_file, turn on the set-group-ID bit and turn off the group-execute bit, to enable mandatory locking on that particular file. (This way has been chosen because when you turn off the group-execute bit, set-group-ID has no real meaning to it )","title":"2. Mandatory Locking"},{"location":"Programming/IO/File-IO/Interface/Lock/File-Locking%28Advisory-Mandatory-Lock-Examples%29/#linux#file#locking#examples","text":"To understand how this works, crate the following file_lock.c program: #include <stdio.h> #include <fcntl.h> int main ( int argc , char ** argv ) { if ( argc > 1 ) { int fd = open ( argv [ 1 ], O_WRONLY ); if ( fd == -1 ) { printf ( \"Unable to open the file \\n \" ); exit ( 1 ); } static struct flock lock ; lock . l_type = F_WRLCK ; lock . l_start = 0 ; lock . l_whence = SEEK_SET ; lock . l_len = 0 ; lock . l_pid = getpid (); int ret = fcntl ( fd , F_SETLKW , & lock ); printf ( \"Return value of fcntl:%d \\n \" , ret ); if ( ret == 0 ) { while ( 1 ) { scanf ( \"%c\" , NULL ); } } } } Compile the program using gcc. # cc -o file_lock file_lock.c Remount the root filesystem with \u201cmand\u201d option using the mount command as shown below. This will enable mandatory locking at the file system level. Note: You need to be root to execute the below command. # mount -oremount,mand / Create 2 files named \u201cadvisory.txt\u201d and \u201cmandatory.txt\u201d in the directory where the executable (file_lock) is located. Enable the Set-Group-ID and disable the Group-Execute-Bit for \u201cmandatory.txt\u201d as follows # touch advisory.txt # touch mandatory.txt # chmod g+s,g-x mandatory.txt Test Advisory Locking: Now execute the sample program with \u2018advisory.txt\u2019 as the argument. # ./file_lock advisory.txt The program will wait to get input from the user. From another terminal, or console, try the following # ls >>advisory.txt In the above example, ls command will write its output to advisory.txt file. Even though we acquire a write lock, still some other process ( Non Cooperating ) can write into the file. This is termed as \u201cAdvisory\u201d locking. Test Mandatory Locking: Once again execute the sample program with \u2018mandatory.txt\u2019 as the argument. # ./file_lock mandatory.txt From another terminal or console, try the following: # ls >>mandatory.txt In the above example, ls command will wait for the lock to be removed before writing its output to the mandatory.txt file. It is still a non-cooperative process, but locking is achieved using mandatory locking.","title":"Linux File Locking Examples"},{"location":"Programming/IO/File-IO/Interface/Lock/File-locking/","text":"File locking","title":"File-locking"},{"location":"Programming/IO/File-IO/Interface/Lock/File-locking/#file#locking","text":"","title":"File locking"},{"location":"Programming/IO/File-IO/Interface/Lock/man-2-flock/","text":"FLOCK(2) NAME flock - apply or remove an advisory lock on an open file SYNOPSIS #include <sys/file.h> int flock ( int fd , int operation ); DESCRIPTION Apply or remove an advisory lock on the open file specified by fd . The argument operation is one of the following: LOCK_SH Place a shared lock . More than one process may hold a shared lock for a given file at a given time. LOCK_EX Place an exclusive lock . Only one process may hold an exclusive lock for a given file at a given time. LOCK_UN Remove an existing lock held by this process. A call to flock() may block if an incompatible lock is held by another process. To make a nonblocking request , include LOCK_NB (by ORing) with any of the above operations. A single file may not simultaneously have both shared and exclusive locks. Locks created by flock() are associated with an open file description (see open(2) ). This means that duplicate file descriptors (created by, for example, fork(2) or dup(2) ) refer to the same lock , and this lock may be modified or released using any of these file descriptors . Furthermore, the lock is released either by an explicit LOCK_UN operation on any of these duplicate file descriptors, or when all such file descriptors have been closed. If a process uses open(2) (or similar) to obtain more than one file descriptor for the same file, these file descriptors are treated independently by flock(). An attempt to lock the file using one of these file descriptors may be denied by a lock that the calling process has already placed via another file descriptor. Locks created by flock() are preserved across an execve(2) . A shared or exclusive lock can be placed on a file regardless of the mode in which the file was opened. RETURN VALUE On success, zero is returned. On error, -1 is returned, and errno is set appropriately. ERRORS EBADF fd is not an open file descriptor. EINTR While waiting to acquire a lock, the call was interrupted by delivery of a signal caught by a handler; see signal(7) . EINVAL operation is invalid. ENOLCK The kernel ran out of memory for allocating lock records. EWOULDBLOCK The file is locked and the LOCK_NB flag was selected. NOTES Since kernel 2.0, flock() is implemented as a system call in its own right rather than being emulated in the GNU C library as a call to fcntl(2) . With this implementation, there is no interaction between the types of lock placed by flock() and fcntl(2) , and flock() does not detect deadlock . (Note, however, that on some systems, such as the modern BSDs, flock() and fcntl(2) locks do interact with one another.) flock() places advisory locks only; given suitable permissions on a file, a process is free to ignore the use of flock() and perform I/O on the file. SUMMARY : \u53c2\u89c1 2 Types of Linux File Locking (Advisory, Mandatory Lock Examples) flock() and fcntl(2) locks have different semantics with respect to forked processes and dup(2). On systems that implement flock() using fcntl(2), the semantics of flock() will be different from those described in this manual page. Converting a lock (shared to exclusive, or vice versa) is not guaranteed to be atomic: the existing lock is first removed, and then a new lock is established. Between these two steps, a pending lock request by another process may be granted, with the result that the conversion either blocks, or fails if LOCK_NB was specified. (This is the original BSD behavior, and occurs on many other implementations.)","title":"man-2-flock"},{"location":"Programming/IO/File-IO/Interface/Lock/man-2-flock/#flock2","text":"","title":"FLOCK(2)"},{"location":"Programming/IO/File-IO/Interface/Lock/man-2-flock/#name","text":"flock - apply or remove an advisory lock on an open file","title":"NAME"},{"location":"Programming/IO/File-IO/Interface/Lock/man-2-flock/#synopsis","text":"#include <sys/file.h> int flock ( int fd , int operation );","title":"SYNOPSIS"},{"location":"Programming/IO/File-IO/Interface/Lock/man-2-flock/#description","text":"Apply or remove an advisory lock on the open file specified by fd . The argument operation is one of the following: LOCK_SH Place a shared lock . More than one process may hold a shared lock for a given file at a given time. LOCK_EX Place an exclusive lock . Only one process may hold an exclusive lock for a given file at a given time. LOCK_UN Remove an existing lock held by this process. A call to flock() may block if an incompatible lock is held by another process. To make a nonblocking request , include LOCK_NB (by ORing) with any of the above operations. A single file may not simultaneously have both shared and exclusive locks. Locks created by flock() are associated with an open file description (see open(2) ). This means that duplicate file descriptors (created by, for example, fork(2) or dup(2) ) refer to the same lock , and this lock may be modified or released using any of these file descriptors . Furthermore, the lock is released either by an explicit LOCK_UN operation on any of these duplicate file descriptors, or when all such file descriptors have been closed. If a process uses open(2) (or similar) to obtain more than one file descriptor for the same file, these file descriptors are treated independently by flock(). An attempt to lock the file using one of these file descriptors may be denied by a lock that the calling process has already placed via another file descriptor. Locks created by flock() are preserved across an execve(2) . A shared or exclusive lock can be placed on a file regardless of the mode in which the file was opened.","title":"DESCRIPTION"},{"location":"Programming/IO/File-IO/Interface/Lock/man-2-flock/#return#value","text":"On success, zero is returned. On error, -1 is returned, and errno is set appropriately.","title":"RETURN VALUE"},{"location":"Programming/IO/File-IO/Interface/Lock/man-2-flock/#errors","text":"EBADF fd is not an open file descriptor. EINTR While waiting to acquire a lock, the call was interrupted by delivery of a signal caught by a handler; see signal(7) . EINVAL operation is invalid. ENOLCK The kernel ran out of memory for allocating lock records. EWOULDBLOCK The file is locked and the LOCK_NB flag was selected.","title":"ERRORS"},{"location":"Programming/IO/File-IO/Interface/Lock/man-2-flock/#notes","text":"Since kernel 2.0, flock() is implemented as a system call in its own right rather than being emulated in the GNU C library as a call to fcntl(2) . With this implementation, there is no interaction between the types of lock placed by flock() and fcntl(2) , and flock() does not detect deadlock . (Note, however, that on some systems, such as the modern BSDs, flock() and fcntl(2) locks do interact with one another.) flock() places advisory locks only; given suitable permissions on a file, a process is free to ignore the use of flock() and perform I/O on the file. SUMMARY : \u53c2\u89c1 2 Types of Linux File Locking (Advisory, Mandatory Lock Examples) flock() and fcntl(2) locks have different semantics with respect to forked processes and dup(2). On systems that implement flock() using fcntl(2), the semantics of flock() will be different from those described in this manual page. Converting a lock (shared to exclusive, or vice versa) is not guaranteed to be atomic: the existing lock is first removed, and then a new lock is established. Between these two steps, a pending lock request by another process may be granted, with the result that the conversion either blocks, or fails if LOCK_NB was specified. (This is the original BSD behavior, and occurs on many other implementations.)","title":"NOTES"},{"location":"Programming/IO/File-IO/Interface/Notify/Fanotify/man-7-fanotify/","text":"FANOTIFY(7)","title":"man-7-fanotify"},{"location":"Programming/IO/File-IO/Interface/Notify/Fanotify/man-7-fanotify/#fanotify7","text":"","title":"FANOTIFY(7)"},{"location":"Programming/IO/File-IO/Interface/Notify/Inotify/man-7-inotify/","text":"INOTIFY(7)","title":"man-7-inotify"},{"location":"Programming/IO/File-IO/Interface/Notify/Inotify/man-7-inotify/#inotify7","text":"","title":"INOTIFY(7)"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/","text":"Notify via file descriptor Linux\u4e2d\u9075\u5faaeverything is a file\uff0c\u56e0\u6b64\uff0c\u5f88\u591aevent\u90fd\u53ef\u4ee5\u4ee5 fd (file descriptor)\u7684\u65b9\u5f0f\u6765\u8fdb\u884c\u901a\u77e5\u3002 TIMERFD_CREATE(2) man: http://man7.org/linux/man-pages/man2/timerfd_create.2.html SIGNALFD(2) man: http://man7.org/linux/man-pages/man2/signalfd.2.html EVENTFD(2) man: http://man7.org/linux/man-pages/man2/eventfd.2.html","title":"Introduction"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/#notify#via#file#descriptor","text":"Linux\u4e2d\u9075\u5faaeverything is a file\uff0c\u56e0\u6b64\uff0c\u5f88\u591aevent\u90fd\u53ef\u4ee5\u4ee5 fd (file descriptor)\u7684\u65b9\u5f0f\u6765\u8fdb\u884c\u901a\u77e5\u3002","title":"Notify via file descriptor"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/#timerfd_create2","text":"man: http://man7.org/linux/man-pages/man2/timerfd_create.2.html","title":"TIMERFD_CREATE(2)"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/#signalfd2","text":"man: http://man7.org/linux/man-pages/man2/signalfd.2.html","title":"SIGNALFD(2)"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/#eventfd2","text":"man: http://man7.org/linux/man-pages/man2/eventfd.2.html","title":"EVENTFD(2)"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/","text":"EVENTFD(2) Linux\u4e2d\u9075\u5faaeverything is a file\uff0c\u56e0\u6b64\uff0c\u5f88\u591aevent\u90fd\u53ef\u4ee5\u4ee5 fd (file descriptor)\u7684\u65b9\u5f0f\u6765\u8fdb\u884c\u901a\u77e5\u3002 \u5728\u9605\u8bfb folly-io-async: An object-oriented wrapper around libevent \u65f6\uff0c\u5176\u4e2d\u6709\u5173\u4e8e eventfd \u7684\u4ecb\u7ecd\uff0c\u5f15\u53d1\u4e86\u6211\u5bf9\u5b83\u7684\u5b66\u4e60\u3002 man 2 EVENTFD(2) yangyang Worker Pool With Eventfd #include <sys/eventfd.h> int eventfd(unsigned int initval, int flags); That\u2019s all we need to create one eventfd file, after that, we can perform normal file operations (like read / write , poll and close ) with it. Once some user-space thread write it with value greater than 0 (zero), it will instantly be notified to user-space by kernel. Then, the first thread which read it, will reset it (zero its counter), i.e. consume the event. And all the later read will get Error (Resource Temporarily Unavailable), until it is written again (event triggered). Briefly, it transforms an event to a file descriptor that can be effectively monitored. eventfd VS pipe There\u2019re several notes of which we should take special account: Applications can use an eventfd file descriptor instead of a pipe **in all cases where a pipe is used simply to signal events* . The kernel overhead of an eventfd file descriptor is much lower than that of a pipe, and only one file descriptor is required (versus the two required for a pipe).* As with signal events, eventfd is much more light-weight (thus fast) compared to the pipes, it\u2019s just a counter in kernel after all. A key point about an eventfd file descriptor is that it can be monitored just like any other file descriptor using select (2), poll (2), or epoll (7). This means that an application can simultaneously monitor the readiness of \u201ctraditional\u201d files and the readiness of other kernel mechanisms that support the eventfd interface. You won\u2019t wield the true power of eventfd , unless you monitor them with epoll (especially EPOLLET ). So, let\u2019s get our hands dirty with an simple worker thread pool! Worker Pool Design We adopt Producer/Consumer pattern for our worker thread pool , as it\u2019s the most common style of decoupling, achieving the best scalability. By leveraging the asynchronous notification feature from the eventfd, our inter-thread communication sequence could be described as following: Implementation Our per-thread data structure is fairly simple, only contains 3 fields: thread_id , rank (thread index) and epfd which is the epoll file descriptor created by main function. typedef struct thread_info { pthread_t thread_id ; int rank ; // thread index int epfd ; // epoll file descriptor } thread_info_t ; Consumer thread routine // \u7ebf\u7a0b\u6267\u884c\u51fd\u6570 static void * consumer_routine ( void * data ) { struct thread_info * c = ( struct thread_info * ) data ; struct epoll_event * events ; int epfd = c -> epfd ; int nfds = -1 ; int i = -1 ; int ret = -1 ; uint64_t v ; int num_done = 0 ; events = calloc ( MAX_EVENTS_SIZE , sizeof ( struct epoll_event )); if ( events == NULL ) exit_error ( \"calloc epoll events \\n \" ); for (;;) { nfds = epoll_wait ( epfd , events , MAX_EVENTS_SIZE , 1000 ); for ( i = 0 ; i < nfds ; i ++ ) { if ( events [ i ]. events & EPOLLIN ) { log_debug ( \"[consumer-%d] got event from fd-%d\" , c -> rank , events [ i ]. data . fd ); ret = read ( events [ i ]. data . fd , & v , sizeof ( v )); if ( ret < 0 ) { log_error ( \"[consumer-%d] failed to read eventfd\" , c -> rank ); continue ; } close ( events [ i ]. data . fd ); do_task (); log_debug ( \"[consumer-%d] tasks done: %d\" , c -> rank , ++ num_done ); } } } } As we can see, the worker thread get the notification by simply polling epoll_wait() the epoll-added fd list, and read() the eventfd to consume it, then close() to clean it. And we can do anything sequential within the do_task , although it now does nothing. In short: poll -> read -> close. Producer thread routine static void * producer_routine ( void * data ) { struct thread_info * p = ( struct thread_info * ) data ; struct epoll_event event ; int epfd = p -> epfd ; int efd = -1 ; int ret = -1 ; int interval = 1 ; log_debug ( \"[producer-%d] issues 1 task per %d second\" , p -> rank , interval ); while ( 1 ) { efd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ); // \u975e\u963b\u585eIO if ( efd == -1 ) exit_error ( \"eventfd create: %s\" , strerror ( errno )); event . data . fd = efd ; event . events = EPOLLIN | EPOLLET ; ret = epoll_ctl ( epfd , EPOLL_CTL_ADD , efd , & event ); if ( ret != 0 ) exit_error ( \"epoll_ctl\" ); ret = write ( efd , & ( uint64_t ){ 1 }, sizeof ( uint64_t )); if ( ret != 8 ) log_error ( \"[producer-%d] failed to write eventfd\" , p -> rank ); sleep ( interval ); } } In producer routine, after creating eventfd , we register the event with epoll object by epoll_ctl() . Note that the event is set for write (EPOLLIN) and Edge-Triggered (EPOLLET). For notification, what we need to do is just write 0x1 (any value you want) to eventfd. In short: create -> register -> write. Source code repository : eventfd_examples Try something hard But now, let\u2019s try something hard. We\u2019ll smoke test our worker by generate a heavy instant load, instead of the former regular one. And we tweak the producer/consumer thread to 1, and watching the performance. static void * producer_routine_spike ( void * data ) { struct thread_info * p = ( struct thread_info * ) data ; struct epoll_event event ; int epfd = p -> epfd ; int efd = -1 ; int ret = -1 ; int num_task = 1000000 ; log_debug ( \"[producer-%d] will issue %d tasks\" , p -> rank , num_task ); for ( int i = 0 ; i < num_task ; i ++ ) { efd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ); if ( efd == -1 ) exit_error ( \"eventfd create: %s\" , strerror ( errno )); event . data . fd = efd ; event . events = EPOLLIN | EPOLLET ; ret = epoll_ctl ( epfd , EPOLL_CTL_ADD , efd , & event ); if ( ret != 0 ) exit_error ( \"epoll_ctl\" ); ret = write ( efd , & ( uint64_t ){ 1 }, sizeof ( uint64_t )); if ( ret != 8 ) log_error ( \"[producer-%d] failed to write eventfd\" , p -> rank ); } return ( void * ) 0 ; } Over 1 million? Indeed! By using the ulimit command below, we can increase the open files limit of the current shell, which is usually 1024 by default. Note that you need to be root. ulimit -n 1048576 # 1048576 is the default maximum for open files, as `/proc/sys/fs/nr_open` shows. # To make it larger, you need to tweak kernel settings like this (which is beyond our scope) # sysctl -w fs.nr_open=10485760 With my test VM (S2.Medium4 type on TencentCloud , which has only 2 vCPU and 4G memory, it takes less than 6.5 seconds to deal with 1 million concurrent (almost) events. And we\u2019ve seen the kernel-implemented counters and wait queue are quite efficient. Conclusions Multi-threaded programming model is prevailing(\u6d41\u884c\u7684) now, while the best way of scheduling (event trigger and dispatching method) is still under discussion and sometimes even opinionated(\u81ea\u4ee5\u4e3a\u662f\u7684). In this post, we\u2019ve implemented general-purposed worker thread pool based on an advanced message mechanism, which includes: message notification: asynchronous delivering, extremely low overhead, high performance message dispatching: as a load balancer, highly scalable message buffering: as message queue, with robustness All the above are fulfilled by using basic Linux kernel feature/syscall, like epoll and eventfd . Everyone may refers to this approach when he/she designs a single-process performant (especially IO-bound) background service. To sum up, taking advantage of Linux kernel capability, we are now managed to implement our high-performance message-based worker pool, which is able to deal with large throughput and of high scalability. References eventfd(2) - Linux Man Page eventpoll - Linux Source Code eventfd - Linux Source Code stackoverflow Writing to eventfd from kernel module","title":"Introduction"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#eventfd2","text":"Linux\u4e2d\u9075\u5faaeverything is a file\uff0c\u56e0\u6b64\uff0c\u5f88\u591aevent\u90fd\u53ef\u4ee5\u4ee5 fd (file descriptor)\u7684\u65b9\u5f0f\u6765\u8fdb\u884c\u901a\u77e5\u3002 \u5728\u9605\u8bfb folly-io-async: An object-oriented wrapper around libevent \u65f6\uff0c\u5176\u4e2d\u6709\u5173\u4e8e eventfd \u7684\u4ecb\u7ecd\uff0c\u5f15\u53d1\u4e86\u6211\u5bf9\u5b83\u7684\u5b66\u4e60\u3002","title":"EVENTFD(2)"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#man#2#eventfd2","text":"","title":"man 2 EVENTFD(2)"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#yangyang#worker#pool#with#eventfd","text":"#include <sys/eventfd.h> int eventfd(unsigned int initval, int flags); That\u2019s all we need to create one eventfd file, after that, we can perform normal file operations (like read / write , poll and close ) with it. Once some user-space thread write it with value greater than 0 (zero), it will instantly be notified to user-space by kernel. Then, the first thread which read it, will reset it (zero its counter), i.e. consume the event. And all the later read will get Error (Resource Temporarily Unavailable), until it is written again (event triggered). Briefly, it transforms an event to a file descriptor that can be effectively monitored.","title":"yangyang Worker Pool With Eventfd"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#eventfd#vs#pipe","text":"There\u2019re several notes of which we should take special account: Applications can use an eventfd file descriptor instead of a pipe **in all cases where a pipe is used simply to signal events* . The kernel overhead of an eventfd file descriptor is much lower than that of a pipe, and only one file descriptor is required (versus the two required for a pipe).* As with signal events, eventfd is much more light-weight (thus fast) compared to the pipes, it\u2019s just a counter in kernel after all. A key point about an eventfd file descriptor is that it can be monitored just like any other file descriptor using select (2), poll (2), or epoll (7). This means that an application can simultaneously monitor the readiness of \u201ctraditional\u201d files and the readiness of other kernel mechanisms that support the eventfd interface. You won\u2019t wield the true power of eventfd , unless you monitor them with epoll (especially EPOLLET ). So, let\u2019s get our hands dirty with an simple worker thread pool!","title":"eventfd VS pipe"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#worker#pool#design","text":"We adopt Producer/Consumer pattern for our worker thread pool , as it\u2019s the most common style of decoupling, achieving the best scalability. By leveraging the asynchronous notification feature from the eventfd, our inter-thread communication sequence could be described as following:","title":"Worker Pool Design"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#implementation","text":"Our per-thread data structure is fairly simple, only contains 3 fields: thread_id , rank (thread index) and epfd which is the epoll file descriptor created by main function. typedef struct thread_info { pthread_t thread_id ; int rank ; // thread index int epfd ; // epoll file descriptor } thread_info_t ;","title":"Implementation"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#consumer#thread#routine","text":"// \u7ebf\u7a0b\u6267\u884c\u51fd\u6570 static void * consumer_routine ( void * data ) { struct thread_info * c = ( struct thread_info * ) data ; struct epoll_event * events ; int epfd = c -> epfd ; int nfds = -1 ; int i = -1 ; int ret = -1 ; uint64_t v ; int num_done = 0 ; events = calloc ( MAX_EVENTS_SIZE , sizeof ( struct epoll_event )); if ( events == NULL ) exit_error ( \"calloc epoll events \\n \" ); for (;;) { nfds = epoll_wait ( epfd , events , MAX_EVENTS_SIZE , 1000 ); for ( i = 0 ; i < nfds ; i ++ ) { if ( events [ i ]. events & EPOLLIN ) { log_debug ( \"[consumer-%d] got event from fd-%d\" , c -> rank , events [ i ]. data . fd ); ret = read ( events [ i ]. data . fd , & v , sizeof ( v )); if ( ret < 0 ) { log_error ( \"[consumer-%d] failed to read eventfd\" , c -> rank ); continue ; } close ( events [ i ]. data . fd ); do_task (); log_debug ( \"[consumer-%d] tasks done: %d\" , c -> rank , ++ num_done ); } } } } As we can see, the worker thread get the notification by simply polling epoll_wait() the epoll-added fd list, and read() the eventfd to consume it, then close() to clean it. And we can do anything sequential within the do_task , although it now does nothing. In short: poll -> read -> close.","title":"Consumer thread routine"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#producer#thread#routine","text":"static void * producer_routine ( void * data ) { struct thread_info * p = ( struct thread_info * ) data ; struct epoll_event event ; int epfd = p -> epfd ; int efd = -1 ; int ret = -1 ; int interval = 1 ; log_debug ( \"[producer-%d] issues 1 task per %d second\" , p -> rank , interval ); while ( 1 ) { efd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ); // \u975e\u963b\u585eIO if ( efd == -1 ) exit_error ( \"eventfd create: %s\" , strerror ( errno )); event . data . fd = efd ; event . events = EPOLLIN | EPOLLET ; ret = epoll_ctl ( epfd , EPOLL_CTL_ADD , efd , & event ); if ( ret != 0 ) exit_error ( \"epoll_ctl\" ); ret = write ( efd , & ( uint64_t ){ 1 }, sizeof ( uint64_t )); if ( ret != 8 ) log_error ( \"[producer-%d] failed to write eventfd\" , p -> rank ); sleep ( interval ); } } In producer routine, after creating eventfd , we register the event with epoll object by epoll_ctl() . Note that the event is set for write (EPOLLIN) and Edge-Triggered (EPOLLET). For notification, what we need to do is just write 0x1 (any value you want) to eventfd. In short: create -> register -> write.","title":"Producer thread routine"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#source#code#repository","text":"eventfd_examples","title":"Source code repository:"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#try#something#hard","text":"But now, let\u2019s try something hard. We\u2019ll smoke test our worker by generate a heavy instant load, instead of the former regular one. And we tweak the producer/consumer thread to 1, and watching the performance. static void * producer_routine_spike ( void * data ) { struct thread_info * p = ( struct thread_info * ) data ; struct epoll_event event ; int epfd = p -> epfd ; int efd = -1 ; int ret = -1 ; int num_task = 1000000 ; log_debug ( \"[producer-%d] will issue %d tasks\" , p -> rank , num_task ); for ( int i = 0 ; i < num_task ; i ++ ) { efd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ); if ( efd == -1 ) exit_error ( \"eventfd create: %s\" , strerror ( errno )); event . data . fd = efd ; event . events = EPOLLIN | EPOLLET ; ret = epoll_ctl ( epfd , EPOLL_CTL_ADD , efd , & event ); if ( ret != 0 ) exit_error ( \"epoll_ctl\" ); ret = write ( efd , & ( uint64_t ){ 1 }, sizeof ( uint64_t )); if ( ret != 8 ) log_error ( \"[producer-%d] failed to write eventfd\" , p -> rank ); } return ( void * ) 0 ; } Over 1 million? Indeed! By using the ulimit command below, we can increase the open files limit of the current shell, which is usually 1024 by default. Note that you need to be root. ulimit -n 1048576 # 1048576 is the default maximum for open files, as `/proc/sys/fs/nr_open` shows. # To make it larger, you need to tweak kernel settings like this (which is beyond our scope) # sysctl -w fs.nr_open=10485760 With my test VM (S2.Medium4 type on TencentCloud , which has only 2 vCPU and 4G memory, it takes less than 6.5 seconds to deal with 1 million concurrent (almost) events. And we\u2019ve seen the kernel-implemented counters and wait queue are quite efficient.","title":"Try something hard"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#conclusions","text":"Multi-threaded programming model is prevailing(\u6d41\u884c\u7684) now, while the best way of scheduling (event trigger and dispatching method) is still under discussion and sometimes even opinionated(\u81ea\u4ee5\u4e3a\u662f\u7684). In this post, we\u2019ve implemented general-purposed worker thread pool based on an advanced message mechanism, which includes: message notification: asynchronous delivering, extremely low overhead, high performance message dispatching: as a load balancer, highly scalable message buffering: as message queue, with robustness All the above are fulfilled by using basic Linux kernel feature/syscall, like epoll and eventfd . Everyone may refers to this approach when he/she designs a single-process performant (especially IO-bound) background service. To sum up, taking advantage of Linux kernel capability, we are now managed to implement our high-performance message-based worker pool, which is able to deal with large throughput and of high scalability.","title":"Conclusions"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#references","text":"eventfd(2) - Linux Man Page eventpoll - Linux Source Code eventfd - Linux Source Code","title":"References"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Eventfd/#stackoverflow#writing#to#eventfd#from#kernel#module","text":"","title":"stackoverflow Writing to eventfd from kernel module"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Timefd/","text":"TIMERFD_CREATE(2) man 2 timerfd_create Example source code timefd_examples","title":"Introduction"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Timefd/#timerfd_create2","text":"","title":"TIMERFD_CREATE(2)"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Timefd/#man#2#timerfd_create","text":"","title":"man 2 timerfd_create"},{"location":"Programming/IO/File-IO/Interface/Notify/Notify-via-fd/Timefd/#example#source#code","text":"timefd_examples","title":"Example source code"},{"location":"Programming/IO/IO-model/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u603b\u7ed3Unix-like OS\u4e2d\u7684I/O model\uff0c\u5efa\u7acb\u8d77I/O\u7684big picture\u3002","title":"Introduction"},{"location":"Programming/IO/IO-model/#_1","text":"\u672c\u7ae0\u603b\u7ed3Unix-like OS\u4e2d\u7684I/O model\uff0c\u5efa\u7acb\u8d77I/O\u7684big picture\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/IO/IO-model/Blocking-IO-VS-Nonblocking-IO/","text":"https://stackoverflow.com/questions/14643249/why-having-to-use-non-blocking-fd-in-a-edge-triggered-epoll-function http://man7.org/linux/man-pages/man7/epoll.7.html","title":"Blocking-IO-VS-Nonblocking-IO"},{"location":"Programming/IO/IO-model/Blocking-and-non-blocking-VS-sync-and-async/","text":"Linux sync and async VS blocking and non-blocking \u524d\u9762\u4ecb\u7ecd\u4e86Linux OS\u4e2d\u7684IO model\uff0c\u73b0\u5728\u6709\u5fc5\u8981\u5bf9Linux OS\u4e2d\u7684\u8fd9\u4e9b\u6982\u5ff5\u8fdb\u884c\u603b\u7ed3\u4e86\u3002 Signal \u4fe1\u53f7\u662f\u4e00\u79cd\u8f6f\u4ef6\u4e2d\u65ad\uff0c\u6240\u4ee5\u4e5f\u662f\u4e00\u79cd\u5f02\u6b65\u3002 \u5728APUE\u768410.2 Signal Concepts\u4e2d\u6709\u4e0b\u9762\u8fd9\u6837\u7684\u4e00\u6bb5\u8bdd\uff1a Signals are classic examples of asynchronous events . They occur at what appear to be random times to the process. The process can\u2019t simply test a variable (such as errno) to see whether a signal has occurred; instead, the process has to tell the kernel \u2018\u2018if and when this signal occurs, do the following.\u2019\u2019We can tell the kernel to do one of three things when a signal occurs. We call this the disposition of the signal, or the action associated with a signal. Linux\u7684signal\u7684event handler\u4e00\u822c\u88ab\u79f0\u4e3a**signal handler**\uff0cOS\u63d0\u4f9b\u4e86\u6ce8\u518c\u7684signal handler\u7684\u63a5\u53e3\u7ed9\u7528\u6237\uff0c\u8ba9\u4ed6\u4eec\u6765\u6307\u5b9a\u5bf9signal\u7684\u5904\u7406\uff1b APUE 14.2 \u975e\u963b\u585eIO \u963b\u585e\u7684\u51fd\u6570\u5f80\u5f80\u662f\u548c\u8fdb\u7a0b\u7684\u963b\u585e\u72b6\u6001\u6709\u5173\u7684\uff0c\u4e00\u65e6\u963b\u585e\uff0c\u5219\u8868\u793a\u8fdb\u7a0b\u5c06\u6682\u505c\u6267\u884c\u3002 \u8fd9\u4e00\u8282\u6700\u540e\u4e00\u6bb5\u5f15\u8d77\u4e86\u6211\u7684\u601d\u8003:\u524d\u9762\u5b83\u8bf4\uff0c\u6267\u884c\u4f4e\u901f\u7684\u7cfb\u7edf\u8c03\u7528\u662f\u53ef\u80fd\u4f1a\u4f7f\u8fdb\u7a0b\u6c38\u8fdc\u963b\u585e\u7684\u4e00\u7c7b\u7cfb\u7edf\u8c03\u7528\u3002\u5bf9\u4e8e\u8fd9\u6bb5\u8bdd\u6211\u7684\u60f3\u6cd5\u662f\u5f53\u8fdb\u7a0b\u88ab\u963b\u585e\u7684\u65f6\u5019\uff0c\u6b64\u65f6\u8fdb\u7a0b\u7684\u72b6\u6001\u662fblocking\u3002 \u5728\u6700\u540e\u4e00\u6bb5\u4e2d\uff0c\u4f5c\u8005\u53c8\u4ecb\u7ecd\uff0c\u53ef\u4ee5\u4f7f\u7528\u591a\u7ebf\u7a0b\uff0c\u8ba9\u5176\u4e2d\u4e00\u4e2a\u7ebf\u7a0b\u6765\u6267\u884c\u4f4e\u901f\u7684io\u64cd\u4f5c\uff0c\u5176\u4ed6\u7ebf\u7a0b\u5219\u65e0\u9700\u963b\u585e\uff0c\u53ef\u4ee5\u7ee7\u7eed\u6267\u884c\u3002 \u663e\u7136\uff0c\u6b64\u65f6\u8fdb\u7a0b\u7684\u4e00\u4e2a\u7ebf\u7a0b\u88ab\u963b\u585e\u4e86\uff0c\u4f46\u662f\u8fdb\u7a0b\u4e2d\u7684\u5176\u4ed6\u7ebf\u7a0b\u4ecd\u7136\u7ee7\u7eed\u8fd0\u884c\uff0c\u90a3\u4e48\u6b64\u65f6\u8fdb\u7a0b\u7684\u72b6\u6001\u662f\u4ec0\u4e48\u5462\uff1f APUE 16.8 \u8fd9\u4e00\u8282\u63cf\u8ff0\u4e86\u975e\u963b\u585e\u548c\u5f02\u6b65\u7684socket IO\u3002 \u975e\u963b\u585e\u7684IO\uff0c\u8c03\u7528\u8005\u4e3a\u4e86\u77e5\u9053\u53ef\u4ee5\u8fdb\u884cIO\u4e86\uff0c\u9700\u8981\u4e0d\u65ad\u5730\u53bb\u5c1d\u8bd5\uff0c\u5982\u679c\u53ef\u4ee5\uff0c\u5219\u6267\u884c\uff0c\u5982\u679c\u4e0d\u53ef\u4ee5\u5219\u8fd4\u56de\uff0c\u5982\u6b64\u5f80\u590d\u3002\u5f02\u6b65IO\uff0c\u5219\u4e0d\u9700\u8981\u8c03\u7528\u8005\u53bb\u4e3b\u52a8\u5730\u4e0d\u65ad\u5c1d\u8bd5\uff0cOS\u4f1a\u5728IO\u64cd\u4f5c\u53ef\u4ee5\u6267\u884c\u7684\u60c5\u51b5\u4e0b\uff0c\u901a\u8fc7\u6d88\u606f\u6216\u8005\u5176\u4ed6\u7684\u65b9\u5f0f\u6765\u901a\u77e5\u8c03\u7528\u8005\u3002\u663e\u7136\uff0c\u8fd9\u662f\u975e\u963b\u585eIO\u548c\u5f02\u6b65IO\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5dee\u522b\u3002 \u9664\u4e86\u672c\u8282\u6240\u63cf\u8ff0\u7684\u8fd9\u4e24\u79cd\u5f62\u5f0f\u7684IO\uff0c\u8fd8\u5b58\u5728IO multiplex \u5728APUE\u7684\u7b2c14\u7ae0\uff0c\u5bf9\u8fd9\u4e9b\u5185\u5bb9\u8fdb\u884c\u4e86\u6574\u4f53\u5730\u4ecb\u7ecd\u3002 Linux\u4e2d\u57fa\u4e8esignal\u7684asynchronous IO \u5728 pipe(7) - Linux man page \u7684I/O on pipes and FIFOs\u7ae0\u8282\uff0c\u4ecb\u7ecd\u4e86pipe\u548cFIFO\u7684blocking \u548cnonblocking IO\uff0c\u4ee5\u53caasynchronous IO\uff0c\u4ece\u5176\u4e2d\u53ef\u4ee5\u770b\u5230\uff0cpipe\u7684asynchronous IO\u662f\u57fa\u4e8esignal\u7684\uff1b","title":"Blocking-and-non-blocking-VS-sync-and-async"},{"location":"Programming/IO/IO-model/Blocking-and-non-blocking-VS-sync-and-async/#linux#sync#and#async#vs#blocking#and#non-blocking","text":"\u524d\u9762\u4ecb\u7ecd\u4e86Linux OS\u4e2d\u7684IO model\uff0c\u73b0\u5728\u6709\u5fc5\u8981\u5bf9Linux OS\u4e2d\u7684\u8fd9\u4e9b\u6982\u5ff5\u8fdb\u884c\u603b\u7ed3\u4e86\u3002","title":"Linux sync and async VS blocking and non-blocking"},{"location":"Programming/IO/IO-model/Blocking-and-non-blocking-VS-sync-and-async/#signal","text":"\u4fe1\u53f7\u662f\u4e00\u79cd\u8f6f\u4ef6\u4e2d\u65ad\uff0c\u6240\u4ee5\u4e5f\u662f\u4e00\u79cd\u5f02\u6b65\u3002 \u5728APUE\u768410.2 Signal Concepts\u4e2d\u6709\u4e0b\u9762\u8fd9\u6837\u7684\u4e00\u6bb5\u8bdd\uff1a Signals are classic examples of asynchronous events . They occur at what appear to be random times to the process. The process can\u2019t simply test a variable (such as errno) to see whether a signal has occurred; instead, the process has to tell the kernel \u2018\u2018if and when this signal occurs, do the following.\u2019\u2019We can tell the kernel to do one of three things when a signal occurs. We call this the disposition of the signal, or the action associated with a signal. Linux\u7684signal\u7684event handler\u4e00\u822c\u88ab\u79f0\u4e3a**signal handler**\uff0cOS\u63d0\u4f9b\u4e86\u6ce8\u518c\u7684signal handler\u7684\u63a5\u53e3\u7ed9\u7528\u6237\uff0c\u8ba9\u4ed6\u4eec\u6765\u6307\u5b9a\u5bf9signal\u7684\u5904\u7406\uff1b","title":"Signal"},{"location":"Programming/IO/IO-model/Blocking-and-non-blocking-VS-sync-and-async/#apue#142#io","text":"\u963b\u585e\u7684\u51fd\u6570\u5f80\u5f80\u662f\u548c\u8fdb\u7a0b\u7684\u963b\u585e\u72b6\u6001\u6709\u5173\u7684\uff0c\u4e00\u65e6\u963b\u585e\uff0c\u5219\u8868\u793a\u8fdb\u7a0b\u5c06\u6682\u505c\u6267\u884c\u3002 \u8fd9\u4e00\u8282\u6700\u540e\u4e00\u6bb5\u5f15\u8d77\u4e86\u6211\u7684\u601d\u8003:\u524d\u9762\u5b83\u8bf4\uff0c\u6267\u884c\u4f4e\u901f\u7684\u7cfb\u7edf\u8c03\u7528\u662f\u53ef\u80fd\u4f1a\u4f7f\u8fdb\u7a0b\u6c38\u8fdc\u963b\u585e\u7684\u4e00\u7c7b\u7cfb\u7edf\u8c03\u7528\u3002\u5bf9\u4e8e\u8fd9\u6bb5\u8bdd\u6211\u7684\u60f3\u6cd5\u662f\u5f53\u8fdb\u7a0b\u88ab\u963b\u585e\u7684\u65f6\u5019\uff0c\u6b64\u65f6\u8fdb\u7a0b\u7684\u72b6\u6001\u662fblocking\u3002 \u5728\u6700\u540e\u4e00\u6bb5\u4e2d\uff0c\u4f5c\u8005\u53c8\u4ecb\u7ecd\uff0c\u53ef\u4ee5\u4f7f\u7528\u591a\u7ebf\u7a0b\uff0c\u8ba9\u5176\u4e2d\u4e00\u4e2a\u7ebf\u7a0b\u6765\u6267\u884c\u4f4e\u901f\u7684io\u64cd\u4f5c\uff0c\u5176\u4ed6\u7ebf\u7a0b\u5219\u65e0\u9700\u963b\u585e\uff0c\u53ef\u4ee5\u7ee7\u7eed\u6267\u884c\u3002 \u663e\u7136\uff0c\u6b64\u65f6\u8fdb\u7a0b\u7684\u4e00\u4e2a\u7ebf\u7a0b\u88ab\u963b\u585e\u4e86\uff0c\u4f46\u662f\u8fdb\u7a0b\u4e2d\u7684\u5176\u4ed6\u7ebf\u7a0b\u4ecd\u7136\u7ee7\u7eed\u8fd0\u884c\uff0c\u90a3\u4e48\u6b64\u65f6\u8fdb\u7a0b\u7684\u72b6\u6001\u662f\u4ec0\u4e48\u5462\uff1f","title":"APUE 14.2 \u975e\u963b\u585eIO"},{"location":"Programming/IO/IO-model/Blocking-and-non-blocking-VS-sync-and-async/#apue#168","text":"\u8fd9\u4e00\u8282\u63cf\u8ff0\u4e86\u975e\u963b\u585e\u548c\u5f02\u6b65\u7684socket IO\u3002 \u975e\u963b\u585e\u7684IO\uff0c\u8c03\u7528\u8005\u4e3a\u4e86\u77e5\u9053\u53ef\u4ee5\u8fdb\u884cIO\u4e86\uff0c\u9700\u8981\u4e0d\u65ad\u5730\u53bb\u5c1d\u8bd5\uff0c\u5982\u679c\u53ef\u4ee5\uff0c\u5219\u6267\u884c\uff0c\u5982\u679c\u4e0d\u53ef\u4ee5\u5219\u8fd4\u56de\uff0c\u5982\u6b64\u5f80\u590d\u3002\u5f02\u6b65IO\uff0c\u5219\u4e0d\u9700\u8981\u8c03\u7528\u8005\u53bb\u4e3b\u52a8\u5730\u4e0d\u65ad\u5c1d\u8bd5\uff0cOS\u4f1a\u5728IO\u64cd\u4f5c\u53ef\u4ee5\u6267\u884c\u7684\u60c5\u51b5\u4e0b\uff0c\u901a\u8fc7\u6d88\u606f\u6216\u8005\u5176\u4ed6\u7684\u65b9\u5f0f\u6765\u901a\u77e5\u8c03\u7528\u8005\u3002\u663e\u7136\uff0c\u8fd9\u662f\u975e\u963b\u585eIO\u548c\u5f02\u6b65IO\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5dee\u522b\u3002 \u9664\u4e86\u672c\u8282\u6240\u63cf\u8ff0\u7684\u8fd9\u4e24\u79cd\u5f62\u5f0f\u7684IO\uff0c\u8fd8\u5b58\u5728IO multiplex \u5728APUE\u7684\u7b2c14\u7ae0\uff0c\u5bf9\u8fd9\u4e9b\u5185\u5bb9\u8fdb\u884c\u4e86\u6574\u4f53\u5730\u4ecb\u7ecd\u3002","title":"APUE 16.8"},{"location":"Programming/IO/IO-model/Blocking-and-non-blocking-VS-sync-and-async/#linuxsignalasynchronous#io","text":"\u5728 pipe(7) - Linux man page \u7684I/O on pipes and FIFOs\u7ae0\u8282\uff0c\u4ecb\u7ecd\u4e86pipe\u548cFIFO\u7684blocking \u548cnonblocking IO\uff0c\u4ee5\u53caasynchronous IO\uff0c\u4ece\u5176\u4e2d\u53ef\u4ee5\u770b\u5230\uff0cpipe\u7684asynchronous IO\u662f\u57fa\u4e8esignal\u7684\uff1b","title":"Linux\u4e2d\u57fa\u4e8esignal\u7684asynchronous IO"},{"location":"Programming/IO/IO-model/IO-models/","text":"I/O Models UNP 6.1 I/O Multiplexing: The select and poll Functions \u00b6 NOTE: \u672c\u8282\u4ee5UNP\u7684chapter 6.2 I/O Models\u57fa\u51c6\u6765\u63cf\u8ff0Unix-like OS\u4e2d\u7684**I/O models**\u3002\u7f51\u7edc\u8d44\u6e90\u94fe\u63a5\uff1a https://notes.shichao.io/unp/ch6/#io-models \u3002\u6b63\u6587\u5982\u4e0b\uff1a In Section 5.12, we saw our TCP client handling two inputs at the same time: standard input and a TCP socket . We encountered a problem when the client was blocked in a call to fgets (on standard input) and the server process was killed. The server TCP correctly sent a FIN to the client TCP, but since the client process was blocked reading from standard input , it never saw the EOF until it read from the socket (possibly much later). What we need is the capability to tell the kernel that we want to be notified if one or more I/O conditions are ready (i.e., input is ready to be read, or the descriptor is capable of taking more output). This capability is called I/O multiplexing and is provided by the select and poll functions. We will also cover a newer POSIX variation of the former, called pselect . Some systems provide more advanced ways for processes to wait for a list of events. A poll device is one mechanism provided in different forms by different vendors. This mechanism will be described in Chapter 14. I/O multiplexing is typically used in networking applications in the following scenarios: When a client is handling multiple descriptors (normally interactive input and a network socket), I/O multiplexing should be used. This is the scenario we described previously. It is possible, but rare, for a client to handle multiple sockets at the same time. We will show an example of this using select in Section 16.5 in the context of a Web client. If a TCP server handles both a listening socket and its connected sockets, I/O multiplexing is normally used, as we will show in Section 6.8. If a server handles both TCP and UDP , I/O multiplexing is normally used. We will show an example of this in Section 8.15. If a server handles multiple services and perhaps multiple protocols (e.g., the inetd daemon that we will describe in Section 13.5), I/O multiplexing is normally used. I/O multiplexing is not limited to network programming. Many nontrivial applications find a need for these techniques. Before describing select and poll , we need to step back and look at the bigger picture, examining the basic differences in the five I/O models that are available to us under Unix: blocking I/O nonblocking I/O I/O multiplexing ( select and poll ) signal driven I/O ( SIGIO ) asynchronous I/O (the POSIX aio_ functions) You may want to skim this section on your first reading and then refer back to it as you encounter the different I/O models described in more detail in later chapters. As we show in all the examples in this section, there are normally two distinct phases for an input operation: Waiting for the data to be ready Copying the data from the kernel to the process For an input operation on a socket , the first step normally involves waiting for data to arrive on the network. When the packet arrives, it is copied into a buffer within the kernel . The second step is copying this data from the kernel's buffer into our application buffer. Blocking I/O Model The most prevalent(\u6d41\u884c) model for I/O is the blocking I/O model , which we have used for all our examples so far in the text. By default, all sockets are blocking . Using a datagram socket for our examples, we have the scenario shown in Figure 6.1. Figure 6.1. Blocking I/O model. We use UDP for this example instead of TCP because with UDP , the concept of data being \"ready\" to read is simple: either an entire datagram(\u6570\u636e\u62a5) has been received or it has not. With TCP it gets more complicated, as additional variables such as the socket's low-water mark come into play \uff08\u4ea7\u751f\u4f5c\u7528\uff09. In the examples in this section, we also refer to recvfrom as a system call because we are differentiating\uff08\u533a\u5206\uff09 between our application and the kernel. Regardless of how recvfrom is implemented (as a system call on a Berkeley-derived kernel or as a function that invokes the getmsg system call on a System V kernel), there is normally a switch from running in the application to running in the kernel, followed at some time later by a return to the application. In Figure 6.1 , the process calls recvfrom and the system call does not return until the datagram arrives and is copied into our application buffer, or an error occurs. The most common error is the system call being interrupted by a signal , as we described in Section 5.9. We say that our process is blocked the entire time from when it calls recvfrom until it returns. When recvfrom returns successfully, our application processes the datagram. Nonblocking I/O Model When we set a socket to be nonblocking , we are telling the kernel \"when an I/O operation that I request cannot be completed without putting the process to sleep, do not put the process to sleep , but return an error instead.\" We will describe nonblocking I/O in Chapter 16, but Figure 6.2 shows a summary of the example we are considering. Figure 6.2. Nonblocking I/O model. The first three times that we call recvfrom , there is no data to return, so the kernel immediately returns an error of EWOULDBLOCK instead. The fourth time we call recvfrom , a datagram is ready, it is copied into our application buffer, and recvfrom returns successfully. We then process the data. When an application sits in a loop calling recvfrom on a nonblocking descriptor like this, it is called polling . The application is continually polling the kernel to see if some operation is ready. This is often a waste of CPU time, but this model is occasionally encountered, normally on systems dedicated to one function. I/O Multiplexing Model With I/O multiplexing , we call select or poll and block(\u963b\u585e) in one of these two system calls , instead of blocking in the actual I/O system call . Figure 6.3 is a summary of the I/O multiplexing model. NOTE: \u963b\u585e\u5728 select \u6216 poll \u4e2d\uff1b OS kernel\u6240\u901a\u77e5\u7684\u662fIO readiness\uff1b Figure 6.3. I/O multiplexing model. We block in a call to select , waiting for the datagram socket to be readable. When select returns that the socket is readable, we then call recvfrom to copy the datagram into our application buffer. Comparing Figure 6.3 to Figure 6.1, there does not appear to be any advantage, and in fact, there is a slight disadvantage because using select requires two system calls instead of one. But the advantage in using select , which we will see later in this chapter, is that we can wait for more than one descriptor to be ready. Another closely related I/O model is to use multithreading with blocking I/O. That model very closely resembles the model described above, except that instead of using select to block on multiple file descriptors, the program uses multiple threads (one per file descriptor), and each thread is then free to call blocking system calls like recvfrom . Signal-Driven I/O Model We can also use signals , telling the kernel to notify us with the SIGIO signal when the descriptor is ready. We call this signal-driven I/O and show a summary of it in Figure 6.4. NOTE: OS kernel\u6240\u901a\u77e5\u7684\u662fIO readiness\uff1b Figure 6.4. Signal-Driven I/O model. We first enable the socket for signal-driven I/O (as we will describe in Section 25.2) and install a signal handler using the sigaction system call. The return from this system call is immediate and our process continues; it is not blocked. When the datagram is ready to be read, the SIGIO signal is generated for our process. We can either read the datagram from the signal handler by calling recvfrom and then notify the main loop that the data is ready to be processed (this is what we will do in Section 25.3), or we can notify the main loop and let it read the datagram. Regardless of how we handle the signal, the advantage to this model is that we are not blocked while waiting for the datagram to arrive. The main loop can continue executing and just wait to be notified by the signal handler that either the data is ready to process or the datagram is ready to be read. Asynchronous I/O Model Asynchronous I/O is defined by the POSIX specification , and various differences in the real-time functions that appeared in the various standards which came together to form the current POSIX specification have been reconciled(\u548c\u89e3\u4e86\uff09. In general, these functions work by telling the kernel to start the operation and to notify us when the entire operation (including the copy of the data from the kernel to our buffer) is complete. The main difference between this model and the signal-driven I/O model in the previous section is that with signal-driven I/O , the kernel tells us when an I/O operation can be initiated(\u5f00\u59cb), but with synchronous I/O, the kernel tells us when an I/O operation is complete . We show an example in Figure 6.5. NOTE: OS kernel\u6240\u901a\u77e5\u7684\u662fIO completion\uff1b Figure 6.5. Asynchronous I/O model. We call aio_read (the POSIX asynchronous I/O functions begin with aio_ or lio_ ) and pass the kernel the descriptor, buffer pointer, buffer size (the same three arguments for read ), file offset (similar to lseek ), and how to notify us when the entire operation is complete. This system call returns immediately and our process is not blocked while waiting for the I/O to complete. We assume in this example that we ask the kernel to generate some signal when the operation is complete. This signal is not generated until the data has been copied into our application buffer, which is different from the signal-driven I/O model. As of this writing, few systems support POSIX asynchronous I/O. We are not certain, for example, if systems will support it for sockets. Our use of it here is as an example to compare against the signal-driven I/O model. Comparison of the I/O Models Figure 6.6 is a comparison of the five different I/O models. It shows that the main difference between the first four models is the first phase , as the second phase in the first four models is the same: the process is blocked in a call to recvfrom while the data is copied from the kernel to the caller's buffer. Asynchronous I/O, however, handles both phases and is different from the first four. Figure 6.6. Comparison of the five I/O models. POSIX: Synchronous I/O versus Asynchronous I/O NOTE: \u4e0d\u540c\u7684\u6807\u51c6\u6709\u7740\u4e0d\u540c\u7684\u5b9a\u4e49POSIX\u7684Synchronous I/O \u3001Asynchronous I/O\u5b9a\u4e49\u662f\u6839\u636e\u5177\u4f53\u7684IO\u64cd\u4f5c(copy data from kernel to user )\u662f\u5426\u963b\u585e\u4e3b\u8c03\u7ebf\u7a0b\u3002 POSIX defines these two terms as follows: A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes. An asynchronous I/O operation does not cause the requesting process to be blocked . NOTE: \u5b83\u7684\"copy data from kernel to user\"\u662f\u7531kernel\u6267\u884c\u7684\uff0c\u4e0d\u4f1a\u963b\u585e\u8c03\u7528\u7ebf\u7a0b\uff0c\u5b83\u88ab\u901a\u77e5\u7684\u662fIO completion\uff0c\u800c\u4e0d\u662fIO readiness\u3002 Using these definitions, the first four I/O models\u2014blocking, nonblocking, I/O multiplexing, and signal-riven I/O\u2014are all synchronous because the actual I/O operation ( recvfrom ) blocks the process. Only the asynchronous I/O model matches the asynchronous I/O definition. NOTE: \u4e0b\u56fe\u662f\u5bf9\u4e0a\u9762IO model\u7684\u603b\u7ed3: classification Synchronous I/O - blocking - nonblocking - I/O multiplexing - signal-riven I/O Asynchronous I/O asynchronous I/O NOTE: signal-driven IO VS asynchronous IO signal-driven \u6240\u901a\u77e5\u7684\u662f: IO readiness; asynchronous IO \u6240\u901a\u77e5\u7684\u662f: IO completion; ibm Boost application performance using asynchronous I/O Introduction to AIO Linux asynchronous I/O is a relatively recent addition to the Linux kernel. It's a standard feature of the 2.6 kernel, but you can find patches for 2.4. The basic idea behind AIO is to allow a process to initiate(\u5f00\u59cb\uff0c\u542f\u52a8) a number of I/O operations without having to block or wait for any to complete. At some later time, or after being notified of I/O completion , the process can retrieve the results of the I/O. I/O models Before digging into the AIO API, let's explore the different I/O models that are available under Linux. This isn't intended as an exhaustive review, but rather aims to cover the most common models to illustrate their differences from asynchronous I/O. Figure 1 shows synchronous and asynchronous models, as well as blocking and non-blocking models. Figure 1. Simplified matrix of basic Linux I/O models Each of these I/O models has usage patterns that are advantageous for particular applications. This section briefly explores each one. Synchronous blocking I/O I/O-bound versus CPU-bound processes A process that is I/O bound is one that performs more I/O than processing. A CPU-bound process does more processing than I/O. The Linux 2.6 scheduler(\u8c03\u5ea6\u7a0b\u5e8f) actually favors I/O-bound processes because they commonly initiate an I/O and then block, which means other work can be efficiently interlaced(\u4ea4\u9519) between them. One of the most common models is the synchronous blocking I/O model . In this model, the user-space application performs a system call that results in the application blocking. This means that the application blocks until the system call is complete (data transferred or error). The calling application is in a state where it consumes no CPU and simply awaits the response, so it is efficient from a processing perspective. Figure 2 illustrates the traditional blocking I/O model, which is also the most common model used in applications today. Its behaviors are well understood, and its usage is efficient for typical applications. When the read system call is invoked, the application blocks and the context switches to the kernel . The read is then initiated, and when the response returns (from the device from which you're reading), the data is moved to the user-space buffer. Then the application is unblocked (and the read call returns). Figure 2. Typical flow of the synchronous blocking I/O model From the application's perspective, the read call spans a long duration. But, in fact, the application is actually blocked while the read is multiplexed(\u591a\u8def\u590d\u7528) with other work in the kernel. Synchronous non-blocking I/O A less efficient variant of synchronous blocking is synchronous non-blocking I/O . In this model, a device is opened as non-blocking . This means that instead of completing an I/O immediately, a read may return an error code indicating that the command could not be immediately satisfied ( EAGAIN or EWOULDBLOCK ), as shown in Figure 3. Figure 3. Typical flow of the synchronous non-blocking I/O model The implication(\u5f71\u54cd) of non-blocking is that an I/O command may not be satisfied immediately, requiring that the application make numerous calls to await completion. This can be extremely inefficient because in many cases the application must busy-wait until the data is available or attempt to do other work while the command is performed in the kernel. As also shown in Figure 3, this method can introduce latency in the I/O because any gap between the data becoming available in the kernel and the user calling read to return it can reduce the overall data throughput. Asynchronous blocking I/O Another blocking paradigm is non-blocking I/O with blocking notifications . In this model, non-blocking I/O is configured, and then the blocking select system call is used to determine when there's any activity for an I/O descriptor . What makes the select call interesting is that it can be used to provide notification for not just one descriptor, but many. For each descriptor, you can request notification of the descriptor's ability to write data, availability of read data, and also whether an error has occurred. Figure 4. Typical flow of the asynchronous blocking I/O model (select) The primary issue with the select call is that it's not very efficient. While it's a convenient model for asynchronous notification , its use for high-performance I/O is not advised. Asynchronous non-blocking I/O (AIO) Finally, the asynchronous non-blocking I/O model is one of overlapping(\u91cd\u53e0\uff1b\u8986\u76d6) processing with I/O. The read request returns immediately, indicating that the read was successfully initiated. The application can then perform other processing while the background read operation completes. When the read response arrives, a signal or a thread-based callback can be generated to complete the I/O transaction. Figure 5. Typical flow of the asynchronous non-blocking I/O model The ability to overlap computation and I/O processing in a single process for potentially multiple I/O requests exploits the gap\uff08\u5dee\u8ddd\uff09 between processing speed and I/O speed . While one or more slow I/O requests are pending, the CPU can perform other tasks or, more commonly, operate on already completed I/Os while other I/Os are initiated. NOTE:I feel that the idea in the above paragraph can also be implemented using threads as describe in this article NOTE:Asynchronous IO has the mechanism of notification.Blocked IO mean that the application would be blocked; \u7ef4\u57fa\u767e\u79d1 Asynchronous I/O \u7ef4\u57fa\u767e\u79d1 Asynchronous I/O \u7684 Forms \u7ae0\u8282\u5bf9IO form\u7684\u5206\u7c7b\u548c\u672c\u8282\u524d\u9762\u6240\u63cf\u8ff0\u7684POSIX \u7684IO \u5206\u7c7b\u662f\u4e00\u81f4\u7684\u3002 Blocking Non-blocking Asynchronous API write, read write, read + poll / select aio_write, aio_read \u7ef4\u57fa\u767e\u79d1 Asynchronous I/O \u7684 Examples \u7ae0\u8282\u7ed9\u51fa\u7684\u4f8b\u5b50\u503c\u7684\u4e00\u8bfb\u3002 Summary \u4ece\u4e0a\u9762\u4e09\u7bc7\u6587\u7ae0: 1) UNP 6.1 I/O Multiplexing: The select and poll Functions \u00b6 2) ibm Boost application performance using asynchronous I/O 3) wikipedia Asynchronous I/O \u53ef\u4ee5\u770b\u51fa\uff0c\u5b83\u4eec\u5bf9IO model\u7684\u5206\u7c7b\u662f\u4e0d\u540c\u7684\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5b83\u4eec\u7684\u5206\u7c7b\u90fd\u6ca1\u6709\u9519\u8bef\uff0c\u5bf9blocking\u3001non-blocking \u548c sync\u3001async \u7684\u7528\u6cd5\u4e5f\u6ca1\u6709\u9519\u8bef\uff0c\u5b83\u4eec\u90fd\u662f\u5728IO\u7684\u67d0\u4e2a\u89d2\u5ea6\u6765\u8fdb\u884c\u63cf\u8ff0\u3001\u5206\u7c7b\u7684\u3002","title":"IO-models"},{"location":"Programming/IO/IO-model/IO-models/#io#models","text":"","title":"I/O Models"},{"location":"Programming/IO/IO-model/IO-models/#unp#61#io#multiplexing#the#select#and#poll#functions","text":"NOTE: \u672c\u8282\u4ee5UNP\u7684chapter 6.2 I/O Models\u57fa\u51c6\u6765\u63cf\u8ff0Unix-like OS\u4e2d\u7684**I/O models**\u3002\u7f51\u7edc\u8d44\u6e90\u94fe\u63a5\uff1a https://notes.shichao.io/unp/ch6/#io-models \u3002\u6b63\u6587\u5982\u4e0b\uff1a In Section 5.12, we saw our TCP client handling two inputs at the same time: standard input and a TCP socket . We encountered a problem when the client was blocked in a call to fgets (on standard input) and the server process was killed. The server TCP correctly sent a FIN to the client TCP, but since the client process was blocked reading from standard input , it never saw the EOF until it read from the socket (possibly much later). What we need is the capability to tell the kernel that we want to be notified if one or more I/O conditions are ready (i.e., input is ready to be read, or the descriptor is capable of taking more output). This capability is called I/O multiplexing and is provided by the select and poll functions. We will also cover a newer POSIX variation of the former, called pselect . Some systems provide more advanced ways for processes to wait for a list of events. A poll device is one mechanism provided in different forms by different vendors. This mechanism will be described in Chapter 14. I/O multiplexing is typically used in networking applications in the following scenarios: When a client is handling multiple descriptors (normally interactive input and a network socket), I/O multiplexing should be used. This is the scenario we described previously. It is possible, but rare, for a client to handle multiple sockets at the same time. We will show an example of this using select in Section 16.5 in the context of a Web client. If a TCP server handles both a listening socket and its connected sockets, I/O multiplexing is normally used, as we will show in Section 6.8. If a server handles both TCP and UDP , I/O multiplexing is normally used. We will show an example of this in Section 8.15. If a server handles multiple services and perhaps multiple protocols (e.g., the inetd daemon that we will describe in Section 13.5), I/O multiplexing is normally used. I/O multiplexing is not limited to network programming. Many nontrivial applications find a need for these techniques. Before describing select and poll , we need to step back and look at the bigger picture, examining the basic differences in the five I/O models that are available to us under Unix: blocking I/O nonblocking I/O I/O multiplexing ( select and poll ) signal driven I/O ( SIGIO ) asynchronous I/O (the POSIX aio_ functions) You may want to skim this section on your first reading and then refer back to it as you encounter the different I/O models described in more detail in later chapters. As we show in all the examples in this section, there are normally two distinct phases for an input operation: Waiting for the data to be ready Copying the data from the kernel to the process For an input operation on a socket , the first step normally involves waiting for data to arrive on the network. When the packet arrives, it is copied into a buffer within the kernel . The second step is copying this data from the kernel's buffer into our application buffer.","title":"UNP 6.1 I/O Multiplexing: The select and poll Functions\u00b6"},{"location":"Programming/IO/IO-model/IO-models/#blocking#io#model","text":"The most prevalent(\u6d41\u884c) model for I/O is the blocking I/O model , which we have used for all our examples so far in the text. By default, all sockets are blocking . Using a datagram socket for our examples, we have the scenario shown in Figure 6.1. Figure 6.1. Blocking I/O model. We use UDP for this example instead of TCP because with UDP , the concept of data being \"ready\" to read is simple: either an entire datagram(\u6570\u636e\u62a5) has been received or it has not. With TCP it gets more complicated, as additional variables such as the socket's low-water mark come into play \uff08\u4ea7\u751f\u4f5c\u7528\uff09. In the examples in this section, we also refer to recvfrom as a system call because we are differentiating\uff08\u533a\u5206\uff09 between our application and the kernel. Regardless of how recvfrom is implemented (as a system call on a Berkeley-derived kernel or as a function that invokes the getmsg system call on a System V kernel), there is normally a switch from running in the application to running in the kernel, followed at some time later by a return to the application. In Figure 6.1 , the process calls recvfrom and the system call does not return until the datagram arrives and is copied into our application buffer, or an error occurs. The most common error is the system call being interrupted by a signal , as we described in Section 5.9. We say that our process is blocked the entire time from when it calls recvfrom until it returns. When recvfrom returns successfully, our application processes the datagram.","title":"Blocking I/O Model"},{"location":"Programming/IO/IO-model/IO-models/#nonblocking#io#model","text":"When we set a socket to be nonblocking , we are telling the kernel \"when an I/O operation that I request cannot be completed without putting the process to sleep, do not put the process to sleep , but return an error instead.\" We will describe nonblocking I/O in Chapter 16, but Figure 6.2 shows a summary of the example we are considering. Figure 6.2. Nonblocking I/O model. The first three times that we call recvfrom , there is no data to return, so the kernel immediately returns an error of EWOULDBLOCK instead. The fourth time we call recvfrom , a datagram is ready, it is copied into our application buffer, and recvfrom returns successfully. We then process the data. When an application sits in a loop calling recvfrom on a nonblocking descriptor like this, it is called polling . The application is continually polling the kernel to see if some operation is ready. This is often a waste of CPU time, but this model is occasionally encountered, normally on systems dedicated to one function.","title":"Nonblocking I/O Model"},{"location":"Programming/IO/IO-model/IO-models/#io#multiplexing#model","text":"With I/O multiplexing , we call select or poll and block(\u963b\u585e) in one of these two system calls , instead of blocking in the actual I/O system call . Figure 6.3 is a summary of the I/O multiplexing model. NOTE: \u963b\u585e\u5728 select \u6216 poll \u4e2d\uff1b OS kernel\u6240\u901a\u77e5\u7684\u662fIO readiness\uff1b Figure 6.3. I/O multiplexing model. We block in a call to select , waiting for the datagram socket to be readable. When select returns that the socket is readable, we then call recvfrom to copy the datagram into our application buffer. Comparing Figure 6.3 to Figure 6.1, there does not appear to be any advantage, and in fact, there is a slight disadvantage because using select requires two system calls instead of one. But the advantage in using select , which we will see later in this chapter, is that we can wait for more than one descriptor to be ready. Another closely related I/O model is to use multithreading with blocking I/O. That model very closely resembles the model described above, except that instead of using select to block on multiple file descriptors, the program uses multiple threads (one per file descriptor), and each thread is then free to call blocking system calls like recvfrom .","title":"I/O Multiplexing Model"},{"location":"Programming/IO/IO-model/IO-models/#signal-driven#io#model","text":"We can also use signals , telling the kernel to notify us with the SIGIO signal when the descriptor is ready. We call this signal-driven I/O and show a summary of it in Figure 6.4. NOTE: OS kernel\u6240\u901a\u77e5\u7684\u662fIO readiness\uff1b Figure 6.4. Signal-Driven I/O model. We first enable the socket for signal-driven I/O (as we will describe in Section 25.2) and install a signal handler using the sigaction system call. The return from this system call is immediate and our process continues; it is not blocked. When the datagram is ready to be read, the SIGIO signal is generated for our process. We can either read the datagram from the signal handler by calling recvfrom and then notify the main loop that the data is ready to be processed (this is what we will do in Section 25.3), or we can notify the main loop and let it read the datagram. Regardless of how we handle the signal, the advantage to this model is that we are not blocked while waiting for the datagram to arrive. The main loop can continue executing and just wait to be notified by the signal handler that either the data is ready to process or the datagram is ready to be read.","title":"Signal-Driven I/O Model"},{"location":"Programming/IO/IO-model/IO-models/#asynchronous#io#model","text":"Asynchronous I/O is defined by the POSIX specification , and various differences in the real-time functions that appeared in the various standards which came together to form the current POSIX specification have been reconciled(\u548c\u89e3\u4e86\uff09. In general, these functions work by telling the kernel to start the operation and to notify us when the entire operation (including the copy of the data from the kernel to our buffer) is complete. The main difference between this model and the signal-driven I/O model in the previous section is that with signal-driven I/O , the kernel tells us when an I/O operation can be initiated(\u5f00\u59cb), but with synchronous I/O, the kernel tells us when an I/O operation is complete . We show an example in Figure 6.5. NOTE: OS kernel\u6240\u901a\u77e5\u7684\u662fIO completion\uff1b Figure 6.5. Asynchronous I/O model. We call aio_read (the POSIX asynchronous I/O functions begin with aio_ or lio_ ) and pass the kernel the descriptor, buffer pointer, buffer size (the same three arguments for read ), file offset (similar to lseek ), and how to notify us when the entire operation is complete. This system call returns immediately and our process is not blocked while waiting for the I/O to complete. We assume in this example that we ask the kernel to generate some signal when the operation is complete. This signal is not generated until the data has been copied into our application buffer, which is different from the signal-driven I/O model. As of this writing, few systems support POSIX asynchronous I/O. We are not certain, for example, if systems will support it for sockets. Our use of it here is as an example to compare against the signal-driven I/O model.","title":"Asynchronous I/O Model"},{"location":"Programming/IO/IO-model/IO-models/#comparison#of#the#io#models","text":"Figure 6.6 is a comparison of the five different I/O models. It shows that the main difference between the first four models is the first phase , as the second phase in the first four models is the same: the process is blocked in a call to recvfrom while the data is copied from the kernel to the caller's buffer. Asynchronous I/O, however, handles both phases and is different from the first four. Figure 6.6. Comparison of the five I/O models.","title":"Comparison of the I/O Models"},{"location":"Programming/IO/IO-model/IO-models/#posix#synchronous#io#versus#asynchronous#io","text":"NOTE: \u4e0d\u540c\u7684\u6807\u51c6\u6709\u7740\u4e0d\u540c\u7684\u5b9a\u4e49POSIX\u7684Synchronous I/O \u3001Asynchronous I/O\u5b9a\u4e49\u662f\u6839\u636e\u5177\u4f53\u7684IO\u64cd\u4f5c(copy data from kernel to user )\u662f\u5426\u963b\u585e\u4e3b\u8c03\u7ebf\u7a0b\u3002 POSIX defines these two terms as follows: A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes. An asynchronous I/O operation does not cause the requesting process to be blocked . NOTE: \u5b83\u7684\"copy data from kernel to user\"\u662f\u7531kernel\u6267\u884c\u7684\uff0c\u4e0d\u4f1a\u963b\u585e\u8c03\u7528\u7ebf\u7a0b\uff0c\u5b83\u88ab\u901a\u77e5\u7684\u662fIO completion\uff0c\u800c\u4e0d\u662fIO readiness\u3002 Using these definitions, the first four I/O models\u2014blocking, nonblocking, I/O multiplexing, and signal-riven I/O\u2014are all synchronous because the actual I/O operation ( recvfrom ) blocks the process. Only the asynchronous I/O model matches the asynchronous I/O definition. NOTE: \u4e0b\u56fe\u662f\u5bf9\u4e0a\u9762IO model\u7684\u603b\u7ed3: classification Synchronous I/O - blocking - nonblocking - I/O multiplexing - signal-riven I/O Asynchronous I/O asynchronous I/O NOTE: signal-driven IO VS asynchronous IO signal-driven \u6240\u901a\u77e5\u7684\u662f: IO readiness; asynchronous IO \u6240\u901a\u77e5\u7684\u662f: IO completion;","title":"POSIX: Synchronous I/O versus Asynchronous I/O"},{"location":"Programming/IO/IO-model/IO-models/#ibm#boost#application#performance#using#asynchronous#io","text":"","title":"ibm Boost application performance using asynchronous I/O"},{"location":"Programming/IO/IO-model/IO-models/#introduction#to#aio","text":"Linux asynchronous I/O is a relatively recent addition to the Linux kernel. It's a standard feature of the 2.6 kernel, but you can find patches for 2.4. The basic idea behind AIO is to allow a process to initiate(\u5f00\u59cb\uff0c\u542f\u52a8) a number of I/O operations without having to block or wait for any to complete. At some later time, or after being notified of I/O completion , the process can retrieve the results of the I/O.","title":"Introduction to AIO"},{"location":"Programming/IO/IO-model/IO-models/#io#models_1","text":"Before digging into the AIO API, let's explore the different I/O models that are available under Linux. This isn't intended as an exhaustive review, but rather aims to cover the most common models to illustrate their differences from asynchronous I/O. Figure 1 shows synchronous and asynchronous models, as well as blocking and non-blocking models. Figure 1. Simplified matrix of basic Linux I/O models Each of these I/O models has usage patterns that are advantageous for particular applications. This section briefly explores each one.","title":"I/O models"},{"location":"Programming/IO/IO-model/IO-models/#synchronous#blocking#io","text":"","title":"Synchronous blocking I/O"},{"location":"Programming/IO/IO-model/IO-models/#io-bound#versus#cpu-bound#processes","text":"A process that is I/O bound is one that performs more I/O than processing. A CPU-bound process does more processing than I/O. The Linux 2.6 scheduler(\u8c03\u5ea6\u7a0b\u5e8f) actually favors I/O-bound processes because they commonly initiate an I/O and then block, which means other work can be efficiently interlaced(\u4ea4\u9519) between them. One of the most common models is the synchronous blocking I/O model . In this model, the user-space application performs a system call that results in the application blocking. This means that the application blocks until the system call is complete (data transferred or error). The calling application is in a state where it consumes no CPU and simply awaits the response, so it is efficient from a processing perspective. Figure 2 illustrates the traditional blocking I/O model, which is also the most common model used in applications today. Its behaviors are well understood, and its usage is efficient for typical applications. When the read system call is invoked, the application blocks and the context switches to the kernel . The read is then initiated, and when the response returns (from the device from which you're reading), the data is moved to the user-space buffer. Then the application is unblocked (and the read call returns). Figure 2. Typical flow of the synchronous blocking I/O model From the application's perspective, the read call spans a long duration. But, in fact, the application is actually blocked while the read is multiplexed(\u591a\u8def\u590d\u7528) with other work in the kernel.","title":"I/O-bound versus CPU-bound processes"},{"location":"Programming/IO/IO-model/IO-models/#synchronous#non-blocking#io","text":"A less efficient variant of synchronous blocking is synchronous non-blocking I/O . In this model, a device is opened as non-blocking . This means that instead of completing an I/O immediately, a read may return an error code indicating that the command could not be immediately satisfied ( EAGAIN or EWOULDBLOCK ), as shown in Figure 3. Figure 3. Typical flow of the synchronous non-blocking I/O model The implication(\u5f71\u54cd) of non-blocking is that an I/O command may not be satisfied immediately, requiring that the application make numerous calls to await completion. This can be extremely inefficient because in many cases the application must busy-wait until the data is available or attempt to do other work while the command is performed in the kernel. As also shown in Figure 3, this method can introduce latency in the I/O because any gap between the data becoming available in the kernel and the user calling read to return it can reduce the overall data throughput.","title":"Synchronous non-blocking I/O"},{"location":"Programming/IO/IO-model/IO-models/#asynchronous#blocking#io","text":"Another blocking paradigm is non-blocking I/O with blocking notifications . In this model, non-blocking I/O is configured, and then the blocking select system call is used to determine when there's any activity for an I/O descriptor . What makes the select call interesting is that it can be used to provide notification for not just one descriptor, but many. For each descriptor, you can request notification of the descriptor's ability to write data, availability of read data, and also whether an error has occurred. Figure 4. Typical flow of the asynchronous blocking I/O model (select) The primary issue with the select call is that it's not very efficient. While it's a convenient model for asynchronous notification , its use for high-performance I/O is not advised.","title":"Asynchronous blocking I/O"},{"location":"Programming/IO/IO-model/IO-models/#asynchronous#non-blocking#io#aio","text":"Finally, the asynchronous non-blocking I/O model is one of overlapping(\u91cd\u53e0\uff1b\u8986\u76d6) processing with I/O. The read request returns immediately, indicating that the read was successfully initiated. The application can then perform other processing while the background read operation completes. When the read response arrives, a signal or a thread-based callback can be generated to complete the I/O transaction. Figure 5. Typical flow of the asynchronous non-blocking I/O model The ability to overlap computation and I/O processing in a single process for potentially multiple I/O requests exploits the gap\uff08\u5dee\u8ddd\uff09 between processing speed and I/O speed . While one or more slow I/O requests are pending, the CPU can perform other tasks or, more commonly, operate on already completed I/Os while other I/Os are initiated. NOTE:I feel that the idea in the above paragraph can also be implemented using threads as describe in this article NOTE:Asynchronous IO has the mechanism of notification.Blocked IO mean that the application would be blocked;","title":"Asynchronous non-blocking I/O (AIO)"},{"location":"Programming/IO/IO-model/IO-models/#asynchronous#io","text":"\u7ef4\u57fa\u767e\u79d1 Asynchronous I/O \u7684 Forms \u7ae0\u8282\u5bf9IO form\u7684\u5206\u7c7b\u548c\u672c\u8282\u524d\u9762\u6240\u63cf\u8ff0\u7684POSIX \u7684IO \u5206\u7c7b\u662f\u4e00\u81f4\u7684\u3002 Blocking Non-blocking Asynchronous API write, read write, read + poll / select aio_write, aio_read \u7ef4\u57fa\u767e\u79d1 Asynchronous I/O \u7684 Examples \u7ae0\u8282\u7ed9\u51fa\u7684\u4f8b\u5b50\u503c\u7684\u4e00\u8bfb\u3002","title":"\u7ef4\u57fa\u767e\u79d1 Asynchronous I/O"},{"location":"Programming/IO/IO-model/IO-models/#summary","text":"\u4ece\u4e0a\u9762\u4e09\u7bc7\u6587\u7ae0: 1) UNP 6.1 I/O Multiplexing: The select and poll Functions \u00b6 2) ibm Boost application performance using asynchronous I/O 3) wikipedia Asynchronous I/O \u53ef\u4ee5\u770b\u51fa\uff0c\u5b83\u4eec\u5bf9IO model\u7684\u5206\u7c7b\u662f\u4e0d\u540c\u7684\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5b83\u4eec\u7684\u5206\u7c7b\u90fd\u6ca1\u6709\u9519\u8bef\uff0c\u5bf9blocking\u3001non-blocking \u548c sync\u3001async \u7684\u7528\u6cd5\u4e5f\u6ca1\u6709\u9519\u8bef\uff0c\u5b83\u4eec\u90fd\u662f\u5728IO\u7684\u67d0\u4e2a\u89d2\u5ea6\u6765\u8fdb\u884c\u63cf\u8ff0\u3001\u5206\u7c7b\u7684\u3002","title":"Summary"},{"location":"Programming/IO/IO-model/Asynchronous-IO/","text":"Asynchronous I/O ibm Boost application performance using asynchronous I/O The next section examines this model further, explores the API, and then demonstrates a number of the commands. Motivation for asynchronous I/O From the previous taxonomy(\u5206\u7c7b\u578b) of I/O models, you can see the motivation for AIO. The blocking models require the initiating application to block when the I/O has started. This means that it isn't possible to overlap\uff08\u91cd\u53e0\uff09 processing and I/O at the same time. The synchronous non-blocking model allows overlap of processing and I/O, but it requires that the application check the status of the I/O on a recurring basis. This leaves asynchronous non-blocking I/O, which permits overlap of processing and I/O, including notification of I/O completion. The functionality provided by the select function (asynchronous blocking I/O) is similar to AIO, except that it still blocks. However, it blocks on notifications instead of the I/O call. Introduction to AIO for Linux AIO for Linux AIO first entered the Linux kernel in 2.5 and is now a standard feature of 2.6 production kernels. This section explores the asynchronous I/O model for Linux to help you understand how to apply it in your applications. In a traditional I/O model, there is an I/O channel that is identified by a unique handle. In UNIX\u00ae, these are file descriptors (which are the same for files, pipes, sockets, and so on). In blocking I/O, you initiate a transfer and the system call returns when it's complete or an error has occurred. In asynchronous non-blocking I/O , you have the ability to initiate multiple transfers at the same time. This requires a unique context for each transfer so you can identify it when it completes. In AIO, this is an aiocb (AIO I/O Control Block) structure. This structure contains all of the information about a transfer, including a user buffer for data. When notification for an I/O occurs (called a completion), the aiocb structure is provided to uniquely identify the completed I/O. The API demonstration shows how to do this. AIO API The AIO interface API is quite simple, but it provides the necessary functions for data transfer with a couple of different notification models . Table 1 shows the AIO interface functions, which are further explained later in this section. Table 1. AIO interface APIs API function Description aio_read Request an asynchronous read operation aio_error Check the status of an asynchronous request aio_return Get the return status of a completed asynchronous request aio_write Request an asynchronous operation aio_suspend Suspend the calling process until one or more asynchronous requests have completed (or failed) aio_cancel Cancel an asynchronous I/O request lio_listio Initiate a list of I/O operations Each of these API functions uses the aiocb structure for initiating or checking. This structure has a number of elements, but Listing 1 shows only the ones that you'll need to (or can) use. Listing 1. The aiocb structure showing the relevant fields struct aiocb { int aio_fildes ; // File Descriptor int aio_lio_opcode ; // Valid only for lio_listio (r/w/nop) volatile void * aio_buf ; // Data Buffer size_t aio_nbytes ; // Number of Bytes in Data Buffer struct sigevent aio_sigevent ; // Notification Structure /* Internal fields */ ... }; The sigevent structure tells AIO what to do when the I/O completes. You'll explore this structure in the AIO demonstration. Now I'll show you how the individual API functions for AIO work and how you can use them. aio_read The aio_read function requests an asynchronous read operation for a valid file descriptor. The file descriptor can represent a file, a socket, or even a pipe. The aio_read function has the following prototype: int aio_read ( struct aiocb * aiocbp ); The aio_read function returns immediately after the request has been queued . The return value is zero on success or -1 on error, where errno is defined. NOTE:\u4e5f\u662f\u901a\u8fc7queue\u673a\u5236\u6765\u5b9e\u73b0\u7684\uff1b To perform a read, the application must initialize the aiocb structure. The following short example illustrates filling in the aiocb request structure and using aio_read to perform an asynchronous read request (ignore notification for now). It also shows use of the aio_error function, but I'll explain that later. Listing 2. Sample code for an asynchronous read with aio_read #include <aio.h> int fd , ret ; struct aiocb my_aiocb ; fd = open ( \"file.txt\" , O_RDONLY ); if ( fd < 0 ) perror ( \"open\" ); /* Zero out the aiocb structure (recommended) */ bzero ( ( char * ) & my_aiocb , sizeof ( struct aiocb ) ); /* Allocate a data buffer for the aiocb request */ my_aiocb . aio_buf = malloc ( BUFSIZE + 1 ); if ( ! my_aiocb . aio_buf ) perror ( \"malloc\" ); /* Initialize the necessary fields in the aiocb */ my_aiocb . aio_fildes = fd ; my_aiocb . aio_nbytes = BUFSIZE ; my_aiocb . aio_offset = 0 ; ret = aio_read ( & my_aiocb ); if ( ret < 0 ) perror ( \"aio_read\" ); while ( aio_error ( & my_aiocb ) == EINPROGRESS ) ; if (( ret = aio_return ( & my_iocb )) > 0 ) { /* got ret bytes on the read */ } else { /* read failed, consult errno */ } In Listing 2, after the file from which you're reading data is opened, you zero out your aiocb structure, and then allocate a data buffer. The reference to the data buffer is placed into aio_buf . Subsequently, you initialize the size of the buffer into aio_nbytes . The aio_offset is set to zero (the first offset in the file). You set the file descriptor from which you're reading into aio_fildes . After these fields are set, you call aio_read to request the read. You can then make a call to aio_error to determine the status of the aio_read . As long as the status is EINPROGRESS , you busy-wait until the status changes. At this point, your request has either succeeded or failed. Note the similarities to reading from the file with the standard library functions. In addition to the asynchronous nature of aio_read , another difference is setting the offset for the read. In a typical read call, the offset is maintained for you in the file descriptor context. For each read, the offset is updated so that subsequent reads address the next block of data. This isn't possible with asynchronous I/O because you can perform many read requests simultaneously, so you must specify the offset for each particular read request. Building with the AIO interface You can find the function prototypes and other necessary symbolics in the aio.h header file. When building an application that uses this interface, you must use the POSIX real-time extensions library ( librt ). aio_error The aio_error function is used to determine the status of a request. Its prototype is: int aio_error ( struct aiocb * aiocbp ); This function can return the following: EINPROGRESS , indicating the request has not yet completed ECANCELLED , indicating the request was cancelled by the application -1 , indicating that an error occurred for which you can consult errno aio_return Another difference between asynchronous I/O and standard blocking I/O is that you don't have immediate access to the return status of your function because you're not blocking on the read call. In a standard read call, the return status is provided upon return of the function. With asynchronous I/O, you use the aio_return function. This function has the following prototype: ssize_t aio_return ( struct aiocb * aiocbp ); aio_write The aio_write function is used to request an asynchronous write. Its function prototype is: int aio_write ( struct aiocb * aiocbp ); The aio_write function returns immediately, indicating that the request has been enqueued (with a return of 0 on success and -1 on failure, with errno properly set). This is similar to the read system call, but one behavior difference is worth noting. Recall that the offset to be used is important with the read call. However, with write , the offset is important only if used in a file context where the O_APPEND option is not set. If O_APPEND is set, then the offset is ignored and the data is appended to the end of the file. Otherwise, the aio_offset field determines the offset at which the data is written to the file. aio_suspend TODO aio_cancel TODO lio_listio TODO AIO notifications Now that you've seen the AIO functions that are available, this section digs into the methods that you can use for asynchronous notification . I'll explore asynchronous notification through signals and function callbacks. Asynchronous notification with signals The use of signals for interprocess communication (IPC) is a traditional mechanism in UNIX and is also supported by AIO. In this paradigm, the application defines a signal handler that is invoked when a specified signal occurs. The application then specifies that an asynchronous request will raise a signal when the request has completed. As part of the signal context, the particular aiocb request is provided to keep track of multiple potentially outstanding requests. Listing 5 demonstrates this notification method. Listing 5. Using signals as notification for AIO requests void setup_io ( ... ) { int fd ; struct sigaction sig_act ; struct aiocb my_aiocb ; ... /* Set up the signal handler */ sigemptyset ( & sig_act . sa_mask ); sig_act . sa_flags = SA_SIGINFO ; sig_act . sa_sigaction = aio_completion_handler ; /* Set up the AIO request */ bzero ( ( char * ) & my_aiocb , sizeof ( struct aiocb ) ); my_aiocb . aio_fildes = fd ; my_aiocb . aio_buf = malloc ( BUF_SIZE + 1 ); my_aiocb . aio_nbytes = BUF_SIZE ; my_aiocb . aio_offset = next_offset ; /* Link the AIO request with the Signal Handler */ my_aiocb . aio_sigevent . sigev_notify = SIGEV_SIGNAL ; my_aiocb . aio_sigevent . sigev_signo = SIGIO ; my_aiocb . aio_sigevent . sigev_value . sival_ptr = & my_aiocb ; /* Map the Signal to the Signal Handler */ ret = sigaction ( SIGIO , & sig_act , NULL ); ... ret = aio_read ( & my_aiocb ); } void aio_completion_handler ( int signo , siginfo_t * info , void * context ) { struct aiocb * req ; /* Ensure it's our signal */ if ( info -> si_signo == SIGIO ) { req = ( struct aiocb * ) info -> si_value . sival_ptr ; /* Did the request complete? */ if ( aio_error ( req ) == 0 ) { /* Request completed successfully, get the return status */ ret = aio_return ( req ); } } return ; } In Listing 5, you set up your signal handler to catch the SIGIO signal in the aio_completion_handler function. You then initialize the aio_sigevent structure to raise SIGIO for notification (which is specified via the SIGEV_SIGNAL definition in sigev_notify ). When your read completes, your signal handler extracts the particular aiocb from the signal's si_value structure and checks the error status and return status to determine I/O completion. For performance, the completion handler is an ideal spot to continue the I/O by requesting the next asynchronous transfer. In this way, when completion of one transfer has completed, you immediately start the next. Asynchronous notification with callbacks An alternative notification mechanism is the system callback. Instead of raising a signal for notification, this mechanism calls a function in user-space for notification. You initialize the aiocb reference into the sigevent structure to uniquely identify the particular request being completed; see Listing 6. Listing 6. Using thread callback notification for AIO requests void setup_io ( ... ) { int fd ; struct aiocb my_aiocb ; ... /* Set up the AIO request */ bzero ( ( char * ) & my_aiocb , sizeof ( struct aiocb ) ); my_aiocb . aio_fildes = fd ; my_aiocb . aio_buf = malloc ( BUF_SIZE + 1 ); my_aiocb . aio_nbytes = BUF_SIZE ; my_aiocb . aio_offset = next_offset ; /* Link the AIO request with a thread callback */ my_aiocb . aio_sigevent . sigev_notify = SIGEV_THREAD ; my_aiocb . aio_sigevent . notify_function = aio_completion_handler ; my_aiocb . aio_sigevent . notify_attributes = NULL ; my_aiocb . aio_sigevent . sigev_value . sival_ptr = & my_aiocb ; ... ret = aio_read ( & my_aiocb ); } void aio_completion_handler ( sigval_t sigval ) { struct aiocb * req ; req = ( struct aiocb * ) sigval . sival_ptr ; /* Did the request complete? */ if ( aio_error ( req ) == 0 ) { /* Request completed successfully, get the return status */ ret = aio_return ( req ); } return ; } In Listing 6, after creating your aiocb request, you request a thread callback using SIGEV_THREAD for the notification method. You then specify the particular notification handler and load the context to be passed to the handler (in this case, a reference to the aiocb request itself). In the handler, you simply cast the incoming sigval pointer and use the AIO functions to validate the completion of the request. System tuning for AIO The proc file system contains two virtual files that can be tuned for asynchronous I/O performance: The /proc/sys/fs/aio-nr file provides the current number of system-wide asynchronous I/O requests. The /proc/sys/fs/aio-max-nr file is the maximum number of allowable concurrent requests. The maximum is commonly 64KB, which is adequate for most applications. Summary Using asynchronous I/O can help you build faster and more efficient I/O applications. If your application can overlap processing and I/O, then AIO can help you build an application that more efficiently uses the CPU resources available to you. While this I/O model differs from the traditional blocking patterns found in most Linux applications, the asynchronous notification model is conceptually simple and can simplify your design.","title":"Introduction"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#asynchronous#io","text":"","title":"Asynchronous I/O"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#ibm#boost#application#performance#using#asynchronous#io","text":"The next section examines this model further, explores the API, and then demonstrates a number of the commands.","title":"ibm Boost application performance using asynchronous I/O"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#motivation#for#asynchronous#io","text":"From the previous taxonomy(\u5206\u7c7b\u578b) of I/O models, you can see the motivation for AIO. The blocking models require the initiating application to block when the I/O has started. This means that it isn't possible to overlap\uff08\u91cd\u53e0\uff09 processing and I/O at the same time. The synchronous non-blocking model allows overlap of processing and I/O, but it requires that the application check the status of the I/O on a recurring basis. This leaves asynchronous non-blocking I/O, which permits overlap of processing and I/O, including notification of I/O completion. The functionality provided by the select function (asynchronous blocking I/O) is similar to AIO, except that it still blocks. However, it blocks on notifications instead of the I/O call.","title":"Motivation for asynchronous I/O"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#introduction#to#aio#for#linux","text":"AIO for Linux AIO first entered the Linux kernel in 2.5 and is now a standard feature of 2.6 production kernels. This section explores the asynchronous I/O model for Linux to help you understand how to apply it in your applications. In a traditional I/O model, there is an I/O channel that is identified by a unique handle. In UNIX\u00ae, these are file descriptors (which are the same for files, pipes, sockets, and so on). In blocking I/O, you initiate a transfer and the system call returns when it's complete or an error has occurred. In asynchronous non-blocking I/O , you have the ability to initiate multiple transfers at the same time. This requires a unique context for each transfer so you can identify it when it completes. In AIO, this is an aiocb (AIO I/O Control Block) structure. This structure contains all of the information about a transfer, including a user buffer for data. When notification for an I/O occurs (called a completion), the aiocb structure is provided to uniquely identify the completed I/O. The API demonstration shows how to do this.","title":"Introduction to AIO for Linux"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#aio#api","text":"The AIO interface API is quite simple, but it provides the necessary functions for data transfer with a couple of different notification models . Table 1 shows the AIO interface functions, which are further explained later in this section. Table 1. AIO interface APIs API function Description aio_read Request an asynchronous read operation aio_error Check the status of an asynchronous request aio_return Get the return status of a completed asynchronous request aio_write Request an asynchronous operation aio_suspend Suspend the calling process until one or more asynchronous requests have completed (or failed) aio_cancel Cancel an asynchronous I/O request lio_listio Initiate a list of I/O operations Each of these API functions uses the aiocb structure for initiating or checking. This structure has a number of elements, but Listing 1 shows only the ones that you'll need to (or can) use. Listing 1. The aiocb structure showing the relevant fields struct aiocb { int aio_fildes ; // File Descriptor int aio_lio_opcode ; // Valid only for lio_listio (r/w/nop) volatile void * aio_buf ; // Data Buffer size_t aio_nbytes ; // Number of Bytes in Data Buffer struct sigevent aio_sigevent ; // Notification Structure /* Internal fields */ ... }; The sigevent structure tells AIO what to do when the I/O completes. You'll explore this structure in the AIO demonstration. Now I'll show you how the individual API functions for AIO work and how you can use them.","title":"AIO API"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#aio_read","text":"The aio_read function requests an asynchronous read operation for a valid file descriptor. The file descriptor can represent a file, a socket, or even a pipe. The aio_read function has the following prototype: int aio_read ( struct aiocb * aiocbp ); The aio_read function returns immediately after the request has been queued . The return value is zero on success or -1 on error, where errno is defined. NOTE:\u4e5f\u662f\u901a\u8fc7queue\u673a\u5236\u6765\u5b9e\u73b0\u7684\uff1b To perform a read, the application must initialize the aiocb structure. The following short example illustrates filling in the aiocb request structure and using aio_read to perform an asynchronous read request (ignore notification for now). It also shows use of the aio_error function, but I'll explain that later. Listing 2. Sample code for an asynchronous read with aio_read #include <aio.h> int fd , ret ; struct aiocb my_aiocb ; fd = open ( \"file.txt\" , O_RDONLY ); if ( fd < 0 ) perror ( \"open\" ); /* Zero out the aiocb structure (recommended) */ bzero ( ( char * ) & my_aiocb , sizeof ( struct aiocb ) ); /* Allocate a data buffer for the aiocb request */ my_aiocb . aio_buf = malloc ( BUFSIZE + 1 ); if ( ! my_aiocb . aio_buf ) perror ( \"malloc\" ); /* Initialize the necessary fields in the aiocb */ my_aiocb . aio_fildes = fd ; my_aiocb . aio_nbytes = BUFSIZE ; my_aiocb . aio_offset = 0 ; ret = aio_read ( & my_aiocb ); if ( ret < 0 ) perror ( \"aio_read\" ); while ( aio_error ( & my_aiocb ) == EINPROGRESS ) ; if (( ret = aio_return ( & my_iocb )) > 0 ) { /* got ret bytes on the read */ } else { /* read failed, consult errno */ } In Listing 2, after the file from which you're reading data is opened, you zero out your aiocb structure, and then allocate a data buffer. The reference to the data buffer is placed into aio_buf . Subsequently, you initialize the size of the buffer into aio_nbytes . The aio_offset is set to zero (the first offset in the file). You set the file descriptor from which you're reading into aio_fildes . After these fields are set, you call aio_read to request the read. You can then make a call to aio_error to determine the status of the aio_read . As long as the status is EINPROGRESS , you busy-wait until the status changes. At this point, your request has either succeeded or failed. Note the similarities to reading from the file with the standard library functions. In addition to the asynchronous nature of aio_read , another difference is setting the offset for the read. In a typical read call, the offset is maintained for you in the file descriptor context. For each read, the offset is updated so that subsequent reads address the next block of data. This isn't possible with asynchronous I/O because you can perform many read requests simultaneously, so you must specify the offset for each particular read request. Building with the AIO interface You can find the function prototypes and other necessary symbolics in the aio.h header file. When building an application that uses this interface, you must use the POSIX real-time extensions library ( librt ).","title":"aio_read"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#aio_error","text":"The aio_error function is used to determine the status of a request. Its prototype is: int aio_error ( struct aiocb * aiocbp ); This function can return the following: EINPROGRESS , indicating the request has not yet completed ECANCELLED , indicating the request was cancelled by the application -1 , indicating that an error occurred for which you can consult errno","title":"aio_error"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#aio_return","text":"Another difference between asynchronous I/O and standard blocking I/O is that you don't have immediate access to the return status of your function because you're not blocking on the read call. In a standard read call, the return status is provided upon return of the function. With asynchronous I/O, you use the aio_return function. This function has the following prototype: ssize_t aio_return ( struct aiocb * aiocbp );","title":"aio_return"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#aio_write","text":"The aio_write function is used to request an asynchronous write. Its function prototype is: int aio_write ( struct aiocb * aiocbp ); The aio_write function returns immediately, indicating that the request has been enqueued (with a return of 0 on success and -1 on failure, with errno properly set). This is similar to the read system call, but one behavior difference is worth noting. Recall that the offset to be used is important with the read call. However, with write , the offset is important only if used in a file context where the O_APPEND option is not set. If O_APPEND is set, then the offset is ignored and the data is appended to the end of the file. Otherwise, the aio_offset field determines the offset at which the data is written to the file.","title":"aio_write"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#aio_suspend","text":"TODO","title":"aio_suspend"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#aio_cancel","text":"TODO","title":"aio_cancel"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#lio_listio","text":"TODO","title":"lio_listio"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#aio#notifications","text":"Now that you've seen the AIO functions that are available, this section digs into the methods that you can use for asynchronous notification . I'll explore asynchronous notification through signals and function callbacks.","title":"AIO notifications"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#asynchronous#notification#with#signals","text":"The use of signals for interprocess communication (IPC) is a traditional mechanism in UNIX and is also supported by AIO. In this paradigm, the application defines a signal handler that is invoked when a specified signal occurs. The application then specifies that an asynchronous request will raise a signal when the request has completed. As part of the signal context, the particular aiocb request is provided to keep track of multiple potentially outstanding requests. Listing 5 demonstrates this notification method. Listing 5. Using signals as notification for AIO requests void setup_io ( ... ) { int fd ; struct sigaction sig_act ; struct aiocb my_aiocb ; ... /* Set up the signal handler */ sigemptyset ( & sig_act . sa_mask ); sig_act . sa_flags = SA_SIGINFO ; sig_act . sa_sigaction = aio_completion_handler ; /* Set up the AIO request */ bzero ( ( char * ) & my_aiocb , sizeof ( struct aiocb ) ); my_aiocb . aio_fildes = fd ; my_aiocb . aio_buf = malloc ( BUF_SIZE + 1 ); my_aiocb . aio_nbytes = BUF_SIZE ; my_aiocb . aio_offset = next_offset ; /* Link the AIO request with the Signal Handler */ my_aiocb . aio_sigevent . sigev_notify = SIGEV_SIGNAL ; my_aiocb . aio_sigevent . sigev_signo = SIGIO ; my_aiocb . aio_sigevent . sigev_value . sival_ptr = & my_aiocb ; /* Map the Signal to the Signal Handler */ ret = sigaction ( SIGIO , & sig_act , NULL ); ... ret = aio_read ( & my_aiocb ); } void aio_completion_handler ( int signo , siginfo_t * info , void * context ) { struct aiocb * req ; /* Ensure it's our signal */ if ( info -> si_signo == SIGIO ) { req = ( struct aiocb * ) info -> si_value . sival_ptr ; /* Did the request complete? */ if ( aio_error ( req ) == 0 ) { /* Request completed successfully, get the return status */ ret = aio_return ( req ); } } return ; } In Listing 5, you set up your signal handler to catch the SIGIO signal in the aio_completion_handler function. You then initialize the aio_sigevent structure to raise SIGIO for notification (which is specified via the SIGEV_SIGNAL definition in sigev_notify ). When your read completes, your signal handler extracts the particular aiocb from the signal's si_value structure and checks the error status and return status to determine I/O completion. For performance, the completion handler is an ideal spot to continue the I/O by requesting the next asynchronous transfer. In this way, when completion of one transfer has completed, you immediately start the next.","title":"Asynchronous notification with signals"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#asynchronous#notification#with#callbacks","text":"An alternative notification mechanism is the system callback. Instead of raising a signal for notification, this mechanism calls a function in user-space for notification. You initialize the aiocb reference into the sigevent structure to uniquely identify the particular request being completed; see Listing 6. Listing 6. Using thread callback notification for AIO requests void setup_io ( ... ) { int fd ; struct aiocb my_aiocb ; ... /* Set up the AIO request */ bzero ( ( char * ) & my_aiocb , sizeof ( struct aiocb ) ); my_aiocb . aio_fildes = fd ; my_aiocb . aio_buf = malloc ( BUF_SIZE + 1 ); my_aiocb . aio_nbytes = BUF_SIZE ; my_aiocb . aio_offset = next_offset ; /* Link the AIO request with a thread callback */ my_aiocb . aio_sigevent . sigev_notify = SIGEV_THREAD ; my_aiocb . aio_sigevent . notify_function = aio_completion_handler ; my_aiocb . aio_sigevent . notify_attributes = NULL ; my_aiocb . aio_sigevent . sigev_value . sival_ptr = & my_aiocb ; ... ret = aio_read ( & my_aiocb ); } void aio_completion_handler ( sigval_t sigval ) { struct aiocb * req ; req = ( struct aiocb * ) sigval . sival_ptr ; /* Did the request complete? */ if ( aio_error ( req ) == 0 ) { /* Request completed successfully, get the return status */ ret = aio_return ( req ); } return ; } In Listing 6, after creating your aiocb request, you request a thread callback using SIGEV_THREAD for the notification method. You then specify the particular notification handler and load the context to be passed to the handler (in this case, a reference to the aiocb request itself). In the handler, you simply cast the incoming sigval pointer and use the AIO functions to validate the completion of the request.","title":"Asynchronous notification with callbacks"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#system#tuning#for#aio","text":"The proc file system contains two virtual files that can be tuned for asynchronous I/O performance: The /proc/sys/fs/aio-nr file provides the current number of system-wide asynchronous I/O requests. The /proc/sys/fs/aio-max-nr file is the maximum number of allowable concurrent requests. The maximum is commonly 64KB, which is adequate for most applications.","title":"System tuning for AIO"},{"location":"Programming/IO/IO-model/Asynchronous-IO/#summary","text":"Using asynchronous I/O can help you build faster and more efficient I/O applications. If your application can overlap processing and I/O, then AIO can help you build an application that more efficiently uses the CPU resources available to you. While this I/O model differs from the traditional blocking patterns found in most Linux applications, the asynchronous notification model is conceptually simple and can simplify your design.","title":"Summary"},{"location":"Programming/IO/IO-model/IO-multiplexing/Epoll/man-7-epoll/","text":"EPOLL(7) NAME epoll - I/O event notification facility SUMMARY : \u663e\u7136 epoll \u7684\u672c\u8d28\u662f**event notifier** SYNOPSIS #include <sys/epoll.h> DESCRIPTION The epoll API performs a similar task to poll (2) : monitoring multiple file descriptors to see if I/O is possible on any of them. The epoll API can be used either as an edge-triggered or a level-triggered interface and scales well to large numbers of watched file descriptors. The central concept of the epoll API is the epoll instance , an in-kernel data structure which, from a user-space perspective, can be considered as a container for two lists: The interest list (sometimes also called the epoll set ): the set of file descriptors that the process has registered an interest in monitoring. The ready list : the set of file descriptors that are \"ready\" for I/O. The ready list is a subset of (or, more precisely, a set of references to) the file descriptors in the interest list that is dynamically populated by the kernel as a result of I/O activity on those file descriptors. The following system calls are provided to create and manage an epoll instance: epoll_create (2) creates an epoll instance and returns a file descriptor referring to that instance. (The more recent epoll_create1 (2) extends the functionality of epoll_create (2).) Interest in particular file descriptors is then registered via epoll_ctl (2) . The set of file descriptors currently registered on an epoll instance is sometimes called an ***epoll* set**. epoll_wait (2) waits for I/O events, blocking the calling thread if no events are currently available. \u5982\u679c\u6709event\u5df2\u7ecfavailable\u4e86\uff0c\u5219\u7acb\u5373\u8fd4\u56de\u8fd9\u4e2aevent\u5bf9\u5e94\u7684 fd \u3002 Level-triggered and edge-triggered The epoll event distribution interface is able to behave both as edge-triggered (ET) and as level-triggered (LT). The difference between the two mechanisms can be described as follows. Suppose that this scenario happens: The file descriptor that represents the read side of a pipe ( rfd ) is registered on the epoll instance. A pipe writer writes 2 kB of data on the write side of the pipe. A call to epoll_wait(2) is done that will return rfd as a ready file descriptor . The pipe reader reads 1 kB of data from rfd . A call to epoll_wait(2) is done. If the rfd file descriptor has been added to the epoll interface using the EPOLLET (edge-triggered) flag, the call to epoll_wait(2) done in step 5 will probably hang despite the available data still present in the file input buffer ; meanwhile the remote peer might be expecting a response based on the data it already sent. The reason for this is that edge-triggered mode delivers events only when changes occur on the monitored file descriptor. So, in step 5 the caller might end up waiting for some data that is already present inside the input buffer. In the above example, an event on rfd will be generated because of the write done in 2 and the event is consumed in 3. Since the read operation done in 4 does not consume the whole buffer data, the call to epoll_wait(2) done in step 5 might block indefinitely. \u5982\u679c\u5df2\u4f7f\u7528EPOLLET\uff08\u8fb9\u7f18\u89e6\u53d1\uff09\u6807\u5fd7\u5c06rfd\u6587\u4ef6\u63cf\u8ff0\u7b26\u6dfb\u52a0\u5230epoll\u63a5\u53e3\uff0c\u5219\u5c3d\u7ba1\u6587\u4ef6\u8f93\u5165\u7f13\u51b2\u533a\u4e2d\u4ecd\u5b58\u5728\u53ef\u7528\u6570\u636e\uff0c\u4f46\u5728\u6b65\u9aa45\u4e2d\u5b8c\u6210\u7684\u5bf9epoll_wait\uff082\uff09\u7684\u8c03\u7528\u53ef\u80fd\u4f1a\u6302\u8d77; \u540c\u65f6\uff0c\u8fdc\u7a0b\u5bf9\u7b49\u4f53\u53ef\u80fd\u671f\u671b\u57fa\u4e8e\u5176\u5df2\u53d1\u9001\u7684\u6570\u636e\u8fdb\u884c\u54cd\u5e94\u3002 \u539f\u56e0\u662f\u8fb9\u7f18\u89e6\u53d1\u6a21\u5f0f\u4ec5\u5728\u53d7\u76d1\u89c6\u6587\u4ef6\u63cf\u8ff0\u7b26\u53d1\u751f\u66f4\u6539\u65f6\u624d\u4f20\u9012\u4e8b\u4ef6\u3002 \u56e0\u6b64\uff0c\u5728\u6b65\u9aa45\u4e2d\uff0c\u8c03\u7528\u8005\u53ef\u80fd\u6700\u7ec8\u7b49\u5f85\u8f93\u5165\u7f13\u51b2\u533a\u5185\u5df2\u5b58\u5728\u7684\u67d0\u4e9b\u6570\u636e\u3002 \u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u5c06\u751f\u6210rfd\u4e0a\u7684\u4e8b\u4ef6\uff0c\u56e0\u4e3a\u5199\u5165\u57282\u4e2d\u5b8c\u6210\u5e76\u4e14\u4e8b\u4ef6\u57283\u4e2d\u6d88\u8017\u3002\u7531\u4e8e\u57284\u4e2d\u5b8c\u6210\u7684\u8bfb\u53d6\u64cd\u4f5c\u4e0d\u6d88\u8017\u6574\u4e2a\u7f13\u51b2\u533a\u6570\u636e\uff0c\u56e0\u6b64\u5bf9epoll_wait\uff082\uff09\u7684\u8c03\u7528\u5df2\u5b8c\u6210 \u5728\u6b65\u9aa45\u4e2d\u53ef\u80fd\u4f1a\u65e0\u9650\u671f\u5730\u963b\u6b62\u3002 An application that employs the EPOLLET flag should use nonblocking file descriptors to avoid having a blocking read or write starve a task that is handling multiple file descriptors. The suggested way to use epoll as an edge-triggered ( EPOLLET ) interface is as follows: i with nonblocking file descriptors; and ii by waiting for an event only after read(2) or write(2) return EAGAIN . SUMMARY : \u8981\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u542b\u4e49\uff0c\u5c31\u9700\u8981\u641e\u6e05\u695ablocking IO\u548cnonblocking IO\uff0c\u4ee5\u53ca\u5b83\u4eec\u548c epoll \u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u53c2\u8003\u4e0b\u9762\u7684\u4e24\u7bc7\u6587\u7ae0\uff1a Why having to use non-blocking fd in a edge triggered epoll function? Blocking I/O, Nonblocking I/O, And Epoll By contrast, when used as a level-triggered interface (the default, when EPOLLET is not specified), epoll is simply a faster poll(2), and can be used wherever the latter is used since it shares the same semantics. Since even with edge-triggered epoll , multiple events can be generated upon receipt of multiple chunks of data, the caller has the option to specify the EPOLLONESHOT flag, to tell epoll to disable the associated file descriptor after the receipt of an event with epoll_wait(2) . When the EPOLLONESHOT flag is specified, it is the caller's responsibility to rearm the file descriptor using epoll_ctl(2) with EPOLL_CTL_MOD . If multiple threads (or processes, if child processes have inherited the epoll file descriptor across fork(2) ) are blocked in epoll_wait(2) waiting on the same the same epoll file descriptor and a file descriptor in the interest list that is marked for edge-triggered ( EPOLLET ) notification becomes ready, just one of the threads (or processes) is awoken from epoll_wait(2) . This provides a useful optimization for avoiding \"thundering herd\" wake-ups in some scenarios. Interaction with autosleep If the system is in autosleep mode via /sys/power/autosleep and an event happens which wakes the device from sleep, the device driver will keep the device awake only until that event is queued. To keep the device awake until the event has been processed, it is necessary to use the epoll_ctl(2) EPOLLWAKEUP flag. When the EPOLLWAKEUP flag is set in the events field for a struct epoll_event , the system will be kept awake from the moment the event is queued, through the epoll_wait(2) call which returns the event until the subsequent epoll_wait(2) call. If the event should keep the system awake beyond that time, then a separate wake_lock should be taken before the second epoll_wait(2) call. /proc interfaces The following interfaces can be used to limit the amount of kernel memory consumed by epoll : /proc/sys/fs/epoll/max_user_watches (since Linux 2.6.28) This specifies a limit on the total number of file descriptors that a user can register across all epoll instances on the system. The limit is per real user ID . Each registered file descriptor costs roughly 90 bytes on a 32-bit kernel, and roughly 160 bytes on a 64-bit kernel. Currently, the default value for max_user_watches is 1/25 (4%) of the available low memory, divided by the registration cost in bytes. Example for suggested usage While the usage of epoll when employed as a level-triggered interface does have the same semantics as poll(2), the edge-triggered usage requires more clarification to avoid stalls in the application event loop. In this example, listener is a nonblocking socket on which listen(2) has been called. The function do_use_fd() uses the new ready file descriptor until EAGAIN is returned by either read(2) or write(2) . An event-driven state machine application should, after having received EAGAIN , record its current state so that at the next call to do_use_fd() it will continue to read(2) or write(2) from where it stopped before. #define MAX_EVENTS 10 struct epoll_event ev , events [ MAX_EVENTS ]; int listen_sock , conn_sock , nfds , epollfd ; /* Code to set up listening socket, 'listen_sock', (socket(), bind(), listen()) omitted */ epollfd = epoll_create1 ( 0 ); if ( epollfd == -1 ) { perror ( \"epoll_create1\" ); exit ( EXIT_FAILURE ); } ev . events = EPOLLIN ; ev . data . fd = listen_sock ; if ( epoll_ctl ( epollfd , EPOLL_CTL_ADD , listen_sock , & ev ) == -1 ) { perror ( \"epoll_ctl: listen_sock\" ); exit ( EXIT_FAILURE ); } for (;;) { nfds = epoll_wait ( epollfd , events , MAX_EVENTS , -1 ); if ( nfds == -1 ) { perror ( \"epoll_wait\" ); exit ( EXIT_FAILURE ); } for ( n = 0 ; n < nfds ; ++ n ) { if ( events [ n ]. data . fd == listen_sock ) { conn_sock = accept ( listen_sock , ( struct sockaddr * ) & addr , & addrlen ); if ( conn_sock == -1 ) { perror ( \"accept\" ); exit ( EXIT_FAILURE ); } setnonblocking ( conn_sock ); ev . events = EPOLLIN | EPOLLET ; ev . data . fd = conn_sock ; if ( epoll_ctl ( epollfd , EPOLL_CTL_ADD , conn_sock , & ev ) == -1 ) { perror ( \"epoll_ctl: conn_sock\" ); exit ( EXIT_FAILURE ); } } else { do_use_fd ( events [ n ]. data . fd ); } } } When used as an edge-triggered interface, for performance reasons, it is possible to add the file descriptor inside the epoll interface ( EPOLL_CTL_ADD ) once by specifying ( EPOLLIN|EPOLLOUT ). This allows you to avoid continuously switching between EPOLLIN and EPOLLOUT calling epoll_ctl(2) with EPOLL_CTL_MOD . Questions and answers What is the key used to distinguish the file descriptors registered in an interest list? The key is the combination of the file descriptor number and the open file description (also known as an \"open file handle\", the kernel's internal representation of an open file). What happens if you register the same file descriptor on an epoll instance twice? You will probably get EEXIST . However, it is possible to add a duplicate ( dup(2) , dup2(2) , fcntl(2) F_DUPFD ) file descriptor to the same epoll instance . This can be a useful technique for filtering events, if the duplicate file descriptors are registered with different events masks. Can two epoll instances wait for the same file descriptor? If so, are events reported to both epoll file descriptors? Yes, and events would be reported to both. However, careful pro\u2010 gramming may be needed to do this correctly. Is the epoll file descriptor itself poll/epoll/selectable? Yes. If an epoll file descriptor has events waiting, then it will indicate as being readable. What happens if one attempts to put an epoll file descriptor into its own file descriptor set? The epoll_ctl(2) call fails (EINVAL). However, you can add an epoll file descriptor inside another epoll file descriptor set. Can I send an epoll file descriptor over a UNIX domain socket to another process? Yes, but it does not make sense to do this, since the receiving process would not have copies of the file descriptors in the interest list. Will closing a file descriptor cause it to be removed from all epoll interest lists? Yes, but be aware of the following point. A file descriptor is a reference to an open file description (see open(2)). Whenever a file descriptor is duplicated via dup(2), dup2(2), fcntl(2) F_DUPFD, or fork(2), a new file descriptor referring to the same open file description is created. An open file description con\u2010 tinues to exist until all file descriptors referring to it have been closed. A file descriptor is removed from an interest list only after all the file descriptors referring to the underlying open file description have been closed. This means that even after a file descriptor that is part of an interest list has been closed, events may be reported for that file descriptor if other file descriptors referring to the same underlying file description remain open. To prevent this happening, the file descriptor must be explicitly removed from the interest list (using epoll_ctl(2) EPOLL_CTL_DEL) before it is duplicated. Alternatively, the application must ensure that all file descriptors are closed (which may be difficult if file descriptors were duplicated behind the scenes by library functions that used dup(2) or fork(2)). If more than one event occurs between epoll_wait(2) calls, are they combined or reported separately? They will be combined. Does an operation on a file descriptor affect the already col\u2010 lected but not yet reported events? You can do two operations on an existing file descriptor. Remove would be meaningless for this case. Modify will reread available I/O. Do I need to continuously read/write a file descriptor until EAGAIN when using the EPOLLET flag (edge-triggered behavior)? Receiving an event from epoll_wait(2) should suggest to you that such file descriptor is ready for the requested I/O operation. You must consider it ready until the next (nonblocking) read/write yields EAGAIN. When and how you will use the file descriptor is entirely up to you. For packet/token-oriented files (e.g., datagram socket, terminal in canonical mode), the only way to detect the end of the read/write I/O space is to continue to read/write until EAGAIN. For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition that the read/write I/O space is exhausted can also be detected by checking the amount of data read from / written to the target file descriptor. For example, if you call read(2) by asking to read a certain amount of data and read(2) returns a lower number of bytes, you can be sure of having exhausted the read I/O space for the file descriptor. The same is true when writing using write(2). (Avoid this latter technique if you can\u2010 not guarantee that the monitored file descriptor always refers to a stream-oriented file.)","title":"man-7-epoll"},{"location":"Programming/IO/IO-model/IO-multiplexing/Epoll/man-7-epoll/#epoll7","text":"","title":"EPOLL(7)"},{"location":"Programming/IO/IO-model/IO-multiplexing/Epoll/man-7-epoll/#name","text":"epoll - I/O event notification facility SUMMARY : \u663e\u7136 epoll \u7684\u672c\u8d28\u662f**event notifier**","title":"NAME"},{"location":"Programming/IO/IO-model/IO-multiplexing/Epoll/man-7-epoll/#synopsis","text":"#include <sys/epoll.h>","title":"SYNOPSIS"},{"location":"Programming/IO/IO-model/IO-multiplexing/Epoll/man-7-epoll/#description","text":"The epoll API performs a similar task to poll (2) : monitoring multiple file descriptors to see if I/O is possible on any of them. The epoll API can be used either as an edge-triggered or a level-triggered interface and scales well to large numbers of watched file descriptors. The central concept of the epoll API is the epoll instance , an in-kernel data structure which, from a user-space perspective, can be considered as a container for two lists: The interest list (sometimes also called the epoll set ): the set of file descriptors that the process has registered an interest in monitoring. The ready list : the set of file descriptors that are \"ready\" for I/O. The ready list is a subset of (or, more precisely, a set of references to) the file descriptors in the interest list that is dynamically populated by the kernel as a result of I/O activity on those file descriptors. The following system calls are provided to create and manage an epoll instance: epoll_create (2) creates an epoll instance and returns a file descriptor referring to that instance. (The more recent epoll_create1 (2) extends the functionality of epoll_create (2).) Interest in particular file descriptors is then registered via epoll_ctl (2) . The set of file descriptors currently registered on an epoll instance is sometimes called an ***epoll* set**. epoll_wait (2) waits for I/O events, blocking the calling thread if no events are currently available. \u5982\u679c\u6709event\u5df2\u7ecfavailable\u4e86\uff0c\u5219\u7acb\u5373\u8fd4\u56de\u8fd9\u4e2aevent\u5bf9\u5e94\u7684 fd \u3002","title":"DESCRIPTION"},{"location":"Programming/IO/IO-model/IO-multiplexing/Epoll/man-7-epoll/#level-triggered#and#edge-triggered","text":"The epoll event distribution interface is able to behave both as edge-triggered (ET) and as level-triggered (LT). The difference between the two mechanisms can be described as follows. Suppose that this scenario happens: The file descriptor that represents the read side of a pipe ( rfd ) is registered on the epoll instance. A pipe writer writes 2 kB of data on the write side of the pipe. A call to epoll_wait(2) is done that will return rfd as a ready file descriptor . The pipe reader reads 1 kB of data from rfd . A call to epoll_wait(2) is done. If the rfd file descriptor has been added to the epoll interface using the EPOLLET (edge-triggered) flag, the call to epoll_wait(2) done in step 5 will probably hang despite the available data still present in the file input buffer ; meanwhile the remote peer might be expecting a response based on the data it already sent. The reason for this is that edge-triggered mode delivers events only when changes occur on the monitored file descriptor. So, in step 5 the caller might end up waiting for some data that is already present inside the input buffer. In the above example, an event on rfd will be generated because of the write done in 2 and the event is consumed in 3. Since the read operation done in 4 does not consume the whole buffer data, the call to epoll_wait(2) done in step 5 might block indefinitely. \u5982\u679c\u5df2\u4f7f\u7528EPOLLET\uff08\u8fb9\u7f18\u89e6\u53d1\uff09\u6807\u5fd7\u5c06rfd\u6587\u4ef6\u63cf\u8ff0\u7b26\u6dfb\u52a0\u5230epoll\u63a5\u53e3\uff0c\u5219\u5c3d\u7ba1\u6587\u4ef6\u8f93\u5165\u7f13\u51b2\u533a\u4e2d\u4ecd\u5b58\u5728\u53ef\u7528\u6570\u636e\uff0c\u4f46\u5728\u6b65\u9aa45\u4e2d\u5b8c\u6210\u7684\u5bf9epoll_wait\uff082\uff09\u7684\u8c03\u7528\u53ef\u80fd\u4f1a\u6302\u8d77; \u540c\u65f6\uff0c\u8fdc\u7a0b\u5bf9\u7b49\u4f53\u53ef\u80fd\u671f\u671b\u57fa\u4e8e\u5176\u5df2\u53d1\u9001\u7684\u6570\u636e\u8fdb\u884c\u54cd\u5e94\u3002 \u539f\u56e0\u662f\u8fb9\u7f18\u89e6\u53d1\u6a21\u5f0f\u4ec5\u5728\u53d7\u76d1\u89c6\u6587\u4ef6\u63cf\u8ff0\u7b26\u53d1\u751f\u66f4\u6539\u65f6\u624d\u4f20\u9012\u4e8b\u4ef6\u3002 \u56e0\u6b64\uff0c\u5728\u6b65\u9aa45\u4e2d\uff0c\u8c03\u7528\u8005\u53ef\u80fd\u6700\u7ec8\u7b49\u5f85\u8f93\u5165\u7f13\u51b2\u533a\u5185\u5df2\u5b58\u5728\u7684\u67d0\u4e9b\u6570\u636e\u3002 \u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u5c06\u751f\u6210rfd\u4e0a\u7684\u4e8b\u4ef6\uff0c\u56e0\u4e3a\u5199\u5165\u57282\u4e2d\u5b8c\u6210\u5e76\u4e14\u4e8b\u4ef6\u57283\u4e2d\u6d88\u8017\u3002\u7531\u4e8e\u57284\u4e2d\u5b8c\u6210\u7684\u8bfb\u53d6\u64cd\u4f5c\u4e0d\u6d88\u8017\u6574\u4e2a\u7f13\u51b2\u533a\u6570\u636e\uff0c\u56e0\u6b64\u5bf9epoll_wait\uff082\uff09\u7684\u8c03\u7528\u5df2\u5b8c\u6210 \u5728\u6b65\u9aa45\u4e2d\u53ef\u80fd\u4f1a\u65e0\u9650\u671f\u5730\u963b\u6b62\u3002 An application that employs the EPOLLET flag should use nonblocking file descriptors to avoid having a blocking read or write starve a task that is handling multiple file descriptors. The suggested way to use epoll as an edge-triggered ( EPOLLET ) interface is as follows: i with nonblocking file descriptors; and ii by waiting for an event only after read(2) or write(2) return EAGAIN . SUMMARY : \u8981\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u542b\u4e49\uff0c\u5c31\u9700\u8981\u641e\u6e05\u695ablocking IO\u548cnonblocking IO\uff0c\u4ee5\u53ca\u5b83\u4eec\u548c epoll \u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u53c2\u8003\u4e0b\u9762\u7684\u4e24\u7bc7\u6587\u7ae0\uff1a Why having to use non-blocking fd in a edge triggered epoll function? Blocking I/O, Nonblocking I/O, And Epoll By contrast, when used as a level-triggered interface (the default, when EPOLLET is not specified), epoll is simply a faster poll(2), and can be used wherever the latter is used since it shares the same semantics. Since even with edge-triggered epoll , multiple events can be generated upon receipt of multiple chunks of data, the caller has the option to specify the EPOLLONESHOT flag, to tell epoll to disable the associated file descriptor after the receipt of an event with epoll_wait(2) . When the EPOLLONESHOT flag is specified, it is the caller's responsibility to rearm the file descriptor using epoll_ctl(2) with EPOLL_CTL_MOD . If multiple threads (or processes, if child processes have inherited the epoll file descriptor across fork(2) ) are blocked in epoll_wait(2) waiting on the same the same epoll file descriptor and a file descriptor in the interest list that is marked for edge-triggered ( EPOLLET ) notification becomes ready, just one of the threads (or processes) is awoken from epoll_wait(2) . This provides a useful optimization for avoiding \"thundering herd\" wake-ups in some scenarios.","title":"Level-triggered and edge-triggered"},{"location":"Programming/IO/IO-model/IO-multiplexing/Epoll/man-7-epoll/#interaction#with#autosleep","text":"If the system is in autosleep mode via /sys/power/autosleep and an event happens which wakes the device from sleep, the device driver will keep the device awake only until that event is queued. To keep the device awake until the event has been processed, it is necessary to use the epoll_ctl(2) EPOLLWAKEUP flag. When the EPOLLWAKEUP flag is set in the events field for a struct epoll_event , the system will be kept awake from the moment the event is queued, through the epoll_wait(2) call which returns the event until the subsequent epoll_wait(2) call. If the event should keep the system awake beyond that time, then a separate wake_lock should be taken before the second epoll_wait(2) call.","title":"Interaction with autosleep"},{"location":"Programming/IO/IO-model/IO-multiplexing/Epoll/man-7-epoll/#proc#interfaces","text":"The following interfaces can be used to limit the amount of kernel memory consumed by epoll : /proc/sys/fs/epoll/max_user_watches (since Linux 2.6.28) This specifies a limit on the total number of file descriptors that a user can register across all epoll instances on the system. The limit is per real user ID . Each registered file descriptor costs roughly 90 bytes on a 32-bit kernel, and roughly 160 bytes on a 64-bit kernel. Currently, the default value for max_user_watches is 1/25 (4%) of the available low memory, divided by the registration cost in bytes.","title":"/proc interfaces"},{"location":"Programming/IO/IO-model/IO-multiplexing/Epoll/man-7-epoll/#example#for#suggested#usage","text":"While the usage of epoll when employed as a level-triggered interface does have the same semantics as poll(2), the edge-triggered usage requires more clarification to avoid stalls in the application event loop. In this example, listener is a nonblocking socket on which listen(2) has been called. The function do_use_fd() uses the new ready file descriptor until EAGAIN is returned by either read(2) or write(2) . An event-driven state machine application should, after having received EAGAIN , record its current state so that at the next call to do_use_fd() it will continue to read(2) or write(2) from where it stopped before. #define MAX_EVENTS 10 struct epoll_event ev , events [ MAX_EVENTS ]; int listen_sock , conn_sock , nfds , epollfd ; /* Code to set up listening socket, 'listen_sock', (socket(), bind(), listen()) omitted */ epollfd = epoll_create1 ( 0 ); if ( epollfd == -1 ) { perror ( \"epoll_create1\" ); exit ( EXIT_FAILURE ); } ev . events = EPOLLIN ; ev . data . fd = listen_sock ; if ( epoll_ctl ( epollfd , EPOLL_CTL_ADD , listen_sock , & ev ) == -1 ) { perror ( \"epoll_ctl: listen_sock\" ); exit ( EXIT_FAILURE ); } for (;;) { nfds = epoll_wait ( epollfd , events , MAX_EVENTS , -1 ); if ( nfds == -1 ) { perror ( \"epoll_wait\" ); exit ( EXIT_FAILURE ); } for ( n = 0 ; n < nfds ; ++ n ) { if ( events [ n ]. data . fd == listen_sock ) { conn_sock = accept ( listen_sock , ( struct sockaddr * ) & addr , & addrlen ); if ( conn_sock == -1 ) { perror ( \"accept\" ); exit ( EXIT_FAILURE ); } setnonblocking ( conn_sock ); ev . events = EPOLLIN | EPOLLET ; ev . data . fd = conn_sock ; if ( epoll_ctl ( epollfd , EPOLL_CTL_ADD , conn_sock , & ev ) == -1 ) { perror ( \"epoll_ctl: conn_sock\" ); exit ( EXIT_FAILURE ); } } else { do_use_fd ( events [ n ]. data . fd ); } } } When used as an edge-triggered interface, for performance reasons, it is possible to add the file descriptor inside the epoll interface ( EPOLL_CTL_ADD ) once by specifying ( EPOLLIN|EPOLLOUT ). This allows you to avoid continuously switching between EPOLLIN and EPOLLOUT calling epoll_ctl(2) with EPOLL_CTL_MOD .","title":"Example for suggested usage"},{"location":"Programming/IO/IO-model/IO-multiplexing/Epoll/man-7-epoll/#questions#and#answers","text":"What is the key used to distinguish the file descriptors registered in an interest list? The key is the combination of the file descriptor number and the open file description (also known as an \"open file handle\", the kernel's internal representation of an open file). What happens if you register the same file descriptor on an epoll instance twice? You will probably get EEXIST . However, it is possible to add a duplicate ( dup(2) , dup2(2) , fcntl(2) F_DUPFD ) file descriptor to the same epoll instance . This can be a useful technique for filtering events, if the duplicate file descriptors are registered with different events masks. Can two epoll instances wait for the same file descriptor? If so, are events reported to both epoll file descriptors? Yes, and events would be reported to both. However, careful pro\u2010 gramming may be needed to do this correctly. Is the epoll file descriptor itself poll/epoll/selectable? Yes. If an epoll file descriptor has events waiting, then it will indicate as being readable. What happens if one attempts to put an epoll file descriptor into its own file descriptor set? The epoll_ctl(2) call fails (EINVAL). However, you can add an epoll file descriptor inside another epoll file descriptor set. Can I send an epoll file descriptor over a UNIX domain socket to another process? Yes, but it does not make sense to do this, since the receiving process would not have copies of the file descriptors in the interest list. Will closing a file descriptor cause it to be removed from all epoll interest lists? Yes, but be aware of the following point. A file descriptor is a reference to an open file description (see open(2)). Whenever a file descriptor is duplicated via dup(2), dup2(2), fcntl(2) F_DUPFD, or fork(2), a new file descriptor referring to the same open file description is created. An open file description con\u2010 tinues to exist until all file descriptors referring to it have been closed. A file descriptor is removed from an interest list only after all the file descriptors referring to the underlying open file description have been closed. This means that even after a file descriptor that is part of an interest list has been closed, events may be reported for that file descriptor if other file descriptors referring to the same underlying file description remain open. To prevent this happening, the file descriptor must be explicitly removed from the interest list (using epoll_ctl(2) EPOLL_CTL_DEL) before it is duplicated. Alternatively, the application must ensure that all file descriptors are closed (which may be difficult if file descriptors were duplicated behind the scenes by library functions that used dup(2) or fork(2)). If more than one event occurs between epoll_wait(2) calls, are they combined or reported separately? They will be combined. Does an operation on a file descriptor affect the already col\u2010 lected but not yet reported events? You can do two operations on an existing file descriptor. Remove would be meaningless for this case. Modify will reread available I/O. Do I need to continuously read/write a file descriptor until EAGAIN when using the EPOLLET flag (edge-triggered behavior)? Receiving an event from epoll_wait(2) should suggest to you that such file descriptor is ready for the requested I/O operation. You must consider it ready until the next (nonblocking) read/write yields EAGAIN. When and how you will use the file descriptor is entirely up to you. For packet/token-oriented files (e.g., datagram socket, terminal in canonical mode), the only way to detect the end of the read/write I/O space is to continue to read/write until EAGAIN. For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition that the read/write I/O space is exhausted can also be detected by checking the amount of data read from / written to the target file descriptor. For example, if you call read(2) by asking to read a certain amount of data and read(2) returns a lower number of bytes, you can be sure of having exhausted the read I/O space for the file descriptor. The same is true when writing using write(2). (Avoid this latter technique if you can\u2010 not guarantee that the monitored file descriptor always refers to a stream-oriented file.)","title":"Questions and answers"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/","text":"\u5173\u4e8e\u672c\u7ae0 \u524d\u9762\uff0c\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86file descriptor\u7684\u6982\u5ff5\uff0c\u672c\u7ae0\u5c06\u4ecb\u7ecd\u5728IO\u4e2d\u7684\u53e6\u5916\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u6982\u5ff5\uff1astream\u3002file descriptor\u548cstream\u662fIO\u7684\u4e24\u79cd\u6d41\u6d3e\uff0c\u672c\u7ae0\u5c06\u5bf9\u5b83\u4eec\u8fdb\u884c\u4ecb\u7ecd\uff0c\u8fdb\u884c\u5bf9\u6bd4\u3002","title":"Introduction"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/#_1","text":"\u524d\u9762\uff0c\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86file descriptor\u7684\u6982\u5ff5\uff0c\u672c\u7ae0\u5c06\u4ecb\u7ecd\u5728IO\u4e2d\u7684\u53e6\u5916\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u6982\u5ff5\uff1astream\u3002file descriptor\u548cstream\u662fIO\u7684\u4e24\u79cd\u6d41\u6d3e\uff0c\u672c\u7ae0\u5c06\u5bf9\u5b83\u4eec\u8fdb\u884c\u4ecb\u7ecd\uff0c\u8fdb\u884c\u5bf9\u6bd4\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/VS-stream-VS-fd/","text":"Stream VS fd OS\u5c42\u7684system call\u90fd\u662f\u4f7f\u7528\u7684fd\u3002 Stream\u4e00\u79cd\u62bd\u8c61\uff0c\u4ed6\u662f\u5bf9fd\u7684\u5c01\u88c5\uff0c\u57fa\u4e8e\u5b83\uff0c\u5b9e\u73b0\u4e86\u5f88\u591a\u975e\u5e38\u7b80\u5355\u6613\u7528\u7684\u64cd\u4f5c\u3002 Stream-based IO VS file descriptor-based IO stackoverflow What is the difference between a stream and a file? A In the context of the C Standard Library a stream is a generic interface for performing certain I/O operations. You can read from streams, write to streams, some streams are seekable. Opening a file as a stream is only one way to get a stream as an I/O interface for an application. Let me quote: 11.1.1 Streams and File Descriptors When you want to do input or output to a file, you have a choice of two basic mechanisms for representing the connection between your program and the file: file descriptors and streams. File descriptors are represented as objects of type int , while streams are represented as FILE * objects. File descriptors provide a primitive, low-level interface to input and output operations. Both file descriptors and streams can represent a connection to a device (such as a terminal), or a pipe or socket for communicating with another process, as well as a normal file. [...] ... and further: 12.1 Streams For historical reasons, the type of the C data structure that represents a stream is called FILE rather than \u201cstream\u201d. Since most of the library functions deal with objects of type FILE * , sometimes the term file pointer is also used to mean \u201cstream\u201d. This leads to unfortunate confusion over terminology in many books on C. Examples for I/O streams in C: Standard Streams: https://linux.die.net/man/3/stdin File Streams: https://linux.die.net/man/3/fopen Pipes: https://linux.die.net/man/3/popen Stream Sockets: https://linux.die.net/man/2/socket For further reading, also have a look at these links: https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Overview https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-on-Streams The stream-based API is built on top of the low-level file descriptor API and provides additional functionality. Some low-level features are however only available via the lower level API, e.g., memory-mapped I/O , non-blocking I/O or \"event-driven\" I/O: https://www.gnu.org/software/libc/manual/html_node/Memory_002dmapped-I_002fO.html https://linux.die.net/man/2/poll https://linux.die.net/man/4/epoll TO READ https://www.gnu.org/software/libc/manual/html_node/I_002fO-Concepts.html#I_002fO-Concepts https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html","title":"VS-stream-VS-fd"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/VS-stream-VS-fd/#stream#vs#fd","text":"OS\u5c42\u7684system call\u90fd\u662f\u4f7f\u7528\u7684fd\u3002 Stream\u4e00\u79cd\u62bd\u8c61\uff0c\u4ed6\u662f\u5bf9fd\u7684\u5c01\u88c5\uff0c\u57fa\u4e8e\u5b83\uff0c\u5b9e\u73b0\u4e86\u5f88\u591a\u975e\u5e38\u7b80\u5355\u6613\u7528\u7684\u64cd\u4f5c\u3002","title":"Stream VS fd"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/VS-stream-VS-fd/#stream-based#io#vs#file#descriptor-based#io","text":"","title":"Stream-based IO VS file descriptor-based IO"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/VS-stream-VS-fd/#stackoverflow#what#is#the#difference#between#a#stream#and#a#file","text":"","title":"stackoverflow What is the difference between a stream and a file?"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/VS-stream-VS-fd/#a","text":"In the context of the C Standard Library a stream is a generic interface for performing certain I/O operations. You can read from streams, write to streams, some streams are seekable. Opening a file as a stream is only one way to get a stream as an I/O interface for an application. Let me quote: 11.1.1 Streams and File Descriptors When you want to do input or output to a file, you have a choice of two basic mechanisms for representing the connection between your program and the file: file descriptors and streams. File descriptors are represented as objects of type int , while streams are represented as FILE * objects. File descriptors provide a primitive, low-level interface to input and output operations. Both file descriptors and streams can represent a connection to a device (such as a terminal), or a pipe or socket for communicating with another process, as well as a normal file. [...] ... and further: 12.1 Streams For historical reasons, the type of the C data structure that represents a stream is called FILE rather than \u201cstream\u201d. Since most of the library functions deal with objects of type FILE * , sometimes the term file pointer is also used to mean \u201cstream\u201d. This leads to unfortunate confusion over terminology in many books on C. Examples for I/O streams in C: Standard Streams: https://linux.die.net/man/3/stdin File Streams: https://linux.die.net/man/3/fopen Pipes: https://linux.die.net/man/3/popen Stream Sockets: https://linux.die.net/man/2/socket For further reading, also have a look at these links: https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Overview https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-on-Streams The stream-based API is built on top of the low-level file descriptor API and provides additional functionality. Some low-level features are however only available via the lower level API, e.g., memory-mapped I/O , non-blocking I/O or \"event-driven\" I/O: https://www.gnu.org/software/libc/manual/html_node/Memory_002dmapped-I_002fO.html https://linux.die.net/man/2/poll https://linux.die.net/man/4/epoll","title":"A"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/VS-stream-VS-fd/#to#read","text":"https://www.gnu.org/software/libc/manual/html_node/I_002fO-Concepts.html#I_002fO-Concepts https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html","title":"TO READ"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/Stream/","text":"Stream-based IO \u5173\u4e8estream\uff0c\u53c2\u89c1\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Model\\Stream \u7ae0\u8282\u3002 Stream\u62bd\u8c61\u4e86\u6570\u636e\u7684\u6d41\u52a8\uff08\u6d41\u51fa\u3001\u6d41\u5165\uff09\uff0cstream\u6a21\u578b\u53ef\u4ee5\u62bd\u8c61 input/output device\uff0c\u5b83\u80fd\u591f\u62bd\u8c61file\u3001network device\u3001custom adaptor device\uff0c\u6240\u4ee5\u4f7f\u7528stream\u6a21\u578b\u6784\u5efa\u7684\u7a0b\u5e8f\uff0c\u5141\u8bb8\u6211\u4eec\u5b9e\u73b0\u4f7f\u7528\u62bd\u8c61\u7684stream\u6765\u5b8c\u6210\u5bf9\u591a\u79cddevice\u7684IO\u3002\u8fd9\u4e2a\u601d\u60f3\u5c31\u662f abstraction \u601d\u60f3\u3002 stream\u6a21\u578b\u57fa\u672c\u4e0a\u7edf\u6cbb\u4e86IO\u9886\u57df\uff1a \u5728 Everything-is-a-file \u4e2d\uff0c\u6211\u4eec\u5176\u5b9e\u5df2\u7ecf\u63a2\u8ba8\u4e86linux\u7684file descriptor\u5176\u5b9e\u4ee3\u8868\u7684\u5c31\u662f\u4e00\u4e2astream\uff0c\u5b83\u4f7f\u7528\u7684\u5c31\u662fstream\u6a21\u578b\uff0c\u5e76\u4e14\u7ef4\u57fa\u767e\u79d1 Everything is a file \u63cf\u8ff0\u7684\u601d\u60f3\u548c\u4e0a\u4e00\u6bb5\u4e2d\u7684\u601d\u60f3\u4e00\u81f4\u3002 C++\u7684 Input/output library \u5c31\u662f\u57fa\u4e8estream\u6a21\u578b\u521b\u5efa\u7684\u3002 IO\u5373\u8f93\u5165\u3001\u8f93\u51fa\uff0c\u5c31\u662f\u5178\u578b\u7684\u53ef\u4ee5\u4f7f\u7528stream\u6765\u8fdb\u884c\u63cf\u8ff0\u7684\u3002 wikipedia Stream (computing) # Examples 2) On Unix and related systems based on the C language , a stream is a source or sink of data, usually individual bytes or characters . Streams are an abstraction used when reading or writing files, or communicating over network sockets . The standard streams are three streams made available to all programs. 3) I/O devices can be interpreted as streams , as they produce or consume potentially unlimited data over time. wikipedia C file input/output C++ IO library \u53c2\u89c1\u5de5\u7a0bprogramming-language\u7684 C-family-language\\C++\\Library\\Standard-library\\IO-library \u7ae0\u8282\u3002","title":"Stream"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/Stream/#stream-based#io","text":"\u5173\u4e8estream\uff0c\u53c2\u89c1\u5de5\u7a0bdiscrete\u7684 Relation-structure-computation\\Model\\Stream \u7ae0\u8282\u3002 Stream\u62bd\u8c61\u4e86\u6570\u636e\u7684\u6d41\u52a8\uff08\u6d41\u51fa\u3001\u6d41\u5165\uff09\uff0cstream\u6a21\u578b\u53ef\u4ee5\u62bd\u8c61 input/output device\uff0c\u5b83\u80fd\u591f\u62bd\u8c61file\u3001network device\u3001custom adaptor device\uff0c\u6240\u4ee5\u4f7f\u7528stream\u6a21\u578b\u6784\u5efa\u7684\u7a0b\u5e8f\uff0c\u5141\u8bb8\u6211\u4eec\u5b9e\u73b0\u4f7f\u7528\u62bd\u8c61\u7684stream\u6765\u5b8c\u6210\u5bf9\u591a\u79cddevice\u7684IO\u3002\u8fd9\u4e2a\u601d\u60f3\u5c31\u662f abstraction \u601d\u60f3\u3002 stream\u6a21\u578b\u57fa\u672c\u4e0a\u7edf\u6cbb\u4e86IO\u9886\u57df\uff1a \u5728 Everything-is-a-file \u4e2d\uff0c\u6211\u4eec\u5176\u5b9e\u5df2\u7ecf\u63a2\u8ba8\u4e86linux\u7684file descriptor\u5176\u5b9e\u4ee3\u8868\u7684\u5c31\u662f\u4e00\u4e2astream\uff0c\u5b83\u4f7f\u7528\u7684\u5c31\u662fstream\u6a21\u578b\uff0c\u5e76\u4e14\u7ef4\u57fa\u767e\u79d1 Everything is a file \u63cf\u8ff0\u7684\u601d\u60f3\u548c\u4e0a\u4e00\u6bb5\u4e2d\u7684\u601d\u60f3\u4e00\u81f4\u3002 C++\u7684 Input/output library \u5c31\u662f\u57fa\u4e8estream\u6a21\u578b\u521b\u5efa\u7684\u3002 IO\u5373\u8f93\u5165\u3001\u8f93\u51fa\uff0c\u5c31\u662f\u5178\u578b\u7684\u53ef\u4ee5\u4f7f\u7528stream\u6765\u8fdb\u884c\u63cf\u8ff0\u7684\u3002","title":"Stream-based IO"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/Stream/#wikipedia#stream#computing#examples","text":"2) On Unix and related systems based on the C language , a stream is a source or sink of data, usually individual bytes or characters . Streams are an abstraction used when reading or writing files, or communicating over network sockets . The standard streams are three streams made available to all programs. 3) I/O devices can be interpreted as streams , as they produce or consume potentially unlimited data over time.","title":"wikipedia Stream (computing) # Examples"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/Stream/#wikipedia#c#file#inputoutput","text":"","title":"wikipedia C file input/output"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/Stream/#c#io#library","text":"\u53c2\u89c1\u5de5\u7a0bprogramming-language\u7684 C-family-language\\C++\\Library\\Standard-library\\IO-library \u7ae0\u8282\u3002","title":"C++ IO library"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/Stream/Standard-streams/","text":"Standard streams \u7ef4\u57fa\u767e\u79d1 Standard streams","title":"Standard-streams"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/Stream/Standard-streams/#standard#streams","text":"","title":"Standard streams"},{"location":"Programming/IO/IO-%E6%B5%81%E6%B4%BE/Stream/Standard-streams/#standard#streams_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Standard streams"},{"location":"Programming/IO/Network-IO/","text":"\u5173\u4e8e\u672c\u7ae0 \u4e0enetwork\u76f8\u5173\u7684IO\u653e\u5230\u4e86 Network \u7ae0\u8282\u3002","title":"Introduction"},{"location":"Programming/IO/Network-IO/#_1","text":"\u4e0enetwork\u76f8\u5173\u7684IO\u653e\u5230\u4e86 Network \u7ae0\u8282\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/IO/Tools/fuser/","text":"fuser fuser(1) - Linux man page wikipedia fuser (Unix) The Unix command fuser is used to show which processes are using a specified computer file , file system , or Unix socket . Example Find Which Process Accessing a Directory $ fuser . OR $ fuser /home/tecmint Under the ACCESS column, you will see access types signified by the following letters: c \u2013 current directory e \u2013 an executable file being run f \u2013 open file, however, f is left out in the output F \u2013 open file for writing, F is as well excluded from the output r \u2013 root directory m \u2013 mmap\u2019ed file or shared library Find Which Process Accessing A File System Next, you can determine which processes are accessing your ~.bashrc file like so: $ fuser -v -m .bashrc The option, -m NAME or --mount NAME means name all processes accessing the file NAME . In case you a spell out directory as NAME , it is spontaneously changed to NAME/ , to use any file system that is possibly mounted on that directory. How to Kill and Signal Processes Using fuser In this section we shall work through using fuser to kill and send signals to processes . In order to kill a processes accessing a file or socket, employ the -k or --kill option like so: $ sudo fuser -k . To interactively kill a process, where you are that asked to confirm your intention to kill the processes accessing a file or socket, make use of -i or --interactive option: $ sudo fuser -ki . The two previous commands will kill all processes accessing your current directory, the default signal sent to the processes is SIGKILL , except when -SIGNAL is used. Suggested Read: A Guide to Kill, Pkill and Killall Commands in Linux You can list all the signals using the -l or --list-signals options as below: $ sudo fuser --list-signals List All Kill Process Signals Therefore, you can send a signal to processes as in the next command, where SIGNAL is any of the signals listed in the output above. $ sudo fuser -k -SIGNAL For example, this command below sends the HUP signal to all processes that have your /boot directory open. $ sudo fuser -k -HUP /boot Try to read through the fuser man page for advanced usage options, additional and more detailed information. That is it for now, you can reach us by means of the feedback section below for any assistance that you possibly need or suggestions you wish to make. Check Processes Using TCP/UDP Sockets Using fuser we can also check the processes using TCP/UDP sockets. Since the above stated socket_serv sample C program executable is running on TCP port 5000, lets use fuser utility on this socket. $ fuser -v -n tcp 5000 USER PID ACCESS COMMAND 5000/tcp: himanshu 4334 F.... socket_serv So we see that fuser gives all detailed information of the process running on TCP port 5000. Other than the examples above, we can use the \u2018-m\u2019 flag with this utility to display processes using a mounted file system like a USB drive.","title":"fuser"},{"location":"Programming/IO/Tools/fuser/#fuser","text":"","title":"fuser"},{"location":"Programming/IO/Tools/fuser/#fuser1#-#linux#man#page","text":"","title":"fuser(1) - Linux man page"},{"location":"Programming/IO/Tools/fuser/#wikipedia#fuser#unix","text":"The Unix command fuser is used to show which processes are using a specified computer file , file system , or Unix socket .","title":"wikipedia fuser (Unix)"},{"location":"Programming/IO/Tools/fuser/#example","text":"","title":"Example"},{"location":"Programming/IO/Tools/fuser/#find#which#process#accessing#a#directory","text":"$ fuser . OR $ fuser /home/tecmint Under the ACCESS column, you will see access types signified by the following letters: c \u2013 current directory e \u2013 an executable file being run f \u2013 open file, however, f is left out in the output F \u2013 open file for writing, F is as well excluded from the output r \u2013 root directory m \u2013 mmap\u2019ed file or shared library","title":"Find Which Process Accessing a Directory"},{"location":"Programming/IO/Tools/fuser/#find#which#process#accessing#a#file#system","text":"Next, you can determine which processes are accessing your ~.bashrc file like so: $ fuser -v -m .bashrc The option, -m NAME or --mount NAME means name all processes accessing the file NAME . In case you a spell out directory as NAME , it is spontaneously changed to NAME/ , to use any file system that is possibly mounted on that directory.","title":"Find Which Process Accessing A File System"},{"location":"Programming/IO/Tools/fuser/#how#to#kill#and#signal#processes#using#fuser","text":"In this section we shall work through using fuser to kill and send signals to processes . In order to kill a processes accessing a file or socket, employ the -k or --kill option like so: $ sudo fuser -k . To interactively kill a process, where you are that asked to confirm your intention to kill the processes accessing a file or socket, make use of -i or --interactive option: $ sudo fuser -ki . The two previous commands will kill all processes accessing your current directory, the default signal sent to the processes is SIGKILL , except when -SIGNAL is used. Suggested Read: A Guide to Kill, Pkill and Killall Commands in Linux You can list all the signals using the -l or --list-signals options as below: $ sudo fuser --list-signals List All Kill Process Signals Therefore, you can send a signal to processes as in the next command, where SIGNAL is any of the signals listed in the output above. $ sudo fuser -k -SIGNAL For example, this command below sends the HUP signal to all processes that have your /boot directory open. $ sudo fuser -k -HUP /boot Try to read through the fuser man page for advanced usage options, additional and more detailed information. That is it for now, you can reach us by means of the feedback section below for any assistance that you possibly need or suggestions you wish to make.","title":"How to Kill and Signal Processes Using fuser"},{"location":"Programming/IO/Tools/fuser/#check#processes#using#tcpudp#sockets","text":"Using fuser we can also check the processes using TCP/UDP sockets. Since the above stated socket_serv sample C program executable is running on TCP port 5000, lets use fuser utility on this socket. $ fuser -v -n tcp 5000 USER PID ACCESS COMMAND 5000/tcp: himanshu 4334 F.... socket_serv So we see that fuser gives all detailed information of the process running on TCP port 5000. Other than the examples above, we can use the \u2018-m\u2019 flag with this utility to display processes using a mounted file system like a USB drive.","title":"Check Processes Using TCP/UDP Sockets"},{"location":"Programming/IO/Tools/lsof/","text":"lsof Everything in Unix is a file\uff0c\u800clsof\u80fd\u591flist open files\uff0c\u6240\u4ee5\u8db3\u89c1\u5b83\u7684\u91cd\u8981\u6027\u3002 wikipedia lsof Examples Open files in the system include disk files, named pipes , network sockets and devices opened by all processes. The listing of open files can be consulted (suitably filtered if necessary) to identify the process that is using the files. # lsof /var COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME syslogd 350 root 5w VREG 222 ,5 0 440818 /var/adm/messages syslogd 350 root 6w VREG 222 ,5 339098 6248 /var/log/syslog cron 353 root cwd VDIR 222 ,5 512 254550 /var -- atjobs To view the port associated with a daemon: # lsof -i -n -P | grep sendmail sendmail 31649 root 4u IPv4 521738 TCP *:25 ( LISTEN ) From the above one can see that \"sendmail\" is listening on its standard port of \"25\". -i Lists IP sockets. -n Do not resolve hostnames (no DNS). -P Do not resolve port names (list port number instead of its name). One can also list Unix Sockets by using lsof -U . lsof(8) - Linux man page lsof - list open files NOTE: \u663e\u7136\uff0c\u4f7f\u7528\u8fd9\u4e2acommand\uff0c\u9700\u8981\u5bf9Linux\u7684\u6587\u4ef6\u6709\u7740\u975e\u5e38\u8be6\u7ec6\u7684\u8ba4\u8bc6\uff0c\u4e0b\u9762\u603b\u7ed3\u4e86\u4e0d\u540c\u7c7b\u578b\u7684file\u548c\u5176\u5bf9\u5e94\u7684option\uff1b\u5728\u539f\u6587\u7684Output\u6bb5\u4e2d\uff0c\u5bf9\u6587\u4ef6\u7c7b\u578b\u8fdb\u884c\u4e86\u8be6\u7ec6\u7684\u8bf4\u660e\uff0c\u636e\u6b64\u53ef\u4ee5\u77e5\u9053OS\u6240\u652f\u6301\u7684\u6240\u6709\u7684\u6587\u4ef6\u7c7b\u578b\u3002 Options file type \u6587\u4ef6\u7c7b\u578b list request option regular file directory block special file character special file executing text reference library Internet socket -i NFS file -N UNIX domain socket -U A specific file or all the files in a file system may be selected by path. user -u NOTE: \u4e0b\u9762\u662ftecmint 10 lsof Command Examples in Linux \u4e2d\u7ed9\u51fa\u7684\u7b80\u4ecb: display the list of all opened files of user tecmint . # lsof -u tecmint COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME sshd 1838 tecmint cwd DIR 253 ,0 4096 2 / PID NOTE: \u4e0b\u9762\u662ftecmint 10 lsof Command Examples in Linux \u4e2d\u7ed9\u51fa\u7684\u7b80\u4ecb: 9. Search by PID The below example only shows whose PID is 1 [ One ]. # lsof -p 1 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME init 1 root cwd DIR 253 ,0 4096 2 / Exclude NOTE: 10 lsof Command Examples in Linux: Exclude User with \u2018^\u2019 Character Here, we have excluded root user. You can exclude a particular user using \u2018^\u2019 with command as shown above. # lsof -i -u^root COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME rpcbind 1203 rpc 6u IPv4 11326 0t0 UDP *:sunrpc rpcbind 1203 rpc 7u IPv4 11330 0t0 UDP *:954 Output NOTE: \u8bfb\u61c2\u8f93\u51fa\u7684\u4e00\u4e2a\u91cd\u8981\u524d\u63d0\u662f\u6e05\u695a\u8f93\u51fa\u4e2d\u5404\u5217\u7684\u542b\u4e49\uff0c\u539f\u6587\u5bf9\u6b64\u8fdb\u884c\u4e86\u8be6\u7ec6\u8bf4\u660e\uff0c\u4f46\u662f\u5197\u957f\u3002\u4e0b\u9762\u662ftecmint 10 lsof Command Examples in Linux \u4e2d\u7ed9\u51fa\u7684\u7b80\u4ecb # lsof COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME init 1 root cwd DIR 253 ,0 4096 2 / init 1 root txt REG 253 ,0 145180 147164 /sbin/init init 1 root 0u CHR 1 ,3 0t0 3764 /dev/null init 1 root 3r FIFO 0 ,8 0t0 8449 pipe init 1 root 5r DIR 0 ,10 0 1 inotify init 1 root 7u unix 0xc1513880 0t0 8450 socket FD NOTE:\u4e0b\u9762\u662ftecmint 10 lsof Command Examples in Linux \u4e2d\u7ed9\u51fa\u7684\u7b80\u4ecb: FD \u2013 stands for File descriptor and may seen some of the values as: cwd current working directory rtd root directory txt program text (code and data) mem memory-mapped file Also in FD column numbers like 1u is actual file descriptor and followed by u,r,w of it\u2019s mode as: r for read access. w for write access. u for read and write access. COMMAND NOTE: \u5373\u547d\u4ee4 TYPE NOTE: \u6587\u4ef6\u7c7b\u578b\uff0c\u4e0b\u9762\u662ftecmint 10 lsof Command Examples in Linux \u4e2d\u7ed9\u51fa\u7684\u7b80\u4ecb: TYPE \u2013 of files and it\u2019s identification. DIR \u2013 Directory REG \u2013 Regular file CHR \u2013 Character special file. FIFO \u2013 First In First Out is the type of the node associated with the file - e.g., GDIR, GREG, VDIR, VREG, etc. Examples Find Processes running on Specific Port stackexchange Kill process running on port 80 # A : There are several ways to find which running process is using a port. Using fuser it will give the PID(s) of the multiple instances associated with the listening port. sudo apt-get install psmisc sudo fuser 80 /tcp 80 /tcp: 1858 1867 1868 1869 1871 After finding out, you can either stop or kill the process(es). You can also find the PIDs and more details using lsof sudo lsof -i tcp:80 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME nginx 1858 root 6u IPv4 5043 0t0 TCP ruir.mxxx.com:http ( LISTEN ) nginx 1867 www-data 6u IPv4 5043 0t0 TCP ruir.mxxx.com:http ( LISTEN ) To limit to sockets that listen on port 80 (as opposed to clients that connect to port 80): sudo lsof -i tcp:80 -s tcp:listen To kill them automatically: sudo lsof -t -i tcp:80 -s tcp:listen | sudo xargs kill 10 lsof Command Examples in Linux: To find out all the running process of specific port, just use the following command with option -i . The below example will list all running process of port 22 . # lsof -i TCP:22 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME sshd 1471 root 3u IPv4 12683 0t0 TCP *:ssh ( LISTEN ) sshd 1471 root 4u IPv6 12685 0t0 TCP *:ssh ( LISTEN ) see also: cyberciti Linux: Find Out What Is Using TCP Port 80 List Only IPv4 & IPv6 Open Files 10 lsof Command Examples in Linux: In below example shows only IPv4 and IPv6 network files open with separate commands. # lsof -i 4 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME rpcbind 1203 rpc 6u IPv4 11326 0t0 UDP *:sunrpc # lsof -i 6 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME rpcbind 1203 rpc 9u IPv6 11333 0t0 UDP *:sunrpc List Open Files of TCP Port ranges 1-1024 10 lsof Command Examples in Linux: To list all the running process of open files of TCP Port ranges from 1-1024 . # lsof -i TCP:1-1024 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME rpcbind 1203 rpc 11u IPv6 11336 0t0 TCP *:sunrpc ( LISTEN ) cupsd 1346 root 7u IPv4 12113 0t0 TCP localhost:ipp ( LISTEN ) List all Network Connections 10 lsof Command Examples in Linux: The following command with option \u2018-i\u2019 shows the list of all network connections \u2018 LISTENING & ESTABLISHED\u2019 . # lsof -i COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME rpcbind 1203 rpc 6u IPv4 11326 0t0 UDP *:sunrpc rpcbind 1203 rpc 7u IPv4 11330 0t0 UDP *:954 rpcbind 1203 rpc 11u IPv6 11336 0t0 TCP *:sunrpc ( LISTEN ) avahi-dae 1241 avahi 13u IPv4 11579 0t0 UDP *:mdns avahi-dae 1241 avahi 14u IPv4 11580 0t0 UDP *:58600 rpc.statd 1277 rpcuser 11u IPv6 11862 0t0 TCP *:56428 ( LISTEN ) cupsd 1346 root 6u IPv6 12112 0t0 TCP localhost:ipp ( LISTEN ) cupsd 1346 root 7u IPv4 12113 0t0 TCP localhost:ipp ( LISTEN ) sshd 1471 root 3u IPv4 12683 0t0 TCP *:ssh ( LISTEN ) master 1551 root 12u IPv4 12896 0t0 TCP localhost:smtp ( LISTEN ) master 1551 root 13u IPv6 12898 0t0 TCP localhost:smtp ( LISTEN ) sshd 1834 root 3r IPv4 15101 0t0 TCP 192 .168.0.2:ssh->192.168.0.1:conclave-cpp ( ESTABLISHED ) Kill all Activity of Particular User 10 lsof Command Examples in Linux: Sometimes you may have to kill all the processes for a specific user. Below command will kills all the processes of tecmint user. # kill -9 `lsof -t -u tecmint`","title":"lsof"},{"location":"Programming/IO/Tools/lsof/#lsof","text":"Everything in Unix is a file\uff0c\u800clsof\u80fd\u591flist open files\uff0c\u6240\u4ee5\u8db3\u89c1\u5b83\u7684\u91cd\u8981\u6027\u3002","title":"lsof"},{"location":"Programming/IO/Tools/lsof/#wikipedia#lsof","text":"","title":"wikipedia lsof"},{"location":"Programming/IO/Tools/lsof/#examples","text":"Open files in the system include disk files, named pipes , network sockets and devices opened by all processes. The listing of open files can be consulted (suitably filtered if necessary) to identify the process that is using the files. # lsof /var COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME syslogd 350 root 5w VREG 222 ,5 0 440818 /var/adm/messages syslogd 350 root 6w VREG 222 ,5 339098 6248 /var/log/syslog cron 353 root cwd VDIR 222 ,5 512 254550 /var -- atjobs To view the port associated with a daemon: # lsof -i -n -P | grep sendmail sendmail 31649 root 4u IPv4 521738 TCP *:25 ( LISTEN ) From the above one can see that \"sendmail\" is listening on its standard port of \"25\". -i Lists IP sockets. -n Do not resolve hostnames (no DNS). -P Do not resolve port names (list port number instead of its name). One can also list Unix Sockets by using lsof -U .","title":"Examples"},{"location":"Programming/IO/Tools/lsof/#lsof8#-#linux#man#page","text":"lsof - list open files NOTE: \u663e\u7136\uff0c\u4f7f\u7528\u8fd9\u4e2acommand\uff0c\u9700\u8981\u5bf9Linux\u7684\u6587\u4ef6\u6709\u7740\u975e\u5e38\u8be6\u7ec6\u7684\u8ba4\u8bc6\uff0c\u4e0b\u9762\u603b\u7ed3\u4e86\u4e0d\u540c\u7c7b\u578b\u7684file\u548c\u5176\u5bf9\u5e94\u7684option\uff1b\u5728\u539f\u6587\u7684Output\u6bb5\u4e2d\uff0c\u5bf9\u6587\u4ef6\u7c7b\u578b\u8fdb\u884c\u4e86\u8be6\u7ec6\u7684\u8bf4\u660e\uff0c\u636e\u6b64\u53ef\u4ee5\u77e5\u9053OS\u6240\u652f\u6301\u7684\u6240\u6709\u7684\u6587\u4ef6\u7c7b\u578b\u3002","title":"lsof(8) - Linux man page"},{"location":"Programming/IO/Tools/lsof/#options","text":"","title":"Options"},{"location":"Programming/IO/Tools/lsof/#file#type","text":"\u6587\u4ef6\u7c7b\u578b list request option regular file directory block special file character special file executing text reference library Internet socket -i NFS file -N UNIX domain socket -U A specific file or all the files in a file system may be selected by path.","title":"file type"},{"location":"Programming/IO/Tools/lsof/#user","text":"-u NOTE: \u4e0b\u9762\u662ftecmint 10 lsof Command Examples in Linux \u4e2d\u7ed9\u51fa\u7684\u7b80\u4ecb: display the list of all opened files of user tecmint . # lsof -u tecmint COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME sshd 1838 tecmint cwd DIR 253 ,0 4096 2 /","title":"user"},{"location":"Programming/IO/Tools/lsof/#pid","text":"NOTE: \u4e0b\u9762\u662ftecmint 10 lsof Command Examples in Linux \u4e2d\u7ed9\u51fa\u7684\u7b80\u4ecb:","title":"PID"},{"location":"Programming/IO/Tools/lsof/#9#search#by#pid","text":"The below example only shows whose PID is 1 [ One ]. # lsof -p 1 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME init 1 root cwd DIR 253 ,0 4096 2 /","title":"9. Search by PID"},{"location":"Programming/IO/Tools/lsof/#exclude","text":"NOTE: 10 lsof Command Examples in Linux: Exclude User with \u2018^\u2019 Character Here, we have excluded root user. You can exclude a particular user using \u2018^\u2019 with command as shown above. # lsof -i -u^root COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME rpcbind 1203 rpc 6u IPv4 11326 0t0 UDP *:sunrpc rpcbind 1203 rpc 7u IPv4 11330 0t0 UDP *:954","title":"Exclude"},{"location":"Programming/IO/Tools/lsof/#output","text":"NOTE: \u8bfb\u61c2\u8f93\u51fa\u7684\u4e00\u4e2a\u91cd\u8981\u524d\u63d0\u662f\u6e05\u695a\u8f93\u51fa\u4e2d\u5404\u5217\u7684\u542b\u4e49\uff0c\u539f\u6587\u5bf9\u6b64\u8fdb\u884c\u4e86\u8be6\u7ec6\u8bf4\u660e\uff0c\u4f46\u662f\u5197\u957f\u3002\u4e0b\u9762\u662ftecmint 10 lsof Command Examples in Linux \u4e2d\u7ed9\u51fa\u7684\u7b80\u4ecb # lsof COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME init 1 root cwd DIR 253 ,0 4096 2 / init 1 root txt REG 253 ,0 145180 147164 /sbin/init init 1 root 0u CHR 1 ,3 0t0 3764 /dev/null init 1 root 3r FIFO 0 ,8 0t0 8449 pipe init 1 root 5r DIR 0 ,10 0 1 inotify init 1 root 7u unix 0xc1513880 0t0 8450 socket","title":"Output"},{"location":"Programming/IO/Tools/lsof/#fd","text":"NOTE:\u4e0b\u9762\u662ftecmint 10 lsof Command Examples in Linux \u4e2d\u7ed9\u51fa\u7684\u7b80\u4ecb: FD \u2013 stands for File descriptor and may seen some of the values as: cwd current working directory rtd root directory txt program text (code and data) mem memory-mapped file Also in FD column numbers like 1u is actual file descriptor and followed by u,r,w of it\u2019s mode as: r for read access. w for write access. u for read and write access.","title":"FD"},{"location":"Programming/IO/Tools/lsof/#command","text":"NOTE: \u5373\u547d\u4ee4","title":"COMMAND"},{"location":"Programming/IO/Tools/lsof/#type","text":"NOTE: \u6587\u4ef6\u7c7b\u578b\uff0c\u4e0b\u9762\u662ftecmint 10 lsof Command Examples in Linux \u4e2d\u7ed9\u51fa\u7684\u7b80\u4ecb: TYPE \u2013 of files and it\u2019s identification. DIR \u2013 Directory REG \u2013 Regular file CHR \u2013 Character special file. FIFO \u2013 First In First Out is the type of the node associated with the file - e.g., GDIR, GREG, VDIR, VREG, etc.","title":"TYPE"},{"location":"Programming/IO/Tools/lsof/#examples_1","text":"","title":"Examples"},{"location":"Programming/IO/Tools/lsof/#find#processes#running#on#specific#port","text":"stackexchange Kill process running on port 80 # A : There are several ways to find which running process is using a port. Using fuser it will give the PID(s) of the multiple instances associated with the listening port. sudo apt-get install psmisc sudo fuser 80 /tcp 80 /tcp: 1858 1867 1868 1869 1871 After finding out, you can either stop or kill the process(es). You can also find the PIDs and more details using lsof sudo lsof -i tcp:80 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME nginx 1858 root 6u IPv4 5043 0t0 TCP ruir.mxxx.com:http ( LISTEN ) nginx 1867 www-data 6u IPv4 5043 0t0 TCP ruir.mxxx.com:http ( LISTEN ) To limit to sockets that listen on port 80 (as opposed to clients that connect to port 80): sudo lsof -i tcp:80 -s tcp:listen To kill them automatically: sudo lsof -t -i tcp:80 -s tcp:listen | sudo xargs kill 10 lsof Command Examples in Linux: To find out all the running process of specific port, just use the following command with option -i . The below example will list all running process of port 22 . # lsof -i TCP:22 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME sshd 1471 root 3u IPv4 12683 0t0 TCP *:ssh ( LISTEN ) sshd 1471 root 4u IPv6 12685 0t0 TCP *:ssh ( LISTEN ) see also: cyberciti Linux: Find Out What Is Using TCP Port 80","title":"Find Processes running on Specific Port"},{"location":"Programming/IO/Tools/lsof/#list#only#ipv4#ipv6#open#files","text":"10 lsof Command Examples in Linux: In below example shows only IPv4 and IPv6 network files open with separate commands. # lsof -i 4 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME rpcbind 1203 rpc 6u IPv4 11326 0t0 UDP *:sunrpc # lsof -i 6 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME rpcbind 1203 rpc 9u IPv6 11333 0t0 UDP *:sunrpc","title":"List Only IPv4 &amp; IPv6 Open Files"},{"location":"Programming/IO/Tools/lsof/#list#open#files#of#tcp#port#ranges#1-1024","text":"10 lsof Command Examples in Linux: To list all the running process of open files of TCP Port ranges from 1-1024 . # lsof -i TCP:1-1024 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME rpcbind 1203 rpc 11u IPv6 11336 0t0 TCP *:sunrpc ( LISTEN ) cupsd 1346 root 7u IPv4 12113 0t0 TCP localhost:ipp ( LISTEN )","title":"List Open Files of TCP Port ranges 1-1024"},{"location":"Programming/IO/Tools/lsof/#list#all#network#connections","text":"10 lsof Command Examples in Linux: The following command with option \u2018-i\u2019 shows the list of all network connections \u2018 LISTENING & ESTABLISHED\u2019 . # lsof -i COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME rpcbind 1203 rpc 6u IPv4 11326 0t0 UDP *:sunrpc rpcbind 1203 rpc 7u IPv4 11330 0t0 UDP *:954 rpcbind 1203 rpc 11u IPv6 11336 0t0 TCP *:sunrpc ( LISTEN ) avahi-dae 1241 avahi 13u IPv4 11579 0t0 UDP *:mdns avahi-dae 1241 avahi 14u IPv4 11580 0t0 UDP *:58600 rpc.statd 1277 rpcuser 11u IPv6 11862 0t0 TCP *:56428 ( LISTEN ) cupsd 1346 root 6u IPv6 12112 0t0 TCP localhost:ipp ( LISTEN ) cupsd 1346 root 7u IPv4 12113 0t0 TCP localhost:ipp ( LISTEN ) sshd 1471 root 3u IPv4 12683 0t0 TCP *:ssh ( LISTEN ) master 1551 root 12u IPv4 12896 0t0 TCP localhost:smtp ( LISTEN ) master 1551 root 13u IPv6 12898 0t0 TCP localhost:smtp ( LISTEN ) sshd 1834 root 3r IPv4 15101 0t0 TCP 192 .168.0.2:ssh->192.168.0.1:conclave-cpp ( ESTABLISHED )","title":"List all Network Connections"},{"location":"Programming/IO/Tools/lsof/#kill#all#activity#of#particular#user","text":"10 lsof Command Examples in Linux: Sometimes you may have to kill all the processes for a specific user. Below command will kills all the processes of tecmint user. # kill -9 `lsof -t -u tecmint`","title":"Kill all Activity of Particular User"},{"location":"Programming/Kernel-module/Loadable-kernel-module/","text":"Loadable kernel module The Linux Kernel Module Programming Guide","title":"Loadable-kernel-module"},{"location":"Programming/Kernel-module/Loadable-kernel-module/#loadable#kernel#module","text":"","title":"Loadable kernel module"},{"location":"Programming/Kernel-module/Loadable-kernel-module/#the#linux#kernel#module#programming#guide","text":"","title":"The Linux Kernel Module Programming Guide"},{"location":"Programming/Kernel-module/Tool/","text":"MODINFO(8) LSMOD(8) MODPROBE(8)","title":"Introduction"},{"location":"Programming/Kernel-module/Tool/#modinfo8","text":"","title":"MODINFO(8)"},{"location":"Programming/Kernel-module/Tool/#lsmod8","text":"","title":"LSMOD(8)"},{"location":"Programming/Kernel-module/Tool/#modprobe8","text":"","title":"MODPROBE(8)"},{"location":"Programming/Lib/","text":"\u5173\u4e8e\u672c\u7ae0 \u5728linux OS\u4e2d\u8fdb\u884cprogramming\u7684\u65f6\u5019\uff0c\u5c31\u5fc5\u987b\u5bf9\u5b83\u7684\u4e3b\u8981\u7684library\u6709\u4e9b\u4e86\u89e3\uff0c\u672c\u7ae0\u4ecb\u7ecdlinux OS\u7684\u4e3b\u8981\u7684lib\u3002","title":"Introduction"},{"location":"Programming/Lib/#_1","text":"\u5728linux OS\u4e2d\u8fdb\u884cprogramming\u7684\u65f6\u5019\uff0c\u5c31\u5fc5\u987b\u5bf9\u5b83\u7684\u4e3b\u8981\u7684library\u6709\u4e9b\u4e86\u89e3\uff0c\u672c\u7ae0\u4ecb\u7ecdlinux OS\u7684\u4e3b\u8981\u7684lib\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Lib/Glibc/","text":"\u5173\u4e8e\u672c\u7ae0 \u5728linux OS\u4e2d\u8fdb\u884cprogramming\u7684\u65f6\u5019\uff0c\u5c31\u5fc5\u987b\u5bf9\u5b83\u7684\u4e3b\u8981\u7684library\u6709\u4e9b\u4e86\u89e3\uff0c\u672c\u7ae0\u4ecb\u7ecdlinux OS\u7684\u4e3b\u8981\u7684lib\u3002","title":"Introduction"},{"location":"Programming/Lib/Glibc/#_1","text":"\u5728linux OS\u4e2d\u8fdb\u884cprogramming\u7684\u65f6\u5019\uff0c\u5c31\u5fc5\u987b\u5bf9\u5b83\u7684\u4e3b\u8981\u7684library\u6709\u4e9b\u4e86\u89e3\uff0c\u672c\u7ae0\u4ecb\u7ecdlinux OS\u7684\u4e3b\u8981\u7684lib\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Lib/Glibc/Glibc/","text":"Glibc \u5b98\u7f51 The GNU C Library (glibc) \u7ef4\u57fa\u767e\u79d1 GNU C Library https://stackoverflow.com/questions/11460782/what-is-glibc-what-is-it-used-for http://www.linfo.org/glibc.html","title":"Glibc"},{"location":"Programming/Lib/Glibc/Glibc/#glibc","text":"","title":"Glibc"},{"location":"Programming/Lib/Glibc/Glibc/#the#gnu#c#library#glibc","text":"","title":"\u5b98\u7f51The GNU C Library (glibc)"},{"location":"Programming/Lib/Glibc/Glibc/#gnu#c#library","text":"https://stackoverflow.com/questions/11460782/what-is-glibc-what-is-it-used-for http://www.linfo.org/glibc.html","title":"\u7ef4\u57fa\u767e\u79d1GNU C Library"},{"location":"Programming/Lib/Glibc/The-GNU-C-Library/","text":"The GNU C Library","title":"The-GNU-C-Library"},{"location":"Programming/Lib/Glibc/The-GNU-C-Library/#the#gnu#c#library","text":"","title":"The GNU C Library"},{"location":"Programming/Multitasking/","text":"\u5173\u4e8e\u672c\u7ae0 multitasking\u662fLinux OS\u7684\u6838\u5fc3\u7279\u6027\uff0c\u5728 Kernel\\Guide\\Linux-OS's-multitasking \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u63cf\u8ff0\u4e86\u5b83\u7684\u7406\u8bba\u77e5\u8bc6\uff0c\u672c\u7ae0\u5c06\u5bf9\u5b83\u4e0e\u5b83\u76f8\u5173\u7684programming\u8fdb\u884c\u63cf\u8ff0\u3002 Thread functions and the process functions \u5728APUE 11.5 Thread Termination\u4e2d\u603b\u7ed3\u4e86\u201csimilarities between the thread functions and the process functions\u201d By now, you should begin to see similarities between the thread functions and the process functions. Figure 11.6 summarizes the similar functions. Process primitive Thread primitive Description fork pthread_create create a new flow of control exit pthread_exit exit from an existing flow of control waitpid pthread_join get exit status from flow of control atexit pthread_cleanup_push register function to be called at exit from flow of control getpid pthread_self get ID for flow of control abort pthread_cancel request abnormal termination of flow of control Figure 11.6 Comparison of process and thread primitives Fork-join model \u5728\u5de5\u7a0b parallel-computing \u7684 Model\\Fork\u2013join-model.md \u4e2d\u603b\u7ed3\u4e86Fork\u2013join model\uff0c\u53ef\u4ee5\u770b\u5230\u4e0a\u8ff0thread functions\u548cprocess functions\u663e\u7136\u662f\u9075\u5faa\u8fd9\u79cdmodel\u7684\uff1a \u4e0b\u9762\u662f\u8349\u7a3f fork api\uff1a entity api process fork thread pthread_create join api entity api process WAIT(2) \u3001 WAIT4(2) thread PTHREAD_JOIN(3) \u3001 pthread_barrier_wait(3) clone \u4e4b\u524d\u5df2\u7ecf\u8c08\u8bba\u4e86Linux OS\u4e2dprocess\u3001thread\u7684\u5b9e\u73b0\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053: \u5b83\u4eec\u90fd\u4f9d\u8d56\u4e8e clone system call\uff0c\u8fd9\u662fLinux OS\u4e2d\uff0c\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2asystem call\uff0c\u6211\u4eec\u5c06\u5b83\u5355\u72ec\u653e\u5230\u4e00\u4e2a\u7ae0\u8282\u4e2d\u8fdb\u884c\u63cf\u8ff0\u3002","title":"Introduction"},{"location":"Programming/Multitasking/#_1","text":"multitasking\u662fLinux OS\u7684\u6838\u5fc3\u7279\u6027\uff0c\u5728 Kernel\\Guide\\Linux-OS's-multitasking \u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u63cf\u8ff0\u4e86\u5b83\u7684\u7406\u8bba\u77e5\u8bc6\uff0c\u672c\u7ae0\u5c06\u5bf9\u5b83\u4e0e\u5b83\u76f8\u5173\u7684programming\u8fdb\u884c\u63cf\u8ff0\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Multitasking/#thread#functions#and#the#process#functions","text":"\u5728APUE 11.5 Thread Termination\u4e2d\u603b\u7ed3\u4e86\u201csimilarities between the thread functions and the process functions\u201d By now, you should begin to see similarities between the thread functions and the process functions. Figure 11.6 summarizes the similar functions. Process primitive Thread primitive Description fork pthread_create create a new flow of control exit pthread_exit exit from an existing flow of control waitpid pthread_join get exit status from flow of control atexit pthread_cleanup_push register function to be called at exit from flow of control getpid pthread_self get ID for flow of control abort pthread_cancel request abnormal termination of flow of control Figure 11.6 Comparison of process and thread primitives","title":"Thread functions and the process functions"},{"location":"Programming/Multitasking/#fork-join#model","text":"\u5728\u5de5\u7a0b parallel-computing \u7684 Model\\Fork\u2013join-model.md \u4e2d\u603b\u7ed3\u4e86Fork\u2013join model\uff0c\u53ef\u4ee5\u770b\u5230\u4e0a\u8ff0thread functions\u548cprocess functions\u663e\u7136\u662f\u9075\u5faa\u8fd9\u79cdmodel\u7684\uff1a \u4e0b\u9762\u662f\u8349\u7a3f fork api\uff1a entity api process fork thread pthread_create join api entity api process WAIT(2) \u3001 WAIT4(2) thread PTHREAD_JOIN(3) \u3001 pthread_barrier_wait(3)","title":"Fork-join model"},{"location":"Programming/Multitasking/#clone","text":"\u4e4b\u524d\u5df2\u7ecf\u8c08\u8bba\u4e86Linux OS\u4e2dprocess\u3001thread\u7684\u5b9e\u73b0\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053: \u5b83\u4eec\u90fd\u4f9d\u8d56\u4e8e clone system call\uff0c\u8fd9\u662fLinux OS\u4e2d\uff0c\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2asystem call\uff0c\u6211\u4eec\u5c06\u5b83\u5355\u72ec\u653e\u5230\u4e00\u4e2a\u7ae0\u8282\u4e2d\u8fdb\u884c\u63cf\u8ff0\u3002","title":"clone"},{"location":"Programming/Multitasking/Capabilities/Capabilities/","text":"Capabilities CAPABILITIES(7) linux-audit Linux capabilities 101 Linux Capabilities: Why They Exist and How They Work linuxjournal Taking Advantage of Linux Capabilities","title":"Capabilities"},{"location":"Programming/Multitasking/Capabilities/Capabilities/#capabilities","text":"","title":"Capabilities"},{"location":"Programming/Multitasking/Capabilities/Capabilities/#capabilities7","text":"","title":"CAPABILITIES(7)"},{"location":"Programming/Multitasking/Capabilities/Capabilities/#linux-audit#linux#capabilities#101","text":"","title":"linux-audit Linux capabilities 101"},{"location":"Programming/Multitasking/Capabilities/Capabilities/#linux#capabilities#why#they#exist#and#how#they#work","text":"","title":"Linux Capabilities: Why They Exist and How They Work"},{"location":"Programming/Multitasking/Capabilities/Capabilities/#linuxjournal#taking#advantage#of#linux#capabilities","text":"","title":"linuxjournal Taking Advantage of Linux Capabilities"},{"location":"Programming/Multitasking/Capabilities/TO-read/","text":"Reading list Taking Advantage of Linux Capabilities Linux capabilities Linux Capabilities in a nutshell Capabilities","title":"Reading list"},{"location":"Programming/Multitasking/Capabilities/TO-read/#reading#list","text":"Taking Advantage of Linux Capabilities Linux capabilities Linux Capabilities in a nutshell Capabilities","title":"Reading list"},{"location":"Programming/Multitasking/Credential/man-7-credentials/","text":"CREDENTIALS(7) DESCRIPTION Process ID (PID) Each process has a unique nonnegative integer identifier that is assigned when the process is created using fork(2) . A process can obtain its PID using getpid(2) . A PID is represented using the type pid_t (defined in <sys/types.h> ). PIDs are used in a range of system calls to identify the process affected by the call, for example: , ptrace(2) , setpriority(2) setpgid(2) , setsid(2) , sigqueue(3) , and waitpid(2) . A process's PID is preserved across an execve(2) . Process group ID and session ID Each process has a session ID and a process group ID , both represented using the type pid_t . A process can obtain its session ID using getsid(2) , and its process group ID using getpgrp(2) . A child created by fork(2) inherits its parent's session ID and process group ID . A process's session ID and process group ID are preserved across an execve(2) . Sessions and process groups are abstractions devised to support shell job control . A process group (sometimes called a \" job \") is a collection of processes that share the same process group ID ; the shell creates a new process group for the process(es) used to execute single command or pipeline (e.g., the two processes created to execute the command \" ls | wc \" are placed in the same process group). A process's group membership can be set using setpgid(2) . The process whose process ID is the same as its process group ID is the process group leader for that group. A session is a collection of processes that share the same session ID. All of the members of a process group also have the same session ID (i.e., all of the members of a process group always belong to the same session, so that sessions and process groups form a strict two-level hierarchy of processes.) A new session is created when a process calls setsid(2) , which creates a new session whose session ID is the same as the PID of the process that called setsid(2) . The creator of the session is called the session leader . All of the processes in a session share a controlling terminal . The controlling terminal is established when the session leader first opens a terminal (unless the O_NOCTTY flag is specified when calling open(2) ). A terminal may be the controlling terminal of at most one session. NOTE: \u5982\u679csession leader\u4e0d\u53bbopen terminal\uff0c\u5219\u8fd9\u4e2asession\u5c31\u6ca1\u6709controlling terminal\u4e86\uff1b At most one of the jobs in a session may be the foreground job ; other jobs in the session are background jobs . Only the foreground job may read from the terminal; when a process in the background attempts to read from the terminal, its process group is sent a SIGTTIN signal, which suspends the job. If the TOSTOP flag has been set for the terminal (see termios(3)), then only the foreground job may write to the terminal; writes from background job cause a SIGTTOU signal to be generated, which suspends the job. When terminal keys that generate a signal (such as the interrupt key, normally control-C) are pressed, the signal is sent to the processes in the foreground job. Various system calls and library functions may operate on all members of a process group, including kill(2), killpg(3), getpriority(2), setpriority(2), ioprio_get(2), ioprio_set(2), waitid(2), and waitpid(2). See also the discussion of the F_GETOWN, F_GETOWN_EX, F_SETOWN, and F_SETOWN_EX operations in fcntl(2).","title":"man-7-credentials"},{"location":"Programming/Multitasking/Credential/man-7-credentials/#credentials7","text":"","title":"CREDENTIALS(7)"},{"location":"Programming/Multitasking/Credential/man-7-credentials/#description","text":"","title":"DESCRIPTION"},{"location":"Programming/Multitasking/Credential/man-7-credentials/#process#id#pid","text":"Each process has a unique nonnegative integer identifier that is assigned when the process is created using fork(2) . A process can obtain its PID using getpid(2) . A PID is represented using the type pid_t (defined in <sys/types.h> ). PIDs are used in a range of system calls to identify the process affected by the call, for example: , ptrace(2) , setpriority(2) setpgid(2) , setsid(2) , sigqueue(3) , and waitpid(2) . A process's PID is preserved across an execve(2) .","title":"Process ID (PID)"},{"location":"Programming/Multitasking/Credential/man-7-credentials/#process#group#id#and#session#id","text":"Each process has a session ID and a process group ID , both represented using the type pid_t . A process can obtain its session ID using getsid(2) , and its process group ID using getpgrp(2) . A child created by fork(2) inherits its parent's session ID and process group ID . A process's session ID and process group ID are preserved across an execve(2) . Sessions and process groups are abstractions devised to support shell job control . A process group (sometimes called a \" job \") is a collection of processes that share the same process group ID ; the shell creates a new process group for the process(es) used to execute single command or pipeline (e.g., the two processes created to execute the command \" ls | wc \" are placed in the same process group). A process's group membership can be set using setpgid(2) . The process whose process ID is the same as its process group ID is the process group leader for that group. A session is a collection of processes that share the same session ID. All of the members of a process group also have the same session ID (i.e., all of the members of a process group always belong to the same session, so that sessions and process groups form a strict two-level hierarchy of processes.) A new session is created when a process calls setsid(2) , which creates a new session whose session ID is the same as the PID of the process that called setsid(2) . The creator of the session is called the session leader . All of the processes in a session share a controlling terminal . The controlling terminal is established when the session leader first opens a terminal (unless the O_NOCTTY flag is specified when calling open(2) ). A terminal may be the controlling terminal of at most one session. NOTE: \u5982\u679csession leader\u4e0d\u53bbopen terminal\uff0c\u5219\u8fd9\u4e2asession\u5c31\u6ca1\u6709controlling terminal\u4e86\uff1b At most one of the jobs in a session may be the foreground job ; other jobs in the session are background jobs . Only the foreground job may read from the terminal; when a process in the background attempts to read from the terminal, its process group is sent a SIGTTIN signal, which suspends the job. If the TOSTOP flag has been set for the terminal (see termios(3)), then only the foreground job may write to the terminal; writes from background job cause a SIGTTOU signal to be generated, which suspends the job. When terminal keys that generate a signal (such as the interrupt key, normally control-C) are pressed, the signal is sent to the processes in the foreground job. Various system calls and library functions may operate on all members of a process group, including kill(2), killpg(3), getpriority(2), setpriority(2), ioprio_get(2), ioprio_set(2), waitid(2), and waitpid(2). See also the discussion of the F_GETOWN, F_GETOWN_EX, F_SETOWN, and F_SETOWN_EX operations in fcntl(2).","title":"Process group ID and session ID"},{"location":"Programming/Multitasking/Implementation-Clone/TODO-index/","text":"clone thegreenplace Launching Linux threads and processes with clone NOTE: \u975e\u5e38\u597d\u7684\u6587\u7ae0\uff0c\u80fd\u591f\u5e2e\u52a9\u6211\u4eec\u7406\u89e3Linux kernel\u7684\u5b9e\u73b0 clone(2) \u2014 Linux manual page","title":"TODO-index"},{"location":"Programming/Multitasking/Implementation-Clone/TODO-index/#clone","text":"","title":"clone"},{"location":"Programming/Multitasking/Implementation-Clone/TODO-index/#thegreenplace#launching#linux#threads#and#processes#with#clone","text":"NOTE: \u975e\u5e38\u597d\u7684\u6587\u7ae0\uff0c\u80fd\u591f\u5e2e\u52a9\u6211\u4eec\u7406\u89e3Linux kernel\u7684\u5b9e\u73b0","title":"thegreenplace Launching Linux threads and processes with clone"},{"location":"Programming/Multitasking/Implementation-Clone/TODO-index/#clone2#linux#manual#page","text":"","title":"clone(2) \u2014 Linux manual page"},{"location":"Programming/Multitasking/Process/Daemon/man-3-daemon/","text":"DAEMON(3)","title":"man-3-daemon"},{"location":"Programming/Multitasking/Process/Daemon/man-3-daemon/#daemon3","text":"","title":"DAEMON(3)"},{"location":"Programming/Multitasking/Process/Daemon/man-7-daemon/","text":"DAEMON(7) DESCRIPTION A daemon is a service process that runs in the background and supervises the system or provides functionality to other processes. Traditionally, daemons are implemented following a scheme originating in SysV Unix. Modern daemons should follow a simpler yet more powerful scheme (here called \"new-style\" daemons), as implemented by systemd(1) . This manual page covers both schemes, and in particular includes recommendations for daemons that shall be included in the systemd init system. SysV Daemons When a traditional SysV daemon starts, it should execute the following steps as part of the initialization. Note that these steps are unnecessary for new-style daemons (see below), and should only be implemented if compatibility with SysV is essential. Close all open file descriptors except standard input, output, and error (i.e. the first three file descriptors 0, 1, 2). This ensures that no accidentally passed file descriptor stays around in the daemon process . On Linux, this is best implemented by iterating through /proc/self/fd , with a fallback of iterating from file descriptor 3 to the value returned by getrlimit() for RLIMIT_NOFILE . SUMMARY : \u6587\u4ef6\u63cf\u8ff0\u7b26\u6807\u5fd7 close-on-exec Reset all signal handlers to their default. This is best done by iterating through the available signals up to the limit of _NSIG and resetting them to SIG_DFL . Reset the signal mask using sigprocmask(). Sanitize the environment block, removing or resetting environment variables that might negatively impact daemon runtime. Call fork() , to create a background process. In the child, call setsid() to detach from any terminal and create an independent session . In the child, call fork() again, to ensure that the daemon can never re-acquire a terminal again. Call exit() in the first child, so that only the second child (the actual daemon process) stays around. This ensures that the daemon process is re-parented to init/PID 1, as all daemons should be. In the daemon process, connect /dev/null to standard input, output, and error. In the daemon process, reset the umask to 0, so that the file modes passed to open() , mkdir() and suchlike directly control the access mode of the created files and directories. In the daemon process , change the current directory to the root directory (/), in order to avoid that the daemon involuntarily\uff08\u65e0\u610f\u7684\uff09 blocks mount points from being unmounted. In the daemon process, write the daemon PID (as returned by getpid() ) to a PID file, for example /run/foobar.pid (for a hypothetical daemon \" foobar \") to ensure that the daemon cannot be started more than once. This must be implemented in race-free fashion so that the PID file is only updated when it is verified at the same time that the PID previously stored in the PID file no longer exists or belongs to a foreign process. In the daemon process, drop privileges, if possible and applicable. From the daemon process, notify the original process started that initialization is complete. This can be implemented via an unnamed pipe or similar communication channel that is created before the first fork() and hence available in both the original and the daemon process. Call exit() in the original process. The process that invoked the daemon must be able to rely on that this exit() happens after initialization is complete and all external communication channels are established and accessible. The BSD daemon() function should not be used, as it implements only a subset of these steps. A daemon that needs to provide compatibility with SysV systems should implement the scheme pointed out above. However, it is recommended to make this behavior optional and configurable via a command line argument to ease debugging as well as to simplify integration into systems using systemd.","title":"man-7-daemon"},{"location":"Programming/Multitasking/Process/Daemon/man-7-daemon/#daemon7","text":"","title":"DAEMON(7)"},{"location":"Programming/Multitasking/Process/Daemon/man-7-daemon/#description","text":"A daemon is a service process that runs in the background and supervises the system or provides functionality to other processes. Traditionally, daemons are implemented following a scheme originating in SysV Unix. Modern daemons should follow a simpler yet more powerful scheme (here called \"new-style\" daemons), as implemented by systemd(1) . This manual page covers both schemes, and in particular includes recommendations for daemons that shall be included in the systemd init system.","title":"DESCRIPTION"},{"location":"Programming/Multitasking/Process/Daemon/man-7-daemon/#sysv#daemons","text":"When a traditional SysV daemon starts, it should execute the following steps as part of the initialization. Note that these steps are unnecessary for new-style daemons (see below), and should only be implemented if compatibility with SysV is essential. Close all open file descriptors except standard input, output, and error (i.e. the first three file descriptors 0, 1, 2). This ensures that no accidentally passed file descriptor stays around in the daemon process . On Linux, this is best implemented by iterating through /proc/self/fd , with a fallback of iterating from file descriptor 3 to the value returned by getrlimit() for RLIMIT_NOFILE . SUMMARY : \u6587\u4ef6\u63cf\u8ff0\u7b26\u6807\u5fd7 close-on-exec Reset all signal handlers to their default. This is best done by iterating through the available signals up to the limit of _NSIG and resetting them to SIG_DFL . Reset the signal mask using sigprocmask(). Sanitize the environment block, removing or resetting environment variables that might negatively impact daemon runtime. Call fork() , to create a background process. In the child, call setsid() to detach from any terminal and create an independent session . In the child, call fork() again, to ensure that the daemon can never re-acquire a terminal again. Call exit() in the first child, so that only the second child (the actual daemon process) stays around. This ensures that the daemon process is re-parented to init/PID 1, as all daemons should be. In the daemon process, connect /dev/null to standard input, output, and error. In the daemon process, reset the umask to 0, so that the file modes passed to open() , mkdir() and suchlike directly control the access mode of the created files and directories. In the daemon process , change the current directory to the root directory (/), in order to avoid that the daemon involuntarily\uff08\u65e0\u610f\u7684\uff09 blocks mount points from being unmounted. In the daemon process, write the daemon PID (as returned by getpid() ) to a PID file, for example /run/foobar.pid (for a hypothetical daemon \" foobar \") to ensure that the daemon cannot be started more than once. This must be implemented in race-free fashion so that the PID file is only updated when it is verified at the same time that the PID previously stored in the PID file no longer exists or belongs to a foreign process. In the daemon process, drop privileges, if possible and applicable. From the daemon process, notify the original process started that initialization is complete. This can be implemented via an unnamed pipe or similar communication channel that is created before the first fork() and hence available in both the original and the daemon process. Call exit() in the original process. The process that invoked the daemon must be able to rely on that this exit() happens after initialization is complete and all external communication channels are established and accessible. The BSD daemon() function should not be used, as it implements only a subset of these steps. A daemon that needs to provide compatibility with SysV systems should implement the scheme pointed out above. However, it is recommended to make this behavior optional and configurable via a command line argument to ease debugging as well as to simplify integration into systems using systemd.","title":"SysV Daemons"},{"location":"Programming/Multitasking/Process/Daemon/python-run-script-as-daemon/","text":"How to make a Python script run like a service or daemon in Linux I have written a Python script that checks a certain e-mail address and passes new e-mails to an external program. How can I get this script to execute 24/7, such as turning it into daemon or service in Linux. Would I also need a loop that never ends in the program, or can it be done by just having the code re executed multiple times? COMMENTS : 1 See SO question: stackoverflow.com/questions/1423345/\u2026 \u2013 mjv Oct 21 '09 at 19:42 3 \"checks a certain e-mail address and passes new e-mails to an external program\" Isn't that what sendmail does? You can define mail alias to route a mailbox to a script. Why aren't you using mail aliases to do this? \u2013 S.Lott Oct 21 '09 at 19:54 1 On a modern linux which has systemd you can create a systemd service in daemon mode as described here . See also: freedesktop.org/software/systemd/man/systemd.service.html \u2013 ccpizza Sep 11 '18 at 23:22 If the linux system supports systemd, use the approach outlined here . \u2013 gerardw Oct 31 '18 at 18:42 A Here's a nice class that is taken from here : #!/usr/bin/env python import sys , os , time , atexit from signal import SIGTERM class Daemon : \"\"\" A generic daemon class. Usage: subclass the Daemon class and override the run() method \"\"\" def __init__ ( self , pidfile , stdin = '/dev/null' , stdout = '/dev/null' , stderr = '/dev/null' ): self . stdin = stdin self . stdout = stdout self . stderr = stderr self . pidfile = pidfile def daemonize ( self ): \"\"\" do the UNIX double-fork magic, see Stevens' \"Advanced Programming in the UNIX Environment\" for details (ISBN 0201563177) http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16 \"\"\" try : pid = os . fork () if pid > 0 : # exit first parent sys . exit ( 0 ) except OSError , e : sys . stderr . write ( \"fork #1 failed: %d ( %s ) \\n \" % ( e . errno , e . strerror )) sys . exit ( 1 ) # decouple from parent environment os . chdir ( \"/\" ) os . setsid () os . umask ( 0 ) # do second fork try : pid = os . fork () if pid > 0 : # exit from second parent sys . exit ( 0 ) except OSError , e : sys . stderr . write ( \"fork #2 failed: %d ( %s ) \\n \" % ( e . errno , e . strerror )) sys . exit ( 1 ) # redirect standard file descriptors sys . stdout . flush () sys . stderr . flush () si = file ( self . stdin , 'r' ) so = file ( self . stdout , 'a+' ) se = file ( self . stderr , 'a+' , 0 ) os . dup2 ( si . fileno (), sys . stdin . fileno ()) os . dup2 ( so . fileno (), sys . stdout . fileno ()) os . dup2 ( se . fileno (), sys . stderr . fileno ()) # write pidfile atexit . register ( self . delpid ) pid = str ( os . getpid ()) file ( self . pidfile , 'w+' ) . write ( \" %s \\n \" % pid ) def delpid ( self ): os . remove ( self . pidfile ) def start ( self ): \"\"\" Start the daemon \"\"\" # Check for a pidfile to see if the daemon already runs try : pf = file ( self . pidfile , 'r' ) pid = int ( pf . read () . strip ()) pf . close () except IOError : pid = None if pid : message = \"pidfile %s already exist. Daemon already running? \\n \" sys . stderr . write ( message % self . pidfile ) sys . exit ( 1 ) # Start the daemon self . daemonize () self . run () def stop ( self ): \"\"\" Stop the daemon \"\"\" # Get the pid from the pidfile try : pf = file ( self . pidfile , 'r' ) pid = int ( pf . read () . strip ()) pf . close () except IOError : pid = None if not pid : message = \"pidfile %s does not exist. Daemon not running? \\n \" sys . stderr . write ( message % self . pidfile ) return # not an error in a restart # Try killing the daemon process try : while 1 : os . kill ( pid , SIGTERM ) time . sleep ( 0.1 ) except OSError , err : err = str ( err ) if err . find ( \"No such process\" ) > 0 : if os . path . exists ( self . pidfile ): os . remove ( self . pidfile ) else : print str ( err ) sys . exit ( 1 ) def restart ( self ): \"\"\" Restart the daemon \"\"\" self . stop () self . start () def run ( self ): \"\"\" You should override this method when you subclass Daemon. It will be called after the process has been daemonized by start() or restart(). \"\"\"","title":"python-run-script-as-daemon"},{"location":"Programming/Multitasking/Process/Daemon/python-run-script-as-daemon/#how#to#make#a#python#script#run#like#a#service#or#daemon#in#linux","text":"I have written a Python script that checks a certain e-mail address and passes new e-mails to an external program. How can I get this script to execute 24/7, such as turning it into daemon or service in Linux. Would I also need a loop that never ends in the program, or can it be done by just having the code re executed multiple times? COMMENTS : 1 See SO question: stackoverflow.com/questions/1423345/\u2026 \u2013 mjv Oct 21 '09 at 19:42 3 \"checks a certain e-mail address and passes new e-mails to an external program\" Isn't that what sendmail does? You can define mail alias to route a mailbox to a script. Why aren't you using mail aliases to do this? \u2013 S.Lott Oct 21 '09 at 19:54 1 On a modern linux which has systemd you can create a systemd service in daemon mode as described here . See also: freedesktop.org/software/systemd/man/systemd.service.html \u2013 ccpizza Sep 11 '18 at 23:22 If the linux system supports systemd, use the approach outlined here . \u2013 gerardw Oct 31 '18 at 18:42","title":"How to make a Python script run like a service or daemon in Linux"},{"location":"Programming/Multitasking/Process/Daemon/python-run-script-as-daemon/#a","text":"Here's a nice class that is taken from here : #!/usr/bin/env python import sys , os , time , atexit from signal import SIGTERM class Daemon : \"\"\" A generic daemon class. Usage: subclass the Daemon class and override the run() method \"\"\" def __init__ ( self , pidfile , stdin = '/dev/null' , stdout = '/dev/null' , stderr = '/dev/null' ): self . stdin = stdin self . stdout = stdout self . stderr = stderr self . pidfile = pidfile def daemonize ( self ): \"\"\" do the UNIX double-fork magic, see Stevens' \"Advanced Programming in the UNIX Environment\" for details (ISBN 0201563177) http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16 \"\"\" try : pid = os . fork () if pid > 0 : # exit first parent sys . exit ( 0 ) except OSError , e : sys . stderr . write ( \"fork #1 failed: %d ( %s ) \\n \" % ( e . errno , e . strerror )) sys . exit ( 1 ) # decouple from parent environment os . chdir ( \"/\" ) os . setsid () os . umask ( 0 ) # do second fork try : pid = os . fork () if pid > 0 : # exit from second parent sys . exit ( 0 ) except OSError , e : sys . stderr . write ( \"fork #2 failed: %d ( %s ) \\n \" % ( e . errno , e . strerror )) sys . exit ( 1 ) # redirect standard file descriptors sys . stdout . flush () sys . stderr . flush () si = file ( self . stdin , 'r' ) so = file ( self . stdout , 'a+' ) se = file ( self . stderr , 'a+' , 0 ) os . dup2 ( si . fileno (), sys . stdin . fileno ()) os . dup2 ( so . fileno (), sys . stdout . fileno ()) os . dup2 ( se . fileno (), sys . stderr . fileno ()) # write pidfile atexit . register ( self . delpid ) pid = str ( os . getpid ()) file ( self . pidfile , 'w+' ) . write ( \" %s \\n \" % pid ) def delpid ( self ): os . remove ( self . pidfile ) def start ( self ): \"\"\" Start the daemon \"\"\" # Check for a pidfile to see if the daemon already runs try : pf = file ( self . pidfile , 'r' ) pid = int ( pf . read () . strip ()) pf . close () except IOError : pid = None if pid : message = \"pidfile %s already exist. Daemon already running? \\n \" sys . stderr . write ( message % self . pidfile ) sys . exit ( 1 ) # Start the daemon self . daemonize () self . run () def stop ( self ): \"\"\" Stop the daemon \"\"\" # Get the pid from the pidfile try : pf = file ( self . pidfile , 'r' ) pid = int ( pf . read () . strip ()) pf . close () except IOError : pid = None if not pid : message = \"pidfile %s does not exist. Daemon not running? \\n \" sys . stderr . write ( message % self . pidfile ) return # not an error in a restart # Try killing the daemon process try : while 1 : os . kill ( pid , SIGTERM ) time . sleep ( 0.1 ) except OSError , err : err = str ( err ) if err . find ( \"No such process\" ) > 0 : if os . path . exists ( self . pidfile ): os . remove ( self . pidfile ) else : print str ( err ) sys . exit ( 1 ) def restart ( self ): \"\"\" Restart the daemon \"\"\" self . stop () self . start () def run ( self ): \"\"\" You should override this method when you subclass Daemon. It will be called after the process has been daemonized by start() or restart(). \"\"\"","title":"A"},{"location":"Programming/Multitasking/Process/Exit/Process-exit/","text":"Process exit Execute function on exit or program end std::set_terminate ON_EXIT(3) ATEXIT(3) When does a process terminate in UNIX?","title":"Process-exit"},{"location":"Programming/Multitasking/Process/Exit/Process-exit/#process#exit","text":"Execute function on exit or program end std::set_terminate ON_EXIT(3) ATEXIT(3) When does a process terminate in UNIX?","title":"Process exit"},{"location":"Programming/Multitasking/Process/IPC/","text":"Inter-process communication wikipedia Inter-process communication Library Boost.Interprocess https://www.boost.org/","title":"Introduction"},{"location":"Programming/Multitasking/Process/IPC/#inter-process#communication","text":"","title":"Inter-process communication"},{"location":"Programming/Multitasking/Process/IPC/#wikipedia#inter-process#communication","text":"","title":"wikipedia Inter-process communication"},{"location":"Programming/Multitasking/Process/IPC/#library","text":"","title":"Library"},{"location":"Programming/Multitasking/Process/IPC/#boostinterprocess","text":"https://www.boost.org/","title":"Boost.Interprocess"},{"location":"Programming/Multitasking/Process/IPC/POSIX-message-queues/","text":"MQ_OVERVIEW(7)","title":"POSIX-message-queues"},{"location":"Programming/Multitasking/Process/IPC/POSIX-message-queues/#mq_overview7","text":"","title":"MQ_OVERVIEW(7)"},{"location":"Programming/Multitasking/Process/IPC/POSIX-semaphores/","text":"SEM_OVERVIEW(7)","title":"POSIX-semaphores"},{"location":"Programming/Multitasking/Process/IPC/POSIX-semaphores/#sem_overview7","text":"","title":"SEM_OVERVIEW(7)"},{"location":"Programming/Multitasking/Process/IPC/System-V-IPC/man-7-SVIPC/","text":"SVIPC(7)","title":"man-7-SVIPC"},{"location":"Programming/Multitasking/Process/IPC/System-V-IPC/man-7-SVIPC/#svipc7","text":"","title":"SVIPC(7)"},{"location":"Programming/Multitasking/Process/IPC/System-V-IPC/Semaphore/man-7-semaphores/","text":"SEM_OVERVIEW(7) SEM_OVERVIEW(7)","title":"Man 7 semaphores"},{"location":"Programming/Multitasking/Process/IPC/System-V-IPC/Semaphore/man-7-semaphores/#sem_overview7","text":"","title":"SEM_OVERVIEW(7)"},{"location":"Programming/Multitasking/Process/IPC/Tools/ipcrm/","text":"ipcrm ipcrm(1) - Linux man page","title":"ipcrm"},{"location":"Programming/Multitasking/Process/IPC/Tools/ipcrm/#ipcrm","text":"","title":"ipcrm"},{"location":"Programming/Multitasking/Process/IPC/Tools/ipcrm/#ipcrm1#-#linux#man#page","text":"","title":"ipcrm(1) - Linux man page"},{"location":"Programming/Multitasking/Process/IPC/Tools/ipcs/","text":"ipcs csdn ipcs\u547d\u4ee4\u8be6\u89e3\u2014\u2014\u5171\u4eab\u5185\u5b58\u3001\u6d88\u606f\u961f\u5217\u3001\u4fe1\u53f7\u91cf\u5b9a\u4f4d\u5229\u5668 \u6e05\u7a7a\u4fe1\u53f7\u91cf \u5207\u6362\u5230\u5b89\u88c5\u7528\u6237\uff0c\u6bd4\u5982trade\u7528\u6237\uff0c\u8fd0\u884c\u5982\u4e0b\u547d\u4ee4\uff0c\u6e05\u7a7a\u539f\u6709\u7684\u4fe1\u53f7\u91cf\uff1a ipcs -s | grep ` whoami ` | awk -v user = ` whoami ` '{system(\"ipcrm -s\" $2);printf(\"remove %s for %s\\n\",$2,user)}'","title":"ipcs"},{"location":"Programming/Multitasking/Process/IPC/Tools/ipcs/#ipcs","text":"","title":"ipcs"},{"location":"Programming/Multitasking/Process/IPC/Tools/ipcs/#csdn#ipcs","text":"","title":"csdn ipcs\u547d\u4ee4\u8be6\u89e3\u2014\u2014\u5171\u4eab\u5185\u5b58\u3001\u6d88\u606f\u961f\u5217\u3001\u4fe1\u53f7\u91cf\u5b9a\u4f4d\u5229\u5668"},{"location":"Programming/Multitasking/Process/IPC/Tools/ipcs/#_1","text":"\u5207\u6362\u5230\u5b89\u88c5\u7528\u6237\uff0c\u6bd4\u5982trade\u7528\u6237\uff0c\u8fd0\u884c\u5982\u4e0b\u547d\u4ee4\uff0c\u6e05\u7a7a\u539f\u6709\u7684\u4fe1\u53f7\u91cf\uff1a ipcs -s | grep ` whoami ` | awk -v user = ` whoami ` '{system(\"ipcrm -s\" $2);printf(\"remove %s for %s\\n\",$2,user)}'","title":"\u6e05\u7a7a\u4fe1\u53f7\u91cf"},{"location":"Programming/Multitasking/Process/IPC/Unix/man-7-unix/","text":"UNIX(7) unix - sockets for local interprocess communication #include <sys/socket.h> #include <sys/un.h> unix_socket = socket ( AF_UNIX , type , 0 ); error = socketpair ( AF_UNIX , type , 0 , int * sv );","title":"man-7-unix"},{"location":"Programming/Multitasking/Process/IPC/Unix/man-7-unix/#unix7","text":"unix - sockets for local interprocess communication #include <sys/socket.h> #include <sys/un.h> unix_socket = socket ( AF_UNIX , type , 0 ); error = socketpair ( AF_UNIX , type , 0 , int * sv );","title":"UNIX(7)"},{"location":"Programming/Multitasking/Process/Organization-of-process/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u4ee5\u201c\u7ed3\u6784\u5316\u601d\u7ef4\u201d\u6765\u63cf\u8ff0OS\u5bf9process\u7684\u7ec4\u7ec7\uff0c\u5f62\u6210\u4e00\u4e2a\u5b8c\u6574\u7684\u7ed3\u6784\u3002 \u672c\u7ae0\u53c2\u8003\u5185\u5bb9\u6709\uff1a APUE","title":"Introduction"},{"location":"Programming/Multitasking/Process/Organization-of-process/#_1","text":"\u672c\u7ae0\u4ee5\u201c\u7ed3\u6784\u5316\u601d\u7ef4\u201d\u6765\u63cf\u8ff0OS\u5bf9process\u7684\u7ec4\u7ec7\uff0c\u5f62\u6210\u4e00\u4e2a\u5b8c\u6574\u7684\u7ed3\u6784\u3002 \u672c\u7ae0\u53c2\u8003\u5185\u5bb9\u6709\uff1a APUE","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Multitasking/Process/Organization-of-process/Organization-of-process/","text":"Organization of process kernel\u7ec4\u7ec7process\u7684hierarchy\uff1a session process group process thread","title":"Organization-of-process"},{"location":"Programming/Multitasking/Process/Organization-of-process/Organization-of-process/#organization#of#process","text":"kernel\u7ec4\u7ec7process\u7684hierarchy\uff1a session process group process thread","title":"Organization of process"},{"location":"Programming/Multitasking/Process/Organization-of-process/man-7-cgroups/","text":"CGROUPS(7) CGROUPS(7)","title":"man-7-cgroups"},{"location":"Programming/Multitasking/Process/Organization-of-process/man-7-cgroups/#cgroups7","text":"","title":"CGROUPS(7)"},{"location":"Programming/Multitasking/Process/Proc-filesystem/man-5-proc/","text":"/proc PROC(5) wikipedia procfs tldp 1.14. /proc kernel The /proc Filesystem","title":"man-5-proc"},{"location":"Programming/Multitasking/Process/Proc-filesystem/man-5-proc/#proc","text":"","title":"/proc"},{"location":"Programming/Multitasking/Process/Proc-filesystem/man-5-proc/#proc5","text":"","title":"PROC(5)"},{"location":"Programming/Multitasking/Process/Proc-filesystem/man-5-proc/#wikipedia#procfs","text":"","title":"wikipedia procfs"},{"location":"Programming/Multitasking/Process/Proc-filesystem/man-5-proc/#tldp#114#proc","text":"","title":"tldp 1.14. /proc"},{"location":"Programming/Multitasking/Process/Proc-filesystem/man-5-proc/#kernel#the#proc#filesystem","text":"","title":"kernel The /proc Filesystem"},{"location":"Programming/Multitasking/Process/Process-state/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bbaprocess state\uff0c\u5373\u201c\u8fdb\u7a0b\u72b6\u6001\u201d\uff0c\u5728\u4e0b\u9762\u7ae0\u8282\u4e2d\uff0c\u4e5f\u5bf9\u5b83\u8fdb\u884c\u4e86\u8bf4\u660e: \u7ae0\u8282 \u8bf4\u660e Kernel\\Book-Understanding-the-Linux-Kernel\\Chapter-3-Processes\\3.2.1-Process-State.md \u4ecb\u7ecd\u4e86\u4e00\u4e9bprocess state Programming\\Process\\Tools\\procps\\ps \u4ecb\u7ecd\u4e86\u5982\u4f55\u67e5\u770bprocess state\u3001process state Shell-and-tools\\Tools\\Debug\\Application\\Stuck-process.md","title":"Introduction"},{"location":"Programming/Multitasking/Process/Process-state/#_1","text":"\u672c\u7ae0\u8ba8\u8bbaprocess state\uff0c\u5373\u201c\u8fdb\u7a0b\u72b6\u6001\u201d\uff0c\u5728\u4e0b\u9762\u7ae0\u8282\u4e2d\uff0c\u4e5f\u5bf9\u5b83\u8fdb\u884c\u4e86\u8bf4\u660e: \u7ae0\u8282 \u8bf4\u660e Kernel\\Book-Understanding-the-Linux-Kernel\\Chapter-3-Processes\\3.2.1-Process-State.md \u4ecb\u7ecd\u4e86\u4e00\u4e9bprocess state Programming\\Process\\Tools\\procps\\ps \u4ecb\u7ecd\u4e86\u5982\u4f55\u67e5\u770bprocess state\u3001process state Shell-and-tools\\Tools\\Debug\\Application\\Stuck-process.md","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Multitasking/Sched/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u63cf\u8ff0\u4e86\u5982\u4f55\u4f7f\u7528Linux scheduler system call\uff0c\u5173\u4e8eLinux scheduler \u7684\u7406\u8bba\u77e5\u8bc6\uff0c\u53c2\u89c1 Kernel\\Guide\\Linux-OS's-multitasking\\Sched \u3002 \u5728 SCHED(7) \u4e2d\uff0c\u7ed9\u51fa\u4e86API summary\uff0c\u8fd9\u4fbf\u4e8e\u6211\u4eec\u4f7f\u7528\u8fd9\u4e9bsystem call\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Multitasking/Sched/#_1","text":"\u672c\u7ae0\u63cf\u8ff0\u4e86\u5982\u4f55\u4f7f\u7528Linux scheduler system call\uff0c\u5173\u4e8eLinux scheduler \u7684\u7406\u8bba\u77e5\u8bc6\uff0c\u53c2\u89c1 Kernel\\Guide\\Linux-OS's-multitasking\\Sched \u3002 \u5728 SCHED(7) \u4e2d\uff0c\u7ed9\u51fa\u4e86API summary\uff0c\u8fd9\u4fbf\u4e8e\u6211\u4eec\u4f7f\u7528\u8fd9\u4e9bsystem call\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Multitasking/Sched/Sched/","text":"Sched sched_setaffinity man 2 sched_setaffinity Example1 \u6765\u6e90\uff1a \u5982\u4f55\u6307\u5b9a\u8fdb\u7a0b\u8fd0\u884c\u7684CPU(\u547d\u4ee4\u884c taskset) More information on pthread_setaffinity_np and sched_setaffinity \u539f\u6587\u4e2d\u7684\u7a0b\u5e8f\u662f\u65e0\u6cd5\u7f16\u8bd1\u901a\u8fc7\u7684\uff0c\u4e0b\u9762\u662f\u5bf9\u5176\u66f4\u6b63\u540e\uff0c\u53ef\u4ee5\u7f16\u8bd1\u901a\u8fc7\u7684\u7248\u672c\uff1a /* Short test program to test sched_setaffinity * (which sets the affinity of processes to processors). * Compile: gcc sched_setaffinity_test.c * -o sched_setaffinity_test -lm * Usage: ./sched_setaffinity_test * * Open a \"top\"-window at the same time and see all the work * being done on CPU 0 first and after a short wait on CPU 1. * Repeat with different numbers to make sure, it is not a * coincidence. */ #include <stdio.h> #include <math.h> #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/wait.h> double waste_time ( long n ) { double res = 0 ; long i = 0 ; while ( i < n * 200000 ) { i ++ ; res += sqrt ( i ); } return res ; } int main ( int argc , char ** argv ) { unsigned long mask = 1 ; /* processor 0 */ cpu_set_t set ; CPU_SET ( mask , & set ); /* bind process to processor 0 */ if ( sched_setaffinity ( getpid (), sizeof ( set ), & set ) < 0 ) { perror ( \"sched_setaffinity\" ); } /* waste some time so the work is visible with \"top\" */ printf ( \"result: %f \\n \" , waste_time ( 2000 )); mask = 2 ; /* process switches to processor 1 now */ CPU_SET ( mask , & set ); if ( sched_setaffinity ( getpid (), sizeof ( set ), & set ) < 0 ) { perror ( \"sched_setaffinity\" ); } /* waste some more time to see the processor switch */ printf ( \"result: %f \\n \" , waste_time ( 2000 )); } \u7f16\u8bd1\u6307\u4ee4\uff1a gcc test.cpp -lm Example 2 \u6765\u6e90\uff1a sched_setaffinity(2) \u2014 Linux manual page #define _GNU_SOURCE #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/wait.h> #define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ } while (0) int main ( int argc , char * argv []) { cpu_set_t set ; int parentCPU , childCPU ; int nloops , j ; if ( argc != 4 ) { fprintf ( stderr , \"Usage: %s parent-cpu child-cpu num-loops \\n \" , argv [ 0 ]); exit ( EXIT_FAILURE ); } parentCPU = atoi ( argv [ 1 ]); childCPU = atoi ( argv [ 2 ]); nloops = atoi ( argv [ 3 ]); CPU_ZERO ( & set ); switch ( fork ()) { case -1 : /* Error */ errExit ( \"fork\" ); case 0 : /* Child */ CPU_SET ( childCPU , & set ); if ( sched_setaffinity ( getpid (), sizeof ( set ), & set ) == -1 ) errExit ( \"sched_setaffinity\" ); for ( j = 0 ; j < nloops ; j ++ ) getppid (); exit ( EXIT_SUCCESS ); default : /* Parent */ CPU_SET ( parentCPU , & set ); if ( sched_setaffinity ( getpid (), sizeof ( set ), & set ) == -1 ) errExit ( \"sched_setaffinity\" ); for ( j = 0 ; j < nloops ; j ++ ) getppid (); wait ( NULL ); /* Wait for child to terminate */ exit ( EXIT_SUCCESS ); } } pthread_setaffinity_np man 3 pthread_setaffinity_np","title":"Sched"},{"location":"Programming/Multitasking/Sched/Sched/#sched","text":"","title":"Sched"},{"location":"Programming/Multitasking/Sched/Sched/#sched_setaffinity","text":"","title":"sched_setaffinity"},{"location":"Programming/Multitasking/Sched/Sched/#man#2#sched_setaffinity","text":"","title":"man 2 sched_setaffinity"},{"location":"Programming/Multitasking/Sched/Sched/#example1","text":"\u6765\u6e90\uff1a \u5982\u4f55\u6307\u5b9a\u8fdb\u7a0b\u8fd0\u884c\u7684CPU(\u547d\u4ee4\u884c taskset) More information on pthread_setaffinity_np and sched_setaffinity \u539f\u6587\u4e2d\u7684\u7a0b\u5e8f\u662f\u65e0\u6cd5\u7f16\u8bd1\u901a\u8fc7\u7684\uff0c\u4e0b\u9762\u662f\u5bf9\u5176\u66f4\u6b63\u540e\uff0c\u53ef\u4ee5\u7f16\u8bd1\u901a\u8fc7\u7684\u7248\u672c\uff1a /* Short test program to test sched_setaffinity * (which sets the affinity of processes to processors). * Compile: gcc sched_setaffinity_test.c * -o sched_setaffinity_test -lm * Usage: ./sched_setaffinity_test * * Open a \"top\"-window at the same time and see all the work * being done on CPU 0 first and after a short wait on CPU 1. * Repeat with different numbers to make sure, it is not a * coincidence. */ #include <stdio.h> #include <math.h> #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/wait.h> double waste_time ( long n ) { double res = 0 ; long i = 0 ; while ( i < n * 200000 ) { i ++ ; res += sqrt ( i ); } return res ; } int main ( int argc , char ** argv ) { unsigned long mask = 1 ; /* processor 0 */ cpu_set_t set ; CPU_SET ( mask , & set ); /* bind process to processor 0 */ if ( sched_setaffinity ( getpid (), sizeof ( set ), & set ) < 0 ) { perror ( \"sched_setaffinity\" ); } /* waste some time so the work is visible with \"top\" */ printf ( \"result: %f \\n \" , waste_time ( 2000 )); mask = 2 ; /* process switches to processor 1 now */ CPU_SET ( mask , & set ); if ( sched_setaffinity ( getpid (), sizeof ( set ), & set ) < 0 ) { perror ( \"sched_setaffinity\" ); } /* waste some more time to see the processor switch */ printf ( \"result: %f \\n \" , waste_time ( 2000 )); } \u7f16\u8bd1\u6307\u4ee4\uff1a gcc test.cpp -lm","title":"Example1"},{"location":"Programming/Multitasking/Sched/Sched/#example#2","text":"\u6765\u6e90\uff1a sched_setaffinity(2) \u2014 Linux manual page #define _GNU_SOURCE #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/wait.h> #define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\ } while (0) int main ( int argc , char * argv []) { cpu_set_t set ; int parentCPU , childCPU ; int nloops , j ; if ( argc != 4 ) { fprintf ( stderr , \"Usage: %s parent-cpu child-cpu num-loops \\n \" , argv [ 0 ]); exit ( EXIT_FAILURE ); } parentCPU = atoi ( argv [ 1 ]); childCPU = atoi ( argv [ 2 ]); nloops = atoi ( argv [ 3 ]); CPU_ZERO ( & set ); switch ( fork ()) { case -1 : /* Error */ errExit ( \"fork\" ); case 0 : /* Child */ CPU_SET ( childCPU , & set ); if ( sched_setaffinity ( getpid (), sizeof ( set ), & set ) == -1 ) errExit ( \"sched_setaffinity\" ); for ( j = 0 ; j < nloops ; j ++ ) getppid (); exit ( EXIT_SUCCESS ); default : /* Parent */ CPU_SET ( parentCPU , & set ); if ( sched_setaffinity ( getpid (), sizeof ( set ), & set ) == -1 ) errExit ( \"sched_setaffinity\" ); for ( j = 0 ; j < nloops ; j ++ ) getppid (); wait ( NULL ); /* Wait for child to terminate */ exit ( EXIT_SUCCESS ); } }","title":"Example 2"},{"location":"Programming/Multitasking/Sched/Sched/#pthread_setaffinity_np","text":"","title":"pthread_setaffinity_np"},{"location":"Programming/Multitasking/Sched/Sched/#man#3#pthread_setaffinity_np","text":"","title":"man 3 pthread_setaffinity_np"},{"location":"Programming/Multitasking/Sched/Tool/taskset/","text":"taskset(1)","title":"taskset"},{"location":"Programming/Multitasking/Sched/Tool/taskset/#taskset1","text":"","title":"taskset(1)"},{"location":"Programming/Multitasking/Thread/Thread-model/","text":"Thread model \u7ebf\u7a0b\u6a21\u578b\uff1a\u6839\u636e\u6570\u636e\u7ed3\u6784\u6765\u8bbe\u8ba1**\u5e76\u53d1\u5355\u4f4d**","title":"Thread-model"},{"location":"Programming/Multitasking/Thread/Thread-model/#thread#model","text":"\u7ebf\u7a0b\u6a21\u578b\uff1a\u6839\u636e\u6570\u636e\u7ed3\u6784\u6765\u8bbe\u8ba1**\u5e76\u53d1\u5355\u4f4d**","title":"Thread model"},{"location":"Programming/Multitasking/Thread/man-7-attributes/","text":"ATTRIBUTES(7)","title":"man-7-attributes"},{"location":"Programming/Multitasking/Thread/man-7-attributes/#attributes7","text":"","title":"ATTRIBUTES(7)"},{"location":"Programming/Multitasking/Thread/man-7-pthreads/","text":"PTHREADS(7) NAME pthreads - POSIX threads DESCRIPTION POSIX.1 specifies a set of interfaces (functions, header files) for threaded programming commonly known as POSIX threads, or Pthreads. A single process can contain multiple threads, all of which are executing the same program. These threads share the same global memory (data and heap segments), but each thread has its own stack (automatic variables). POSIX.1 also requires that threads share a range of other attributes (i.e., these attributes are process-wide rather than per-thread): process ID parent process ID process group ID and session ID controlling terminal user and group IDs open file descriptors record locks (see fcntl(2) ) signal dispositions file mode creation mask ( umask(2) ) current directory ( chdir(2) ) and root directory ( chroot(2) ) interval timers ( setitimer(2) ) and POSIX timers ( timer_create(2) ) nice value ( setpriority(2) ) resource limits ( setrlimit(2) ) measurements of the consumption of CPU time ( times(2) ) and resources ( getrusage(2) ) SUMMARY : \u5982\u4f55\u7edf\u8ba1the consumption of CPU of a thread\uff1f\u53c2\u89c1 PTHREAD_GETCPUCLOCKID(3) As well as the stack, POSIX.1 specifies that various other attributes are distinct for each thread, including: thread ID (the pthread_t data type) signal mask ( pthread_sigmask(3) ) the errno variable alternate signal stack ( sigaltstack(2) ) real-time scheduling policy and priority ( sched(7) ) The following Linux-specific features are also per-thread: capabilities (see capabilities(7) ) CPU affinity ( sched_setaffinity(2) ) Pthreads function return values Most pthreads functions return 0 on success, and an error number on failure. Note that the pthreads functions do not set errno . For each of the pthreads functions that can return an error, POSIX.1-2001 specifies that the function can never fail with the error EINTR . SUMMARY : linux system call\u662f\u4f1a\u8bbe\u7f6e errno \u7684\u3002 Thread IDs Each of the threads in a process has a unique thread identifier (stored in the type pthread_t). This identifier is returned to the caller of pthread_create(3) , and a thread can obtain its own thread identifier using pthread_self(3) . Thread IDs are guaranteed to be unique only within a process. (In all pthreads functions that accept a thread ID as an argument, that ID by definition refers to a thread in the same process as the caller.) The system may reuse a thread ID after a terminated thread has been joined, or a detached thread has terminated. POSIX says: \"If an application attempts to use a thread ID whose lifetime has ended, the behavior is undefined.\" Thread-safe functions Async-cancel-safe functions An async-cancel-safe function is one that can be safely called in an application where asynchronous cancelability is enabled (see pthread_setcancelstate(3) ). Only the following functions are required to be async-cancel-safe by POSIX.1-2001 and POSIX.1-2008: pthread_cancel () pthread_setcancelstate () pthread_setcanceltype () Cancellation points POSIX.1 specifies that certain functions must, and certain other functions may, be cancellation points . If a thread is cancelable, its cancelability type is deferred , and a cancellation request is pending for the thread, then the thread is canceled when it calls a function that is a cancellation point . The following functions are required to be cancellation points by POSIX.1-2001 and/or POSIX.1-2008: accept () aio_suspend () clock_nanosleep () close () connect () creat () fcntl () F_SETLKW fdatasync () fsync () getmsg () getpmsg () lockf () F_LOCK mq_receive () mq_send () mq_timedreceive () mq_timedsend () msgrcv () msgsnd () msync () nanosleep () open () openat () [ Added in POSIX .1 -2008 ] pause () poll () pread () pselect () pthread_cond_timedwait () pthread_cond_wait () pthread_join () pthread_testcancel () putmsg () putpmsg () pwrite () read () readv () recv () recvfrom () recvmsg () select () sem_timedwait () sem_wait () send () sendmsg () sendto () sigpause () [ POSIX .1 -2001 only ( moves to \"may\" list in POSIX .1 -2008 )] sigsuspend () sigtimedwait () sigwait () sigwaitinfo () sleep () system () tcdrain () usleep () [ POSIX .1 -2001 only ( function removed in POSIX .1 -2008 )] wait () waitid () waitpid () write () writev () The following functions may be cancellation points according to POSIX.1-2001 and/or POSIX.1-2008: access () asctime () asctime_r () catclose () catgets () catopen () chmod () [ Added in POSIX .1 -2008 ] chown () [ Added in POSIX .1 -2008 ] closedir () closelog () ctermid () ctime () ctime_r () dbm_close () dbm_delete () dbm_fetch () dbm_nextkey () dbm_open () dbm_store () dlclose () dlopen () dprintf () [ Added in POSIX .1 -2008 ] endgrent () endhostent () endnetent () endprotoent () endpwent () endservent () endutxent () faccessat () [ Added in POSIX .1 -2008 ] fchmod () [ Added in POSIX .1 -2008 ] fchmodat () [ Added in POSIX .1 -2008 ] fchown () [ Added in POSIX .1 -2008 ] fchownat () [ Added in POSIX .1 -2008 ] fclose () fcntl () ( for any value of cmd argument ) fflush () fgetc () fgetpos () fgets () fgetwc () fgetws () fmtmsg () fopen () fpathconf () fprintf () fputc () fputs () fputwc () fputws () fread () freopen () fscanf () fseek () fseeko () fsetpos () fstat () fstatat () [ Added in POSIX .1 -2008 ] ftell () ftello () ftw () futimens () [ Added in POSIX .1 -2008 ] fwprintf () fwrite () fwscanf () getaddrinfo () getc () getc_unlocked () getchar () getchar_unlocked () getcwd () getdate () getdelim () [ Added in POSIX .1 -2008 ] getgrent () getgrgid () getgrgid_r () getgrnam () getgrnam_r () gethostbyaddr () [ SUSv3 only ( function removed in POSIX .1 -2008 )] gethostbyname () [ SUSv3 only ( function removed in POSIX .1 -2008 )] gethostent () gethostid () gethostname () getline () [ Added in POSIX .1 -2008 ] getlogin () getlogin_r () getnameinfo () getnetbyaddr () getnetbyname () getnetent () getopt () ( if opterr is nonzero ) getprotobyname () getprotobynumber () getprotoent () getpwent () getpwnam () getpwnam_r () getpwuid () getpwuid_r () gets () getservbyname () getservbyport () getservent () getutxent () getutxid () getutxline () getwc () getwchar () getwd () [ SUSv3 only ( function removed in POSIX .1 -2008 )] glob () iconv_close () iconv_open () ioctl () link () linkat () [ Added in POSIX .1 -2008 ] lio_listio () [ Added in POSIX .1 -2008 ] localtime () localtime_r () lockf () [ Added in POSIX .1 -2008 ] lseek () lstat () mkdir () [ Added in POSIX .1 -2008 ] mkdirat () [ Added in POSIX .1 -2008 ] mkdtemp () [ Added in POSIX .1 -2008 ] mkfifo () [ Added in POSIX .1 -2008 ] mkfifoat () [ Added in POSIX .1 -2008 ] mknod () [ Added in POSIX .1 -2008 ] mknodat () [ Added in POSIX .1 -2008 ] mkstemp () mktime () nftw () opendir () openlog () pathconf () pclose () perror () popen () posix_fadvise () posix_fallocate () posix_madvise () posix_openpt () posix_spawn () posix_spawnp () posix_trace_clear () posix_trace_close () posix_trace_create () posix_trace_create_withlog () posix_trace_eventtypelist_getnext_id () posix_trace_eventtypelist_rewind () posix_trace_flush () posix_trace_get_attr () posix_trace_get_filter () posix_trace_get_status () posix_trace_getnext_event () posix_trace_open () posix_trace_rewind () posix_trace_set_filter () posix_trace_shutdown () posix_trace_timedgetnext_event () posix_typed_mem_open () printf () psiginfo () [ Added in POSIX .1 -2008 ] psignal () [ Added in POSIX .1 -2008 ] pthread_rwlock_rdlock () pthread_rwlock_timedrdlock () pthread_rwlock_timedwrlock () pthread_rwlock_wrlock () putc () putc_unlocked () putchar () putchar_unlocked () puts () pututxline () putwc () putwchar () readdir () readdir_r () readlink () [ Added in POSIX .1 -2008 ] readlinkat () [ Added in POSIX .1 -2008 ] remove () rename () renameat () [ Added in POSIX .1 -2008 ] rewind () rewinddir () scandir () [ Added in POSIX .1 -2008 ] scanf () seekdir () semop () setgrent () sethostent () setnetent () setprotoent () setpwent () setservent () setutxent () sigpause () [ Added in POSIX .1 -2008 ] stat () strerror () strerror_r () strftime () symlink () symlinkat () [ Added in POSIX .1 -2008 ] sync () syslog () tmpfile () tmpnam () ttyname () ttyname_r () tzset () ungetc () ungetwc () unlink () unlinkat () [ Added in POSIX .1 -2008 ] utime () [ Added in POSIX .1 -2008 ] utimensat () [ Added in POSIX .1 -2008 ] utimes () [ Added in POSIX .1 -2008 ] vdprintf () [ Added in POSIX .1 -2008 ] vfprintf () vfwprintf () vprintf () vwprintf () wcsftime () wordexp () wprintf () wscanf () An implementation may also mark other functions not specified in the standard as cancellation points . In particular, an implementation is likely to mark any nonstandard function that may block as a cancellation point . (This includes most functions that can touch files.) Linux implementations of POSIX threads Over time, two threading implementations have been provided by the GNU C library on Linux: LinuxThreads This is the original Pthreads implementation. Since glibc 2.4, this implementation is no longer supported. NPTL (Native POSIX Threads Library) This is the modern Pthreads implementation. By comparison with LinuxThreads, NPTL provides closer conformance to the requirements of the POSIX.1 specification and better performance when creating large numbers of threads. NPTL is available since glibc 2.3.2, and requires features that are present in the Linux 2.6 kernel. Both of these are so-called 1:1 implementations, meaning that each thread maps to a kernel scheduling entity . Both threading implementations employ the Linux clone(2) system call. In NPTL, thread synchronization primitives (mutexes, thread joining, and so on) are implemented using the Linux futex(2) system call.","title":"man-7-pthreads"},{"location":"Programming/Multitasking/Thread/man-7-pthreads/#pthreads7","text":"","title":"PTHREADS(7)"},{"location":"Programming/Multitasking/Thread/man-7-pthreads/#name","text":"pthreads - POSIX threads","title":"NAME"},{"location":"Programming/Multitasking/Thread/man-7-pthreads/#description","text":"POSIX.1 specifies a set of interfaces (functions, header files) for threaded programming commonly known as POSIX threads, or Pthreads. A single process can contain multiple threads, all of which are executing the same program. These threads share the same global memory (data and heap segments), but each thread has its own stack (automatic variables). POSIX.1 also requires that threads share a range of other attributes (i.e., these attributes are process-wide rather than per-thread): process ID parent process ID process group ID and session ID controlling terminal user and group IDs open file descriptors record locks (see fcntl(2) ) signal dispositions file mode creation mask ( umask(2) ) current directory ( chdir(2) ) and root directory ( chroot(2) ) interval timers ( setitimer(2) ) and POSIX timers ( timer_create(2) ) nice value ( setpriority(2) ) resource limits ( setrlimit(2) ) measurements of the consumption of CPU time ( times(2) ) and resources ( getrusage(2) ) SUMMARY : \u5982\u4f55\u7edf\u8ba1the consumption of CPU of a thread\uff1f\u53c2\u89c1 PTHREAD_GETCPUCLOCKID(3) As well as the stack, POSIX.1 specifies that various other attributes are distinct for each thread, including: thread ID (the pthread_t data type) signal mask ( pthread_sigmask(3) ) the errno variable alternate signal stack ( sigaltstack(2) ) real-time scheduling policy and priority ( sched(7) ) The following Linux-specific features are also per-thread: capabilities (see capabilities(7) ) CPU affinity ( sched_setaffinity(2) )","title":"DESCRIPTION"},{"location":"Programming/Multitasking/Thread/man-7-pthreads/#pthreads#function#return#values","text":"Most pthreads functions return 0 on success, and an error number on failure. Note that the pthreads functions do not set errno . For each of the pthreads functions that can return an error, POSIX.1-2001 specifies that the function can never fail with the error EINTR . SUMMARY : linux system call\u662f\u4f1a\u8bbe\u7f6e errno \u7684\u3002","title":"Pthreads function return values"},{"location":"Programming/Multitasking/Thread/man-7-pthreads/#thread#ids","text":"Each of the threads in a process has a unique thread identifier (stored in the type pthread_t). This identifier is returned to the caller of pthread_create(3) , and a thread can obtain its own thread identifier using pthread_self(3) . Thread IDs are guaranteed to be unique only within a process. (In all pthreads functions that accept a thread ID as an argument, that ID by definition refers to a thread in the same process as the caller.) The system may reuse a thread ID after a terminated thread has been joined, or a detached thread has terminated. POSIX says: \"If an application attempts to use a thread ID whose lifetime has ended, the behavior is undefined.\"","title":"Thread IDs"},{"location":"Programming/Multitasking/Thread/man-7-pthreads/#thread-safe#functions","text":"","title":"Thread-safe functions"},{"location":"Programming/Multitasking/Thread/man-7-pthreads/#async-cancel-safe#functions","text":"An async-cancel-safe function is one that can be safely called in an application where asynchronous cancelability is enabled (see pthread_setcancelstate(3) ). Only the following functions are required to be async-cancel-safe by POSIX.1-2001 and POSIX.1-2008: pthread_cancel () pthread_setcancelstate () pthread_setcanceltype ()","title":"Async-cancel-safe functions"},{"location":"Programming/Multitasking/Thread/man-7-pthreads/#cancellation#points","text":"POSIX.1 specifies that certain functions must, and certain other functions may, be cancellation points . If a thread is cancelable, its cancelability type is deferred , and a cancellation request is pending for the thread, then the thread is canceled when it calls a function that is a cancellation point . The following functions are required to be cancellation points by POSIX.1-2001 and/or POSIX.1-2008: accept () aio_suspend () clock_nanosleep () close () connect () creat () fcntl () F_SETLKW fdatasync () fsync () getmsg () getpmsg () lockf () F_LOCK mq_receive () mq_send () mq_timedreceive () mq_timedsend () msgrcv () msgsnd () msync () nanosleep () open () openat () [ Added in POSIX .1 -2008 ] pause () poll () pread () pselect () pthread_cond_timedwait () pthread_cond_wait () pthread_join () pthread_testcancel () putmsg () putpmsg () pwrite () read () readv () recv () recvfrom () recvmsg () select () sem_timedwait () sem_wait () send () sendmsg () sendto () sigpause () [ POSIX .1 -2001 only ( moves to \"may\" list in POSIX .1 -2008 )] sigsuspend () sigtimedwait () sigwait () sigwaitinfo () sleep () system () tcdrain () usleep () [ POSIX .1 -2001 only ( function removed in POSIX .1 -2008 )] wait () waitid () waitpid () write () writev () The following functions may be cancellation points according to POSIX.1-2001 and/or POSIX.1-2008: access () asctime () asctime_r () catclose () catgets () catopen () chmod () [ Added in POSIX .1 -2008 ] chown () [ Added in POSIX .1 -2008 ] closedir () closelog () ctermid () ctime () ctime_r () dbm_close () dbm_delete () dbm_fetch () dbm_nextkey () dbm_open () dbm_store () dlclose () dlopen () dprintf () [ Added in POSIX .1 -2008 ] endgrent () endhostent () endnetent () endprotoent () endpwent () endservent () endutxent () faccessat () [ Added in POSIX .1 -2008 ] fchmod () [ Added in POSIX .1 -2008 ] fchmodat () [ Added in POSIX .1 -2008 ] fchown () [ Added in POSIX .1 -2008 ] fchownat () [ Added in POSIX .1 -2008 ] fclose () fcntl () ( for any value of cmd argument ) fflush () fgetc () fgetpos () fgets () fgetwc () fgetws () fmtmsg () fopen () fpathconf () fprintf () fputc () fputs () fputwc () fputws () fread () freopen () fscanf () fseek () fseeko () fsetpos () fstat () fstatat () [ Added in POSIX .1 -2008 ] ftell () ftello () ftw () futimens () [ Added in POSIX .1 -2008 ] fwprintf () fwrite () fwscanf () getaddrinfo () getc () getc_unlocked () getchar () getchar_unlocked () getcwd () getdate () getdelim () [ Added in POSIX .1 -2008 ] getgrent () getgrgid () getgrgid_r () getgrnam () getgrnam_r () gethostbyaddr () [ SUSv3 only ( function removed in POSIX .1 -2008 )] gethostbyname () [ SUSv3 only ( function removed in POSIX .1 -2008 )] gethostent () gethostid () gethostname () getline () [ Added in POSIX .1 -2008 ] getlogin () getlogin_r () getnameinfo () getnetbyaddr () getnetbyname () getnetent () getopt () ( if opterr is nonzero ) getprotobyname () getprotobynumber () getprotoent () getpwent () getpwnam () getpwnam_r () getpwuid () getpwuid_r () gets () getservbyname () getservbyport () getservent () getutxent () getutxid () getutxline () getwc () getwchar () getwd () [ SUSv3 only ( function removed in POSIX .1 -2008 )] glob () iconv_close () iconv_open () ioctl () link () linkat () [ Added in POSIX .1 -2008 ] lio_listio () [ Added in POSIX .1 -2008 ] localtime () localtime_r () lockf () [ Added in POSIX .1 -2008 ] lseek () lstat () mkdir () [ Added in POSIX .1 -2008 ] mkdirat () [ Added in POSIX .1 -2008 ] mkdtemp () [ Added in POSIX .1 -2008 ] mkfifo () [ Added in POSIX .1 -2008 ] mkfifoat () [ Added in POSIX .1 -2008 ] mknod () [ Added in POSIX .1 -2008 ] mknodat () [ Added in POSIX .1 -2008 ] mkstemp () mktime () nftw () opendir () openlog () pathconf () pclose () perror () popen () posix_fadvise () posix_fallocate () posix_madvise () posix_openpt () posix_spawn () posix_spawnp () posix_trace_clear () posix_trace_close () posix_trace_create () posix_trace_create_withlog () posix_trace_eventtypelist_getnext_id () posix_trace_eventtypelist_rewind () posix_trace_flush () posix_trace_get_attr () posix_trace_get_filter () posix_trace_get_status () posix_trace_getnext_event () posix_trace_open () posix_trace_rewind () posix_trace_set_filter () posix_trace_shutdown () posix_trace_timedgetnext_event () posix_typed_mem_open () printf () psiginfo () [ Added in POSIX .1 -2008 ] psignal () [ Added in POSIX .1 -2008 ] pthread_rwlock_rdlock () pthread_rwlock_timedrdlock () pthread_rwlock_timedwrlock () pthread_rwlock_wrlock () putc () putc_unlocked () putchar () putchar_unlocked () puts () pututxline () putwc () putwchar () readdir () readdir_r () readlink () [ Added in POSIX .1 -2008 ] readlinkat () [ Added in POSIX .1 -2008 ] remove () rename () renameat () [ Added in POSIX .1 -2008 ] rewind () rewinddir () scandir () [ Added in POSIX .1 -2008 ] scanf () seekdir () semop () setgrent () sethostent () setnetent () setprotoent () setpwent () setservent () setutxent () sigpause () [ Added in POSIX .1 -2008 ] stat () strerror () strerror_r () strftime () symlink () symlinkat () [ Added in POSIX .1 -2008 ] sync () syslog () tmpfile () tmpnam () ttyname () ttyname_r () tzset () ungetc () ungetwc () unlink () unlinkat () [ Added in POSIX .1 -2008 ] utime () [ Added in POSIX .1 -2008 ] utimensat () [ Added in POSIX .1 -2008 ] utimes () [ Added in POSIX .1 -2008 ] vdprintf () [ Added in POSIX .1 -2008 ] vfprintf () vfwprintf () vprintf () vwprintf () wcsftime () wordexp () wprintf () wscanf () An implementation may also mark other functions not specified in the standard as cancellation points . In particular, an implementation is likely to mark any nonstandard function that may block as a cancellation point . (This includes most functions that can touch files.)","title":"Cancellation points"},{"location":"Programming/Multitasking/Thread/man-7-pthreads/#linux#implementations#of#posix#threads","text":"Over time, two threading implementations have been provided by the GNU C library on Linux: LinuxThreads This is the original Pthreads implementation. Since glibc 2.4, this implementation is no longer supported. NPTL (Native POSIX Threads Library) This is the modern Pthreads implementation. By comparison with LinuxThreads, NPTL provides closer conformance to the requirements of the POSIX.1 specification and better performance when creating large numbers of threads. NPTL is available since glibc 2.3.2, and requires features that are present in the Linux 2.6 kernel. Both of these are so-called 1:1 implementations, meaning that each thread maps to a kernel scheduling entity . Both threading implementations employ the Linux clone(2) system call. In NPTL, thread synchronization primitives (mutexes, thread joining, and so on) are implemented using the Linux futex(2) system call.","title":"Linux implementations of POSIX threads"},{"location":"Programming/Multitasking/Thread/Synchronization/Condition-variables/","text":"","title":"Condition-variables"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/","text":"Barrier APUE-11.6.8-barrier barrier\u662f\u7528\u6237\u534f\u8c03\u591a\u4e2athread\u5e76\u884c\u5de5\u4f5c\u7684\u540c\u6b65\u673a\u5236\u3002 barrier\u5141\u8bb8\u6bcf\u4e2athread\u7b49\u5f85\uff0c\u76f4\u5230\u6240\u6709\u7684\u5408\u4f5cthread\u90fd\u5230\u8fbe\u67d0\u4e00\u70b9\uff0c\u7136\u540e\u4ece\u6539\u70b9\u7ee7\u7eed\u8fdb\u884c\u5de5\u4f5c\u3002 NOTE: \u663e\u7136barrier\u7684\u8fd9\u79cd\u7279\u6027\u975e\u5e38\u9002\u5408\u4e8e\u7c7b\u4f3c\u4e8eheap-sort\u8fd9\u79cddivide-and-conquer\u7684\u5de5\u4f5c\u65b9\u5f0f\u3002 wikipedia Barrier (computer science) Oracle Using Barrier Synchronization System call pthread_barrier_init(3) pthread_barrier_destroy(3) pthread_barrier_wait(3) \u8fd9\u7bc7\u8bb2\u89e3\u5730\u4e0d\u9519\u3002 \u5173\u4e8e PTHREAD_BARRIER_SERIAL_THREAD \u7684\u7528\u9014\uff0c\u53c2\u89c1APUE chapter 11.6.8. Exmaple http://man7.org/tlpi/code/online/dist/threads/pthread_barrier_demo.c.html APUE 11.6.8 Barriers \u5728APUE 11.6.8 Barriers\u7ed9\u51fa\u4e86\u4e00\u4e2a\u4f7f\u7528\u6392\u5e8f\u7684\u975e\u5e38\u597d\u7684\u4f8b\u5b50\uff0c\u4e0b\u9762\u662f\u8be5\u4f8b\u5b50\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u3002 #include <pthread.h> #include <stdlib.h> /*qsort header*/ #include <stdio.h> #include <limits.h> #include <sys/time.h> #include <errno.h> /* for definition of errno */ #include <stdarg.h> /* ISO C variable aruments */ #include <stddef.h> /* for offsetof */ #include <string.h> /* for convenience */ #include <unistd.h> /* for convenience */ /** * \u8fd9\u662f\u6e90\u81ea\u4e8eAPUE\u768411.6.8\u8282\u7684\u4f8b\u5b50\u3002 *\u7f16\u8bd1\u6307\u4ee4\uff1a * gcc -std=gnu99 barrier.c -lpthread * * \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u4f7f\u7528\u5982\u4e0b\u7f16\u8bd1\u6307\u4ee4\uff1a * gcc -std=c99 barrier.c -lpthread * \u5219\u4f1a\u62a5\u5982\u4e0b\u9519\u8bef\uff1a * \u672a\u77e5\u7684\u7c7b\u578b\u540d\u2018pthread_barrier_t\u2019 */ /*\u6253\u5370\u9519\u8bef\u65e5\u5fd7\u8f85\u52a9\u51fd\u6570*/ #define MAXLINE 4096 /* max line length */ void err_exit ( int , const char * , ...) __attribute__ (( noreturn )); static void err_doit ( int , int , const char * , va_list ); #define NTHR 8 /* number of threads */ #define NUMNUM 8000000L /* number of numbers to sort */ #define TNUM (NUMNUM/NTHR) /* number to sort per thread */ long nums [ NUMNUM ]; long snums [ NUMNUM ]; pthread_barrier_t b ; //#ifdef SOLARIS //#define heapsort qsort //#else //extern int heapsort(void *, size_t, size_t, // int (*)(const void *, const void *)); //#endif /* * Compare two long integers (helper function for heapsort) */ int complong ( const void * arg1 , const void * arg2 ) { long l1 = * ( long * ) arg1 ; long l2 = * ( long * ) arg2 ; if ( l1 == l2 ) return 0 ; else if ( l1 < l2 ) return -1 ; else return 1 ; } /* * Worker thread to sort a portion of the set of numbers. */ void * thr_fn ( void * arg ) { long idx = ( long ) arg ; qsort ( & nums [ idx ], TNUM , sizeof ( long ), complong ); pthread_barrier_wait ( & b ); /* * Go off and perform more work ... */ return (( void * ) 0 ); } /* * Merge the results of the individual sorted ranges. */ void merge () { long idx [ NTHR ]; long i , minidx , sidx , num ; for ( i = 0 ; i < NTHR ; i ++ ) idx [ i ] = i * TNUM ; for ( sidx = 0 ; sidx < NUMNUM ; sidx ++ ) { num = LONG_MAX ; for ( i = 0 ; i < NTHR ; i ++ ) { if (( idx [ i ] < ( i + 1 ) * TNUM ) && ( nums [ idx [ i ]] < num )) { num = nums [ idx [ i ]]; minidx = i ; } } snums [ sidx ] = nums [ idx [ minidx ]]; idx [ minidx ] ++ ; } } int main () { unsigned long i ; struct timeval start , end ; long long startusec , endusec ; double elapsed ; int err ; pthread_t tid ; /* * Create the initial set of numbers to sort. */ srandom ( 1 ); for ( i = 0 ; i < NUMNUM ; i ++ ) nums [ i ] = random (); /* * Create 8 threads to sort the numbers. */ gettimeofday ( & start , NULL ); pthread_barrier_init ( & b , NULL , NTHR + 1 ); for ( i = 0 ; i < NTHR ; i ++ ) { err = pthread_create ( & tid , NULL , thr_fn , ( void * ) ( i * TNUM )); if ( err != 0 ) err_exit ( err , \"can't create thread\" ); } pthread_barrier_wait ( & b ); merge (); gettimeofday ( & end , NULL ); /* * Print the sorted list. */ startusec = start . tv_sec * 1000000 + start . tv_usec ; endusec = end . tv_sec * 1000000 + end . tv_usec ; elapsed = ( double ) ( endusec - startusec ) / 1000000.0 ; printf ( \"sort took %.4f seconds \\n \" , elapsed ); for ( i = 0 ; i < NUMNUM ; i ++ ) printf ( \"%ld \\n \" , snums [ i ]); exit ( 0 ); } /* * Fatal error unrelated to a system call. * Error code passed as explict parameter. * Print a message and terminate. */ void err_exit ( int error , const char * fmt , ...) { va_list ap ; va_start ( ap , fmt ); err_doit ( 1 , error , fmt , ap ); va_end ( ap ); exit ( 1 ); } /* * Print a message and return to caller. * Caller specifies \"errnoflag\". */ static void err_doit ( int errnoflag , int error , const char * fmt , va_list ap ) { char buf [ MAXLINE ]; vsnprintf ( buf , MAXLINE - 1 , fmt , ap ); if ( errnoflag ) snprintf ( buf + strlen ( buf ), MAXLINE - strlen ( buf ) - 1 , \": %s\" , strerror ( error )); strcat ( buf , \" \\n \" ); fflush ( stdout ); /* in case stdout and stderr are the same */ fputs ( buf , stderr ); fflush ( NULL ); /* flushes all stdio output streams */ } \u7f16\u8bd1\u95ee\u9898 \u4f7f\u7528 pthread_barrier_t \u65f6\uff0c\u5982\u679c\u4f7f\u7528\u5982\u4e0b\u7f16\u8bd1\u6307\u4ee4\uff1a gcc -std=gnu99 barrier.c -lpthread \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u4f7f\u7528\u5982\u4e0b\u7f16\u8bd1\u6307\u4ee4\uff1a gcc -std=c99 barrier.c -lpthread \u5219\u4f1a\u62a5\u5982\u4e0b\u9519\u8bef\uff1a \u672a\u77e5\u7684\u7c7b\u578b\u540d\u2018pthread_barrier_t\u2019 \u5177\u4f53\u53c2\u8003\uff1a https://stackoverflow.com/questions/15673492/gcc-compile-fails-with-pthread-and-option-std-c99","title":"Introduction"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#barrier","text":"","title":"Barrier"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#apue-1168-barrier","text":"barrier\u662f\u7528\u6237\u534f\u8c03\u591a\u4e2athread\u5e76\u884c\u5de5\u4f5c\u7684\u540c\u6b65\u673a\u5236\u3002 barrier\u5141\u8bb8\u6bcf\u4e2athread\u7b49\u5f85\uff0c\u76f4\u5230\u6240\u6709\u7684\u5408\u4f5cthread\u90fd\u5230\u8fbe\u67d0\u4e00\u70b9\uff0c\u7136\u540e\u4ece\u6539\u70b9\u7ee7\u7eed\u8fdb\u884c\u5de5\u4f5c\u3002 NOTE: \u663e\u7136barrier\u7684\u8fd9\u79cd\u7279\u6027\u975e\u5e38\u9002\u5408\u4e8e\u7c7b\u4f3c\u4e8eheap-sort\u8fd9\u79cddivide-and-conquer\u7684\u5de5\u4f5c\u65b9\u5f0f\u3002","title":"APUE-11.6.8-barrier"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#wikipedia#barrier#computer#science","text":"","title":"wikipedia Barrier (computer science)"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#oracle#using#barrier#synchronization","text":"","title":"Oracle Using Barrier Synchronization"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#system#call","text":"","title":"System call"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#pthread_barrier_init3","text":"","title":"pthread_barrier_init(3)"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#pthread_barrier_destroy3","text":"","title":"pthread_barrier_destroy(3)"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#pthread_barrier_wait3","text":"\u8fd9\u7bc7\u8bb2\u89e3\u5730\u4e0d\u9519\u3002 \u5173\u4e8e PTHREAD_BARRIER_SERIAL_THREAD \u7684\u7528\u9014\uff0c\u53c2\u89c1APUE chapter 11.6.8.","title":"pthread_barrier_wait(3)"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#exmaple","text":"http://man7.org/tlpi/code/online/dist/threads/pthread_barrier_demo.c.html","title":"Exmaple"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#apue#1168#barriers","text":"\u5728APUE 11.6.8 Barriers\u7ed9\u51fa\u4e86\u4e00\u4e2a\u4f7f\u7528\u6392\u5e8f\u7684\u975e\u5e38\u597d\u7684\u4f8b\u5b50\uff0c\u4e0b\u9762\u662f\u8be5\u4f8b\u5b50\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u3002 #include <pthread.h> #include <stdlib.h> /*qsort header*/ #include <stdio.h> #include <limits.h> #include <sys/time.h> #include <errno.h> /* for definition of errno */ #include <stdarg.h> /* ISO C variable aruments */ #include <stddef.h> /* for offsetof */ #include <string.h> /* for convenience */ #include <unistd.h> /* for convenience */ /** * \u8fd9\u662f\u6e90\u81ea\u4e8eAPUE\u768411.6.8\u8282\u7684\u4f8b\u5b50\u3002 *\u7f16\u8bd1\u6307\u4ee4\uff1a * gcc -std=gnu99 barrier.c -lpthread * * \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u4f7f\u7528\u5982\u4e0b\u7f16\u8bd1\u6307\u4ee4\uff1a * gcc -std=c99 barrier.c -lpthread * \u5219\u4f1a\u62a5\u5982\u4e0b\u9519\u8bef\uff1a * \u672a\u77e5\u7684\u7c7b\u578b\u540d\u2018pthread_barrier_t\u2019 */ /*\u6253\u5370\u9519\u8bef\u65e5\u5fd7\u8f85\u52a9\u51fd\u6570*/ #define MAXLINE 4096 /* max line length */ void err_exit ( int , const char * , ...) __attribute__ (( noreturn )); static void err_doit ( int , int , const char * , va_list ); #define NTHR 8 /* number of threads */ #define NUMNUM 8000000L /* number of numbers to sort */ #define TNUM (NUMNUM/NTHR) /* number to sort per thread */ long nums [ NUMNUM ]; long snums [ NUMNUM ]; pthread_barrier_t b ; //#ifdef SOLARIS //#define heapsort qsort //#else //extern int heapsort(void *, size_t, size_t, // int (*)(const void *, const void *)); //#endif /* * Compare two long integers (helper function for heapsort) */ int complong ( const void * arg1 , const void * arg2 ) { long l1 = * ( long * ) arg1 ; long l2 = * ( long * ) arg2 ; if ( l1 == l2 ) return 0 ; else if ( l1 < l2 ) return -1 ; else return 1 ; } /* * Worker thread to sort a portion of the set of numbers. */ void * thr_fn ( void * arg ) { long idx = ( long ) arg ; qsort ( & nums [ idx ], TNUM , sizeof ( long ), complong ); pthread_barrier_wait ( & b ); /* * Go off and perform more work ... */ return (( void * ) 0 ); } /* * Merge the results of the individual sorted ranges. */ void merge () { long idx [ NTHR ]; long i , minidx , sidx , num ; for ( i = 0 ; i < NTHR ; i ++ ) idx [ i ] = i * TNUM ; for ( sidx = 0 ; sidx < NUMNUM ; sidx ++ ) { num = LONG_MAX ; for ( i = 0 ; i < NTHR ; i ++ ) { if (( idx [ i ] < ( i + 1 ) * TNUM ) && ( nums [ idx [ i ]] < num )) { num = nums [ idx [ i ]]; minidx = i ; } } snums [ sidx ] = nums [ idx [ minidx ]]; idx [ minidx ] ++ ; } } int main () { unsigned long i ; struct timeval start , end ; long long startusec , endusec ; double elapsed ; int err ; pthread_t tid ; /* * Create the initial set of numbers to sort. */ srandom ( 1 ); for ( i = 0 ; i < NUMNUM ; i ++ ) nums [ i ] = random (); /* * Create 8 threads to sort the numbers. */ gettimeofday ( & start , NULL ); pthread_barrier_init ( & b , NULL , NTHR + 1 ); for ( i = 0 ; i < NTHR ; i ++ ) { err = pthread_create ( & tid , NULL , thr_fn , ( void * ) ( i * TNUM )); if ( err != 0 ) err_exit ( err , \"can't create thread\" ); } pthread_barrier_wait ( & b ); merge (); gettimeofday ( & end , NULL ); /* * Print the sorted list. */ startusec = start . tv_sec * 1000000 + start . tv_usec ; endusec = end . tv_sec * 1000000 + end . tv_usec ; elapsed = ( double ) ( endusec - startusec ) / 1000000.0 ; printf ( \"sort took %.4f seconds \\n \" , elapsed ); for ( i = 0 ; i < NUMNUM ; i ++ ) printf ( \"%ld \\n \" , snums [ i ]); exit ( 0 ); } /* * Fatal error unrelated to a system call. * Error code passed as explict parameter. * Print a message and terminate. */ void err_exit ( int error , const char * fmt , ...) { va_list ap ; va_start ( ap , fmt ); err_doit ( 1 , error , fmt , ap ); va_end ( ap ); exit ( 1 ); } /* * Print a message and return to caller. * Caller specifies \"errnoflag\". */ static void err_doit ( int errnoflag , int error , const char * fmt , va_list ap ) { char buf [ MAXLINE ]; vsnprintf ( buf , MAXLINE - 1 , fmt , ap ); if ( errnoflag ) snprintf ( buf + strlen ( buf ), MAXLINE - strlen ( buf ) - 1 , \": %s\" , strerror ( error )); strcat ( buf , \" \\n \" ); fflush ( stdout ); /* in case stdout and stderr are the same */ fputs ( buf , stderr ); fflush ( NULL ); /* flushes all stdio output streams */ }","title":"APUE 11.6.8 Barriers"},{"location":"Programming/Multitasking/Thread/Synchronization/Barrier/#_1","text":"\u4f7f\u7528 pthread_barrier_t \u65f6\uff0c\u5982\u679c\u4f7f\u7528\u5982\u4e0b\u7f16\u8bd1\u6307\u4ee4\uff1a gcc -std=gnu99 barrier.c -lpthread \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u4f7f\u7528\u5982\u4e0b\u7f16\u8bd1\u6307\u4ee4\uff1a gcc -std=c99 barrier.c -lpthread \u5219\u4f1a\u62a5\u5982\u4e0b\u9519\u8bef\uff1a \u672a\u77e5\u7684\u7c7b\u578b\u540d\u2018pthread_barrier_t\u2019 \u5177\u4f53\u53c2\u8003\uff1a https://stackoverflow.com/questions/15673492/gcc-compile-fails-with-pthread-and-option-std-c99","title":"\u7f16\u8bd1\u95ee\u9898"},{"location":"Programming/Multitasking/Thread/Synchronization/TODO-futex/TODO-index/","text":"futex wikipedia Futex futex(7) \u2014 Linux manual page futex(2) \u2014 Linux manual page futex VS spinning lock","title":"Introduction"},{"location":"Programming/Multitasking/Thread/Synchronization/TODO-futex/TODO-index/#futex","text":"","title":"futex"},{"location":"Programming/Multitasking/Thread/Synchronization/TODO-futex/TODO-index/#wikipedia#futex","text":"","title":"wikipedia Futex"},{"location":"Programming/Multitasking/Thread/Synchronization/TODO-futex/TODO-index/#futex7#linux#manual#page","text":"","title":"futex(7) \u2014 Linux manual page"},{"location":"Programming/Multitasking/Thread/Synchronization/TODO-futex/TODO-index/#futex2#linux#manual#page","text":"","title":"futex(2) \u2014 Linux manual page"},{"location":"Programming/Multitasking/Thread/Synchronization/TODO-futex/TODO-index/#futex#vs#spinning#lock","text":"","title":"futex VS spinning lock"},{"location":"Programming/Multitasking/Tools/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u63cf\u8ff0Linux OS\u63d0\u4f9b\u7684process\u76f8\u5173\u7684\u5de5\u5177\u3002","title":"Introduction"},{"location":"Programming/Multitasking/Tools/#_1","text":"\u672c\u7ae0\u63cf\u8ff0Linux OS\u63d0\u4f9b\u7684process\u76f8\u5173\u7684\u5de5\u5177\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Multitasking/Tools/procps/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u63cf\u8ff0procps\u3002 procps gitlab procps command introduction free Report the amount of free and used memory in the system kill Send a signal to a process based on PID pgrep List processes based on name or other attributes pkill Send a signal to a process based on name or other attributes pmap Report memory map of a process ps Report information of processes pwdx Report current directory of a process skill Obsolete version of pgrep/pkill slabtop Display kernel slab cache information in real time snice Renice a process sysctl Read or Write kernel parameters at run tload Graphical representation of system load average top Dynamic real uptime Display how long the system has been running vmstat Report virtual memory statistics w Report logged in users and what they are doing watch Execute a program periodically, showing output fullscreen What is the difference between ps and top command? A top is mostly used interactively (try reading man page or pressing \"h\" while top is running) and ps is designed for non-interactive use (scripts, extracting some information with shell pipelines etc.) A top allows you display of process statistics continuously until stopped vs. ps which gives you a single snapshot. A For CPU usage, ps displays average CPU usage over the lifetime of the process as it is instantaneous and would always be 0% or 100%. top gives a more instantaneous look at it from averaging over recent polls. More information here: Top and ps not showing the same cpu result","title":"Introduction"},{"location":"Programming/Multitasking/Tools/procps/#_1","text":"\u672c\u7ae0\u63cf\u8ff0procps\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Multitasking/Tools/procps/#procps","text":"gitlab procps command introduction free Report the amount of free and used memory in the system kill Send a signal to a process based on PID pgrep List processes based on name or other attributes pkill Send a signal to a process based on name or other attributes pmap Report memory map of a process ps Report information of processes pwdx Report current directory of a process skill Obsolete version of pgrep/pkill slabtop Display kernel slab cache information in real time snice Renice a process sysctl Read or Write kernel parameters at run tload Graphical representation of system load average top Dynamic real uptime Display how long the system has been running vmstat Report virtual memory statistics w Report logged in users and what they are doing watch Execute a program periodically, showing output fullscreen","title":"procps"},{"location":"Programming/Multitasking/Tools/procps/#what#is#the#difference#between#ps#and#top#command","text":"","title":"What is the difference between ps and top command?"},{"location":"Programming/Multitasking/Tools/procps/#a","text":"top is mostly used interactively (try reading man page or pressing \"h\" while top is running) and ps is designed for non-interactive use (scripts, extracting some information with shell pipelines etc.)","title":"A"},{"location":"Programming/Multitasking/Tools/procps/#a_1","text":"top allows you display of process statistics continuously until stopped vs. ps which gives you a single snapshot.","title":"A"},{"location":"Programming/Multitasking/Tools/procps/#a_2","text":"For CPU usage, ps displays average CPU usage over the lifetime of the process as it is instantaneous and would always be 0% or 100%. top gives a more instantaneous look at it from averaging over recent polls. More information here: Top and ps not showing the same cpu result","title":"A"},{"location":"Programming/Multitasking/Tools/procps/pgrep/","text":"pgrep pgrep(1) \u2014 Linux manual page","title":"pgrep"},{"location":"Programming/Multitasking/Tools/procps/pgrep/#pgrep","text":"","title":"pgrep"},{"location":"Programming/Multitasking/Tools/procps/pgrep/#pgrep1#linux#manual#page","text":"","title":"pgrep(1) \u2014 Linux manual page"},{"location":"Programming/Multitasking/Tools/procps/pstree/","text":"pstree pstree(1) \u2014 Linux manual page wikipedia Pstree (Unix)","title":"pstree"},{"location":"Programming/Multitasking/Tools/procps/pstree/#pstree","text":"","title":"pstree"},{"location":"Programming/Multitasking/Tools/procps/pstree/#pstree1#linux#manual#page","text":"","title":"pstree(1) \u2014 Linux manual page"},{"location":"Programming/Multitasking/Tools/procps/pstree/#wikipedia#pstree#unix","text":"","title":"wikipedia Pstree (Unix)"},{"location":"Programming/Multitasking/Tools/procps/ps/Wait-channel/","text":"Wait channel askubuntu Values of WCHAN in ps stackoverflow in ps -l, what does wchan=stext mean?","title":"Wait-channel"},{"location":"Programming/Multitasking/Tools/procps/ps/Wait-channel/#wait#channel","text":"","title":"Wait channel"},{"location":"Programming/Multitasking/Tools/procps/ps/Wait-channel/#askubuntu#values#of#wchan#in#ps","text":"","title":"askubuntu Values of WCHAN in ps"},{"location":"Programming/Multitasking/Tools/procps/ps/Wait-channel/#stackoverflow#in#ps#-l#what#does#wchanstext#mean","text":"","title":"stackoverflow in ps -l, what does wchan=stext mean?"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/","text":"ps(1) \u2014 Linux manual page NAME ps - report a snapshot of the current processes. SYNOPSIS ps [options] DESCRIPTION ps displays information about a selection of the active processes. If you want a repetitive update of the selection and the displayed information, use top (1) instead. This version of ps accepts several kinds of options: 1UNIX options, which may be grouped and must be preceded by a dash. 2 BSD options, which may be grouped and must not be used with a dash. 3 GNU long options, which are preceded by two dashes. NOTE: \u663e\u7136 ps \u7684\u5b9e\u73b0\uff0c\u6839\u636edash\u4e2a\u6570\u6765\u533a\u5206\u662f\u54ea\u79cdoption\u3002\u7ed3\u5408\u540e\u6587\u6765\u770b\uff0c1UNIX option\u662fstandard\u3002 Options of different types may be freely mixed, but conflicts can appear. There are some synonymous\uff08\u540c\u4e49\u7684\uff09 options, which are functionally identical, due to the many standards and ps implementations that this ps is compatible with. Note that \" ps -aux \" is distinct from \" ps aux \". The POSIX and UNIX standards require that \" ps -aux \" print all processes owned by a user named \"x\", as well as printing all processes that would be selected by the -a option. If the user named \"x\" does not exist, this ps may interpret the command as \" ps aux \" instead and print a warning. This behavior is intended to aid in transitioning(\u8fc7\u6e21) old scripts and habits. It is fragile, subject to change, and thus should not be relied upon. By default, ps selects all processes with the same effective user ID ( euid = EUID ) as the current user and associated with the same terminal as the invoker. It displays the process ID ( pid = PID ), the terminal associated with the process ( tname = TTY ), the cumulated(\u7d2f\u8ba1\u7684) CPU time in [dd-]hh:mm:ss format (time=TIME), and the executable name ( ucmd = CMD ). Output is unsorted by default. [ tensorflow@localhost ~ ] $ ps PID TTY TIME CMD 1741 pts/0 00 :00:00 bash 2109 pts/0 00 :00:00 ps The use of BSD-style options will add process state (stat=STAT) to the default display and show the command args ( args =COMMAND) instead of the executable name. You can override this with the PS_FORMAT environment variable. The use of BSD-style options will also change the process selection to include processes on other terminals (TTYs) that are owned by you; alternately, this may be described as setting the selection to be the set of all processes filtered to exclude processes owned by other users or not on a terminal. These effects are not considered when options are described as being \"identical\" below, so -M will be considered identical to Z and so on. Except as described below, process selection options are additive. The default selection is discarded, and then the selected processes are added to the set of processes to be displayed. A process will thus be shown if it meets any of the given selection criteria. Examples All process To see every process on the system using standard syntax: ps -e ps -ef ps -eF ps -ely To see every process on the system using BSD syntax: ps ax ps axu Process tree To print a process tree: ps -ejH ps axjf Threads To get info about threads: ps -eLf ps axms Security info To get security info: ps -eo euser,ruser,suser,fuser,f,comm,label ps axZ ps -eM Run as root To see every process running as root (real & effective ID) in user format : ps -U root -u root u User-defined format To see every process with a user-defined format: ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm ps -eopid,tt,user,fname,tmout,f,wchan Process ID of Print only the process IDs of syslogd : ps -C syslogd -o pid = Name of Print only the name of PID 42: ps -p 42 -o comm = ps -x Process Selection NOTE: \u4f7f\u7528 ps \u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5185\u5bb9\u662f\uff1aprocess selection Simple Process Selection Process Selection By List These options accept a single argument in the form of a blank-separated or comma-separated list. They can be used multiple times. For example: ps -p \"1 2\" -p 3,4 -C cmdlist Select by command name . This selects the processes whose executable name is given in cmdlist . -G grplist Select by real group ID (RGID) or name. This selects the processes whose real group name or ID is in the grplist list. The real group ID identifies the group of the user who created the process, see getgid (2) . Output Format Control These options are used to choose the information displayed by ps . The output may differ by personality. -F extra full format. See the -f option, which -F implies. -O format Output Modifiers Thread Display Other Information Notes This ps works by reading the virtual files in /proc . This ps does not need to be setuid kmem or have any privileges to run. Do not give this ps any special permissions. NOTE: \u53c2\u89c1 Programming\\Process\\Proc-filesystem \u3002 This ps needs access to namelist data for proper WCHAN display. For kernels prior to 2.6, the System.map file must be installed. NOTE wikipedia System.map CPU usage CPU usage is currently expressed as the percentage of time spent running during the entire lifetime of a process. This is not ideal, and it does not conform to the standards that ps otherwise conforms to. CPU usage is unlikely to add up to exactly 100%. SIZE and RSS The SIZE and RSS fields don't count some parts of a process including the page tables, kernel stack, struct thread_info, and struct task_struct. This is usually at least 20 KiB of memory that is always resident. SIZE is the virtual size of the process (code+data+stack). <defunct> Processes marked <defunct> are dead processes (so-called \"zombies\") that remain because their parent has not destroyed them properly. These processes will be destroyed by init (8) if the parent process exits. If the length of the username is greater than the length of the display column, the numeric user ID is displayed instead. System.map file This ps needs access to namelist data for proper WCHAN display. For kernels prior to 2.6, the System.map file must be installed. NOTE: \u672c\u6bb5\u6240\u63cf\u8ff0\u7684\u95ee\u9898\uff0c\u5728stackoverflow in ps -l, what does wchan=stext mean? \u4e2d\u4e5f\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u63a2\u8ba8\u3002 \u5173\u4e8e System.map file\uff0c\u53c2\u89c1 Kernel\\Guide\\Debug\\System.map \u3002 Process Flags The sum of these values is displayed in the \"F\" column, which is provided by the flags output specifier. 1 forked but didn't exec 4 used super-user privileges NOTE: \u6ca1\u6709\u7406\u89e3\u610f\u601d Process State Codes NOTE: Process State \u975e\u5e38\u91cd\u8981 Here are the different values that the s , stat and state output specifiers (header \"STAT\" or \"S\") will display to describe the state of a process. D Uninterruptible sleep (usually IO) NOTE: docstore 21.7. Hanging Processes: Detection and Diagnostics \u4e2d\uff0c\u6709\u8fd9\u6837\u7684\u63cf\u8ff0: ' D ' disk wait in ps report \u6240\u4ee5\uff0c\u6211\u89c9\u5f97 D \u5e94\u8be5\u4ee3\u8868\u7684\u5c31\u662fdisk wait\u3002 I Idle kernel thread R Running or runnable (on run queue) S Interruptible sleep (waiting for an event to complete) T Stopped, either by a job control signal or because it is being traced. W paging (not valid since the 2.6.xx kernel) X dead (should never be seen) Z Defunct (\"zombie\") process, terminated but not reaped by its parent. For BSD formats and when the stat keyword is used, additional characters may be displayed: < high-priority (not nice to other users) N low-priority (nice to other users) L has pages locked into memory (for real-time and custom IO) NOTE: \u5173\u4e8e\u6b64\uff0c\u53c2\u89c1: docstore 21.7.1. Hanging Because of an Operating System Problem s is a session leader l is multi-threaded (using CLONE_THREAD , like NPTL pthreads do) + is in the foreground process group Examples In UNIX, what are the Ss, Sl, and Ssl proccess types I see with ps aux? From the ps manpage : S Interruptible sleep (waiting for an event to complete) For BSD formats and when the stat keyword is used, additional characters may be displayed: s is a session leader l is multi-threaded (using CLONE_THREAD, like NPTL pthreads do) STANDARD FORMAT SPECIFIERS ENVIRONMENT VARIABLES PERSONALITY","title":"man-1-ps"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#ps1#linux#manual#page","text":"","title":"ps(1) \u2014 Linux manual page"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#name","text":"ps - report a snapshot of the current processes.","title":"NAME"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#synopsis","text":"ps [options]","title":"SYNOPSIS"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#description","text":"ps displays information about a selection of the active processes. If you want a repetitive update of the selection and the displayed information, use top (1) instead. This version of ps accepts several kinds of options: 1UNIX options, which may be grouped and must be preceded by a dash. 2 BSD options, which may be grouped and must not be used with a dash. 3 GNU long options, which are preceded by two dashes. NOTE: \u663e\u7136 ps \u7684\u5b9e\u73b0\uff0c\u6839\u636edash\u4e2a\u6570\u6765\u533a\u5206\u662f\u54ea\u79cdoption\u3002\u7ed3\u5408\u540e\u6587\u6765\u770b\uff0c1UNIX option\u662fstandard\u3002 Options of different types may be freely mixed, but conflicts can appear. There are some synonymous\uff08\u540c\u4e49\u7684\uff09 options, which are functionally identical, due to the many standards and ps implementations that this ps is compatible with. Note that \" ps -aux \" is distinct from \" ps aux \". The POSIX and UNIX standards require that \" ps -aux \" print all processes owned by a user named \"x\", as well as printing all processes that would be selected by the -a option. If the user named \"x\" does not exist, this ps may interpret the command as \" ps aux \" instead and print a warning. This behavior is intended to aid in transitioning(\u8fc7\u6e21) old scripts and habits. It is fragile, subject to change, and thus should not be relied upon. By default, ps selects all processes with the same effective user ID ( euid = EUID ) as the current user and associated with the same terminal as the invoker. It displays the process ID ( pid = PID ), the terminal associated with the process ( tname = TTY ), the cumulated(\u7d2f\u8ba1\u7684) CPU time in [dd-]hh:mm:ss format (time=TIME), and the executable name ( ucmd = CMD ). Output is unsorted by default. [ tensorflow@localhost ~ ] $ ps PID TTY TIME CMD 1741 pts/0 00 :00:00 bash 2109 pts/0 00 :00:00 ps The use of BSD-style options will add process state (stat=STAT) to the default display and show the command args ( args =COMMAND) instead of the executable name. You can override this with the PS_FORMAT environment variable. The use of BSD-style options will also change the process selection to include processes on other terminals (TTYs) that are owned by you; alternately, this may be described as setting the selection to be the set of all processes filtered to exclude processes owned by other users or not on a terminal. These effects are not considered when options are described as being \"identical\" below, so -M will be considered identical to Z and so on. Except as described below, process selection options are additive. The default selection is discarded, and then the selected processes are added to the set of processes to be displayed. A process will thus be shown if it meets any of the given selection criteria.","title":"DESCRIPTION"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#examples","text":"","title":"Examples"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#all#process","text":"To see every process on the system using standard syntax: ps -e ps -ef ps -eF ps -ely To see every process on the system using BSD syntax: ps ax ps axu","title":"All process"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#process#tree","text":"To print a process tree: ps -ejH ps axjf","title":"Process tree"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#threads","text":"To get info about threads: ps -eLf ps axms","title":"Threads"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#security#info","text":"To get security info: ps -eo euser,ruser,suser,fuser,f,comm,label ps axZ ps -eM","title":"Security info"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#run#as#root","text":"To see every process running as root (real & effective ID) in user format : ps -U root -u root u","title":"Run as root"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#user-defined#format","text":"To see every process with a user-defined format: ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm ps -eopid,tt,user,fname,tmout,f,wchan","title":"User-defined format"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#process#id#of","text":"Print only the process IDs of syslogd : ps -C syslogd -o pid =","title":"Process ID of"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#name#of","text":"Print only the name of PID 42: ps -p 42 -o comm =","title":"Name of"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#ps#-x","text":"","title":"ps -x"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#process#selection","text":"NOTE: \u4f7f\u7528 ps \u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5185\u5bb9\u662f\uff1aprocess selection","title":"Process Selection"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#simple#process#selection","text":"","title":"Simple Process Selection"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#process#selection#by#list","text":"These options accept a single argument in the form of a blank-separated or comma-separated list. They can be used multiple times. For example: ps -p \"1 2\" -p 3,4","title":"Process Selection By List"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#-c#cmdlist","text":"Select by command name . This selects the processes whose executable name is given in cmdlist .","title":"-C cmdlist"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#-g#grplist","text":"Select by real group ID (RGID) or name. This selects the processes whose real group name or ID is in the grplist list. The real group ID identifies the group of the user who created the process, see getgid (2) .","title":"-G grplist"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#output#format#control","text":"These options are used to choose the information displayed by ps . The output may differ by personality.","title":"Output Format Control"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#-f","text":"extra full format. See the -f option, which -F implies.","title":"-F"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#-o#format","text":"","title":"-O format"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#output#modifiers","text":"","title":"Output Modifiers"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#thread#display","text":"","title":"Thread Display"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#other#information","text":"","title":"Other Information"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#notes","text":"This ps works by reading the virtual files in /proc . This ps does not need to be setuid kmem or have any privileges to run. Do not give this ps any special permissions. NOTE: \u53c2\u89c1 Programming\\Process\\Proc-filesystem \u3002 This ps needs access to namelist data for proper WCHAN display. For kernels prior to 2.6, the System.map file must be installed. NOTE wikipedia System.map","title":"Notes"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#cpu#usage","text":"CPU usage is currently expressed as the percentage of time spent running during the entire lifetime of a process. This is not ideal, and it does not conform to the standards that ps otherwise conforms to. CPU usage is unlikely to add up to exactly 100%.","title":"CPU usage"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#size#and#rss","text":"The SIZE and RSS fields don't count some parts of a process including the page tables, kernel stack, struct thread_info, and struct task_struct. This is usually at least 20 KiB of memory that is always resident. SIZE is the virtual size of the process (code+data+stack).","title":"SIZE and RSS"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#defunct","text":"Processes marked <defunct> are dead processes (so-called \"zombies\") that remain because their parent has not destroyed them properly. These processes will be destroyed by init (8) if the parent process exits. If the length of the username is greater than the length of the display column, the numeric user ID is displayed instead.","title":"&lt;defunct&gt;"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#systemmap#file","text":"This ps needs access to namelist data for proper WCHAN display. For kernels prior to 2.6, the System.map file must be installed. NOTE: \u672c\u6bb5\u6240\u63cf\u8ff0\u7684\u95ee\u9898\uff0c\u5728stackoverflow in ps -l, what does wchan=stext mean? \u4e2d\u4e5f\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u63a2\u8ba8\u3002 \u5173\u4e8e System.map file\uff0c\u53c2\u89c1 Kernel\\Guide\\Debug\\System.map \u3002","title":"System.map file"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#process#flags","text":"The sum of these values is displayed in the \"F\" column, which is provided by the flags output specifier. 1 forked but didn't exec 4 used super-user privileges NOTE: \u6ca1\u6709\u7406\u89e3\u610f\u601d","title":"Process Flags"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#process#state#codes","text":"NOTE: Process State \u975e\u5e38\u91cd\u8981 Here are the different values that the s , stat and state output specifiers (header \"STAT\" or \"S\") will display to describe the state of a process.","title":"Process State Codes"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#d","text":"Uninterruptible sleep (usually IO) NOTE: docstore 21.7. Hanging Processes: Detection and Diagnostics \u4e2d\uff0c\u6709\u8fd9\u6837\u7684\u63cf\u8ff0: ' D ' disk wait in ps report \u6240\u4ee5\uff0c\u6211\u89c9\u5f97 D \u5e94\u8be5\u4ee3\u8868\u7684\u5c31\u662fdisk wait\u3002","title":"D"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#i","text":"Idle kernel thread","title":"I"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#r","text":"Running or runnable (on run queue)","title":"R"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#s","text":"Interruptible sleep (waiting for an event to complete)","title":"S"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#t","text":"Stopped, either by a job control signal or because it is being traced.","title":"T"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#w","text":"paging (not valid since the 2.6.xx kernel)","title":"W"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#x","text":"dead (should never be seen)","title":"X"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#z","text":"Defunct (\"zombie\") process, terminated but not reaped by its parent. For BSD formats and when the stat keyword is used, additional characters may be displayed:","title":"Z"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#_1","text":"high-priority (not nice to other users)","title":"&lt;"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#n","text":"low-priority (nice to other users)","title":"N"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#l","text":"has pages locked into memory (for real-time and custom IO) NOTE: \u5173\u4e8e\u6b64\uff0c\u53c2\u89c1: docstore 21.7.1. Hanging Because of an Operating System Problem","title":"L"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#s_1","text":"is a session leader","title":"s"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#l_1","text":"is multi-threaded (using CLONE_THREAD , like NPTL pthreads do)","title":"l"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#_2","text":"is in the foreground process group","title":"+"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#examples_1","text":"In UNIX, what are the Ss, Sl, and Ssl proccess types I see with ps aux? From the ps manpage : S Interruptible sleep (waiting for an event to complete) For BSD formats and when the stat keyword is used, additional characters may be displayed: s is a session leader l is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)","title":"Examples"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#standard#format#specifiers","text":"","title":"STANDARD FORMAT SPECIFIERS"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#environment#variables","text":"","title":"ENVIRONMENT VARIABLES"},{"location":"Programming/Multitasking/Tools/procps/ps/man-1-ps/#personality","text":"","title":"PERSONALITY"},{"location":"Programming/Multitasking/Tools/procps/ps/wikipedia-ps%28Unix%29/","text":"ps (Unix) In most Unix-like operating systems , the ps program (short for \"**p**rocess **s**tatus\") displays the currently-running processes . A related Unix utility named top provides a real-time view of the running processes. In Windows PowerShell , ps is a predefined command alias for the Get-Process cmdlet, which essentially serves the same purpose. Examples For example: # ps PID TTY TIME CMD 7431 pts/0 00 :00:00 su 7434 pts/0 00 :00:00 bash 18585 pts/0 00 :00:00 ps Users can also utilize the ps command in conjunction with the grep command (see the pgrep and pkill commands) to find information about a single process, such as its id: $ # Trying to find the PID of `firefox-bin` which is 2701 $ ps -A | grep firefox-bin 2701 ? 22 :16:04 firefox-bin The use of pgrep simplifies the syntax and avoids potential race conditions : $ pgrep -l firefox-bin 2701 firefox-bin To see every process running as root in user format: # ps -U root -u USER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND root 1 0 .0 0 .0 9436 128 - ILs Sun00AM 0 :00.12 /sbin/init -- Break Down Column Header Contents %CPU How much of the CPU the process is using %MEM How much memory the process is using ADDR Memory address of the process C or CP CPU usage and scheduling information COMMAND* Name of the process, including arguments, if any NI nice value F Flags PID Process ID number PPID ID number of the process\u2032s parent process PRI Priority of the process RSS Resident set size S or STAT Process status code START or STIME Time when the process started VSZ Virtual memory usage TIME The amount of CPU time used by the process TT or TTY Terminal associated with the process UID or USER Username of the process\u2032s owner WCHAN Memory address of the event the process is waiting for * = Often abbreviated Options ps has many options. On operating systems that support the SUS and POSIX standards, ps commonly runs with the options -ef , where \"-e\" selects e**very process and \"-f\" chooses the \"**f**ull\" output format. Another common option on these systems is **-l , which specifies the \"**l**ong\" output format. Most systems derived from BSD fail to accept the SUS and POSIX standard options because of historical conflicts. (For example, the \"e\" or \"-e\" option will display environment variables .) On such systems, ps commonly runs with the non-standard options aux , where \"a\" lists all processes on a terminal , including those of other users, \"x\" lists all processes without controlling terminals and \"u\" adds a column for the controlling user for each process. For maximum compatibility, there is no \"-\" in front of the \"aux\". \"ps auxww\" provides complete information about the process, including all parameters. See also Task manager kill List of Unix commands nmon \u2014 a system monitor tool for the AIX and Linux operating systems. pgrep pstree top lsof","title":"[ps (Unix)](https://en.wikipedia.org/wiki/Ps_(Unix))"},{"location":"Programming/Multitasking/Tools/procps/ps/wikipedia-ps%28Unix%29/#ps#unix","text":"In most Unix-like operating systems , the ps program (short for \"**p**rocess **s**tatus\") displays the currently-running processes . A related Unix utility named top provides a real-time view of the running processes. In Windows PowerShell , ps is a predefined command alias for the Get-Process cmdlet, which essentially serves the same purpose.","title":"ps (Unix)"},{"location":"Programming/Multitasking/Tools/procps/ps/wikipedia-ps%28Unix%29/#examples","text":"For example: # ps PID TTY TIME CMD 7431 pts/0 00 :00:00 su 7434 pts/0 00 :00:00 bash 18585 pts/0 00 :00:00 ps Users can also utilize the ps command in conjunction with the grep command (see the pgrep and pkill commands) to find information about a single process, such as its id: $ # Trying to find the PID of `firefox-bin` which is 2701 $ ps -A | grep firefox-bin 2701 ? 22 :16:04 firefox-bin The use of pgrep simplifies the syntax and avoids potential race conditions : $ pgrep -l firefox-bin 2701 firefox-bin To see every process running as root in user format: # ps -U root -u USER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND root 1 0 .0 0 .0 9436 128 - ILs Sun00AM 0 :00.12 /sbin/init --","title":"Examples"},{"location":"Programming/Multitasking/Tools/procps/ps/wikipedia-ps%28Unix%29/#break#down","text":"Column Header Contents %CPU How much of the CPU the process is using %MEM How much memory the process is using ADDR Memory address of the process C or CP CPU usage and scheduling information COMMAND* Name of the process, including arguments, if any NI nice value F Flags PID Process ID number PPID ID number of the process\u2032s parent process PRI Priority of the process RSS Resident set size S or STAT Process status code START or STIME Time when the process started VSZ Virtual memory usage TIME The amount of CPU time used by the process TT or TTY Terminal associated with the process UID or USER Username of the process\u2032s owner WCHAN Memory address of the event the process is waiting for * = Often abbreviated","title":"Break Down"},{"location":"Programming/Multitasking/Tools/procps/ps/wikipedia-ps%28Unix%29/#options","text":"ps has many options. On operating systems that support the SUS and POSIX standards, ps commonly runs with the options -ef , where \"-e\" selects e**very process and \"-f\" chooses the \"**f**ull\" output format. Another common option on these systems is **-l , which specifies the \"**l**ong\" output format. Most systems derived from BSD fail to accept the SUS and POSIX standard options because of historical conflicts. (For example, the \"e\" or \"-e\" option will display environment variables .) On such systems, ps commonly runs with the non-standard options aux , where \"a\" lists all processes on a terminal , including those of other users, \"x\" lists all processes without controlling terminals and \"u\" adds a column for the controlling user for each process. For maximum compatibility, there is no \"-\" in front of the \"aux\". \"ps auxww\" provides complete information about the process, including all parameters.","title":"Options"},{"location":"Programming/Multitasking/Tools/procps/ps/wikipedia-ps%28Unix%29/#see#also","text":"Task manager kill List of Unix commands nmon \u2014 a system monitor tool for the AIX and Linux operating systems. pgrep pstree top lsof","title":"See also"},{"location":"Programming/Multitasking/Tools/procps/top/htop/","text":"","title":"htop"},{"location":"Programming/Multitasking/Tools/procps/top/top/","text":"top top(1) - Linux man page Overview The remaining Table of Contents 1 COMMAND-LINE Options 2 FIELDS / Columns a. DESCRIPTIONS of Fields b. SELECTING and ORDERING Columns 3 INTERACTIVE Commands a. GLOBAL Commands b. SUMMARY Area Commands c. TASK Area Commands d. COLOR Mapping 4 ALTERNATE-DISPLAY Mode a. WINDOWS Overview b. COMMANDS for Windows 5 FILES a. SYSTEM Configuration File b. PERSONAL Configuration File 6 STUPID TRICKS Sampler a. Kernel Magic b. Bouncing Windows c. The Big Bird Window 7 BUGS 8 HISTORY Former top 9 AUTHOR 10 SEE ALSO 1. COMMAND-LINE Options 2. FIELDS / Columns 2a. DESCRIPTIONS of Fields 2b. SELECTING and ORDERING Columns 2c. SUMMARY Area Fields 3. INTERACTIVE Commands 3a. GLOBAL Commands 3b. SUMMARY Area Commands '1' Toggle_Single/Separate_Cpu_States -- On/Off NOTE: \u7b80\u5355\u8bf4\u6765\uff0c\u952e\u51651\uff0c\u8868\u793a\u6211\u4eec\u60f3\u8981\u67e5\u770b: Show CPU Usage on all cores\uff0c\u8fd9\u662f\u6211\u5728\u9605\u8bfbhaydenjames Linux server performance: Is disk I/O slowing your application? \u65f6\u53d1\u73b0\u7684\uff0c\u5b83\u7684\u89c6\u9891\u4e2d\u5c55\u793a\u4e86CPU-wise usage info\u3002\u4e0b\u9762\u662f\u4e00\u4e9b\u5bf9\u6b64\u8fdb\u884c\u8bf4\u660e\u7684\u6587\u7ae0: bencane Top: Show CPU Usage on all cores stackexchange top command on multi core processor cyberciti How to display cpu wise usage using top command on FreeBSD Unix operating system top %CPU over 100% \u4e0b\u9762\u6587\u7ae0\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u89e3\u91ca: askubuntu top command on ubuntu multicore cpu shows cpu usage >100% stackexchange Understanding %CPU while running top command [duplicate] superuser Why is the \u201ctop\u201d command showing a CPU usage of 799%? \u4e0b\u9762\u662f\u6211\u89c9\u5f97\u6700\u597d\u7684\u56de\u7b54: A : %CPU -- CPU Usage : The percentage of your CPU that is being used by the process. By default, top displays this as a percentage of a single CPU. On multi-core systems, you can have percentages that are greater than 100%. For example, if 3 cores are at 60% use, top will show a CPU use of 180%. See here for more information. You can toggle this behavior by hitting Shifti while top is running to show the overall percentage of available CPUs in use. Source for above quote . You can use htop instead. To answer your question about how many cores and virtual cores you have: According to your lscpu output: You have 32 cores ( CPU(s) ) in total. You have 2 physical sockets ( Socket(s) ), each contains 1 physical processor. Each processor of yours has 8 physical cores ( Core(s) per socket ) inside, which means you have 8 * 2 = 16 real cores. Each real core can have 2 threads ( Thread(s) per core ), which means you have real cores * threads = 16 * 2 = 32 cores in total. So you have 32 virtual cores from 16 real cores. Also see this , this and this link.","title":"top"},{"location":"Programming/Multitasking/Tools/procps/top/top/#top","text":"","title":"top"},{"location":"Programming/Multitasking/Tools/procps/top/top/#top1#-#linux#man#page","text":"","title":"top(1) - Linux man page"},{"location":"Programming/Multitasking/Tools/procps/top/top/#overview","text":"The remaining Table of Contents 1 COMMAND-LINE Options 2 FIELDS / Columns a. DESCRIPTIONS of Fields b. SELECTING and ORDERING Columns 3 INTERACTIVE Commands a. GLOBAL Commands b. SUMMARY Area Commands c. TASK Area Commands d. COLOR Mapping 4 ALTERNATE-DISPLAY Mode a. WINDOWS Overview b. COMMANDS for Windows 5 FILES a. SYSTEM Configuration File b. PERSONAL Configuration File 6 STUPID TRICKS Sampler a. Kernel Magic b. Bouncing Windows c. The Big Bird Window 7 BUGS 8 HISTORY Former top 9 AUTHOR 10 SEE ALSO","title":"Overview"},{"location":"Programming/Multitasking/Tools/procps/top/top/#1#command-line#options","text":"","title":"1. COMMAND-LINE Options"},{"location":"Programming/Multitasking/Tools/procps/top/top/#2#fields#columns","text":"","title":"2. FIELDS / Columns"},{"location":"Programming/Multitasking/Tools/procps/top/top/#2a#descriptions#of#fields","text":"","title":"2a. DESCRIPTIONS of Fields"},{"location":"Programming/Multitasking/Tools/procps/top/top/#2b#selecting#and#ordering#columns","text":"","title":"2b. SELECTING and ORDERING Columns"},{"location":"Programming/Multitasking/Tools/procps/top/top/#2c#summary#area#fields","text":"","title":"2c. SUMMARY Area Fields"},{"location":"Programming/Multitasking/Tools/procps/top/top/#3#interactive#commands","text":"","title":"3. INTERACTIVE Commands"},{"location":"Programming/Multitasking/Tools/procps/top/top/#3a#global#commands","text":"","title":"3a. GLOBAL Commands"},{"location":"Programming/Multitasking/Tools/procps/top/top/#3b#summary#area#commands","text":"'1' Toggle_Single/Separate_Cpu_States -- On/Off NOTE: \u7b80\u5355\u8bf4\u6765\uff0c\u952e\u51651\uff0c\u8868\u793a\u6211\u4eec\u60f3\u8981\u67e5\u770b: Show CPU Usage on all cores\uff0c\u8fd9\u662f\u6211\u5728\u9605\u8bfbhaydenjames Linux server performance: Is disk I/O slowing your application? \u65f6\u53d1\u73b0\u7684\uff0c\u5b83\u7684\u89c6\u9891\u4e2d\u5c55\u793a\u4e86CPU-wise usage info\u3002\u4e0b\u9762\u662f\u4e00\u4e9b\u5bf9\u6b64\u8fdb\u884c\u8bf4\u660e\u7684\u6587\u7ae0: bencane Top: Show CPU Usage on all cores stackexchange top command on multi core processor cyberciti How to display cpu wise usage using top command on FreeBSD Unix operating system","title":"3b. SUMMARY Area Commands"},{"location":"Programming/Multitasking/Tools/procps/top/top/#top#cpu#over#100","text":"\u4e0b\u9762\u6587\u7ae0\u5bf9\u8fd9\u4e2a\u95ee\u9898\u8fdb\u884c\u4e86\u89e3\u91ca: askubuntu top command on ubuntu multicore cpu shows cpu usage >100% stackexchange Understanding %CPU while running top command [duplicate] superuser Why is the \u201ctop\u201d command showing a CPU usage of 799%? \u4e0b\u9762\u662f\u6211\u89c9\u5f97\u6700\u597d\u7684\u56de\u7b54: A : %CPU -- CPU Usage : The percentage of your CPU that is being used by the process. By default, top displays this as a percentage of a single CPU. On multi-core systems, you can have percentages that are greater than 100%. For example, if 3 cores are at 60% use, top will show a CPU use of 180%. See here for more information. You can toggle this behavior by hitting Shifti while top is running to show the overall percentage of available CPUs in use. Source for above quote . You can use htop instead. To answer your question about how many cores and virtual cores you have: According to your lscpu output: You have 32 cores ( CPU(s) ) in total. You have 2 physical sockets ( Socket(s) ), each contains 1 physical processor. Each processor of yours has 8 physical cores ( Core(s) per socket ) inside, which means you have 8 * 2 = 16 real cores. Each real core can have 2 threads ( Thread(s) per core ), which means you have real cores * threads = 16 * 2 = 32 cores in total. So you have 32 virtual cores from 16 real cores. Also see this , this and this link.","title":"top %CPU over 100%"},{"location":"Programming/Object-file/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bbaLinux OS\u5bf9object file\u7684\u652f\u6301\uff0c\u8fd9\u5bf9\u4e8e\u4e00\u4e2aOS\u800c\u8a00\uff0c\u662f\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u529f\u80fd\u3002 Object file in Linux OS \u6211\u4eec\u5e38\u5e38\u4ee5\u591a\u79cd\u5f62\u5f0f\u6765\u63d0\u4f9b\u6211\u4eec\u7684\u7a0b\u5e8f\u6587\u4ef6\uff0cLinux OS\u652f\u6301\u7684Object file: 1) object file 2) executable file(\u53ef\u6267\u884c\u7a0b\u5e8f\u6587\u4ef6) 3) shared library(\u52a8\u6001\u94fe\u63a5\u5e93\u6587\u4ef6) ELF Linux OS\u5b9a\u4e49\u7684Object file\u7684\u683c\u5f0f\uff1b Interface load api executable file exec shared library dlopen","title":"Introduction"},{"location":"Programming/Object-file/#_1","text":"\u672c\u7ae0\u8ba8\u8bbaLinux OS\u5bf9object file\u7684\u652f\u6301\uff0c\u8fd9\u5bf9\u4e8e\u4e00\u4e2aOS\u800c\u8a00\uff0c\u662f\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u529f\u80fd\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Object-file/#object#file#in#linux#os","text":"\u6211\u4eec\u5e38\u5e38\u4ee5\u591a\u79cd\u5f62\u5f0f\u6765\u63d0\u4f9b\u6211\u4eec\u7684\u7a0b\u5e8f\u6587\u4ef6\uff0cLinux OS\u652f\u6301\u7684Object file: 1) object file 2) executable file(\u53ef\u6267\u884c\u7a0b\u5e8f\u6587\u4ef6) 3) shared library(\u52a8\u6001\u94fe\u63a5\u5e93\u6587\u4ef6)","title":"Object file in Linux OS"},{"location":"Programming/Object-file/#elf","text":"Linux OS\u5b9a\u4e49\u7684Object file\u7684\u683c\u5f0f\uff1b","title":"ELF"},{"location":"Programming/Object-file/#interface","text":"load api executable file exec shared library dlopen","title":"Interface"},{"location":"Programming/Object-file/ELF/","text":"Executable file format compiler\u7f16\u8bd1\u751f\u6210\u7684executable \uff0c\u4f1a\u6309\u7167\u56fa\u5b9a\u7684format\u6765\u4fdd\u5b58\uff0c\u8fd9\u662f\u672c\u7ae0\u8ba8\u8bba\u8ba8\u8bba\u7684\u95ee\u9898\u3002 wikipedia Comparison of executable file formats This is a comparison of binary executable file formats which, once loaded by a suitable executable loader , can be directly executed by the CPU rather than become interpreted by software. In addition to the binary application code, the executables may contain headers and tables with relocation and fixup information as well as various kinds of meta data. Among those formats listed, the ones in most common use are PE (on Microsoft Windows ), ELF (on Linux and most other versions of Unix ), Mach-O (on macOS and iOS ) and MZ (on DOS ). NOTE:As soon as I saw the loader, I thought of a loader in celery . wikipedia Weak symbol wikipedia Executable and Linkable Format","title":"Introduction"},{"location":"Programming/Object-file/ELF/#executable#file#format","text":"compiler\u7f16\u8bd1\u751f\u6210\u7684executable \uff0c\u4f1a\u6309\u7167\u56fa\u5b9a\u7684format\u6765\u4fdd\u5b58\uff0c\u8fd9\u662f\u672c\u7ae0\u8ba8\u8bba\u8ba8\u8bba\u7684\u95ee\u9898\u3002","title":"Executable file format"},{"location":"Programming/Object-file/ELF/#wikipedia#comparison#of#executable#file#formats","text":"This is a comparison of binary executable file formats which, once loaded by a suitable executable loader , can be directly executed by the CPU rather than become interpreted by software. In addition to the binary application code, the executables may contain headers and tables with relocation and fixup information as well as various kinds of meta data. Among those formats listed, the ones in most common use are PE (on Microsoft Windows ), ELF (on Linux and most other versions of Unix ), Mach-O (on macOS and iOS ) and MZ (on DOS ). NOTE:As soon as I saw the loader, I thought of a loader in celery .","title":"wikipedia Comparison of executable file formats"},{"location":"Programming/Object-file/ELF/#wikipedia#weak#symbol","text":"","title":"wikipedia Weak symbol"},{"location":"Programming/Object-file/ELF/#wikipedia#executable#and#linkable#format","text":"","title":"wikipedia Executable and Linkable Format"},{"location":"Programming/Object-file/ELF/Classification-of-object-file/","text":"\u53ef\u6267\u884c\u6587\u4ef6\uff08ELF\uff09\u683c\u5f0f\u7684\u7406\u89e3 ELF(Executable and Linking Format)\u662f\u4e00\u79cd\u5bf9\u8c61\u6587\u4ef6\u7684\u683c\u5f0f\uff0c\u7528\u4e8e\u5b9a\u4e49\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u6587\u4ef6(Object files)\u4e2d\u90fd\u653e\u4e86\u4ec0\u4e48\u4e1c\u897f\u3001\u4ee5\u53ca\u90fd\u4ee5\u4ec0\u4e48\u6837\u7684\u683c\u5f0f\u53bb\u653e\u8fd9\u4e9b\u4e1c\u897f\u3002\u5b83\u81ea\u6700\u65e9\u5728 System V \u7cfb\u7edf\u4e0a\u51fa\u73b0\u540e\uff0c\u88ab xNIX \u4e16\u754c\u6240\u5e7f\u6cdb\u63a5\u53d7\uff0c\u4f5c\u4e3a\u7f3a\u7701\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u683c\u5f0f\u6765\u4f7f\u7528\u3002\u53ef\u4ee5\u8bf4\uff0cELF\u662f\u6784\u6210\u4f17\u591axNIX\u7cfb\u7edf\u7684\u57fa\u7840\u4e4b\u4e00\uff0c\u6240\u4ee5\u4f5c\u4e3a\u5d4c\u5165\u5f0fLinux\u7cfb\u7edf\u4e43\u81f3\u5185\u6838\u9a71\u52a8\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\uff0c\u4f60\u6700\u597d\u719f\u6089\u5e76\u638c\u63e1\u5b83\u3002 \u5176\u5b9e\uff0c\u5173\u4e8eELF\u8fd9\u4e2a\u4e3b\u9898\uff0c\u7f51\u7edc\u4e0a\u5df2\u7ecf\u6709\u76f8\u5f53\u591a\u7684\u6587\u7ae0\u5b58\u5728\uff0c\u4f46\u662f\u5176\u4ecb\u7ecd\u7684\u5185\u5bb9\u6bd4\u8f83\u5206\u6563\uff0c\u4f7f\u5f97\u521d\u5b66\u8005\u4e0d\u592a\u5bb9\u6613\u4ece\u4e2d\u5f97\u5230\u4e00\u4e2a\u7cfb\u7edf\u6027\u7684\u8ba4\u8bc6\u3002\u4e3a\u4e86\u5e2e\u52a9\u5927\u5bb6\u5b66\u4e60\uff0c\u6211\u8fd9\u91cc\u6253\u7b97\u5199\u4e00\u7cfb\u5217\u8fde\u8d2f\u7684\u6587\u7ae0\u6765\u4ecb\u7ecdELF\u4ee5\u53ca\u76f8\u5173\u7684\u5e94\u7528\u3002\u8fd9\u662f\u8fd9\u4e2a\u7cfb\u5217\u4e2d\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\uff0c\u4e3b\u8981\u662f\u901a\u8fc7\u4e0d\u540c\u5de5\u5177\u7684\u4f7f\u7528\u6765\u719f\u6089ELF\u6587\u4ef6\u7684\u5185\u90e8\u7ed3\u6784\u4ee5\u53ca\u76f8\u5173\u7684\u57fa\u672c\u6982\u5ff5\u3002\u540e\u9762\u7684\u6587\u7ae0\uff0c\u6211\u4eec\u4f1a\u4ecb\u7ecd\u5f88\u591a\u9ad8\u7ea7\u7684\u6982\u5ff5\u548c\u5e94\u7528\uff0c\u6bd4\u65b9\u52a8\u6001\u94fe\u63a5\u548c\u52a0\u8f7d\uff0c\u52a8\u6001\u5e93\u7684\u5f00\u53d1\uff0cC\u8bed\u8a00Main\u51fd\u6570\u662f\u88ab\u8c01\u4ee5\u53ca\u5982\u4f55\u88ab\u8c03\u7528\u7684\uff0cELF\u683c\u5f0f\u5728\u5185\u6838\u4e2d\u7684\u652f\u6301\uff0cLinux\u5185\u6838\u4e2d\u5bf9ELF section\u7684\u6269\u5c55\u4f7f\u7528\u7b49\u7b49\u3002 \u597d\u7684\uff0c\u5f00\u59cb\u6211\u4eec\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\u3002\u5728\u8be6\u7ec6\u8fdb\u5165\u6b63\u9898\u4e4b\u524d\uff0c\u5148\u7ed9\u5927\u5bb6\u4ecb\u7ecd\u4e00\u70b9ELF\u6587\u4ef6\u683c\u5f0f\u7684\u53c2\u8003\u8d44\u6599\u3002\u5728ELF\u683c\u5f0f\u51fa\u6765\u4e4b\u540e\uff0cTISC(Tool Interface Standard Committee)\u59d4\u5458\u4f1a\u5b9a\u4e49\u4e86\u4e00\u5957ELF\u6807\u51c6\u3002\u4f60\u53ef\u4ee5\u4ece\u8fd9\u91cc( http://refspecs.freestandards.org/elf/)\u627e\u5230\u8be6\u7ec6\u7684\u6807\u51c6\u6587\u6863 \u3002TISC\u59d4\u5458\u4f1a\u524d\u540e\u51fa\u4e86\u4e24\u4e2a\u7248\u672c\uff0cv1.1\u548cv1.2\u3002\u4e24\u4e2a\u7248\u672c\u5185\u5bb9\u4e0a\u5dee\u4e0d\u591a\uff0c\u4f46\u5c31\u53ef\u8bfb\u6027\u4e0a\u6765\u8bb2\uff0c\u6211\u8fd8\u662f\u63a8\u8350\u4f60\u8bfb v1.2\u7684\u3002\u56e0\u4e3a\u5728v1.2\u7248\u672c\u4e2d\uff0cTISC\u91cd\u65b0\u7ec4\u7ec7\u539f\u672c\u5728v1.1\u7248\u672c\u4e2d\u7684\u5185\u5bb9\uff0c\u5c06\u5b83\u4eec\u5206\u6210\u4e3a\u4e09\u4e2a\u90e8\u5206(books)\uff1a a) Book I \u4ecb\u7ecd\u4e86\u901a\u7528\u7684\u9002\u7528\u4e8e\u6240\u670932\u4f4d\u67b6\u6784\u5904\u7406\u5668\u7684ELF\u76f8\u5173\u5185\u5bb9 b) Book II \u4ecb\u7ecd\u4e86\u5904\u7406\u5668\u7279\u5b9a\u7684ELF\u76f8\u5173\u5185\u5bb9\uff0c\u8fd9\u91cc\u662f\u4ee5Intel x86 \u67b6\u6784\u5904\u7406\u5668\u4f5c\u4e3a\u4f8b\u5b50\u4ecb\u7ecd c) Book III \u4ecb\u7ecd\u4e86\u64cd\u4f5c\u7cfb\u7edf\u7279\u5b9a\u7684ELF\u76f8\u5173\u5185\u5bb9\uff0c\u8fd9\u91cc\u662f\u4ee5\u8fd0\u884c\u5728x86\u4e0a\u9762\u7684 UNIX System V.4 \u4f5c\u4e3a\u4f8b\u5b50\u4ecb\u7ecd \u503c\u5f97\u4e00\u8bf4\u7684\u662f\uff0c\u867d\u7136TISC\u662f\u4ee5x86\u4e3a\u4f8b\u5b50\u4ecb\u7ecdELF\u89c4\u8303\u7684\uff0c\u4f46\u662f\u5982\u679c\u4f60\u662f\u60f3\u77e5\u9053\u975ex86\u4e0b\u9762\u7684ELF\u5b9e\u73b0\u60c5\u51b5\uff0c\u90a3\u4e5f\u53ef\u4ee5\u5728http://refspecs.freestandards.org/elf/\u4e2d\u627e\u5230\u7279\u5b9a\u5904\u7406\u5668\u76f8\u5173\u7684Supplment\u6587\u6863\u3002\u6bd4\u65b9ARM\u76f8\u5173\u7684\uff0c\u6216\u8005MIPS\u76f8\u5173\u7684\u7b49\u7b49\u3002\u53e6\u5916\uff0c\u76f8\u6bd4\u8f83UNIX\u7cfb\u7edf\u7684\u53e6\u5916\u4e00\u4e2a\u5206\u652fBSD Unix\uff0cLinux\u7cfb\u7edf\u66f4\u9760\u8fd1 System V \u7cfb\u7edf\u3002\u6240\u4ee5\u5173\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7279\u5b9a\u7684ELF\u5185\u5bb9\uff0c\u4f60\u53ef\u4ee5\u76f4\u63a5\u53c2\u8003v1.2\u6807\u51c6\u4e2d\u7684\u5185\u5bb9\u3002 \u8fd9\u91cc\u591a\u8bf4\u4e9b\u5e9f\u8bdd\uff1a\u522b\u5fd8\u4e86 Linus \u5728\u5b9e\u73b0Linux\u7684\u7b2c\u4e00\u4e2a\u7248\u672c\u7684\u65f6\u5019\uff0c\u5c31\u662f\u770b\u4e86\u4ecb\u7ecdUnix\u5185\u90e8\u7ec6\u8282\u7684\u4e66\uff1a\u300aThe of the Unix Operating System\u300b\uff0c\u5f97\u5230\u5f88\u591a\u542f\u53d1\u3002\u8fd9\u672c\u4e66\u5bf9\u5e94\u7684\u64cd\u4f5c\u7cfb\u7edf\u662fSystem V \u7684\u7b2c\u4e8c\u4e2aRelease\u3002\u8fd9\u672c\u4e66\u4ecb\u7ecd\u4e86\u64cd\u4f5c\u7cfb\u7edf\u7684\u5f88\u591a\u8bbe\u8ba1\u89c2\u5ff5\uff0c\u5e76\u4e14\u884c\u6587\u7b80\u5355\u6613\u61c2\u3002\u6240\u4ee5\u867d\u7136\u73b0\u5728\u7684Linux\u4e5f\u5438\u53d6\u4e86\u5176\u4ed6\u5f88\u591aUnix\u53d8\u79cd\u7684\u8bbe\u8ba1\u7406\u5ff5\uff0c\u4f46\u662f\u5982\u679c\u4f60\u60f3\u7814\u7a76\u5b66\u4e60Linux\u5185\u6838\uff0c\u90a3\u8fd8\u662f\u4ee5\u770b\u8fd9\u672c\u4e66\u4f5c\u4e3a\u5f00\u59cb\u4e3a\u597d\u3002\u8fd9\u672c\u4e66\u4e5f\u662f\u6211\u5728\u63a5\u89e6Linux\u5185\u6838\u4e4b\u524d\u6240\u770b\u7684\u7b2c\u4e00\u672c\u4ecb\u7ecd\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e66\uff0c\u6240\u4ee5\u6211\u6781\u529b\u5411\u5927\u5bb6\u63a8\u8350\u3002 \u597d\u4e86\uff0c\u8fd8\u662f\u56de\u6765\u5f00\u59cb\u6211\u4eec\u7b2c\u4e00\u7bc7ELF\u4e3b\u9898\u76f8\u5173\u7684\u6587\u7ae0\u5427\u3002\u8fd9\u7bc7\u6587\u7ae0\u4e3b\u8981\u662f\u901a\u8fc7\u4f7f\u7528\u4e0d\u540c\u7684\u5de5\u5177\u6765\u5206\u6790\u5bf9\u8c61\u6587\u4ef6\uff0c\u6765\u4f7f\u4f60\u638c\u63e1ELF\u6587\u4ef6\u7684\u57fa\u672c\u683c\u5f0f\uff0c\u4ee5\u53ca\u4e86\u89e3\u76f8\u5173\u7684\u57fa\u672c\u6982\u5ff5\u3002\u4f60\u5728\u8bfb\u8fd9\u7bc7\u6587\u7ae0\u7684\u65f6\u5019\uff0c\u5e0c\u671b\u4f60\u5728\u7535\u8111\u4e0a\u5df2\u7ecf\u6253\u5f00\u4e86\u90a3\u4e2a v1.2 \u7248\u672c\u7684ELF\u89c4\u8303\uff0c\u5e76\u5bf9\u7167\u7740\u6587\u7ae0\u5185\u5bb9\u770b\u89c4\u8303\u91cc\u7684\u6587\u5b57\u3002 Object files\u5206\u7c7b \u9996\u5148\uff0c\u4f60\u9700\u8981\u77e5\u9053\u7684\u662f\u6240\u8c13\u5bf9\u8c61\u6587\u4ef6(Object files)\u6709\u4e09\u4e2a\u79cd\u7c7b\uff1a Relocatable file \u8fd9\u662f\u7531**\u6c47\u7f16\u5668**\u6c47\u7f16\u751f\u6210\u7684 .o \u6587\u4ef6\uff08\u53c2\u89c1 linux\u4e0b\u7f16\u8bd1\u7684\u6b65\u9aa4 \uff09\u3002\u540e\u9762\u7684\u94fe\u63a5\u5668(link editor)\u62ff\u4e00\u4e2a\u6216\u4e00\u4e9b Relocatable object files \u4f5c\u4e3a\u8f93\u5165\uff0c\u7ecf\u94fe\u63a5\u5904\u7406\u540e\uff0c\u751f\u6210\u4e00\u4e2a**\u53ef\u6267\u884c\u7684\u5bf9\u8c61\u6587\u4ef6 (Executable file)** \u6216\u8005\u4e00\u4e2a**\u53ef\u88ab\u5171\u4eab\u7684\u5bf9\u8c61\u6587\u4ef6(Shared object file)**\u3002\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 **ar \u5de5\u5177**\u5c06\u4f17\u591a\u7684 .o Relocatable object files \u5f52\u6863(archive)\u6210 .a \u9759\u6001\u5e93\u6587\u4ef6\u3002\u5982\u4f55\u4ea7\u751f Relocatable file\uff0c\u4f60\u5e94\u8be5\u5f88\u719f\u6089\u4e86\u3002\u53e6\u5916\uff0c\u53ef\u4ee5\u9884\u5148\u544a\u8bc9\u5927\u5bb6\u7684\u662f\u6211\u4eec\u7684\u5185\u6838\u53ef\u52a0\u8f7d\u6a21\u5757 .ko \u6587\u4ef6\u4e5f\u662f Relocatable object file\u3002 Executable file \u53ef\u6267\u884c\u7684\u5bf9\u8c61\u6587\u4ef6\uff0c\u8fd9\u6211\u4eec\u89c1\u7684\u591a\u4e86\u3002\u6587\u672c\u7f16\u8f91\u5668vi\u3001\u8c03\u5f0f\u7528\u7684\u5de5\u5177gdb\u3001\u64ad\u653emp3\u6b4c\u66f2\u7684\u8f6f\u4ef6mplayer\u7b49\u7b49\u90fd\u662fExecutable object file\u3002\u4f60\u5e94\u8be5\u5df2\u7ecf\u77e5\u9053\uff0c\u5728\u6211\u4eec\u7684 Linux \u7cfb\u7edf\u91cc\u9762\uff0c\u5b58\u5728\u4e24\u79cd\u53ef\u6267\u884c\u7684\u4e1c\u897f\u3002\u9664\u4e86\u8fd9\u91cc\u8bf4\u7684 Executable object file\uff0c\u53e6\u5916\u4e00\u79cd\u5c31\u662f\u53ef\u6267\u884c\u7684\u811a\u672c(\u5982shell\u811a\u672c)\u3002\u6ce8\u610f\u8fd9\u4e9b\u811a\u672c\u4e0d\u662f Executable object file\uff0c\u5b83\u4eec\u53ea\u662f\u6587\u672c\u6587\u4ef6\uff0c\u4f46\u662f\u6267\u884c\u8fd9\u4e9b\u811a\u672c\u6240\u7528\u7684\u89e3\u91ca\u5668\u5c31\u662f Executable object file\uff0c\u6bd4\u5982 bash shell \u7a0b\u5e8f\u3002 Shared object file \u53ef\u88ab\u5171\u4eab\u7684\u5bf9\u8c61\u6587\u4ef6\u5c31\u662f\u6240\u8c13\u7684**\u52a8\u6001\u5e93\u6587\u4ef6**\uff0c\u4e5f\u5373 .so \u6587\u4ef6\u3002\u5982\u679c\u62ff\u524d\u9762\u7684**\u9759\u6001\u5e93**\u6765\u751f\u6210\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u90a3\u6bcf\u4e2a\u751f\u6210\u7684**\u53ef\u6267\u884c\u7a0b\u5e8f**\u4e2d\u90fd\u4f1a\u6709\u4e00\u4efd\u5e93\u4ee3\u7801\u7684\u62f7\u8d1d\u3002\u5982\u679c\u5728\u78c1\u76d8\u4e2d\u5b58\u50a8\u8fd9\u4e9b\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u90a3\u5c31\u4f1a\u5360\u7528\u989d\u5916\u7684\u78c1\u76d8\u7a7a\u95f4\uff1b\u53e6\u5916\u5982\u679c\u62ff\u5b83\u4eec\u653e\u5230Linux\u7cfb\u7edf\u4e0a\u4e00\u8d77\u8fd0\u884c\uff0c\u4e5f\u4f1a\u6d6a\u8d39\u6389\u5b9d\u8d35\u7684\u7269\u7406\u5185\u5b58\u3002\u5982\u679c\u5c06\u9759\u6001\u5e93\u6362\u6210\u52a8\u6001\u5e93\uff0c\u90a3\u4e48\u8fd9\u4e9b\u95ee\u9898\u90fd\u4e0d\u4f1a\u51fa\u73b0\u3002\u52a8\u6001\u5e93\u5728\u53d1\u6325\u4f5c\u7528\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5fc5\u987b\u7ecf\u8fc7\u4e24\u4e2a\u6b65\u9aa4\uff1a a) \u94fe\u63a5\u7f16\u8f91\u5668(link editor\uff0c\u5373linux\u4e2d\u7684ld\u7a0b\u5e8f)\u62ff\u5b83\u548c\u5176\u4ed6Relocatable object file\u4ee5\u53ca\u5176\u4ed6shared object file\u4f5c\u4e3a\u8f93\u5165\uff0c\u7ecf\u94fe\u63a5\u5904\u7406\u540e\uff0c\u751f\u5b58\u53e6\u5916\u7684 shared object file \u6216\u8005 executable file\u3002 b) \u5728\u8fd0\u884c\u65f6\uff0c\u52a8\u6001\u94fe\u63a5\u5668(dynamic linker)\u62ff\u5b83\u548c\u4e00\u4e2aExecutable file\u4ee5\u53ca\u53e6\u5916\u4e00\u4e9b Shared object file \u6765\u4e00\u8d77\u5904\u7406\uff0c\u5728Linux\u7cfb\u7edf\u91cc\u9762\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u6620\u50cf\u3002","title":"Introduction"},{"location":"Programming/Object-file/ELF/Classification-of-object-file/#elf","text":"ELF(Executable and Linking Format)\u662f\u4e00\u79cd\u5bf9\u8c61\u6587\u4ef6\u7684\u683c\u5f0f\uff0c\u7528\u4e8e\u5b9a\u4e49\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u6587\u4ef6(Object files)\u4e2d\u90fd\u653e\u4e86\u4ec0\u4e48\u4e1c\u897f\u3001\u4ee5\u53ca\u90fd\u4ee5\u4ec0\u4e48\u6837\u7684\u683c\u5f0f\u53bb\u653e\u8fd9\u4e9b\u4e1c\u897f\u3002\u5b83\u81ea\u6700\u65e9\u5728 System V \u7cfb\u7edf\u4e0a\u51fa\u73b0\u540e\uff0c\u88ab xNIX \u4e16\u754c\u6240\u5e7f\u6cdb\u63a5\u53d7\uff0c\u4f5c\u4e3a\u7f3a\u7701\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u683c\u5f0f\u6765\u4f7f\u7528\u3002\u53ef\u4ee5\u8bf4\uff0cELF\u662f\u6784\u6210\u4f17\u591axNIX\u7cfb\u7edf\u7684\u57fa\u7840\u4e4b\u4e00\uff0c\u6240\u4ee5\u4f5c\u4e3a\u5d4c\u5165\u5f0fLinux\u7cfb\u7edf\u4e43\u81f3\u5185\u6838\u9a71\u52a8\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\uff0c\u4f60\u6700\u597d\u719f\u6089\u5e76\u638c\u63e1\u5b83\u3002 \u5176\u5b9e\uff0c\u5173\u4e8eELF\u8fd9\u4e2a\u4e3b\u9898\uff0c\u7f51\u7edc\u4e0a\u5df2\u7ecf\u6709\u76f8\u5f53\u591a\u7684\u6587\u7ae0\u5b58\u5728\uff0c\u4f46\u662f\u5176\u4ecb\u7ecd\u7684\u5185\u5bb9\u6bd4\u8f83\u5206\u6563\uff0c\u4f7f\u5f97\u521d\u5b66\u8005\u4e0d\u592a\u5bb9\u6613\u4ece\u4e2d\u5f97\u5230\u4e00\u4e2a\u7cfb\u7edf\u6027\u7684\u8ba4\u8bc6\u3002\u4e3a\u4e86\u5e2e\u52a9\u5927\u5bb6\u5b66\u4e60\uff0c\u6211\u8fd9\u91cc\u6253\u7b97\u5199\u4e00\u7cfb\u5217\u8fde\u8d2f\u7684\u6587\u7ae0\u6765\u4ecb\u7ecdELF\u4ee5\u53ca\u76f8\u5173\u7684\u5e94\u7528\u3002\u8fd9\u662f\u8fd9\u4e2a\u7cfb\u5217\u4e2d\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\uff0c\u4e3b\u8981\u662f\u901a\u8fc7\u4e0d\u540c\u5de5\u5177\u7684\u4f7f\u7528\u6765\u719f\u6089ELF\u6587\u4ef6\u7684\u5185\u90e8\u7ed3\u6784\u4ee5\u53ca\u76f8\u5173\u7684\u57fa\u672c\u6982\u5ff5\u3002\u540e\u9762\u7684\u6587\u7ae0\uff0c\u6211\u4eec\u4f1a\u4ecb\u7ecd\u5f88\u591a\u9ad8\u7ea7\u7684\u6982\u5ff5\u548c\u5e94\u7528\uff0c\u6bd4\u65b9\u52a8\u6001\u94fe\u63a5\u548c\u52a0\u8f7d\uff0c\u52a8\u6001\u5e93\u7684\u5f00\u53d1\uff0cC\u8bed\u8a00Main\u51fd\u6570\u662f\u88ab\u8c01\u4ee5\u53ca\u5982\u4f55\u88ab\u8c03\u7528\u7684\uff0cELF\u683c\u5f0f\u5728\u5185\u6838\u4e2d\u7684\u652f\u6301\uff0cLinux\u5185\u6838\u4e2d\u5bf9ELF section\u7684\u6269\u5c55\u4f7f\u7528\u7b49\u7b49\u3002 \u597d\u7684\uff0c\u5f00\u59cb\u6211\u4eec\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\u3002\u5728\u8be6\u7ec6\u8fdb\u5165\u6b63\u9898\u4e4b\u524d\uff0c\u5148\u7ed9\u5927\u5bb6\u4ecb\u7ecd\u4e00\u70b9ELF\u6587\u4ef6\u683c\u5f0f\u7684\u53c2\u8003\u8d44\u6599\u3002\u5728ELF\u683c\u5f0f\u51fa\u6765\u4e4b\u540e\uff0cTISC(Tool Interface Standard Committee)\u59d4\u5458\u4f1a\u5b9a\u4e49\u4e86\u4e00\u5957ELF\u6807\u51c6\u3002\u4f60\u53ef\u4ee5\u4ece\u8fd9\u91cc( http://refspecs.freestandards.org/elf/)\u627e\u5230\u8be6\u7ec6\u7684\u6807\u51c6\u6587\u6863 \u3002TISC\u59d4\u5458\u4f1a\u524d\u540e\u51fa\u4e86\u4e24\u4e2a\u7248\u672c\uff0cv1.1\u548cv1.2\u3002\u4e24\u4e2a\u7248\u672c\u5185\u5bb9\u4e0a\u5dee\u4e0d\u591a\uff0c\u4f46\u5c31\u53ef\u8bfb\u6027\u4e0a\u6765\u8bb2\uff0c\u6211\u8fd8\u662f\u63a8\u8350\u4f60\u8bfb v1.2\u7684\u3002\u56e0\u4e3a\u5728v1.2\u7248\u672c\u4e2d\uff0cTISC\u91cd\u65b0\u7ec4\u7ec7\u539f\u672c\u5728v1.1\u7248\u672c\u4e2d\u7684\u5185\u5bb9\uff0c\u5c06\u5b83\u4eec\u5206\u6210\u4e3a\u4e09\u4e2a\u90e8\u5206(books)\uff1a a) Book I \u4ecb\u7ecd\u4e86\u901a\u7528\u7684\u9002\u7528\u4e8e\u6240\u670932\u4f4d\u67b6\u6784\u5904\u7406\u5668\u7684ELF\u76f8\u5173\u5185\u5bb9 b) Book II \u4ecb\u7ecd\u4e86\u5904\u7406\u5668\u7279\u5b9a\u7684ELF\u76f8\u5173\u5185\u5bb9\uff0c\u8fd9\u91cc\u662f\u4ee5Intel x86 \u67b6\u6784\u5904\u7406\u5668\u4f5c\u4e3a\u4f8b\u5b50\u4ecb\u7ecd c) Book III \u4ecb\u7ecd\u4e86\u64cd\u4f5c\u7cfb\u7edf\u7279\u5b9a\u7684ELF\u76f8\u5173\u5185\u5bb9\uff0c\u8fd9\u91cc\u662f\u4ee5\u8fd0\u884c\u5728x86\u4e0a\u9762\u7684 UNIX System V.4 \u4f5c\u4e3a\u4f8b\u5b50\u4ecb\u7ecd \u503c\u5f97\u4e00\u8bf4\u7684\u662f\uff0c\u867d\u7136TISC\u662f\u4ee5x86\u4e3a\u4f8b\u5b50\u4ecb\u7ecdELF\u89c4\u8303\u7684\uff0c\u4f46\u662f\u5982\u679c\u4f60\u662f\u60f3\u77e5\u9053\u975ex86\u4e0b\u9762\u7684ELF\u5b9e\u73b0\u60c5\u51b5\uff0c\u90a3\u4e5f\u53ef\u4ee5\u5728http://refspecs.freestandards.org/elf/\u4e2d\u627e\u5230\u7279\u5b9a\u5904\u7406\u5668\u76f8\u5173\u7684Supplment\u6587\u6863\u3002\u6bd4\u65b9ARM\u76f8\u5173\u7684\uff0c\u6216\u8005MIPS\u76f8\u5173\u7684\u7b49\u7b49\u3002\u53e6\u5916\uff0c\u76f8\u6bd4\u8f83UNIX\u7cfb\u7edf\u7684\u53e6\u5916\u4e00\u4e2a\u5206\u652fBSD Unix\uff0cLinux\u7cfb\u7edf\u66f4\u9760\u8fd1 System V \u7cfb\u7edf\u3002\u6240\u4ee5\u5173\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7279\u5b9a\u7684ELF\u5185\u5bb9\uff0c\u4f60\u53ef\u4ee5\u76f4\u63a5\u53c2\u8003v1.2\u6807\u51c6\u4e2d\u7684\u5185\u5bb9\u3002 \u8fd9\u91cc\u591a\u8bf4\u4e9b\u5e9f\u8bdd\uff1a\u522b\u5fd8\u4e86 Linus \u5728\u5b9e\u73b0Linux\u7684\u7b2c\u4e00\u4e2a\u7248\u672c\u7684\u65f6\u5019\uff0c\u5c31\u662f\u770b\u4e86\u4ecb\u7ecdUnix\u5185\u90e8\u7ec6\u8282\u7684\u4e66\uff1a\u300aThe of the Unix Operating System\u300b\uff0c\u5f97\u5230\u5f88\u591a\u542f\u53d1\u3002\u8fd9\u672c\u4e66\u5bf9\u5e94\u7684\u64cd\u4f5c\u7cfb\u7edf\u662fSystem V \u7684\u7b2c\u4e8c\u4e2aRelease\u3002\u8fd9\u672c\u4e66\u4ecb\u7ecd\u4e86\u64cd\u4f5c\u7cfb\u7edf\u7684\u5f88\u591a\u8bbe\u8ba1\u89c2\u5ff5\uff0c\u5e76\u4e14\u884c\u6587\u7b80\u5355\u6613\u61c2\u3002\u6240\u4ee5\u867d\u7136\u73b0\u5728\u7684Linux\u4e5f\u5438\u53d6\u4e86\u5176\u4ed6\u5f88\u591aUnix\u53d8\u79cd\u7684\u8bbe\u8ba1\u7406\u5ff5\uff0c\u4f46\u662f\u5982\u679c\u4f60\u60f3\u7814\u7a76\u5b66\u4e60Linux\u5185\u6838\uff0c\u90a3\u8fd8\u662f\u4ee5\u770b\u8fd9\u672c\u4e66\u4f5c\u4e3a\u5f00\u59cb\u4e3a\u597d\u3002\u8fd9\u672c\u4e66\u4e5f\u662f\u6211\u5728\u63a5\u89e6Linux\u5185\u6838\u4e4b\u524d\u6240\u770b\u7684\u7b2c\u4e00\u672c\u4ecb\u7ecd\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e66\uff0c\u6240\u4ee5\u6211\u6781\u529b\u5411\u5927\u5bb6\u63a8\u8350\u3002 \u597d\u4e86\uff0c\u8fd8\u662f\u56de\u6765\u5f00\u59cb\u6211\u4eec\u7b2c\u4e00\u7bc7ELF\u4e3b\u9898\u76f8\u5173\u7684\u6587\u7ae0\u5427\u3002\u8fd9\u7bc7\u6587\u7ae0\u4e3b\u8981\u662f\u901a\u8fc7\u4f7f\u7528\u4e0d\u540c\u7684\u5de5\u5177\u6765\u5206\u6790\u5bf9\u8c61\u6587\u4ef6\uff0c\u6765\u4f7f\u4f60\u638c\u63e1ELF\u6587\u4ef6\u7684\u57fa\u672c\u683c\u5f0f\uff0c\u4ee5\u53ca\u4e86\u89e3\u76f8\u5173\u7684\u57fa\u672c\u6982\u5ff5\u3002\u4f60\u5728\u8bfb\u8fd9\u7bc7\u6587\u7ae0\u7684\u65f6\u5019\uff0c\u5e0c\u671b\u4f60\u5728\u7535\u8111\u4e0a\u5df2\u7ecf\u6253\u5f00\u4e86\u90a3\u4e2a v1.2 \u7248\u672c\u7684ELF\u89c4\u8303\uff0c\u5e76\u5bf9\u7167\u7740\u6587\u7ae0\u5185\u5bb9\u770b\u89c4\u8303\u91cc\u7684\u6587\u5b57\u3002","title":"\u53ef\u6267\u884c\u6587\u4ef6\uff08ELF\uff09\u683c\u5f0f\u7684\u7406\u89e3"},{"location":"Programming/Object-file/ELF/Classification-of-object-file/#object#files","text":"\u9996\u5148\uff0c\u4f60\u9700\u8981\u77e5\u9053\u7684\u662f\u6240\u8c13\u5bf9\u8c61\u6587\u4ef6(Object files)\u6709\u4e09\u4e2a\u79cd\u7c7b\uff1a","title":"Object files\u5206\u7c7b"},{"location":"Programming/Object-file/ELF/Classification-of-object-file/#relocatable#file","text":"\u8fd9\u662f\u7531**\u6c47\u7f16\u5668**\u6c47\u7f16\u751f\u6210\u7684 .o \u6587\u4ef6\uff08\u53c2\u89c1 linux\u4e0b\u7f16\u8bd1\u7684\u6b65\u9aa4 \uff09\u3002\u540e\u9762\u7684\u94fe\u63a5\u5668(link editor)\u62ff\u4e00\u4e2a\u6216\u4e00\u4e9b Relocatable object files \u4f5c\u4e3a\u8f93\u5165\uff0c\u7ecf\u94fe\u63a5\u5904\u7406\u540e\uff0c\u751f\u6210\u4e00\u4e2a**\u53ef\u6267\u884c\u7684\u5bf9\u8c61\u6587\u4ef6 (Executable file)** \u6216\u8005\u4e00\u4e2a**\u53ef\u88ab\u5171\u4eab\u7684\u5bf9\u8c61\u6587\u4ef6(Shared object file)**\u3002\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 **ar \u5de5\u5177**\u5c06\u4f17\u591a\u7684 .o Relocatable object files \u5f52\u6863(archive)\u6210 .a \u9759\u6001\u5e93\u6587\u4ef6\u3002\u5982\u4f55\u4ea7\u751f Relocatable file\uff0c\u4f60\u5e94\u8be5\u5f88\u719f\u6089\u4e86\u3002\u53e6\u5916\uff0c\u53ef\u4ee5\u9884\u5148\u544a\u8bc9\u5927\u5bb6\u7684\u662f\u6211\u4eec\u7684\u5185\u6838\u53ef\u52a0\u8f7d\u6a21\u5757 .ko \u6587\u4ef6\u4e5f\u662f Relocatable object file\u3002","title":"Relocatable file"},{"location":"Programming/Object-file/ELF/Classification-of-object-file/#executable#file","text":"\u53ef\u6267\u884c\u7684\u5bf9\u8c61\u6587\u4ef6\uff0c\u8fd9\u6211\u4eec\u89c1\u7684\u591a\u4e86\u3002\u6587\u672c\u7f16\u8f91\u5668vi\u3001\u8c03\u5f0f\u7528\u7684\u5de5\u5177gdb\u3001\u64ad\u653emp3\u6b4c\u66f2\u7684\u8f6f\u4ef6mplayer\u7b49\u7b49\u90fd\u662fExecutable object file\u3002\u4f60\u5e94\u8be5\u5df2\u7ecf\u77e5\u9053\uff0c\u5728\u6211\u4eec\u7684 Linux \u7cfb\u7edf\u91cc\u9762\uff0c\u5b58\u5728\u4e24\u79cd\u53ef\u6267\u884c\u7684\u4e1c\u897f\u3002\u9664\u4e86\u8fd9\u91cc\u8bf4\u7684 Executable object file\uff0c\u53e6\u5916\u4e00\u79cd\u5c31\u662f\u53ef\u6267\u884c\u7684\u811a\u672c(\u5982shell\u811a\u672c)\u3002\u6ce8\u610f\u8fd9\u4e9b\u811a\u672c\u4e0d\u662f Executable object file\uff0c\u5b83\u4eec\u53ea\u662f\u6587\u672c\u6587\u4ef6\uff0c\u4f46\u662f\u6267\u884c\u8fd9\u4e9b\u811a\u672c\u6240\u7528\u7684\u89e3\u91ca\u5668\u5c31\u662f Executable object file\uff0c\u6bd4\u5982 bash shell \u7a0b\u5e8f\u3002","title":"Executable file"},{"location":"Programming/Object-file/ELF/Classification-of-object-file/#shared#object#file","text":"\u53ef\u88ab\u5171\u4eab\u7684\u5bf9\u8c61\u6587\u4ef6\u5c31\u662f\u6240\u8c13\u7684**\u52a8\u6001\u5e93\u6587\u4ef6**\uff0c\u4e5f\u5373 .so \u6587\u4ef6\u3002\u5982\u679c\u62ff\u524d\u9762\u7684**\u9759\u6001\u5e93**\u6765\u751f\u6210\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u90a3\u6bcf\u4e2a\u751f\u6210\u7684**\u53ef\u6267\u884c\u7a0b\u5e8f**\u4e2d\u90fd\u4f1a\u6709\u4e00\u4efd\u5e93\u4ee3\u7801\u7684\u62f7\u8d1d\u3002\u5982\u679c\u5728\u78c1\u76d8\u4e2d\u5b58\u50a8\u8fd9\u4e9b\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u90a3\u5c31\u4f1a\u5360\u7528\u989d\u5916\u7684\u78c1\u76d8\u7a7a\u95f4\uff1b\u53e6\u5916\u5982\u679c\u62ff\u5b83\u4eec\u653e\u5230Linux\u7cfb\u7edf\u4e0a\u4e00\u8d77\u8fd0\u884c\uff0c\u4e5f\u4f1a\u6d6a\u8d39\u6389\u5b9d\u8d35\u7684\u7269\u7406\u5185\u5b58\u3002\u5982\u679c\u5c06\u9759\u6001\u5e93\u6362\u6210\u52a8\u6001\u5e93\uff0c\u90a3\u4e48\u8fd9\u4e9b\u95ee\u9898\u90fd\u4e0d\u4f1a\u51fa\u73b0\u3002\u52a8\u6001\u5e93\u5728\u53d1\u6325\u4f5c\u7528\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5fc5\u987b\u7ecf\u8fc7\u4e24\u4e2a\u6b65\u9aa4\uff1a a) \u94fe\u63a5\u7f16\u8f91\u5668(link editor\uff0c\u5373linux\u4e2d\u7684ld\u7a0b\u5e8f)\u62ff\u5b83\u548c\u5176\u4ed6Relocatable object file\u4ee5\u53ca\u5176\u4ed6shared object file\u4f5c\u4e3a\u8f93\u5165\uff0c\u7ecf\u94fe\u63a5\u5904\u7406\u540e\uff0c\u751f\u5b58\u53e6\u5916\u7684 shared object file \u6216\u8005 executable file\u3002 b) \u5728\u8fd0\u884c\u65f6\uff0c\u52a8\u6001\u94fe\u63a5\u5668(dynamic linker)\u62ff\u5b83\u548c\u4e00\u4e2aExecutable file\u4ee5\u53ca\u53e6\u5916\u4e00\u4e9b Shared object file \u6765\u4e00\u8d77\u5904\u7406\uff0c\u5728Linux\u7cfb\u7edf\u91cc\u9762\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u6620\u50cf\u3002","title":"Shared object file"},{"location":"Programming/Object-file/ELF/Tools/man-1-addr2line/","text":"addr2line addr2line(1) - Linux man page stackoverflow How to use the addr2line command in Linux?","title":"man-1-addr2line"},{"location":"Programming/Object-file/ELF/Tools/man-1-addr2line/#addr2line","text":"","title":"addr2line"},{"location":"Programming/Object-file/ELF/Tools/man-1-addr2line/#addr2line1#-#linux#man#page","text":"","title":"addr2line(1) - Linux man page"},{"location":"Programming/Object-file/ELF/Tools/man-1-addr2line/#stackoverflow#how#to#use#the#addr2line#command#in#linux","text":"","title":"stackoverflow How to use the addr2line command in Linux?"},{"location":"Programming/Object-file/ELF/Tools/man-1-objdump/","text":"objdump objdump(1) - Linux man page wikipedia objdump","title":"man-1-objdump"},{"location":"Programming/Object-file/ELF/Tools/man-1-objdump/#objdump","text":"","title":"objdump"},{"location":"Programming/Object-file/ELF/Tools/man-1-objdump/#objdump1#-#linux#man#page","text":"","title":"objdump(1) - Linux man page"},{"location":"Programming/Object-file/ELF/Tools/man-1-objdump/#wikipedia#objdump","text":"","title":"wikipedia objdump"},{"location":"Programming/Object-file/ELF/Tools/man-1-readelf/","text":"readelf readelf(1) \u2014 Linux manual page geeksforgeeks readelf command in Linux with Examples","title":"man-1-readelf"},{"location":"Programming/Object-file/ELF/Tools/man-1-readelf/#readelf","text":"","title":"readelf"},{"location":"Programming/Object-file/ELF/Tools/man-1-readelf/#readelf1#linux#manual#page","text":"","title":"readelf(1) \u2014 Linux manual page"},{"location":"Programming/Object-file/ELF/Tools/man-1-readelf/#geeksforgeeks#readelf#command#in#linux#with#examples","text":"","title":"geeksforgeeks readelf command in Linux with Examples"},{"location":"Programming/Object-file/ELF/Tools/man-1-strip/","text":"strip strip(1) \u2014 Linux manual page wikipedia Strip_(Unix)","title":"man-1-strip"},{"location":"Programming/Object-file/ELF/Tools/man-1-strip/#strip","text":"","title":"strip"},{"location":"Programming/Object-file/ELF/Tools/man-1-strip/#strip1#linux#manual#page","text":"","title":"strip(1) \u2014 Linux manual page"},{"location":"Programming/Object-file/ELF/Tools/man-1-strip/#wikipedia#strip_unix","text":"","title":"wikipedia Strip_(Unix)"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/link-editor-and-dynamic-linker/","text":"\u5728ELF\u6587\u6863\u4e2dlink editing \u548c dynamic linking\u8fd9\u4e24\u4e2a\u8bcd\u662f\u7ecf\u5e38\u770b\u5230\u7684\uff0c\u4ed6\u4eec\u7684\u5177\u4f53\u542b\u4e49\u6211\u76ee\u524d\u5c1a\u4e14\u4e0d\u6e05\u695a\u3002 \u5728\u4ecb\u7ecdshared object file\u7684\u65f6\u5019\uff0c\u4f5c\u8005\u4f7f\u7528\u7684\u662f\u4e0b\u9762\u8fd9\u6bb5\u8bdd\u6765\u63cf\u8ff0\u7684\uff1a A shared object file holds code and data suitable for linking in two contexts. First, the link editor may process it with other relocatable and shared object files to create another object file.Second, the dynamic linker combines it with an executable file and other shared objects to create a process image. shared object file\u53ef\u4ee5\u5728\u4e24\u79cd\u60c5\u51b5\u4e0b\u8fdb\u884clinking\uff1a \u7b2c\u4e00\u79cd\u662flink editor\u62fc\u63a5\u5b83\u548c\u5176\u4ed6\u7684relocatable object file\u548c shared object file\u6765\u7ec4\u6210\u65b0\u7684 shared object file\u3002 \u8fd9\u662fgcc\u7684\u6700\u540e\u4e00\u6b65\uff0c\u5b83\u53ef\u4ee5\u7ffb\u8bd1\u4e3a\u94fe\u63a5\u5668\uff0c\u901a\u5e38\u662f\u7531ld\u5b9e\u73b0\u7684\u3002 [ dk@hundsun ~ ] $ whereis ld ld: /usr/bin/ld /usr/share/man/man1/ld.1.gz \u7b2c\u4e8c\u79cd\u662fdynamic linker\u7ec4\u5408\u5b83\u548c\u5176\u5b83\u7684executable file\u548c shared object file\u6765\u521b\u5efa\u4e00\u4e2aprocess image \u5b83\u53ef\u4ee5\u7ffb\u8bd1\u4e3a\u52a8\u6001\u94fe\u63a5\u5668\u662f\uff0c\u901a\u5e38\u662f\u7531ld-linux.so.2 \u6765\u5b9e\u73b0\u7684\u3002 [ dk@hundsun ~ ] $ whereis ld-linux.so.2 ld-linux.so: /lib/ld-linux.so.2 /usr/share/man/man8/ld-linux.so.8.gz \u5173\u4e8eld-linux.so.2\uff0c\u53c2\u8003\u4e0b\u9762\u7684\u6587\u7ae0\uff1a \u6df1\u5165\u7406\u89e3LINUX\u4e0b\u52a8\u6001\u5e93\u94fe\u63a5\u5668/\u52a0\u8f7d\u5668ld-linux.so.2 ld-linux.so.2 \u662flinux\u4e0b\u7684\u52a8\u6001\u5e93\u52a0\u8f7d\u5668/\u94fe\u63a5\u5668\uff0c\u8fd9\u7bc7\u6587\u7ae0\u4e3b\u8981\u6765\u8bb2\u4e00\u4e0b ld-linux.so.2 \u662f\u5982\u4f55\u548cLinux \u4ee5\u53ca\u76f8\u5173\u5e94\u7528\u6253\u4ea4\u9053\u7684\u3002 1. \u4ec0\u4e48\u662f ld.linux.so ? \u5f88\u591a\u73b0\u4ee3\u5e94\u7528\u90fd\u662f\u901a\u8fc7\u52a8\u6001\u7f16\u8bd1\u94fe\u63a5\u7684\uff0c\u5f53\u4e00\u4e2a \u9700\u8981\u52a8\u6001\u94fe\u63a5 \u7684\u5e94\u7528\u88ab\u64cd\u4f5c\u7cfb\u7edf\u52a0\u8f7d\u65f6\uff0c\u7cfb\u7edf\u5fc5\u987b\u8981 \u5b9a\u4f4d \u7136\u540e \u52a0\u8f7d\u5b83\u6240\u9700\u8981\u7684\u6240\u6709**\u52a8\u6001\u5e93\u6587\u4ef6**\u3002 \u5728Linux\u73af\u5883\u4e0b\uff0c\u8fd9\u9879\u5de5\u4f5c\u662f\u7531ld-linux.so.2\u6765\u8d1f\u8d23\u5b8c\u6210\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 ldd \u547d\u4ee4\u6765\u67e5\u770b\u4e00\u4e2a \u5e94\u7528\u9700\u8981\u54ea\u4e9b\u4f9d\u8d56\u7684\u52a8\u6001\u5e93: $ ldd `which ls` linux-gate.so.1 => (0xb7fff000) librt.so.1 => /lib/librt.so.1 (0x00b98000) libacl.so.1 => /lib/libacl.so.1 (0x00769000) libselinux.so.1 => /lib/libselinux.so.1 (0x00642000) libc.so.6 => /lib/libc.so.6 (0x007b2000) libpthread.so.0 => /lib/libpthread.so.0 (0x00920000) /lib/ld-linux.so.2 (0x00795000) libattr.so.1 => /lib/libattr.so.1 (0x00762000) libdl.so.2 => /lib/libdl.so.2 (0x0091a000) libsepol.so.1 => /lib/libsepol.so.1 (0x0065b000) \u5f53\u6700\u5e38\u89c1\u7684ls\u5c0f\u7a0b\u5e8f\u52a0\u8f7d\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u5c06 \u63a7\u5236\u6743 \u4ea4\u7ed9 ld-linux.so \u800c\u4e0d\u662f \u4ea4\u7ed9\u7a0b\u5e8f\u6b63\u5e38\u7684\u8fdb\u5165\u5730\u5740\u3002 ld-linux.so.2 \u4f1a**\u5bfb\u627e**\u7136\u540e**\u52a0\u8f7d**\u6240\u6709\u9700\u8981\u7684\u5e93\u6587\u4ef6\uff0c\u7136\u540e\u518d\u5c06\u63a7\u5236\u6743\u4ea4\u7ed9\u5e94\u7528\u7684\u8d77\u59cb\u5165\u53e3\u3002 \u4e0a\u9762\u7684ls\u5728\u542f\u52a8\u65f6\uff0c\u5c31\u9700\u8981ld-linux.so\u52a0\u8f7d\u5668\u5c06\u6240\u6709\u7684\u52a8\u6001\u5e93\u52a0\u8f7d\u540e\u7136\u540e\u518d\u5c06\u63a7\u5236\u6743\u79fb\u4ea4\u7ed9ls\u7a0b\u5e8f\u7684\u5165\u53e3\u3002 ld-linux.so.2 man page\u7ed9\u6211\u4eec\u66f4\u9ad8\u4e00\u5c42\u7684\u5168\u5c40\u4ecb\u7ecd\uff0c \u5b83\u662f\u5728 \u94fe\u63a5\u5668\uff08\u901a\u5e38\u662fld\uff09\u5728\u8fd0\u884c\u72b6\u6001\u4e0b\u7684\u90e8\u4ef6\uff0c\u7528\u6765**\u5b9a\u4f4d**\u548c**\u52a0\u8f7d**\u52a8\u6001\u5e93\u5230\u5e94\u7528\u7684\u8fd0\u884c\u5730\u5740\uff08\u6216\u8005\u662f\u8fd0\u884c\u5185\u5b58\uff09\u5f53\u4e2d\u53bb\u3002\u901a\u5e38\uff0c \u52a8\u6001\u94fe\u63a5**\u662f **\u94fe\u63a5\u9636\u6bb5 ( linux\u4e0b\u7f16\u8bd1\u7684\u6b65\u9aa4 \u5f53\u4e2d \u9690\u5f0f\u6307\u5b9a\u7684 \u3002 gcc -W1 options -L/path/included -lxxx \u4f1a\u5c06 options \u4f20\u9012\u5230ld \u7136\u540e\u6307\u5b9a\u76f8\u5e94\u7684**\u52a8\u6001\u5e93\u52a0\u8f7d**\u3002 ELF \u6587\u4ef6\u63d0\u4f9b\u4e86\u76f8\u5e94\u7684\u52a0\u8f7d\u4fe1\u606f\uff0c GCC\u5305\u542b\u4e86\u4e00\u4e2a\u7279\u6b8a\u7684 ELF \u5934\uff1a INTERP\uff0c \u8fd9\u4e2a INTERP\u6307\u5b9a\u4e86 \u52a0\u8f7d\u5668\u7684\u8def\u5f84\uff0c\u6211\u4eec\u53ef\u4ee5\u7528readelf \u6765\u67e5\u770b\u76f8\u5e94\u7684\u7a0b\u5e8f $ readelf -l a.out Elf file type is EXEC (Executable file) Entry point 0x8048310 There are 9 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4 INTERP 0x000154 0x08048154 0x08048154 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0x004cc 0x004cc R E 0x1000 LOAD 0x000f0c 0x08049f0c 0x08049f0c 0x0010c 0x00110 RW 0x1000 . . . ELF \u89c4\u683c\u8981\u6c42\uff0c\u5047\u5982 PT_INTERP \u5b58\u5728\u7684\u8bdd\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5fc5\u987b\u521b\u5efa\u8fd9\u4e2a interpreter\u6587\u4ef6\u7684\u8fd0\u884c\u6620\u5c04\uff0c\u800c\u4e0d\u662f\u8fd9\u4e2a\u7a0b\u5e8f\u672c\u8eab\uff0c \u63a7\u5236\u6743\u4f1a\u4ea4\u7ed9\u8fd9\u4e2ainterpreter\uff0c\u7528\u6765\u5b9a\u4f4d\u548c\u52a0\u8f7d\u6240\u6709\u7684\u52a8\u6001\u5e93\uff0c Segment Types\u4e2d\u786e\u5b9e\u5b58\u5728PT_INTERP\u8fd9\u79cd\u7c7b\u578b\u7684segment\uff0c\u5173\u4e8e PT_INTERP\u8fd9\u662fELF\u6587\u6863\u4e2d\u7684\u76f8\u5173\u4ecb\u7ecd\uff1a The array element specifies the location and size of a null-terminated path name to invoke as an interpreter. See Book III.","title":"Link editor and dynamic linker"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/link-editor-and-dynamic-linker/#1#ldlinuxso","text":"\u5f88\u591a\u73b0\u4ee3\u5e94\u7528\u90fd\u662f\u901a\u8fc7\u52a8\u6001\u7f16\u8bd1\u94fe\u63a5\u7684\uff0c\u5f53\u4e00\u4e2a \u9700\u8981\u52a8\u6001\u94fe\u63a5 \u7684\u5e94\u7528\u88ab\u64cd\u4f5c\u7cfb\u7edf\u52a0\u8f7d\u65f6\uff0c\u7cfb\u7edf\u5fc5\u987b\u8981 \u5b9a\u4f4d \u7136\u540e \u52a0\u8f7d\u5b83\u6240\u9700\u8981\u7684\u6240\u6709**\u52a8\u6001\u5e93\u6587\u4ef6**\u3002 \u5728Linux\u73af\u5883\u4e0b\uff0c\u8fd9\u9879\u5de5\u4f5c\u662f\u7531ld-linux.so.2\u6765\u8d1f\u8d23\u5b8c\u6210\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 ldd \u547d\u4ee4\u6765\u67e5\u770b\u4e00\u4e2a \u5e94\u7528\u9700\u8981\u54ea\u4e9b\u4f9d\u8d56\u7684\u52a8\u6001\u5e93: $ ldd `which ls` linux-gate.so.1 => (0xb7fff000) librt.so.1 => /lib/librt.so.1 (0x00b98000) libacl.so.1 => /lib/libacl.so.1 (0x00769000) libselinux.so.1 => /lib/libselinux.so.1 (0x00642000) libc.so.6 => /lib/libc.so.6 (0x007b2000) libpthread.so.0 => /lib/libpthread.so.0 (0x00920000) /lib/ld-linux.so.2 (0x00795000) libattr.so.1 => /lib/libattr.so.1 (0x00762000) libdl.so.2 => /lib/libdl.so.2 (0x0091a000) libsepol.so.1 => /lib/libsepol.so.1 (0x0065b000) \u5f53\u6700\u5e38\u89c1\u7684ls\u5c0f\u7a0b\u5e8f\u52a0\u8f7d\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u5c06 \u63a7\u5236\u6743 \u4ea4\u7ed9 ld-linux.so \u800c\u4e0d\u662f \u4ea4\u7ed9\u7a0b\u5e8f\u6b63\u5e38\u7684\u8fdb\u5165\u5730\u5740\u3002 ld-linux.so.2 \u4f1a**\u5bfb\u627e**\u7136\u540e**\u52a0\u8f7d**\u6240\u6709\u9700\u8981\u7684\u5e93\u6587\u4ef6\uff0c\u7136\u540e\u518d\u5c06\u63a7\u5236\u6743\u4ea4\u7ed9\u5e94\u7528\u7684\u8d77\u59cb\u5165\u53e3\u3002 \u4e0a\u9762\u7684ls\u5728\u542f\u52a8\u65f6\uff0c\u5c31\u9700\u8981ld-linux.so\u52a0\u8f7d\u5668\u5c06\u6240\u6709\u7684\u52a8\u6001\u5e93\u52a0\u8f7d\u540e\u7136\u540e\u518d\u5c06\u63a7\u5236\u6743\u79fb\u4ea4\u7ed9ls\u7a0b\u5e8f\u7684\u5165\u53e3\u3002 ld-linux.so.2 man page\u7ed9\u6211\u4eec\u66f4\u9ad8\u4e00\u5c42\u7684\u5168\u5c40\u4ecb\u7ecd\uff0c \u5b83\u662f\u5728 \u94fe\u63a5\u5668\uff08\u901a\u5e38\u662fld\uff09\u5728\u8fd0\u884c\u72b6\u6001\u4e0b\u7684\u90e8\u4ef6\uff0c\u7528\u6765**\u5b9a\u4f4d**\u548c**\u52a0\u8f7d**\u52a8\u6001\u5e93\u5230\u5e94\u7528\u7684\u8fd0\u884c\u5730\u5740\uff08\u6216\u8005\u662f\u8fd0\u884c\u5185\u5b58\uff09\u5f53\u4e2d\u53bb\u3002\u901a\u5e38\uff0c \u52a8\u6001\u94fe\u63a5**\u662f **\u94fe\u63a5\u9636\u6bb5 ( linux\u4e0b\u7f16\u8bd1\u7684\u6b65\u9aa4 \u5f53\u4e2d \u9690\u5f0f\u6307\u5b9a\u7684 \u3002 gcc -W1 options -L/path/included -lxxx \u4f1a\u5c06 options \u4f20\u9012\u5230ld \u7136\u540e\u6307\u5b9a\u76f8\u5e94\u7684**\u52a8\u6001\u5e93\u52a0\u8f7d**\u3002 ELF \u6587\u4ef6\u63d0\u4f9b\u4e86\u76f8\u5e94\u7684\u52a0\u8f7d\u4fe1\u606f\uff0c GCC\u5305\u542b\u4e86\u4e00\u4e2a\u7279\u6b8a\u7684 ELF \u5934\uff1a INTERP\uff0c \u8fd9\u4e2a INTERP\u6307\u5b9a\u4e86 \u52a0\u8f7d\u5668\u7684\u8def\u5f84\uff0c\u6211\u4eec\u53ef\u4ee5\u7528readelf \u6765\u67e5\u770b\u76f8\u5e94\u7684\u7a0b\u5e8f $ readelf -l a.out Elf file type is EXEC (Executable file) Entry point 0x8048310 There are 9 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4 INTERP 0x000154 0x08048154 0x08048154 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0x004cc 0x004cc R E 0x1000 LOAD 0x000f0c 0x08049f0c 0x08049f0c 0x0010c 0x00110 RW 0x1000 . . . ELF \u89c4\u683c\u8981\u6c42\uff0c\u5047\u5982 PT_INTERP \u5b58\u5728\u7684\u8bdd\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5fc5\u987b\u521b\u5efa\u8fd9\u4e2a interpreter\u6587\u4ef6\u7684\u8fd0\u884c\u6620\u5c04\uff0c\u800c\u4e0d\u662f\u8fd9\u4e2a\u7a0b\u5e8f\u672c\u8eab\uff0c \u63a7\u5236\u6743\u4f1a\u4ea4\u7ed9\u8fd9\u4e2ainterpreter\uff0c\u7528\u6765\u5b9a\u4f4d\u548c\u52a0\u8f7d\u6240\u6709\u7684\u52a8\u6001\u5e93\uff0c Segment Types\u4e2d\u786e\u5b9e\u5b58\u5728PT_INTERP\u8fd9\u79cd\u7c7b\u578b\u7684segment\uff0c\u5173\u4e8e PT_INTERP\u8fd9\u662fELF\u6587\u6863\u4e2d\u7684\u76f8\u5173\u4ecb\u7ecd\uff1a The array element specifies the location and size of a null-terminated path name to invoke as an interpreter. See Book III.","title":"1. \u4ec0\u4e48\u662f ld.linux.so ?"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/link-viev-and-excution-view/","text":"20180318 \u539f\u6587\u5982\u4e0b: Object files participate in program linking (building a program) and program execution (running a program). For convenience and efficiency, the object file format provides parallel views of a file's contents, reflecting the differing needs of these activities. Figure 1-1 shows an object file's organization. \u6211\u73b0\u5728\u770b\u5230\u8fd9\u6bb5\u8bdd\uff0c\u6211\u7684\u7b2c\u4e00\u60f3\u6cd5\u662f\uff1a\u4e3a\u4ec0\u4e48\u8981\u63d0\u4f9b\u8fd9\u4e24\u79cdview\uff1f\u662f\u5426\u662f\u751f\u6210\u7684relocatable file\u91c7\u7528\u7684\u662flinking view\uff0c\u800cshared object file\u548cexecutable file\u91c7\u7528\u7684\u662fexecution view\uff1f \u8fd9\u4e2a\u95ee\u9898\u662f\u9700\u8981\u597d\u597d\u5730\u8fdb\u884c\u5206\u6790\u7684\u3002 \u8fd8\u6709\uff0c\u5982\u4f55\u533a\u5206\u4e00\u4e2a\u6587\u4ef6\u5230\u5e95\u91c7\u7528\u7684\u662flinking view\u8fd8\u662fexecution view\u5462\uff1f \u521a\u521a\u53c2\u9605\u4e86\u4e0b\u9762\u8fd9\u4e2a\u6587\u7ae0\uff1a https://www.cnblogs.com/LiuYanYGZ/p/5574602.html \u8fd9\u7bc7\u6587\u7ae0\u4e2d\u7684\u8fd9\u6bb5\u8bdd\u5c31\u6b63\u597d\u89e3\u7b54\u4e86\u6211\u7684\u7591\u95ee\uff1a \u6240\u4ee5\uff0c\u57fa\u672c\u4e0a\uff0c\u56fe\u4e2d\u5de6\u8fb9\u7684\u90e8\u5206\uff08linking view\uff09\u8868\u793a\u7684\u662f\u53ef\u91cd\u5b9a\u4f4d\u5bf9\u8c61\u6587\u4ef6\u7684\u683c\u5f0f\uff1b\u800c\u53f3\u8fb9\u90e8\u5206\uff08execution view\uff09\u8868\u793a\u7684\u5219\u662f\u53ef\u6267\u884c\u6587\u4ef6\u4ee5\u53ca\u53ef\u88ab\u5171\u4eab\u7684\u5bf9\u8c61\u6587\u4ef6\u7684\u683c\u5f0f\u3002 \u663e\u7136\uff0c\u53ef\u6267\u884c\u6587\u4ef6\u548c\u53ef\u88ab\u5171\u4eab\u6587\u4ef6\u662f\u9700\u8981\u4ee5\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6\u4e3a\u57fa\u7840\u8fdb\u884c\u751f\u6210\u7684\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u662f\u9700\u8981\u641e\u6e05\u695a\u7684\uff0c\u6211\u89c9\u5f97\u8fd9\u4e2a\u8fc7\u7a0b\u662f\u6d89\u53ca\u4e00\u4e0b\u5173\u8054\u7684\uff1a 1. section\u5982\u4f55\u8f6c\u6362\u4e3asegment","title":"20180318"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/link-viev-and-excution-view/#20180318","text":"\u539f\u6587\u5982\u4e0b: Object files participate in program linking (building a program) and program execution (running a program). For convenience and efficiency, the object file format provides parallel views of a file's contents, reflecting the differing needs of these activities. Figure 1-1 shows an object file's organization. \u6211\u73b0\u5728\u770b\u5230\u8fd9\u6bb5\u8bdd\uff0c\u6211\u7684\u7b2c\u4e00\u60f3\u6cd5\u662f\uff1a\u4e3a\u4ec0\u4e48\u8981\u63d0\u4f9b\u8fd9\u4e24\u79cdview\uff1f\u662f\u5426\u662f\u751f\u6210\u7684relocatable file\u91c7\u7528\u7684\u662flinking view\uff0c\u800cshared object file\u548cexecutable file\u91c7\u7528\u7684\u662fexecution view\uff1f \u8fd9\u4e2a\u95ee\u9898\u662f\u9700\u8981\u597d\u597d\u5730\u8fdb\u884c\u5206\u6790\u7684\u3002 \u8fd8\u6709\uff0c\u5982\u4f55\u533a\u5206\u4e00\u4e2a\u6587\u4ef6\u5230\u5e95\u91c7\u7528\u7684\u662flinking view\u8fd8\u662fexecution view\u5462\uff1f \u521a\u521a\u53c2\u9605\u4e86\u4e0b\u9762\u8fd9\u4e2a\u6587\u7ae0\uff1a https://www.cnblogs.com/LiuYanYGZ/p/5574602.html \u8fd9\u7bc7\u6587\u7ae0\u4e2d\u7684\u8fd9\u6bb5\u8bdd\u5c31\u6b63\u597d\u89e3\u7b54\u4e86\u6211\u7684\u7591\u95ee\uff1a \u6240\u4ee5\uff0c\u57fa\u672c\u4e0a\uff0c\u56fe\u4e2d\u5de6\u8fb9\u7684\u90e8\u5206\uff08linking view\uff09\u8868\u793a\u7684\u662f\u53ef\u91cd\u5b9a\u4f4d\u5bf9\u8c61\u6587\u4ef6\u7684\u683c\u5f0f\uff1b\u800c\u53f3\u8fb9\u90e8\u5206\uff08execution view\uff09\u8868\u793a\u7684\u5219\u662f\u53ef\u6267\u884c\u6587\u4ef6\u4ee5\u53ca\u53ef\u88ab\u5171\u4eab\u7684\u5bf9\u8c61\u6587\u4ef6\u7684\u683c\u5f0f\u3002 \u663e\u7136\uff0c\u53ef\u6267\u884c\u6587\u4ef6\u548c\u53ef\u88ab\u5171\u4eab\u6587\u4ef6\u662f\u9700\u8981\u4ee5\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6\u4e3a\u57fa\u7840\u8fdb\u884c\u751f\u6210\u7684\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u662f\u9700\u8981\u641e\u6e05\u695a\u7684\uff0c\u6211\u89c9\u5f97\u8fd9\u4e2a\u8fc7\u7a0b\u662f\u6d89\u53ca\u4e00\u4e0b\u5173\u8054\u7684\uff1a 1. section\u5982\u4f55\u8f6c\u6362\u4e3asegment","title":"20180318"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/relocatable-file/","text":"\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6 \u672c\u6587\u4f7f\u7528\u7684\u793a\u4f8b\u4ee3\u7801\u5982\u4e0b\uff1a \u7a0b\u5e8f\u4ee3\u7801\u5982\u4e0b\uff1a a.c int sum ( int a , int b ) { return a + b ; } b.c int mul ( int a , int b ) { return a * b ; } main.c #include <stdio.h> int a = 12 ; int main () { int b = 12 ; printf ( \"a+b=%d \\n \" , sum ( a , b )); printf ( \"a*b=%d \\n \" , mul ( a , b )); return 0 ; } \u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807 \u91cd\u5b9a\u4f4d**\u662f\u5c06EFL\u6587\u4ef6\u4e2d\u7684**\u672a\u5b9a\u4e49\u7b26\u53f7 \uff08\u5305\u62ec\u51fd\u6570\u548c\u53d8\u91cf\uff09\u5173\u8054\u5230**\u6709\u6548\u503c**\u7684\u5904\u7406\u8fc7\u7a0b\u3002\u5728 main.o \u4e2d\uff0c\u8fd9\u610f\u5473\u7740\u5bf9 printf \u548c puts \u7684\u672a\u5b9a\u4e49\u7684\u5f15\u7528\u5fc5\u987b\u66ff\u6362\u4e3a\u8be5**\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u4e2d\u9002\u5f53\u7684**\u673a\u5668\u4ee3\u7801**\u6240\u5728\u7684**\u5730\u5740**\u3002\u5728\u76ee\u6807\u4e2d\u7528\u5230\u7684\u76f8\u5173**\u7b26\u53f7**\u4e4b\u5904\uff0c\u90fd\u5fc5\u987b\u66ff\u6362\u3002 \u5bf9*\u7528\u6237\u7a7a\u95f4* \u7a0b\u5e8f\u7b26\u53f7**\u7684\u66ff\u6362\uff0c**\u5185\u6838**\u5e76\u4e0d\u6d89\u53ca\u5176\u4e2d\uff0c\u56e0\u4e3a\u6240\u6709\u7684\u66ff\u6362\u64cd\u4f5c\u90fd\u662f\u7531**\u5916\u90e8\u5de5\u5177**\u5b8c\u6210\u7684\u3002\u5bf9\u5185\u6838\u6a21\u5757\u6765\u8bf4\uff0c\u60c5\u51b5\u6709\u6240\u4e0d\u540c\uff0c\u56e0\u4e3a\u5185\u6838\u6240\u6536\u5230\u7684**\u6a21\u5757\u88f8\u6570\u636e \uff0c\u4e0e\u5176\u5b58\u50a8\u5728\u4e8c\u8fdb\u5236\u6587\u4ef6\u4e2d\u7684\u5f62\u5f0f\u5b8c\u5168\u76f8\u540c\uff0c\u5185\u6838\u672c\u8eab\u9700\u8981\u8d1f\u8d23\u91cd\u5b9a\u4f4d\u64cd\u4f5c\u3002 \u5728\u6bcf\u4e2a**\u76ee\u6807\u6587\u4ef6**\u4e2d\uff0c\u90fd\u6709\u4e00\u4e2a\u4e13\u95e8\u7684\u8868\uff0c\u5305\u542b\u4e86**\u91cd\u5b9a\u4f4d\u9879**\uff0c\u6807\u8bc6\u4e86\u9700\u8981\u8fdb\u884c\u91cd\u5b9a\u4f4d\u7684\u3002\u6bcf\u4e2a**\u8868\u9879**\u90fd\u5305\u542b\u4e0b\u5217\u4fe1\u606f\uff1a \u200b 1\uff09\u4e00\u4e2a**\u504f\u79fb\u91cf**\uff0c\u6307\u5b9a\u4e86\u4fee\u6539\u7684\u9879\u7684\u4f4d\u7f6e \u200b 2\uff09\u5bf9**\u7b26\u53f7**\u7684**\u5f15\u7528**\uff08\u7b26\u53f7\u8868\u7684**\u7d22\u5f15**\uff09\uff0c\u63d0\u4f9b\u4e86\u9700\u8981\u63d2\u5165\u5230**\u91cd\u5b9a\u4f4d\u4f4d\u7f6e**\u7684\u6570\u636e \u91cd\u5b9a\u4f4d\u6b65\u9aa4 \u200b 1\uff09\u91cd\u5b9a\u4f4d \u8282(section)\u548c\u7b26\u53f7\u5b9a\u4e49\u3002 \u200b \u94fe\u63a5\u5668**\u5c06\u6240\u6709**\u76f8\u540c\u7c7b\u578b\u7684\u8282**\u5408\u5e76\u4e3a\u540c\u4e00\u7c7b\u578b\u7684\u65b0\u7684**\u805a\u5408\u8282 \u3002\u4f8b\u5982\u6765\u81ea\u8f93\u5165\u6a21\u5757\u7684 .data \u8282\u5168\u90e8\u5408\u5e76\u6210\u4e00\u4e2a\u8282\uff0c\u8fd9\u4e2a\u8282\u6210\u4e3a\u8f93\u51fa\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684 .data \u8282\u3002\u7136\u540e**\u94fe\u63a5\u5668**\u5c06\u8fd0\u884c\u65f6**\u5b58\u50a8\u5668\u5730\u5740**\u8d4b\u7ed9\u65b0\u7684**\u805a\u5408\u8282**\uff0c\u8d4b\u7ed9\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6bcf\u4e2a\u8282\uff0c\u4ee5\u53ca\u8d4b\u7ed9\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6bcf\u4e2a**\u7b26\u53f7**\u3002\u5f53\u8fd9\u4e00\u6b65\u5b8c\u6210\u65f6\uff0c\u7a0b\u5e8f\u4e2d\u7684\u6bcf\u4e2a**\u6307\u4ee4**\u548c**\u5168\u5c40\u53d8\u91cf**\u90fd\u6709\u552f\u4e00\u7684**\u8fd0\u884c\u65f6\u5b58\u50a8\u5668\u5730\u5740**\u4e86\u3002 \u200b 2\uff09\u91cd\u5b9a\u4f4d \u8282(section)\u4e2d\u7684\u7b26\u53f7\u5f15\u7528\u3002 \u200b \u5728\u8fd9\u4e00\u6b65\u4e2d\uff0c\u94fe\u63a5\u5668\u4fee\u6539**\u4ee3\u7801\u8282**\u548c**\u6570\u636e\u8282**\u4e2d\u5bf9\u6bcf\u4e2a**\u7b26\u53f7**\u7684**\u5f15\u7528**\uff0c\u4f7f\u5f97\u4ed6\u4eec\u6307\u5411**\u6b63\u786e\u7684\u8fd0\u884c\u65f6\u5730\u5740**\u3002\u4e3a\u4e86\u6267\u884c\u8fd9\u4e00\u6b65\uff0c\u94fe\u63a5\u5668\u4f9d\u8d56\u4e8e\u79f0\u4e4b\u4e3a**\u91cd\u5b9a\u4f4d\u6761\u76ee**\u7684\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6a21\u5757\u4e2d\u7684\u6570\u636e\u7ed3\u6784\u3002 \u5bf9\u4e0a\u9762\u8fd9\u6bb5\u6587\u5b57\u4e2d\u63d0\u5230\u7684\u201c \u7b26\u53f7**\u7684**\u5f15\u7528 \u201d\u7684\u6700\u597d\u4e86\u89e3\u662fmain.c\u4e2d\u8c03\u7528\u4e86\u5b9a\u4e49\u5728a.c\u4e2d\u7684sum\u51fd\u6570\u3002 \u91cd\u5b9a\u5411\u6761\u76ee \u5f53**\u6c47\u7f16\u5668**\u751f\u6210\u4e00\u4e2a**\u76ee\u6807\u6a21\u5757**\u65f6\uff0c\u5b83\u5e76\u4e0d\u77e5\u9053**\u6570\u636e**\u548c**\u4ee3\u7801**\u6700\u7ec8\u5c06\u5b58\u653e\u5728**\u5b58\u50a8\u5668**\u4e2d\u7684\u4ec0\u4e48\u4f4d\u7f6e\u3002\u5b83\u4e5f\u4e0d\u77e5\u9053\u8fd9\u4e2a\u6a21\u5757\u5f15\u7528\u7684\u4efb\u4f55\u5916\u90e8\u5b9a\u4e49\u7684**\u51fd\u6570**\u548c**\u5168\u5c40\u53d8\u91cf**\u3002\u6240\u4ee5\uff0c\u65e0\u8bba\u4f55\u65f6**\u6c47\u7f16\u5668**\u9047\u5230\u5bf9\u6700\u7ec8\u4f4d\u7f6e\u672a\u6307\u5b9a**\u76ee\u6807\u5f15\u7528\uff0c\u5b83\u5c31\u4f1a\u751f\u6210\u4e00\u4e2a**\u91cd\u5b9a\u4f4d\u6761\u76ee**\uff0c\u544a\u8bc9**\u94fe\u63a5\u5668**\u5728\u5c06**\u76ee\u6807\u6587\u4ef6**\u5408\u5e76**\u53ef\u6267\u884c\u6587\u4ef6**\u65f6\u5982\u4f55\u4fee\u6539\u8fd9\u4e2a**\u5f15\u7528**\u3002**\u4ee3\u7801\u91cd\u5b9a\u4f4d\u6761\u76ee**\u653e\u5728.rel.text\uff08**SHT_REL\u7c7b\u578b**\u7684\u8282\uff08section\uff09\uff09\u4e2d\u3002**\u5df2\u7ecf\u521d\u59cb\u5316\u6570\u636e\u7684\u91cd\u5b9a\u4f4d\u6761\u76ee**\u653e\u5728.rel.data(**SHT_REL\u7c7b\u578b\u7684\u8282\uff08section\uff09)\u4e2d\u3002 \u6570\u636e\u7ed3\u6784 \u200b \u7531\u4e8e\u6280\u672f\u539f\u56e0\uff0c\u6709\u4e24\u79cd\u7c7b\u578b\u7684\u91cd\u5b9a\u4f4d\u4fe1\u606f\uff0c\u7531\u4e24\u79cd\u7a0d\u6709\u4e0d\u540c\u7684\u6570\u636e\u7ed3\u6784\u8868\u793a\u3002\u7b2c\u4e00\u79cd\u7c7b\u578b\u79f0\u4e4b\u4e3a**\u666e\u901a\u91cd\u5b9a\u4f4d**\u3002 SHT_REL \u7c7b\u578b\u7684\u8282\uff08section\uff09\u4e2d\u7684**\u91cd\u5b9a\u4f4d\u9879**\u7531\u4ee5\u4e0b\u6570\u636e\u7ed3\u6784\u5b9a\u4e49\uff1a /*Relocation table entry without addend (in section of type SHT_REL). */ typedef struct { Elf32_Addr r_offset ; /* Address \u6307\u5b9a\u9700\u8981\u91cd\u5b9a\u4f4d\u7684\u9879\u7684\u4f4d\u7f6e*/ Elf32_Word r_info ; /* Relocation type and symbol index \u63d0\u4f9b\u4e86\u7b26\u53f7\u8868\u4e2d\u7684\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u540c\u65f6\u8fd8\u5305\u62ec\u91cd\u5b9a\u4f4d\u7c7b\u578b\u7684\u6709\u4e2a\u4fe1\u606f\u3002\u8fd9\u662f\u901a\u8fc7\u5c06\u503c\u5212\u5206\u4e3a\u4e24\u90e8\u5206\u6765\u8fbe\u5230\u7684\u3002\u8be5\u5b57\u6bb5\u7684\u7ed3\u6784\u5982\u4e0b\uff1a r_info == int symbol:24,type:8;*/ } Elf32_Rel ; \u53e6\u4e00\u79cd\u7c7b\u578b\uff0c\u79f0\u4e4b\u4e3a\u9700\u8981\u6dfb\u52a0\u5e38\u6570\u7684**\u91cd\u5b9a\u4f4d\u9879**\uff0c\u53ea\u51fa\u73b0\u5728 SHT_RELA \u7c7b\u578b\u7684\u8282\u4e2d\u3002\u6570\u636e\u7ed3\u6784\u5982\u4e0b\uff1a /* Relocation table entry with addend (insection of type SHT_RELA). */ typedef struct { Elf32_Addr r_offset ; /* Address */ Elf32_Word r_info ; /* Relocation type and symbol index */ Elf32_Sword r_addend ; /* Addend \u52a0\u6570\uff0c\u8ba1\u7b97\u91cd\u5b9a\u4f4d\u662f\uff0c\u5c06\u6839\u636e\u91cd\u5b9a\u4f4d\u7c7b\u578b\uff0c\u5bf9\u8be5\u503c\u8fdb\u884c\u4e0d\u540c\u7684\u5904\u7406\u3002*/ } Elf32_Rela ; \u91cd\u5b9a\u4f4d\u7c7b\u578b \u200b ELF \u5b9a\u4e49\u4e86\u5f88\u591a\u91cd\u5b9a\u4f4d\u7c7b\u578b\uff0c\u5bf9\u6bcf\u79cd\u652f\u6301\u7684\u4f53\u7cfb\u7ed3\u6784\uff0c\u90fd\u6709\u4e00\u4e2a\u72ec\u7acb\u7684\u96c6\u5408\u3002\u8fd9\u4e9b\u7c7b\u578b\u5927\u90e8\u5206\u7528\u4e8e\u751f\u6210**\u52a8\u6001**\u6216**\u4e0e\u88c5\u8f7d\u4f4d\u7f6e\u65e0\u5173\u7684\u4ee3\u7801**\u3002\u5728\u4e00\u4e9b\u5e73\u53f0\u4e0a\uff0c\u7279\u522b\u662f IA32 \u5e73\u53f0\uff0c\u8fd8\u5fc5\u987b\u5f25\u8865\u8bb8\u591a\u8bbe\u8ba1\u9519\u8bef\u548c\u5386\u53f2\u5305\u88b1\u3002\u5e78\u8fd0\u7684\u662f\uff0cLinux\u5185\u6838\u53ea\u5bf9\u6a21\u5757\u7684**\u91cd\u5b9a\u4f4d**\u611f\u5174\u8da3\uff0c\u56e0\u6b64\u7528\u4ee5\u4e0b\u4e24\u79cd\u91cd\u5b9a\u4f4d\u7c7b\u578b\u5c31\u53ef\u4ee5\u4e86\uff1a 1\uff09\u76f8\u5bf9\u91cd\u5b9a\u4f4d 2\uff09\u7edd\u5bf9\u91cd\u5b9a\u4f4d \u76f8\u5bf9\u91cd\u5b9a\u4f4d**\u751f\u6210\u7684**\u91cd\u5b9a\u4f4d\u8868\u9879**\u6307\u5411\u76f8\u5bf9\u4e8e**\u7a0b\u5e8f\u8ba1\u6570\u5668 \uff08 pc \uff0c\u4ea6\u5373\u6307\u4ee4\u6307\u9488\uff09\u6307\u5b9a\u7684**\u5185\u5b58\u5730\u5740**\uff0c\u5373**\u76f8\u5bf9\u91cd\u5b9a\u4f4d**\u662f\u76f8\u5bf9\u4e8e**\u7a0b\u5e8f\u8ba1\u6570\u5668**\u8fdb\u884c**\u91cd\u5b9a\u4f4d**\u3002\u8fd9\u4e9b\u4e3b\u8981\u7528\u4e8e**\u5b50\u4f8b\u7a0b**\u8c03\u7528\u3002\u53e6\u4e00\u79cd**\u91cd\u5b9a\u4f4d**\u751f\u6210**\u7edd\u5bf9\u5730\u5740**\uff0c\u4ece\u540d\u5b57\u5c31\u80fd\u770b\u51fa\u3002\u901a\u5e38\uff0c\u8fd9\u79cd\u91cd\u5b9a\u4f4d\u9879\u6307\u5411\u5185\u5b58\u4e2d\u5728\u7f16\u8bd1\u65f6\u5c31\u5df2\u77e5\u7684\u6570\u636e\uff0c\u4f8b\u5982**\u5b57\u7b26\u4e32\u5e38\u6570**\u3002 \u5728 IA32 \u7cfb\u7edf\u4e0a\uff0c\u548c\u4e24\u79cd\u91cd\u5b9a\u4f4d\u7c7b\u578b\u7531\u5e38\u6570 R_386_PC_32 (\u76f8\u5bf9\u91cd\u5b9a\u4f4d)\u548c R_386_32 (\u7edd\u5bf9\u91cd\u5b9a\u4f4d)\u8868\u793a\u3002\u91cd\u5b9a\u4f4d\u7ed3\u679c\u8ba1\u7b97\u5982\u4e0b\uff1a R_386_32 : Result = S + A R_386_PC_32 : Result = S - P + A A \u4ee3\u8868 \u52a0\u6570\u503c \uff0c\u5728 IA32 \u4f53\u7cfb\u7ed3\u6784\u4e0a\uff0c\u7531\u91cd\u5b9a\u4f4d\u4f4d\u7f6e\u5904\u7684\u5185\u5b58\u5185\u5bb9\u9690\u5f0f\u63d0\u4f9b(\u4e00\u822c\u4e3a**\u64cd\u4f5c\u7801**\u540e\u9762\u7684\u6570\u503c)\u3002 S \u662f**\u7b26\u53f7\u8868**\u4e2d\u4fdd\u5b58\u7684\u7b26\u53f7\u7684\u503c\uff0c\u800c P \u4ee3\u8868\u91cd\u5b9a\u4f4d\u7684**\u4f4d\u7f6e\u504f\u79fb\u91cf**\uff0c\u6362\u8a00\u4e4b\uff0c\u5373\u7b97\u51fa\u7684\u6570\u636e\u5199\u5165\u5230\u4e8c\u8fdb\u5236\u6587\u4ef6\u4e2d\u7684**\u4f4d\u7f6e\u504f\u79fb\u91cf**(\u4fee\u6539\u5904\u7684\u8fd0\u884c\u65f6\u5730\u5740\u6216\u8005\u504f\u79fb\uff0c\u5bf9\u4e8e**\u76ee\u6807\u6587\u4ef6** P \u4e3a\u4fee\u8ba2\u5904**\u6bb5**\u5185\u7684\u504f\u79fb\uff0c\u5bf9**\u53ef\u6267\u884c\u6587\u4ef6**P\u4e3a**\u8fd0\u884c\u65f6\u7684\u5730\u5740**)\u3002\u5982\u679c\u52a0\u6570\u503c\u4e3a0\uff0c\u90a3\u4e48**\u7edd\u5bf9\u91cd\u5b9a\u4f4d**\u53ea\u662f\u5c06**\u7b26\u53f7\u8868**\u4e2d\u7684\u7b26\u53f7\u7684\u503c\u63d2\u5165\u5728**\u91cd\u5b9a\u4f4d\u4f4d\u7f6e**\u3002\u4f46\u5728**\u76f8\u5bf9\u91cd\u5b9a\u4f4d**\u4e2d\uff0c\u9700\u8981\u8ba1\u7b97**\u7b26\u53f7\u4f4d\u7f6e**\u548c**\u91cd\u5b9a\u4f4d\u4f4d\u7f6e**\u4e4b\u95f4\u7684\u5dee\u503c\u3002\u6362\u8a00\u4e4b\uff0c\u9700\u8981\u901a\u8fc7\u8ba1\u7b97\u786e\u5b9a\u7b26\u53f7\u4e0e\u91cd\u5b9a\u4f4d\u4f4d\u7f6e\u76f8\u8ddd\u591a\u5c11\u5b57\u8282\u3002 \u5728\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e0b\uff0c\u90fd\u4f1a\u52a0\u4e0a\u52a0\u6570\u503c\uff0c\u56e0\u800c\u4f7f\u5f97\u7ed3\u679c\u4ea7\u751f\u4e00\u4e2a**\u7ebf\u6027\u4f4d\u79fb**\u3002 \u9996\u5148\u6211\u4eec\u660e\u786e\u7684\u662f**\u91cd\u5b9a\u5411**\u53d1\u751f\u5728**\u94fe\u63a5**\u7684\u65f6\u5019\uff0c\u5f53\u591a\u4e2a\u8f93\u5165\u6700\u7ec8\u94fe\u63a5\u6210\u4e00\u4e2a**\u76ee\u6807\u6587\u4ef6**\u7684\u65f6\u5019\uff0c\u5f53**\u7b26\u53f7**\u89e3\u6790\u5b8c\u6210\u4e4b\u540e\u3002 \u5728\u6b64\u4f8b\u5b50\u4e2d\uff0c a.c \u548c b.c \u6ca1\u6709\u5916\u90e8\u5f15\u7528\uff0c\u6240\u4ee5\u5728 .o \u6587\u4ef6\u4e2d\u4e0d\u5b58\u5728\u91cd\u5b9a\u4f4d\u8868\u9879\uff0c\u53ea\u6709 main.o \u5b58\u5728\uff0c\u5982\u56fe\uff1a \u67e5\u770b main.o \u7684\u91cd\u5b9a\u4f4d\u8868\uff1a [ dk@dk rel ] $ readelf -r main.o \u91cd\u5b9a\u4f4d\u8282 '.rela.text' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x300 \u542b\u6709 8 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000011 000900000002 R_X86_64_PC32 0000000000000000 a - 4 000000000022 000b00000002 R_X86_64_PC32 0000000000000000 sum - 4 000000000029 00050000000a R_X86_64_32 0000000000000000 .rodata + 0 000000000033 000c00000002 R_X86_64_PC32 0000000000000000 printf - 4 000000000039 000900000002 R_X86_64_PC32 0000000000000000 a - 4 00000000004a 000d00000002 R_X86_64_PC32 0000000000000000 mul - 4 000000000051 00050000000a R_X86_64_32 0000000000000000 .rodata + 8 00000000005b 000c00000002 R_X86_64_PC32 0000000000000000 printf - 4 \u91cd\u5b9a\u4f4d\u8282 '.rela.eh_frame' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x3c0 \u542b\u6709 1 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 \u67e5\u770b main.o \u7684\u7b26\u53f7\u8868\uff1a [ dk@dk rel ] $ readelf -s main.o Symbol table '.symtab' contains 14 entries: Num: Value Size Type Bind Vis Ndx Name 0 : 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1 : 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2 : 0000000000000000 0 SECTION LOCAL DEFAULT 1 3 : 0000000000000000 0 SECTION LOCAL DEFAULT 3 4 : 0000000000000000 0 SECTION LOCAL DEFAULT 4 5 : 0000000000000000 0 SECTION LOCAL DEFAULT 5 6 : 0000000000000000 0 SECTION LOCAL DEFAULT 7 7 : 0000000000000000 0 SECTION LOCAL DEFAULT 8 8 : 0000000000000000 0 SECTION LOCAL DEFAULT 6 9 : 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 a 10 : 0000000000000000 102 FUNC GLOBAL DEFAULT 1 main 11 : 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sum 12 : 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf 13 : 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND mul \u4ece main.c \u6e90\u6587\u4ef6\u4e5f\u4e0d\u96be\u770b\u51fa\uff0c\u5b83\u5f15\u7528\u4e86\u5916\u9762 sum \u548c mul \u7b26\u53f7\uff0c\u5e76\u4e14\u5f15\u7528\u4e86\u4e00\u4e2a\u5168\u5c40 a \u7b26\u53f7\u3002\u5e76\u4e14\u4ece\u4e0a\u56fe\u4e5f\u53ef\u4ee5\u770b\u51fa\u3002\u5e76\u4e14a\u7684**\u91cd\u5b9a\u4f4d\u7c7b\u578b**\u4e3a**\u76f8\u5bf9\u91cd\u5b9a\u4f4d**\u3002 \u5e76\u4e14\u53ef\u4ee5\u5f97\u5230\uff1a a\u7b2c\u4e00\u5904 r_offset \uff1a 0x11 \u91cd\u5b9a\u4f4d\u7684\u5b57\u8282\u5904 \u5e76\u4e14\u4ece\u7b2c\u4e8c\u5e45\u56fe\u53ef\u4ee5\u5f97\u77e5 a \u7684\u5927\u5c0f\u4e3a4\u4e2a\u5b57\u8282 a\u7b2c\u4e8c\u5904 r_offset \uff1a 0x3f sumr_offset \uff1a 0x29 mulr_offset \uff1a 0x4e \u8ba1\u7b97 a \u7684\u91cd\u5b9a\u4f4d\u540e\u7684\u5730\u5740\uff1a\u6839\u636e\u516c\u5f0f S+A S \u4e3a**\u76ee\u6807\u6587\u4ef6\u7b26\u53f7\u8868**\u4e2d\u7684\u5bf9\u5e94\u7684\u5730\u5740\uff08\u4e3a\u4ec0\u4e48\u4e0d\u662f .o \u6587\u4ef6\u5462\uff0c\u56e0\u4e3a .o \u6587\u4ef6\u7684\u7b26\u53f7\u8868\u4e2d\u7684\u5730\u5740\u90fd\u662f\u91cd\u5b9a\u4f4dREL\u7c7b\u578b\uff0c\u90fd\u4e3a0\uff09\uff1a \u67e5\u770b main \u7684\u7b26\u53f7\u8868\uff0c\u5176\u4e2d\u9700\u8981\u6ce8\u610f\u7684\u662f\u5168\u5c40\u53d8\u91cf a \u7684\u503c\uff0c\u56e0\u4e3a\u4e0b\u9762\u5c06\u4ee5a\u4e3a\u4f8b\u6765\u8bf4\u660e**\u91cd\u5b9a\u4f4d**\u8fc7\u7a0b\uff0c\u4ece\u8f93\u51fa\u7ed3\u679c\u53ef\u4ee5\u770b\u51fa\uff0c\u53d8\u91cf a \u7684\u503c\u4e3a OX601034 [ dk@dk rel ] $ readelf -s main | grep a Symbol table '.dynsym' contains 4 entries: Num: Value Size Type Bind Vis Ndx Name 2 : 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 ( 2 ) 3 : 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ Symbol table '.symtab' contains 70 entries: Num: Value Size Type Bind Vis Ndx Name 17 : 00000000004006a8 0 SECTION LOCAL DEFAULT 17 30 : 00000000004004a0 0 FUNC LOCAL DEFAULT 13 register_tm_clones 31 : 00000000004004e0 0 FUNC LOCAL DEFAULT 13 __do_global_dtors_aux 33 : 0000000000600e18 0 OBJECT LOCAL DEFAULT 19 __do_global_dtors_aux_fin 34 : 0000000000400500 0 FUNC LOCAL DEFAULT 13 frame_dummy 35 : 0000000000600e10 0 OBJECT LOCAL DEFAULT 18 __frame_dummy_init_array_ 36 : 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 38 : 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 43 : 0000000000600e18 0 NOTYPE LOCAL DEFAULT 18 __init_array_end 45 : 0000000000600e10 0 NOTYPE LOCAL DEFAULT 18 __init_array_start 48 : 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab 49 : 0000000000601030 0 NOTYPE WEAK DEFAULT 24 data_start 50 : 0000000000601038 0 NOTYPE GLOBAL DEFAULT 24 _edata 53 : 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_ 54 : 0000000000601030 0 NOTYPE GLOBAL DEFAULT 24 __data_start 55 : 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 56 : 0000000000400648 0 OBJECT GLOBAL HIDDEN 15 __dso_handle 61 : 0000000000400440 0 FUNC GLOBAL DEFAULT 13 _start 62 : 0000000000601034 4 OBJECT GLOBAL DEFAULT 24 a 63 : 0000000000601038 0 NOTYPE GLOBAL DEFAULT 25 __bss_start 64 : 0000000000400554 102 FUNC GLOBAL DEFAULT 13 main 66 : 0000000000000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses 68 : 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable \u53ef\u4ee5\u5f97\u5230 S(a) =0x601034 \uff0c\u63a5\u4e0b\u6765\u8981\u786e\u5b9a\u52a0\u503cA\uff0c\u8fd9\u8981\u770b main.o \u7684\u6c47\u7f16\u4ee3\u7801\u4e86\uff0c\u5229\u7528 objdump \u6765\u67e5\u770b\u8be5.text\u8282\u7684\u6c47\u7f16\u4ee3\u7801\uff1a [dk@dk rel]$ objdump -d main.o main.o\uff1a \u6587\u4ef6\u683c\u5f0f elf64-x86-64 Disassembly of section .text: 0000000000000000 <main>: 0: 55 push %rbp 1: 48 89 e5 mov %rsp,%rbp 4: 48 83 ec 10 sub $0x10,%rsp 8: c7 45 fc 0c 00 00 00 movl $0xc,-0x4(%rbp) f: 8b 05 00 00 00 00 mov 0x0(%rip),%eax # 15 <main+0x15> 15: 8b 55 fc mov -0x4(%rbp),%edx 18: 89 d6 mov %edx,%esi 1a: 89 c7 mov %eax,%edi 1c: b8 00 00 00 00 mov $0x0,%eax 21: e8 00 00 00 00 callq 26 <main+0x26> 26: 89 c6 mov %eax,%esi 28: bf 00 00 00 00 mov $0x0,%edi 2d: b8 00 00 00 00 mov $0x0,%eax 32: e8 00 00 00 00 callq 37 <main+0x37> 37: 8b 05 00 00 00 00 mov 0x0(%rip),%eax # 3d <main+0x3d> 3d: 8b 55 fc mov -0x4(%rbp),%edx 40: 89 d6 mov %edx,%esi 42: 89 c7 mov %eax,%edi 44: b8 00 00 00 00 mov $0x0,%eax 49: e8 00 00 00 00 callq 4e <main+0x4e> 4e: 89 c6 mov %eax,%esi 50: bf 00 00 00 00 mov $0x0,%edi 55: b8 00 00 00 00 mov $0x0,%eax 5a: e8 00 00 00 00 callq 5f <main+0x5f> 5f: b8 00 00 00 00 mov $0x0,%eax 64: c9 leaveq 65: c3 retq \u8fd9\u6837\u6765\u8bfb\u8fd9\u4e9b\u4ee3\u7801\uff1a 1\uff09\u5de6\u8fb9\u4e24\u680f\u4e2d\u6700\u5de6\u9762\u4e00\u680f\u662f\u4e0a\u9762\u6240\u6709**\u673a\u5668\u6307\u4ee4**\u7684\u5b57\u8282\u6570\uff0816\u8fdb\u5236\uff09\uff0c\u7d27\u63a5\u7740\u5176\u540e\u7684\u662f**\u673a\u5668\u4ee3\u7801**\uff08\u5341\u516d\u8fdb\u5236\u5f62\u5f0f\uff09\u3002\u5176\u5b9e\u771f\u6b63\u7684\u4e8c\u8fdb\u5236\u4ee3\u7801\u662f\u8fd9\u6837\u7684\uff08\u5341\u516d\u8fdb\u5236\uff09\uff0c\u524d\u4e24\u884c 8d 4c 24 04 83 e4 f0 \uff0c\u5de5\u5177\u4e3a\u4e86\u65b9\u4fbf\u9605\u8bfb\u3002 \u6211\u5728\u5de5\u5177\u7684\u57fa\u7840\u4e0a\u4e3a\u4e86\u65b9\u4fbf\u8bf4\u660e\u8fd9\u4e24\u680f\uff0c\u53ea\u63d0\u53d6\u4e86\u524d\u9762\u4e24\u680f\uff08\u597d\u6bd4\u4e00\u4e2a\u5927\u7684\u5b57\u8282\u6570\u7ec4\u4ece\u96f6\u5f00\u59cb\uff09\u3002 0 : 8d 4c 24 04 \u4ee5\u524d\u662f0\u4e2a\u5b57\u8282\uff0c\u4e0b\u6807\u662f\u4ece0\u5f00\u59cb\uff0c\u5176\u4e2d8d\u662f\u64cd\u4f5c\u7801 4 : 83 e4 f0 \u4e0a\u9762\u4e00\u5171\u56db\u4e2a\u5b57\u8282\uff0c\u6b64\u884c\u5c0f\u6807\u4e5f\u662f\u4ece4\u5f00\u59cb\uff0c83\u662f\u64cd\u4f5c\u7801 2\uff09\u6700\u540e\u4e00\u680f\u662f\u6c47\u7f16\u6307\u4ee4 lea 0x4(%esp),%ecx and $0xfffffff0,%esp \u5728\u4e0a\u9762 objdump -d main.o \u4e2d\uff0c\u6211\u4eec\u770b\u7b2c 0x11 \u5b57\u8282\u5f00\u59cb\u7684\u56db\u4e2a\u5b57\u8282\u7684\u5185\u5bb9\u7686\u4e3a0\u3002\u5219\u6839\u636e\u516c\u5f0f R_386_PC_32:Result=S-P+A \uff0c\u4e5f\u5c31\u662f**\u76ee\u6807\u6587\u4ef6**\u7684 11 \u540e\u9762\u7684\u540e4\u4e2a\u5b57\u8282\u8981\u88ab\u66ff\u6362\u4e3a\u8be5\u503c\u3002 \u6b64\u5904\u662f\u5982\u4f55\u8ba1\u7b97\u51fa\u91cd\u5b9a\u5411\u503c\u7684\u5462\uff1f\uff1f \u4e0b\u9762\u662f\u67e5\u770b main \u4e2dmain\u51fd\u6570\u7684\u6c47\u7f16\u4ee3\u7801\uff1a [ dk@dk rel ] $ objdump -d main >> assemb \u8f93\u51fa\u7ed3\u679c\u5982\u4e0b\uff1a 0000000000400554 <main>: 400554: 55 push %rbp 400555: 48 89 e5 mov %rsp,%rbp 400558: 48 83 ec 10 sub $0x10,%rsp 40055c: c7 45 fc 0c 00 00 00 movl $0xc,-0x4(%rbp) 400563: 8b 05 cb 0a 20 00 mov 0x200acb(%rip),%eax # 601034 <a> 400569: 8b 55 fc mov -0x4(%rbp),%edx 40056c: 89 d6 mov %edx,%esi 40056e: 89 c7 mov %eax,%edi 400570: b8 00 00 00 00 mov $0x0,%eax 400575: e8 b3 ff ff ff callq 40052d <sum> 40057a: 89 c6 mov %eax,%esi 40057c: bf 50 06 40 00 mov $0x400650,%edi 400581: b8 00 00 00 00 mov $0x0,%eax 400586: e8 85 fe ff ff callq 400410 <printf@plt> 40058b: 8b 05 a3 0a 20 00 mov 0x200aa3(%rip),%eax # 601034 <a> 400591: 8b 55 fc mov -0x4(%rbp),%edx 400594: 89 d6 mov %edx,%esi 400596: 89 c7 mov %eax,%edi 400598: b8 00 00 00 00 mov $0x0,%eax 40059d: e8 9f ff ff ff callq 400541 <mul> 4005a2: 89 c6 mov %eax,%esi 4005a4: bf 58 06 40 00 mov $0x400658,%edi 4005a9: b8 00 00 00 00 mov $0x0,%eax 4005ae: e8 5d fe ff ff callq 400410 <printf@plt> 4005b3: b8 00 00 00 00 mov $0x0,%eax 4005b8: c9 leaveq 4005b9: c3 retq 4005ba: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) \u4ece\u4e0a\u9762\u7ed3\u679c\u53ef\u4ee5\u770b\u51fa\uff0c\u5728\u8fdb\u884c\u91cd\u5b9a\u5411\u7684\u4f4d\u7f6e\uff0c objdump \u7a0b\u5e8f\u5df2\u7ecf\u8fdb\u884c\u4e86\u6807\u6ce8\u3002","title":"[\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6](https://blog.csdn.net/ylcangel/article/details/18188921)"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/relocatable-file/#_1","text":"\u672c\u6587\u4f7f\u7528\u7684\u793a\u4f8b\u4ee3\u7801\u5982\u4e0b\uff1a \u7a0b\u5e8f\u4ee3\u7801\u5982\u4e0b\uff1a a.c int sum ( int a , int b ) { return a + b ; } b.c int mul ( int a , int b ) { return a * b ; } main.c #include <stdio.h> int a = 12 ; int main () { int b = 12 ; printf ( \"a+b=%d \\n \" , sum ( a , b )); printf ( \"a*b=%d \\n \" , mul ( a , b )); return 0 ; }","title":"\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/relocatable-file/#_2","text":"\u91cd\u5b9a\u4f4d**\u662f\u5c06EFL\u6587\u4ef6\u4e2d\u7684**\u672a\u5b9a\u4e49\u7b26\u53f7 \uff08\u5305\u62ec\u51fd\u6570\u548c\u53d8\u91cf\uff09\u5173\u8054\u5230**\u6709\u6548\u503c**\u7684\u5904\u7406\u8fc7\u7a0b\u3002\u5728 main.o \u4e2d\uff0c\u8fd9\u610f\u5473\u7740\u5bf9 printf \u548c puts \u7684\u672a\u5b9a\u4e49\u7684\u5f15\u7528\u5fc5\u987b\u66ff\u6362\u4e3a\u8be5**\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u4e2d\u9002\u5f53\u7684**\u673a\u5668\u4ee3\u7801**\u6240\u5728\u7684**\u5730\u5740**\u3002\u5728\u76ee\u6807\u4e2d\u7528\u5230\u7684\u76f8\u5173**\u7b26\u53f7**\u4e4b\u5904\uff0c\u90fd\u5fc5\u987b\u66ff\u6362\u3002 \u5bf9*\u7528\u6237\u7a7a\u95f4* \u7a0b\u5e8f\u7b26\u53f7**\u7684\u66ff\u6362\uff0c**\u5185\u6838**\u5e76\u4e0d\u6d89\u53ca\u5176\u4e2d\uff0c\u56e0\u4e3a\u6240\u6709\u7684\u66ff\u6362\u64cd\u4f5c\u90fd\u662f\u7531**\u5916\u90e8\u5de5\u5177**\u5b8c\u6210\u7684\u3002\u5bf9\u5185\u6838\u6a21\u5757\u6765\u8bf4\uff0c\u60c5\u51b5\u6709\u6240\u4e0d\u540c\uff0c\u56e0\u4e3a\u5185\u6838\u6240\u6536\u5230\u7684**\u6a21\u5757\u88f8\u6570\u636e \uff0c\u4e0e\u5176\u5b58\u50a8\u5728\u4e8c\u8fdb\u5236\u6587\u4ef6\u4e2d\u7684\u5f62\u5f0f\u5b8c\u5168\u76f8\u540c\uff0c\u5185\u6838\u672c\u8eab\u9700\u8981\u8d1f\u8d23\u91cd\u5b9a\u4f4d\u64cd\u4f5c\u3002 \u5728\u6bcf\u4e2a**\u76ee\u6807\u6587\u4ef6**\u4e2d\uff0c\u90fd\u6709\u4e00\u4e2a\u4e13\u95e8\u7684\u8868\uff0c\u5305\u542b\u4e86**\u91cd\u5b9a\u4f4d\u9879**\uff0c\u6807\u8bc6\u4e86\u9700\u8981\u8fdb\u884c\u91cd\u5b9a\u4f4d\u7684\u3002\u6bcf\u4e2a**\u8868\u9879**\u90fd\u5305\u542b\u4e0b\u5217\u4fe1\u606f\uff1a \u200b 1\uff09\u4e00\u4e2a**\u504f\u79fb\u91cf**\uff0c\u6307\u5b9a\u4e86\u4fee\u6539\u7684\u9879\u7684\u4f4d\u7f6e \u200b 2\uff09\u5bf9**\u7b26\u53f7**\u7684**\u5f15\u7528**\uff08\u7b26\u53f7\u8868\u7684**\u7d22\u5f15**\uff09\uff0c\u63d0\u4f9b\u4e86\u9700\u8981\u63d2\u5165\u5230**\u91cd\u5b9a\u4f4d\u4f4d\u7f6e**\u7684\u6570\u636e","title":"\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/relocatable-file/#_3","text":"\u200b 1\uff09\u91cd\u5b9a\u4f4d \u8282(section)\u548c\u7b26\u53f7\u5b9a\u4e49\u3002 \u200b \u94fe\u63a5\u5668**\u5c06\u6240\u6709**\u76f8\u540c\u7c7b\u578b\u7684\u8282**\u5408\u5e76\u4e3a\u540c\u4e00\u7c7b\u578b\u7684\u65b0\u7684**\u805a\u5408\u8282 \u3002\u4f8b\u5982\u6765\u81ea\u8f93\u5165\u6a21\u5757\u7684 .data \u8282\u5168\u90e8\u5408\u5e76\u6210\u4e00\u4e2a\u8282\uff0c\u8fd9\u4e2a\u8282\u6210\u4e3a\u8f93\u51fa\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684 .data \u8282\u3002\u7136\u540e**\u94fe\u63a5\u5668**\u5c06\u8fd0\u884c\u65f6**\u5b58\u50a8\u5668\u5730\u5740**\u8d4b\u7ed9\u65b0\u7684**\u805a\u5408\u8282**\uff0c\u8d4b\u7ed9\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6bcf\u4e2a\u8282\uff0c\u4ee5\u53ca\u8d4b\u7ed9\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6bcf\u4e2a**\u7b26\u53f7**\u3002\u5f53\u8fd9\u4e00\u6b65\u5b8c\u6210\u65f6\uff0c\u7a0b\u5e8f\u4e2d\u7684\u6bcf\u4e2a**\u6307\u4ee4**\u548c**\u5168\u5c40\u53d8\u91cf**\u90fd\u6709\u552f\u4e00\u7684**\u8fd0\u884c\u65f6\u5b58\u50a8\u5668\u5730\u5740**\u4e86\u3002 \u200b 2\uff09\u91cd\u5b9a\u4f4d \u8282(section)\u4e2d\u7684\u7b26\u53f7\u5f15\u7528\u3002 \u200b \u5728\u8fd9\u4e00\u6b65\u4e2d\uff0c\u94fe\u63a5\u5668\u4fee\u6539**\u4ee3\u7801\u8282**\u548c**\u6570\u636e\u8282**\u4e2d\u5bf9\u6bcf\u4e2a**\u7b26\u53f7**\u7684**\u5f15\u7528**\uff0c\u4f7f\u5f97\u4ed6\u4eec\u6307\u5411**\u6b63\u786e\u7684\u8fd0\u884c\u65f6\u5730\u5740**\u3002\u4e3a\u4e86\u6267\u884c\u8fd9\u4e00\u6b65\uff0c\u94fe\u63a5\u5668\u4f9d\u8d56\u4e8e\u79f0\u4e4b\u4e3a**\u91cd\u5b9a\u4f4d\u6761\u76ee**\u7684\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6a21\u5757\u4e2d\u7684\u6570\u636e\u7ed3\u6784\u3002 \u5bf9\u4e0a\u9762\u8fd9\u6bb5\u6587\u5b57\u4e2d\u63d0\u5230\u7684\u201c \u7b26\u53f7**\u7684**\u5f15\u7528 \u201d\u7684\u6700\u597d\u4e86\u89e3\u662fmain.c\u4e2d\u8c03\u7528\u4e86\u5b9a\u4e49\u5728a.c\u4e2d\u7684sum\u51fd\u6570\u3002","title":"\u91cd\u5b9a\u4f4d\u6b65\u9aa4"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/relocatable-file/#_4","text":"\u5f53**\u6c47\u7f16\u5668**\u751f\u6210\u4e00\u4e2a**\u76ee\u6807\u6a21\u5757**\u65f6\uff0c\u5b83\u5e76\u4e0d\u77e5\u9053**\u6570\u636e**\u548c**\u4ee3\u7801**\u6700\u7ec8\u5c06\u5b58\u653e\u5728**\u5b58\u50a8\u5668**\u4e2d\u7684\u4ec0\u4e48\u4f4d\u7f6e\u3002\u5b83\u4e5f\u4e0d\u77e5\u9053\u8fd9\u4e2a\u6a21\u5757\u5f15\u7528\u7684\u4efb\u4f55\u5916\u90e8\u5b9a\u4e49\u7684**\u51fd\u6570**\u548c**\u5168\u5c40\u53d8\u91cf**\u3002\u6240\u4ee5\uff0c\u65e0\u8bba\u4f55\u65f6**\u6c47\u7f16\u5668**\u9047\u5230\u5bf9\u6700\u7ec8\u4f4d\u7f6e\u672a\u6307\u5b9a**\u76ee\u6807\u5f15\u7528\uff0c\u5b83\u5c31\u4f1a\u751f\u6210\u4e00\u4e2a**\u91cd\u5b9a\u4f4d\u6761\u76ee**\uff0c\u544a\u8bc9**\u94fe\u63a5\u5668**\u5728\u5c06**\u76ee\u6807\u6587\u4ef6**\u5408\u5e76**\u53ef\u6267\u884c\u6587\u4ef6**\u65f6\u5982\u4f55\u4fee\u6539\u8fd9\u4e2a**\u5f15\u7528**\u3002**\u4ee3\u7801\u91cd\u5b9a\u4f4d\u6761\u76ee**\u653e\u5728.rel.text\uff08**SHT_REL\u7c7b\u578b**\u7684\u8282\uff08section\uff09\uff09\u4e2d\u3002**\u5df2\u7ecf\u521d\u59cb\u5316\u6570\u636e\u7684\u91cd\u5b9a\u4f4d\u6761\u76ee**\u653e\u5728.rel.data(**SHT_REL\u7c7b\u578b\u7684\u8282\uff08section\uff09)\u4e2d\u3002","title":"\u91cd\u5b9a\u5411\u6761\u76ee"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/relocatable-file/#_5","text":"\u200b \u7531\u4e8e\u6280\u672f\u539f\u56e0\uff0c\u6709\u4e24\u79cd\u7c7b\u578b\u7684\u91cd\u5b9a\u4f4d\u4fe1\u606f\uff0c\u7531\u4e24\u79cd\u7a0d\u6709\u4e0d\u540c\u7684\u6570\u636e\u7ed3\u6784\u8868\u793a\u3002\u7b2c\u4e00\u79cd\u7c7b\u578b\u79f0\u4e4b\u4e3a**\u666e\u901a\u91cd\u5b9a\u4f4d**\u3002 SHT_REL \u7c7b\u578b\u7684\u8282\uff08section\uff09\u4e2d\u7684**\u91cd\u5b9a\u4f4d\u9879**\u7531\u4ee5\u4e0b\u6570\u636e\u7ed3\u6784\u5b9a\u4e49\uff1a /*Relocation table entry without addend (in section of type SHT_REL). */ typedef struct { Elf32_Addr r_offset ; /* Address \u6307\u5b9a\u9700\u8981\u91cd\u5b9a\u4f4d\u7684\u9879\u7684\u4f4d\u7f6e*/ Elf32_Word r_info ; /* Relocation type and symbol index \u63d0\u4f9b\u4e86\u7b26\u53f7\u8868\u4e2d\u7684\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u540c\u65f6\u8fd8\u5305\u62ec\u91cd\u5b9a\u4f4d\u7c7b\u578b\u7684\u6709\u4e2a\u4fe1\u606f\u3002\u8fd9\u662f\u901a\u8fc7\u5c06\u503c\u5212\u5206\u4e3a\u4e24\u90e8\u5206\u6765\u8fbe\u5230\u7684\u3002\u8be5\u5b57\u6bb5\u7684\u7ed3\u6784\u5982\u4e0b\uff1a r_info == int symbol:24,type:8;*/ } Elf32_Rel ; \u53e6\u4e00\u79cd\u7c7b\u578b\uff0c\u79f0\u4e4b\u4e3a\u9700\u8981\u6dfb\u52a0\u5e38\u6570\u7684**\u91cd\u5b9a\u4f4d\u9879**\uff0c\u53ea\u51fa\u73b0\u5728 SHT_RELA \u7c7b\u578b\u7684\u8282\u4e2d\u3002\u6570\u636e\u7ed3\u6784\u5982\u4e0b\uff1a /* Relocation table entry with addend (insection of type SHT_RELA). */ typedef struct { Elf32_Addr r_offset ; /* Address */ Elf32_Word r_info ; /* Relocation type and symbol index */ Elf32_Sword r_addend ; /* Addend \u52a0\u6570\uff0c\u8ba1\u7b97\u91cd\u5b9a\u4f4d\u662f\uff0c\u5c06\u6839\u636e\u91cd\u5b9a\u4f4d\u7c7b\u578b\uff0c\u5bf9\u8be5\u503c\u8fdb\u884c\u4e0d\u540c\u7684\u5904\u7406\u3002*/ } Elf32_Rela ;","title":"\u6570\u636e\u7ed3\u6784"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/relocatable-file/#_6","text":"\u200b ELF \u5b9a\u4e49\u4e86\u5f88\u591a\u91cd\u5b9a\u4f4d\u7c7b\u578b\uff0c\u5bf9\u6bcf\u79cd\u652f\u6301\u7684\u4f53\u7cfb\u7ed3\u6784\uff0c\u90fd\u6709\u4e00\u4e2a\u72ec\u7acb\u7684\u96c6\u5408\u3002\u8fd9\u4e9b\u7c7b\u578b\u5927\u90e8\u5206\u7528\u4e8e\u751f\u6210**\u52a8\u6001**\u6216**\u4e0e\u88c5\u8f7d\u4f4d\u7f6e\u65e0\u5173\u7684\u4ee3\u7801**\u3002\u5728\u4e00\u4e9b\u5e73\u53f0\u4e0a\uff0c\u7279\u522b\u662f IA32 \u5e73\u53f0\uff0c\u8fd8\u5fc5\u987b\u5f25\u8865\u8bb8\u591a\u8bbe\u8ba1\u9519\u8bef\u548c\u5386\u53f2\u5305\u88b1\u3002\u5e78\u8fd0\u7684\u662f\uff0cLinux\u5185\u6838\u53ea\u5bf9\u6a21\u5757\u7684**\u91cd\u5b9a\u4f4d**\u611f\u5174\u8da3\uff0c\u56e0\u6b64\u7528\u4ee5\u4e0b\u4e24\u79cd\u91cd\u5b9a\u4f4d\u7c7b\u578b\u5c31\u53ef\u4ee5\u4e86\uff1a 1\uff09\u76f8\u5bf9\u91cd\u5b9a\u4f4d 2\uff09\u7edd\u5bf9\u91cd\u5b9a\u4f4d \u76f8\u5bf9\u91cd\u5b9a\u4f4d**\u751f\u6210\u7684**\u91cd\u5b9a\u4f4d\u8868\u9879**\u6307\u5411\u76f8\u5bf9\u4e8e**\u7a0b\u5e8f\u8ba1\u6570\u5668 \uff08 pc \uff0c\u4ea6\u5373\u6307\u4ee4\u6307\u9488\uff09\u6307\u5b9a\u7684**\u5185\u5b58\u5730\u5740**\uff0c\u5373**\u76f8\u5bf9\u91cd\u5b9a\u4f4d**\u662f\u76f8\u5bf9\u4e8e**\u7a0b\u5e8f\u8ba1\u6570\u5668**\u8fdb\u884c**\u91cd\u5b9a\u4f4d**\u3002\u8fd9\u4e9b\u4e3b\u8981\u7528\u4e8e**\u5b50\u4f8b\u7a0b**\u8c03\u7528\u3002\u53e6\u4e00\u79cd**\u91cd\u5b9a\u4f4d**\u751f\u6210**\u7edd\u5bf9\u5730\u5740**\uff0c\u4ece\u540d\u5b57\u5c31\u80fd\u770b\u51fa\u3002\u901a\u5e38\uff0c\u8fd9\u79cd\u91cd\u5b9a\u4f4d\u9879\u6307\u5411\u5185\u5b58\u4e2d\u5728\u7f16\u8bd1\u65f6\u5c31\u5df2\u77e5\u7684\u6570\u636e\uff0c\u4f8b\u5982**\u5b57\u7b26\u4e32\u5e38\u6570**\u3002 \u5728 IA32 \u7cfb\u7edf\u4e0a\uff0c\u548c\u4e24\u79cd\u91cd\u5b9a\u4f4d\u7c7b\u578b\u7531\u5e38\u6570 R_386_PC_32 (\u76f8\u5bf9\u91cd\u5b9a\u4f4d)\u548c R_386_32 (\u7edd\u5bf9\u91cd\u5b9a\u4f4d)\u8868\u793a\u3002\u91cd\u5b9a\u4f4d\u7ed3\u679c\u8ba1\u7b97\u5982\u4e0b\uff1a R_386_32 : Result = S + A R_386_PC_32 : Result = S - P + A A \u4ee3\u8868 \u52a0\u6570\u503c \uff0c\u5728 IA32 \u4f53\u7cfb\u7ed3\u6784\u4e0a\uff0c\u7531\u91cd\u5b9a\u4f4d\u4f4d\u7f6e\u5904\u7684\u5185\u5b58\u5185\u5bb9\u9690\u5f0f\u63d0\u4f9b(\u4e00\u822c\u4e3a**\u64cd\u4f5c\u7801**\u540e\u9762\u7684\u6570\u503c)\u3002 S \u662f**\u7b26\u53f7\u8868**\u4e2d\u4fdd\u5b58\u7684\u7b26\u53f7\u7684\u503c\uff0c\u800c P \u4ee3\u8868\u91cd\u5b9a\u4f4d\u7684**\u4f4d\u7f6e\u504f\u79fb\u91cf**\uff0c\u6362\u8a00\u4e4b\uff0c\u5373\u7b97\u51fa\u7684\u6570\u636e\u5199\u5165\u5230\u4e8c\u8fdb\u5236\u6587\u4ef6\u4e2d\u7684**\u4f4d\u7f6e\u504f\u79fb\u91cf**(\u4fee\u6539\u5904\u7684\u8fd0\u884c\u65f6\u5730\u5740\u6216\u8005\u504f\u79fb\uff0c\u5bf9\u4e8e**\u76ee\u6807\u6587\u4ef6** P \u4e3a\u4fee\u8ba2\u5904**\u6bb5**\u5185\u7684\u504f\u79fb\uff0c\u5bf9**\u53ef\u6267\u884c\u6587\u4ef6**P\u4e3a**\u8fd0\u884c\u65f6\u7684\u5730\u5740**)\u3002\u5982\u679c\u52a0\u6570\u503c\u4e3a0\uff0c\u90a3\u4e48**\u7edd\u5bf9\u91cd\u5b9a\u4f4d**\u53ea\u662f\u5c06**\u7b26\u53f7\u8868**\u4e2d\u7684\u7b26\u53f7\u7684\u503c\u63d2\u5165\u5728**\u91cd\u5b9a\u4f4d\u4f4d\u7f6e**\u3002\u4f46\u5728**\u76f8\u5bf9\u91cd\u5b9a\u4f4d**\u4e2d\uff0c\u9700\u8981\u8ba1\u7b97**\u7b26\u53f7\u4f4d\u7f6e**\u548c**\u91cd\u5b9a\u4f4d\u4f4d\u7f6e**\u4e4b\u95f4\u7684\u5dee\u503c\u3002\u6362\u8a00\u4e4b\uff0c\u9700\u8981\u901a\u8fc7\u8ba1\u7b97\u786e\u5b9a\u7b26\u53f7\u4e0e\u91cd\u5b9a\u4f4d\u4f4d\u7f6e\u76f8\u8ddd\u591a\u5c11\u5b57\u8282\u3002 \u5728\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e0b\uff0c\u90fd\u4f1a\u52a0\u4e0a\u52a0\u6570\u503c\uff0c\u56e0\u800c\u4f7f\u5f97\u7ed3\u679c\u4ea7\u751f\u4e00\u4e2a**\u7ebf\u6027\u4f4d\u79fb**\u3002 \u9996\u5148\u6211\u4eec\u660e\u786e\u7684\u662f**\u91cd\u5b9a\u5411**\u53d1\u751f\u5728**\u94fe\u63a5**\u7684\u65f6\u5019\uff0c\u5f53\u591a\u4e2a\u8f93\u5165\u6700\u7ec8\u94fe\u63a5\u6210\u4e00\u4e2a**\u76ee\u6807\u6587\u4ef6**\u7684\u65f6\u5019\uff0c\u5f53**\u7b26\u53f7**\u89e3\u6790\u5b8c\u6210\u4e4b\u540e\u3002 \u5728\u6b64\u4f8b\u5b50\u4e2d\uff0c a.c \u548c b.c \u6ca1\u6709\u5916\u90e8\u5f15\u7528\uff0c\u6240\u4ee5\u5728 .o \u6587\u4ef6\u4e2d\u4e0d\u5b58\u5728\u91cd\u5b9a\u4f4d\u8868\u9879\uff0c\u53ea\u6709 main.o \u5b58\u5728\uff0c\u5982\u56fe\uff1a \u67e5\u770b main.o \u7684\u91cd\u5b9a\u4f4d\u8868\uff1a [ dk@dk rel ] $ readelf -r main.o \u91cd\u5b9a\u4f4d\u8282 '.rela.text' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x300 \u542b\u6709 8 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000011 000900000002 R_X86_64_PC32 0000000000000000 a - 4 000000000022 000b00000002 R_X86_64_PC32 0000000000000000 sum - 4 000000000029 00050000000a R_X86_64_32 0000000000000000 .rodata + 0 000000000033 000c00000002 R_X86_64_PC32 0000000000000000 printf - 4 000000000039 000900000002 R_X86_64_PC32 0000000000000000 a - 4 00000000004a 000d00000002 R_X86_64_PC32 0000000000000000 mul - 4 000000000051 00050000000a R_X86_64_32 0000000000000000 .rodata + 8 00000000005b 000c00000002 R_X86_64_PC32 0000000000000000 printf - 4 \u91cd\u5b9a\u4f4d\u8282 '.rela.eh_frame' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x3c0 \u542b\u6709 1 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 \u67e5\u770b main.o \u7684\u7b26\u53f7\u8868\uff1a [ dk@dk rel ] $ readelf -s main.o Symbol table '.symtab' contains 14 entries: Num: Value Size Type Bind Vis Ndx Name 0 : 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1 : 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2 : 0000000000000000 0 SECTION LOCAL DEFAULT 1 3 : 0000000000000000 0 SECTION LOCAL DEFAULT 3 4 : 0000000000000000 0 SECTION LOCAL DEFAULT 4 5 : 0000000000000000 0 SECTION LOCAL DEFAULT 5 6 : 0000000000000000 0 SECTION LOCAL DEFAULT 7 7 : 0000000000000000 0 SECTION LOCAL DEFAULT 8 8 : 0000000000000000 0 SECTION LOCAL DEFAULT 6 9 : 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 a 10 : 0000000000000000 102 FUNC GLOBAL DEFAULT 1 main 11 : 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sum 12 : 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf 13 : 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND mul \u4ece main.c \u6e90\u6587\u4ef6\u4e5f\u4e0d\u96be\u770b\u51fa\uff0c\u5b83\u5f15\u7528\u4e86\u5916\u9762 sum \u548c mul \u7b26\u53f7\uff0c\u5e76\u4e14\u5f15\u7528\u4e86\u4e00\u4e2a\u5168\u5c40 a \u7b26\u53f7\u3002\u5e76\u4e14\u4ece\u4e0a\u56fe\u4e5f\u53ef\u4ee5\u770b\u51fa\u3002\u5e76\u4e14a\u7684**\u91cd\u5b9a\u4f4d\u7c7b\u578b**\u4e3a**\u76f8\u5bf9\u91cd\u5b9a\u4f4d**\u3002 \u5e76\u4e14\u53ef\u4ee5\u5f97\u5230\uff1a a\u7b2c\u4e00\u5904 r_offset \uff1a 0x11 \u91cd\u5b9a\u4f4d\u7684\u5b57\u8282\u5904 \u5e76\u4e14\u4ece\u7b2c\u4e8c\u5e45\u56fe\u53ef\u4ee5\u5f97\u77e5 a \u7684\u5927\u5c0f\u4e3a4\u4e2a\u5b57\u8282 a\u7b2c\u4e8c\u5904 r_offset \uff1a 0x3f sumr_offset \uff1a 0x29 mulr_offset \uff1a 0x4e \u8ba1\u7b97 a \u7684\u91cd\u5b9a\u4f4d\u540e\u7684\u5730\u5740\uff1a\u6839\u636e\u516c\u5f0f S+A S \u4e3a**\u76ee\u6807\u6587\u4ef6\u7b26\u53f7\u8868**\u4e2d\u7684\u5bf9\u5e94\u7684\u5730\u5740\uff08\u4e3a\u4ec0\u4e48\u4e0d\u662f .o \u6587\u4ef6\u5462\uff0c\u56e0\u4e3a .o \u6587\u4ef6\u7684\u7b26\u53f7\u8868\u4e2d\u7684\u5730\u5740\u90fd\u662f\u91cd\u5b9a\u4f4dREL\u7c7b\u578b\uff0c\u90fd\u4e3a0\uff09\uff1a \u67e5\u770b main \u7684\u7b26\u53f7\u8868\uff0c\u5176\u4e2d\u9700\u8981\u6ce8\u610f\u7684\u662f\u5168\u5c40\u53d8\u91cf a \u7684\u503c\uff0c\u56e0\u4e3a\u4e0b\u9762\u5c06\u4ee5a\u4e3a\u4f8b\u6765\u8bf4\u660e**\u91cd\u5b9a\u4f4d**\u8fc7\u7a0b\uff0c\u4ece\u8f93\u51fa\u7ed3\u679c\u53ef\u4ee5\u770b\u51fa\uff0c\u53d8\u91cf a \u7684\u503c\u4e3a OX601034 [ dk@dk rel ] $ readelf -s main | grep a Symbol table '.dynsym' contains 4 entries: Num: Value Size Type Bind Vis Ndx Name 2 : 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 ( 2 ) 3 : 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ Symbol table '.symtab' contains 70 entries: Num: Value Size Type Bind Vis Ndx Name 17 : 00000000004006a8 0 SECTION LOCAL DEFAULT 17 30 : 00000000004004a0 0 FUNC LOCAL DEFAULT 13 register_tm_clones 31 : 00000000004004e0 0 FUNC LOCAL DEFAULT 13 __do_global_dtors_aux 33 : 0000000000600e18 0 OBJECT LOCAL DEFAULT 19 __do_global_dtors_aux_fin 34 : 0000000000400500 0 FUNC LOCAL DEFAULT 13 frame_dummy 35 : 0000000000600e10 0 OBJECT LOCAL DEFAULT 18 __frame_dummy_init_array_ 36 : 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 38 : 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 43 : 0000000000600e18 0 NOTYPE LOCAL DEFAULT 18 __init_array_end 45 : 0000000000600e10 0 NOTYPE LOCAL DEFAULT 18 __init_array_start 48 : 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab 49 : 0000000000601030 0 NOTYPE WEAK DEFAULT 24 data_start 50 : 0000000000601038 0 NOTYPE GLOBAL DEFAULT 24 _edata 53 : 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_ 54 : 0000000000601030 0 NOTYPE GLOBAL DEFAULT 24 __data_start 55 : 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 56 : 0000000000400648 0 OBJECT GLOBAL HIDDEN 15 __dso_handle 61 : 0000000000400440 0 FUNC GLOBAL DEFAULT 13 _start 62 : 0000000000601034 4 OBJECT GLOBAL DEFAULT 24 a 63 : 0000000000601038 0 NOTYPE GLOBAL DEFAULT 25 __bss_start 64 : 0000000000400554 102 FUNC GLOBAL DEFAULT 13 main 66 : 0000000000000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses 68 : 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable \u53ef\u4ee5\u5f97\u5230 S(a) =0x601034 \uff0c\u63a5\u4e0b\u6765\u8981\u786e\u5b9a\u52a0\u503cA\uff0c\u8fd9\u8981\u770b main.o \u7684\u6c47\u7f16\u4ee3\u7801\u4e86\uff0c\u5229\u7528 objdump \u6765\u67e5\u770b\u8be5.text\u8282\u7684\u6c47\u7f16\u4ee3\u7801\uff1a [dk@dk rel]$ objdump -d main.o main.o\uff1a \u6587\u4ef6\u683c\u5f0f elf64-x86-64 Disassembly of section .text: 0000000000000000 <main>: 0: 55 push %rbp 1: 48 89 e5 mov %rsp,%rbp 4: 48 83 ec 10 sub $0x10,%rsp 8: c7 45 fc 0c 00 00 00 movl $0xc,-0x4(%rbp) f: 8b 05 00 00 00 00 mov 0x0(%rip),%eax # 15 <main+0x15> 15: 8b 55 fc mov -0x4(%rbp),%edx 18: 89 d6 mov %edx,%esi 1a: 89 c7 mov %eax,%edi 1c: b8 00 00 00 00 mov $0x0,%eax 21: e8 00 00 00 00 callq 26 <main+0x26> 26: 89 c6 mov %eax,%esi 28: bf 00 00 00 00 mov $0x0,%edi 2d: b8 00 00 00 00 mov $0x0,%eax 32: e8 00 00 00 00 callq 37 <main+0x37> 37: 8b 05 00 00 00 00 mov 0x0(%rip),%eax # 3d <main+0x3d> 3d: 8b 55 fc mov -0x4(%rbp),%edx 40: 89 d6 mov %edx,%esi 42: 89 c7 mov %eax,%edi 44: b8 00 00 00 00 mov $0x0,%eax 49: e8 00 00 00 00 callq 4e <main+0x4e> 4e: 89 c6 mov %eax,%esi 50: bf 00 00 00 00 mov $0x0,%edi 55: b8 00 00 00 00 mov $0x0,%eax 5a: e8 00 00 00 00 callq 5f <main+0x5f> 5f: b8 00 00 00 00 mov $0x0,%eax 64: c9 leaveq 65: c3 retq \u8fd9\u6837\u6765\u8bfb\u8fd9\u4e9b\u4ee3\u7801\uff1a 1\uff09\u5de6\u8fb9\u4e24\u680f\u4e2d\u6700\u5de6\u9762\u4e00\u680f\u662f\u4e0a\u9762\u6240\u6709**\u673a\u5668\u6307\u4ee4**\u7684\u5b57\u8282\u6570\uff0816\u8fdb\u5236\uff09\uff0c\u7d27\u63a5\u7740\u5176\u540e\u7684\u662f**\u673a\u5668\u4ee3\u7801**\uff08\u5341\u516d\u8fdb\u5236\u5f62\u5f0f\uff09\u3002\u5176\u5b9e\u771f\u6b63\u7684\u4e8c\u8fdb\u5236\u4ee3\u7801\u662f\u8fd9\u6837\u7684\uff08\u5341\u516d\u8fdb\u5236\uff09\uff0c\u524d\u4e24\u884c 8d 4c 24 04 83 e4 f0 \uff0c\u5de5\u5177\u4e3a\u4e86\u65b9\u4fbf\u9605\u8bfb\u3002 \u6211\u5728\u5de5\u5177\u7684\u57fa\u7840\u4e0a\u4e3a\u4e86\u65b9\u4fbf\u8bf4\u660e\u8fd9\u4e24\u680f\uff0c\u53ea\u63d0\u53d6\u4e86\u524d\u9762\u4e24\u680f\uff08\u597d\u6bd4\u4e00\u4e2a\u5927\u7684\u5b57\u8282\u6570\u7ec4\u4ece\u96f6\u5f00\u59cb\uff09\u3002 0 : 8d 4c 24 04 \u4ee5\u524d\u662f0\u4e2a\u5b57\u8282\uff0c\u4e0b\u6807\u662f\u4ece0\u5f00\u59cb\uff0c\u5176\u4e2d8d\u662f\u64cd\u4f5c\u7801 4 : 83 e4 f0 \u4e0a\u9762\u4e00\u5171\u56db\u4e2a\u5b57\u8282\uff0c\u6b64\u884c\u5c0f\u6807\u4e5f\u662f\u4ece4\u5f00\u59cb\uff0c83\u662f\u64cd\u4f5c\u7801 2\uff09\u6700\u540e\u4e00\u680f\u662f\u6c47\u7f16\u6307\u4ee4 lea 0x4(%esp),%ecx and $0xfffffff0,%esp \u5728\u4e0a\u9762 objdump -d main.o \u4e2d\uff0c\u6211\u4eec\u770b\u7b2c 0x11 \u5b57\u8282\u5f00\u59cb\u7684\u56db\u4e2a\u5b57\u8282\u7684\u5185\u5bb9\u7686\u4e3a0\u3002\u5219\u6839\u636e\u516c\u5f0f R_386_PC_32:Result=S-P+A \uff0c\u4e5f\u5c31\u662f**\u76ee\u6807\u6587\u4ef6**\u7684 11 \u540e\u9762\u7684\u540e4\u4e2a\u5b57\u8282\u8981\u88ab\u66ff\u6362\u4e3a\u8be5\u503c\u3002 \u6b64\u5904\u662f\u5982\u4f55\u8ba1\u7b97\u51fa\u91cd\u5b9a\u5411\u503c\u7684\u5462\uff1f\uff1f \u4e0b\u9762\u662f\u67e5\u770b main \u4e2dmain\u51fd\u6570\u7684\u6c47\u7f16\u4ee3\u7801\uff1a [ dk@dk rel ] $ objdump -d main >> assemb \u8f93\u51fa\u7ed3\u679c\u5982\u4e0b\uff1a 0000000000400554 <main>: 400554: 55 push %rbp 400555: 48 89 e5 mov %rsp,%rbp 400558: 48 83 ec 10 sub $0x10,%rsp 40055c: c7 45 fc 0c 00 00 00 movl $0xc,-0x4(%rbp) 400563: 8b 05 cb 0a 20 00 mov 0x200acb(%rip),%eax # 601034 <a> 400569: 8b 55 fc mov -0x4(%rbp),%edx 40056c: 89 d6 mov %edx,%esi 40056e: 89 c7 mov %eax,%edi 400570: b8 00 00 00 00 mov $0x0,%eax 400575: e8 b3 ff ff ff callq 40052d <sum> 40057a: 89 c6 mov %eax,%esi 40057c: bf 50 06 40 00 mov $0x400650,%edi 400581: b8 00 00 00 00 mov $0x0,%eax 400586: e8 85 fe ff ff callq 400410 <printf@plt> 40058b: 8b 05 a3 0a 20 00 mov 0x200aa3(%rip),%eax # 601034 <a> 400591: 8b 55 fc mov -0x4(%rbp),%edx 400594: 89 d6 mov %edx,%esi 400596: 89 c7 mov %eax,%edi 400598: b8 00 00 00 00 mov $0x0,%eax 40059d: e8 9f ff ff ff callq 400541 <mul> 4005a2: 89 c6 mov %eax,%esi 4005a4: bf 58 06 40 00 mov $0x400658,%edi 4005a9: b8 00 00 00 00 mov $0x0,%eax 4005ae: e8 5d fe ff ff callq 400410 <printf@plt> 4005b3: b8 00 00 00 00 mov $0x0,%eax 4005b8: c9 leaveq 4005b9: c3 retq 4005ba: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) \u4ece\u4e0a\u9762\u7ed3\u679c\u53ef\u4ee5\u770b\u51fa\uff0c\u5728\u8fdb\u884c\u91cd\u5b9a\u5411\u7684\u4f4d\u7f6e\uff0c objdump \u7a0b\u5e8f\u5df2\u7ecf\u8fdb\u884c\u4e86\u6807\u6ce8\u3002","title":"\u91cd\u5b9a\u4f4d\u7c7b\u578b"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/the-logic-structure-of-elf-file/","text":"\u5173\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u662f\u9700\u8981\u9996\u5148\u641e\u6e05\u695aELF\u6587\u4ef6\u7684\u903b\u8f91\u7ed3\u6784\u7684\u3002\u603b\u7684\u6765\u8bf4ELF\u6587\u4ef6\u7684\u903b\u8f91\u7ed3\u6784\u53ef\u4ee5\u4f7f\u7528\u4e0b\u9762\u7684\u8fd9\u4e2a\u56fe\u6765\u8868\u793a\uff1a \u901a\u8fc7ELF header\u7684e_phoff\u6210\u5458\u53ef\u4ee5\u5b9a\u4f4d\u5230program header table\uff0c\u901a\u8fc7ELF header\u7684e_shoff\u6210\u5458\u53ef\u4ee5\u5b9a\u4f4d\u5230section header table\u3002 section header table\u662f\u4e00\u4e2a\u6570\u7ec4\uff0c\u6570\u7ec4\u5143\u7d20\u7684\u7c7b\u578b\u662fsection header\u3002ELF header\u7684e_shentsize\u63cf\u8ff0\u4e86\u8be5\u6570\u7ec4\u6bcf\u4e2a\u5143\u7d20\u7684\u957f\u5ea6\uff0c\u663e\u7136\u6bcf\u4e2a\u5143\u7d20\u7684\u957f\u5ea6\u5c31\u662fsection header\u7ed3\u6784\u7684\u957f\u5ea6\u3002 \u901a\u8fc7section header\u6765\u63cf\u8ff0\u4e00\u4e2asection\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u5728section header\u7ed3\u6784\u4e2d\u6709\u4e00\u4e2ash_offset\u6210\u5458\uff0c\u8fd9\u4e2a\u6210\u5458\u7ed9\u51fa\u4e86\u5bf9\u4e8esection\u5728ELF \u6587\u4ef6\u4e2d\u7684\u4f4d\u7f6e\uff1b\u5728section header\u7ed3\u6784\u4e2d\u6709\u4e00\u4e2ash_size\u6210\u5458\uff0c\u8fd9\u4e2a\u6210\u5458\u7ed9\u51fa\u4e86\u5bf9\u5e94section\u7684\u957f\u5ea6\u3002 program header table\u662f\u4e00\u4e2a\u6570\u7ec4\uff0c\u6570\u7ec4\u5143\u7d20\u7684\u7c7b\u578b\u662fsegment header\u3002ELF header\u7684e_phentsize\u63cf\u8ff0\u4e86\u8be5\u6570\u7ec4\u6bcf\u4e2a\u5143\u7d20\u7684\u957f\u5ea6\uff0c\u663e\u7136\u6bcf\u4e2a\u5143\u7d20\u7684\u957f\u5ea6\u5c31\u662fsegment header\u7ed3\u6784\u7684\u957f\u5ea6\u3002 \u901a\u8fc7segment header\u7ed3\u6784\u6765\u63cf\u8ff0\u4e00\u4e2asegment\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u5728segment \u901a\u8fc7\u4ee5\u4e0a\u7684\u5206\u6790\u5df2\u7ecf\u56de\u7b54\u4e86\u63d0\u95ee\u3002","title":"The logic structure of elf file"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/the-understanding-of-ELF/","text":"","title":"the understanding of ELF"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/linking/","text":"linking Executable files are created from individual object files and libraries through the linking process . The linker resolves the references (including subroutines and data references) among the different object files, adjusts the absolute references in the object files, and relocates instructions . The linking and loading processes, which are described in Chapter 2, require information defined in the object files and store this information in specific sections such as .dynamic \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684reference\u5982\u4f55\u7406\u89e3\uff1f\uff1f Each operating system supports a set of linking models which fall into two categories: 1. Static A set of object files, system libraries and library archives are statically bound, references are resolved, and an executable file is created that is completely self contained. 2. Dynamic A set of object files, libraries, system shared resources and other shared libraries are linked together to create the executable. When this executable is loaded, other shared resources and dynamic libraries must be made available in the system for the program to run successfully. The general method used to resolve references at execution time for a dynamically linked executable file is described in the linkage model used by the operating system, and the actual implementation of this linkage model will contain processor-specific components.","title":"linking"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/linking/#linking","text":"Executable files are created from individual object files and libraries through the linking process . The linker resolves the references (including subroutines and data references) among the different object files, adjusts the absolute references in the object files, and relocates instructions . The linking and loading processes, which are described in Chapter 2, require information defined in the object files and store this information in specific sections such as .dynamic \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684reference\u5982\u4f55\u7406\u89e3\uff1f\uff1f Each operating system supports a set of linking models which fall into two categories: 1. Static A set of object files, system libraries and library archives are statically bound, references are resolved, and an executable file is created that is completely self contained. 2. Dynamic A set of object files, libraries, system shared resources and other shared libraries are linked together to create the executable. When this executable is loaded, other shared resources and dynamic libraries must be made available in the system for the program to run successfully. The general method used to resolve references at execution time for a dynamically linked executable file is described in the linkage model used by the operating system, and the actual implementation of this linkage model will contain processor-specific components.","title":"linking"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections-2/","text":"20180318 Special Sections .bss This section holds uninitialized data that contribute to the program's memory image. \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5728data\u540e\u9762\u52a0\u4e0a\u4e86\u5b9a\u8bed contribute to the program's memory image \uff0c\u662f\u5426\u662f\u6307\u90a3\u4e9b\u5168\u5c40\u7684\u6570\u636e\uff0c\u800c\u4e0d\u662f\u51fd\u6570\u5185\u90e8\u5b9a\u4e49\u7684\u4e34\u65f6\u53d8\u91cf\u5462\uff1f By definition, the system initializes the data with zeros when the program begins to run. The section occupies no file space, as indicated by the section type, SHT_NOBITS \u3002 \u6211\u6bd4\u8f83\u597d\u5947\u7684\u662f\uff0c\u65e2\u7136\u5b83\u5e76\u4e0d\u5360\u7528\u6587\u4ef6\u7a7a\u95f4\uff0c\u90a3\u4e3a\u4ec0\u4e48\u8fd8\u8981\u4fdd\u7559\u8fd9\u4e2asection\u5462\uff1f\uff1f .data and .data1 These sections hold initialized data that contribute to the program's memory image. \u8fd8\u662f\u4ee5\u4e0b\u9762\u8fd9\u4e2a\u5c0f\u7a0b\u5e8f\u4e3a\u4f8b\u6765\u8fdb\u884c\u89c2\u5bdf\u3002 int i; int j = 1; int k; void test_a()//\u5b9a\u4e49\u51fd\u6570test_a { int h = 3; return; } \u8fdb\u884c\u7f16\u8bd1\uff0c\u800c\u4e0d\u8fdb\u884c\u94fe\u63a5\uff0c\u547d\u4ee4\u5982\u4e0b\uff1a gcc -c a.c -o a.o \u7136\u540e\u4f7f\u7528readelf\u8fdb\u884c\u67e5\u770b\uff0c\u8f93\u51fa\u7ed3\u679c\u5982\u4e0b\uff1a \u8282\u5934\uff1a [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 000000000000000e 0000000000000000 AX 0 0 1 [ 2] .data PROGBITS 0000000000000000 00000050 0000000000000004 0000000000000000 WA 0 0 4 [ 3] .bss NOBITS 0000000000000000 00000054 0000000000000000 0000000000000000 WA 0 0 1 [ 4] .comment PROGBITS 0000000000000000 00000054 000000000000002e 0000000000000001 MS 0 0 1 [ 5] .note.GNU-stack PROGBITS 0000000000000000 00000082 0000000000000000 0000000000000000 0 0 1 [ 6] .eh_frame PROGBITS 0000000000000000 00000088 0000000000000038 0000000000000000 A 0 0 8 [ 7] .rela.eh_frame RELA 0000000000000000 00000250 0000000000000018 0000000000000018 I 9 6 8 [ 8] .shstrtab STRTAB 0000000000000000 000000c0 0000000000000054 0000000000000000 0 0 1 [ 9] .symtab SYMTAB 0000000000000000 00000118 0000000000000120 0000000000000018 10 8 8 [10] .strtab STRTAB 0000000000000000 00000238 0000000000000012 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) There are no section groups in this file. \u672c\u6587\u4ef6\u4e2d\u6ca1\u6709\u7a0b\u5e8f\u5934\u3002 \u91cd\u5b9a\u4f4d\u8282 '.rela.eh_frame' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x250 \u542b\u6709 1 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported. Symbol table '.symtab' contains 12 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 2 4: 0000000000000000 0 SECTION LOCAL DEFAULT 3 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 6 7: 0000000000000000 0 SECTION LOCAL DEFAULT 4 8: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM i 9: 0000000000000000 4 OBJECT GLOBAL DEFAULT 2 j 10: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM k 11: 0000000000000000 14 FUNC GLOBAL DEFAULT 1 test_a No version information found in this file. \u901a\u8fc7\u4e0a\u9762\u7684\u7a0b\u5e8f\u53ef\u4ee5\u770b\u5230\uff0c.data\u6bb5\u7684\u5927\u5c0f\u662f4\u5b57\u8282\u3002\u73b0\u5728\u6211\u4eec\u4fee\u6539\u7a0b\u5e8f\uff0c\u5982\u4e0b\uff1a int i; int j = 1; int k = 2; void test_a()//\u5b9a\u4e49\u51fd\u6570test_a { int h = 3; return; } \u7136\u540e\u518d\u8fdb\u884c\u7f16\u8bd1\uff0c\u518d\u8bfb\u53d6\u8fd9\u4e2a\u6587\u4ef6\uff0c\u8f93\u51fa\u7ed3\u679c\u5982\u4e0b\uff1a \u8282\u5934\uff1a [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 000000000000000e 0000000000000000 AX 0 0 1 [ 2] .data PROGBITS 0000000000000000 00000050 0000000000000008 0000000000000000 WA 0 0 4 [ 3] .bss NOBITS 0000000000000000 00000058 0000000000000000 0000000000000000 WA 0 0 1 [ 4] .comment PROGBITS 0000000000000000 00000058 000000000000002e 0000000000000001 MS 0 0 1 [ 5] .note.GNU-stack PROGBITS 0000000000000000 00000086 0000000000000000 0000000000000000 0 0 1 [ 6] .eh_frame PROGBITS 0000000000000000 00000088 0000000000000038 0000000000000000 A 0 0 8 [ 7] .rela.eh_frame RELA 0000000000000000 00000250 0000000000000018 0000000000000018 I 9 6 8 [ 8] .shstrtab STRTAB 0000000000000000 000000c0 0000000000000054 0000000000000000 0 0 1 [ 9] .symtab SYMTAB 0000000000000000 00000118 0000000000000120 0000000000000018 10 8 8 [10] .strtab STRTAB 0000000000000000 00000238 0000000000000012 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) There are no section groups in this file. \u672c\u6587\u4ef6\u4e2d\u6ca1\u6709\u7a0b\u5e8f\u5934\u3002 \u91cd\u5b9a\u4f4d\u8282 '.rela.eh_frame' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x250 \u542b\u6709 1 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported. Symbol table '.symtab' contains 12 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 2 4: 0000000000000000 0 SECTION LOCAL DEFAULT 3 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 6 7: 0000000000000000 0 SECTION LOCAL DEFAULT 4 8: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM i 9: 0000000000000000 4 OBJECT GLOBAL DEFAULT 2 j 10: 0000000000000004 4 OBJECT GLOBAL DEFAULT 2 k 11: 0000000000000000 14 FUNC GLOBAL DEFAULT 1 test_a No version information found in this file. \u53ef\u4ee5\u770b\u5230\uff0c\u73b0\u5728.data\u6bb5\u7684\u5927\u5c0f\u662f8\u5b57\u8282\u3002 \u6211\u4eec\u518d\u4fee\u6539\u7a0b\u5e8f\uff0c\u5728\u51fd\u6570test_a\u4e2d\u6dfb\u52a0\u4e34\u65f6\u53d8\u91cf\uff0c\u5e76\u4e14\u5bf9\u5176\u8fdb\u884c\u8d4b\u503c\uff0c\u5982\u4e0b\uff1a int i; int j = 1; int k = 2; void test_a()//\u5b9a\u4e49\u51fd\u6570test_a { int h = 3; int l = 3; return; } \u901a\u8fc7readelf\u6765\u770b\uff0c\u53d1\u73b0.data\u6bb5\u5e76\u6ca1\u6709\u53d8\u5316\u3002\u8fd9\u6fc0\u8d77\u4e86\u6211\u7684\u4e00\u4e2a\u7591\u95ee\uff0c\u5bf9\u4e8e\u51fd\u6570\u4e2d\u58f0\u660e\u7684\u5386\u53f2\u53d8\u91cf\uff0cELF\u6587\u4ef6\u662f\u5426\u5e76\u4e0d\u4f1a\u8fdb\u884c\u4fdd\u5b58\uff1f\uff1f\u5e76\u4e14\u4e0a\u9762\u63d0\u53ca\u7684\u5b9a\u8bed contribute to the program's memory image. \u5e94\u8be5\u662f\u548c\u8fd9\u6709\u5173\u8054\u7684\u3002","title":"20180318"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections-2/#20180318","text":"","title":"20180318"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections-2/#special#sections","text":"","title":"Special Sections"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections-2/#bss","text":"This section holds uninitialized data that contribute to the program's memory image. \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5728data\u540e\u9762\u52a0\u4e0a\u4e86\u5b9a\u8bed contribute to the program's memory image \uff0c\u662f\u5426\u662f\u6307\u90a3\u4e9b\u5168\u5c40\u7684\u6570\u636e\uff0c\u800c\u4e0d\u662f\u51fd\u6570\u5185\u90e8\u5b9a\u4e49\u7684\u4e34\u65f6\u53d8\u91cf\u5462\uff1f By definition, the system initializes the data with zeros when the program begins to run. The section occupies no file space, as indicated by the section type, SHT_NOBITS \u3002 \u6211\u6bd4\u8f83\u597d\u5947\u7684\u662f\uff0c\u65e2\u7136\u5b83\u5e76\u4e0d\u5360\u7528\u6587\u4ef6\u7a7a\u95f4\uff0c\u90a3\u4e3a\u4ec0\u4e48\u8fd8\u8981\u4fdd\u7559\u8fd9\u4e2asection\u5462\uff1f\uff1f","title":".bss"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections-2/#data#and#data1","text":"These sections hold initialized data that contribute to the program's memory image. \u8fd8\u662f\u4ee5\u4e0b\u9762\u8fd9\u4e2a\u5c0f\u7a0b\u5e8f\u4e3a\u4f8b\u6765\u8fdb\u884c\u89c2\u5bdf\u3002 int i; int j = 1; int k; void test_a()//\u5b9a\u4e49\u51fd\u6570test_a { int h = 3; return; } \u8fdb\u884c\u7f16\u8bd1\uff0c\u800c\u4e0d\u8fdb\u884c\u94fe\u63a5\uff0c\u547d\u4ee4\u5982\u4e0b\uff1a gcc -c a.c -o a.o \u7136\u540e\u4f7f\u7528readelf\u8fdb\u884c\u67e5\u770b\uff0c\u8f93\u51fa\u7ed3\u679c\u5982\u4e0b\uff1a \u8282\u5934\uff1a [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 000000000000000e 0000000000000000 AX 0 0 1 [ 2] .data PROGBITS 0000000000000000 00000050 0000000000000004 0000000000000000 WA 0 0 4 [ 3] .bss NOBITS 0000000000000000 00000054 0000000000000000 0000000000000000 WA 0 0 1 [ 4] .comment PROGBITS 0000000000000000 00000054 000000000000002e 0000000000000001 MS 0 0 1 [ 5] .note.GNU-stack PROGBITS 0000000000000000 00000082 0000000000000000 0000000000000000 0 0 1 [ 6] .eh_frame PROGBITS 0000000000000000 00000088 0000000000000038 0000000000000000 A 0 0 8 [ 7] .rela.eh_frame RELA 0000000000000000 00000250 0000000000000018 0000000000000018 I 9 6 8 [ 8] .shstrtab STRTAB 0000000000000000 000000c0 0000000000000054 0000000000000000 0 0 1 [ 9] .symtab SYMTAB 0000000000000000 00000118 0000000000000120 0000000000000018 10 8 8 [10] .strtab STRTAB 0000000000000000 00000238 0000000000000012 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) There are no section groups in this file. \u672c\u6587\u4ef6\u4e2d\u6ca1\u6709\u7a0b\u5e8f\u5934\u3002 \u91cd\u5b9a\u4f4d\u8282 '.rela.eh_frame' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x250 \u542b\u6709 1 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported. Symbol table '.symtab' contains 12 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 2 4: 0000000000000000 0 SECTION LOCAL DEFAULT 3 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 6 7: 0000000000000000 0 SECTION LOCAL DEFAULT 4 8: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM i 9: 0000000000000000 4 OBJECT GLOBAL DEFAULT 2 j 10: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM k 11: 0000000000000000 14 FUNC GLOBAL DEFAULT 1 test_a No version information found in this file. \u901a\u8fc7\u4e0a\u9762\u7684\u7a0b\u5e8f\u53ef\u4ee5\u770b\u5230\uff0c.data\u6bb5\u7684\u5927\u5c0f\u662f4\u5b57\u8282\u3002\u73b0\u5728\u6211\u4eec\u4fee\u6539\u7a0b\u5e8f\uff0c\u5982\u4e0b\uff1a int i; int j = 1; int k = 2; void test_a()//\u5b9a\u4e49\u51fd\u6570test_a { int h = 3; return; } \u7136\u540e\u518d\u8fdb\u884c\u7f16\u8bd1\uff0c\u518d\u8bfb\u53d6\u8fd9\u4e2a\u6587\u4ef6\uff0c\u8f93\u51fa\u7ed3\u679c\u5982\u4e0b\uff1a \u8282\u5934\uff1a [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 000000000000000e 0000000000000000 AX 0 0 1 [ 2] .data PROGBITS 0000000000000000 00000050 0000000000000008 0000000000000000 WA 0 0 4 [ 3] .bss NOBITS 0000000000000000 00000058 0000000000000000 0000000000000000 WA 0 0 1 [ 4] .comment PROGBITS 0000000000000000 00000058 000000000000002e 0000000000000001 MS 0 0 1 [ 5] .note.GNU-stack PROGBITS 0000000000000000 00000086 0000000000000000 0000000000000000 0 0 1 [ 6] .eh_frame PROGBITS 0000000000000000 00000088 0000000000000038 0000000000000000 A 0 0 8 [ 7] .rela.eh_frame RELA 0000000000000000 00000250 0000000000000018 0000000000000018 I 9 6 8 [ 8] .shstrtab STRTAB 0000000000000000 000000c0 0000000000000054 0000000000000000 0 0 1 [ 9] .symtab SYMTAB 0000000000000000 00000118 0000000000000120 0000000000000018 10 8 8 [10] .strtab STRTAB 0000000000000000 00000238 0000000000000012 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) There are no section groups in this file. \u672c\u6587\u4ef6\u4e2d\u6ca1\u6709\u7a0b\u5e8f\u5934\u3002 \u91cd\u5b9a\u4f4d\u8282 '.rela.eh_frame' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x250 \u542b\u6709 1 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported. Symbol table '.symtab' contains 12 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 2 4: 0000000000000000 0 SECTION LOCAL DEFAULT 3 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 6 7: 0000000000000000 0 SECTION LOCAL DEFAULT 4 8: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM i 9: 0000000000000000 4 OBJECT GLOBAL DEFAULT 2 j 10: 0000000000000004 4 OBJECT GLOBAL DEFAULT 2 k 11: 0000000000000000 14 FUNC GLOBAL DEFAULT 1 test_a No version information found in this file. \u53ef\u4ee5\u770b\u5230\uff0c\u73b0\u5728.data\u6bb5\u7684\u5927\u5c0f\u662f8\u5b57\u8282\u3002 \u6211\u4eec\u518d\u4fee\u6539\u7a0b\u5e8f\uff0c\u5728\u51fd\u6570test_a\u4e2d\u6dfb\u52a0\u4e34\u65f6\u53d8\u91cf\uff0c\u5e76\u4e14\u5bf9\u5176\u8fdb\u884c\u8d4b\u503c\uff0c\u5982\u4e0b\uff1a int i; int j = 1; int k = 2; void test_a()//\u5b9a\u4e49\u51fd\u6570test_a { int h = 3; int l = 3; return; } \u901a\u8fc7readelf\u6765\u770b\uff0c\u53d1\u73b0.data\u6bb5\u5e76\u6ca1\u6709\u53d8\u5316\u3002\u8fd9\u6fc0\u8d77\u4e86\u6211\u7684\u4e00\u4e2a\u7591\u95ee\uff0c\u5bf9\u4e8e\u51fd\u6570\u4e2d\u58f0\u660e\u7684\u5386\u53f2\u53d8\u91cf\uff0cELF\u6587\u4ef6\u662f\u5426\u5e76\u4e0d\u4f1a\u8fdb\u884c\u4fdd\u5b58\uff1f\uff1f\u5e76\u4e14\u4e0a\u9762\u63d0\u53ca\u7684\u5b9a\u8bed contribute to the program's memory image. \u5e94\u8be5\u662f\u548c\u8fd9\u6709\u5173\u8054\u7684\u3002","title":".data and  .data1"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections-3/","text":".symtab .symtab\u7684\u5168\u79f0\u662f Symbol Table . An object file's symbol table holds information needed to locate and relocate a program's symbolic definitions and references . A symbol table index is a subscript into this array. \u770b\u5230\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684**symbolic definitions and references**\u6211\u4e0d\u7981\u60f3\u8d77\u4e86\u4e4b\u524d\u5fc3\u4e2d\u4e00\u76f4\u601d\u7d22\u7684\u201csymbol\u201d\uff0c\u5df2\u7ecf\u4e4b\u524d\u9047\u5230\u7684\u7f16\u8bd1\u62a5\u9519\u201cundefined symbol\u201d\u3002 \u5f52\u6839\u5230\u5e95\uff0c\u6211\u4eec\u7684\u7a0b\u5e8f\u90fd\u662f\u7531\u7b26\u53f7\u7ec4\u7ec7\u800c\u6210\u7684\uff0c\u6211\u4eec\u4eba\u80fd\u591f\u7406\u89e3\u7b26\u53f7\uff0c\u8ba1\u7b97\u673a\u4e5f\u80fd\u591f\u7406\u89e3\u7b26\u53f7\u3002 \u4e0b\u9762\u7ed3\u5408\u6e90\u4ee3\u7801\u6765\u770b\u770brelocatable file\u4e2d\u7684symbol table\u3002 \u6e90\u4ee3\u7801\u5982\u4e0b\uff1a #include<stdio.h> int i; int j = 1; int k = 2; char a[20] = \"hello world\"; void test_a()//\u5b9a\u4e49\u51fd\u6570test_a { int h = 3; int l = 3; char b[20] = \"hello world\"; printf(\"%d\\n\",h); return; } \u7b26\u53f7\u8868\u5982\u4e0b\uff1a Symbol table '.symtab' contains 15 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 7 7: 0000000000000000 0 SECTION LOCAL DEFAULT 8 8: 0000000000000000 0 SECTION LOCAL DEFAULT 6 9: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM i 10: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 j 11: 0000000000000004 4 OBJECT GLOBAL DEFAULT 3 k 12: 0000000000000010 20 OBJECT GLOBAL DEFAULT 3 a 13: 0000000000000000 74 FUNC GLOBAL DEFAULT 1 test_a 14: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf ```","title":".symtab"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections-3/#symtab","text":".symtab\u7684\u5168\u79f0\u662f Symbol Table . An object file's symbol table holds information needed to locate and relocate a program's symbolic definitions and references . A symbol table index is a subscript into this array. \u770b\u5230\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684**symbolic definitions and references**\u6211\u4e0d\u7981\u60f3\u8d77\u4e86\u4e4b\u524d\u5fc3\u4e2d\u4e00\u76f4\u601d\u7d22\u7684\u201csymbol\u201d\uff0c\u5df2\u7ecf\u4e4b\u524d\u9047\u5230\u7684\u7f16\u8bd1\u62a5\u9519\u201cundefined symbol\u201d\u3002 \u5f52\u6839\u5230\u5e95\uff0c\u6211\u4eec\u7684\u7a0b\u5e8f\u90fd\u662f\u7531\u7b26\u53f7\u7ec4\u7ec7\u800c\u6210\u7684\uff0c\u6211\u4eec\u4eba\u80fd\u591f\u7406\u89e3\u7b26\u53f7\uff0c\u8ba1\u7b97\u673a\u4e5f\u80fd\u591f\u7406\u89e3\u7b26\u53f7\u3002 \u4e0b\u9762\u7ed3\u5408\u6e90\u4ee3\u7801\u6765\u770b\u770brelocatable file\u4e2d\u7684symbol table\u3002 \u6e90\u4ee3\u7801\u5982\u4e0b\uff1a #include<stdio.h> int i; int j = 1; int k = 2; char a[20] = \"hello world\"; void test_a()//\u5b9a\u4e49\u51fd\u6570test_a { int h = 3; int l = 3; char b[20] = \"hello world\"; printf(\"%d\\n\",h); return; } \u7b26\u53f7\u8868\u5982\u4e0b\uff1a Symbol table '.symtab' contains 15 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 7 7: 0000000000000000 0 SECTION LOCAL DEFAULT 8 8: 0000000000000000 0 SECTION LOCAL DEFAULT 6 9: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM i 10: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 j 11: 0000000000000004 4 OBJECT GLOBAL DEFAULT 3 k 12: 0000000000000010 20 OBJECT GLOBAL DEFAULT 3 a 13: 0000000000000000 74 FUNC GLOBAL DEFAULT 1 test_a 14: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf ```","title":".symtab"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections/","text":"20180318 \u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u6765\u89c2\u5bdfrelocatable file\u7684section\u4fe1\u606f\u3002\u7a0b\u5e8f\u5982\u4e0b: void test_a () //\u5b9a\u4e49\u51fd\u6570test_a { printf ( \"test_a\" ); return ; } \u53ea\u8fdb\u884c\u7f16\u8bd1\uff0c\u4e0d\u8fdb\u884c\u94fe\u63a5\uff0c\u8fd9\u6837\u5c31\u80fd\u591f\u751f\u6210relocatable file\uff0c\u547d\u4ee4\u5982\u4e0b\uff1a gcc -c a.c -o a.o \u73b0\u5728\u5c31\u53ef\u4ee5\u901a\u8fc7readelf\u547d\u4ee4\u6765\u67e5\u770b\u8fd9\u4e2arelocatable file\u4e86\uff0c\u547d\u4ee4\u5982\u4e0b: readelf -a a.o \u7a0b\u5e8f\u7684\u8f93\u51fa\uff0c\u5373\u5bf9\u8be5relocatable file\u7684\u89e3\u91ca\u5982\u4e0b\uff1a ELF \u5934\uff1a Magic\uff1a 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2 's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6) Machine: Advanced Micro Devices X86-64 Version: 0x1 \u5165\u53e3\u70b9\u5730\u5740\uff1a 0x0 \u7a0b\u5e8f\u5934\u8d77\u70b9\uff1a 0 (bytes into file) Start of section headers: 520 (bytes into file) \u6807\u5fd7\uff1a 0x0 \u672c\u5934\u7684\u5927\u5c0f\uff1a 64 (\u5b57\u8282) \u7a0b\u5e8f\u5934\u5927\u5c0f\uff1a 0 (\u5b57\u8282) Number of program headers: 0 \u8282\u5934\u5927\u5c0f\uff1a 64 (\u5b57\u8282) \u8282\u5934\u6570\u91cf\uff1a 11 \u5b57\u7b26\u4e32\u8868\u7d22\u5f15\u8282\u5934\uff1a 8 \u8282\u5934\uff1a [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000007 0000000000000000 AX 0 0 1 [ 2] .data PROGBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 3] .bss NOBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 4] .comment PROGBITS 0000000000000000 00000047 000000000000002e 0000000000000001 MS 0 0 1 [ 5] .note.GNU-stack PROGBITS 0000000000000000 00000075 0000000000000000 0000000000000000 0 0 1 [ 6] .eh_frame PROGBITS 0000000000000000 00000078 0000000000000038 0000000000000000 A 0 0 8 [ 7] .rela.eh_frame RELA 0000000000000000 000001f0 0000000000000018 0000000000000018 I 9 6 8 [ 8] .shstrtab STRTAB 0000000000000000 000000b0 0000000000000054 0000000000000000 0 0 1 [ 9] .symtab SYMTAB 0000000000000000 00000108 00000000000000d8 0000000000000018 10 8 8 [10] .strtab STRTAB 0000000000000000 000001e0 000000000000000c 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) There are no section groups in this file. \u672c\u6587\u4ef6\u4e2d\u6ca1\u6709\u7a0b\u5e8f\u5934\u3002 \u91cd\u5b9a\u4f4d\u8282 ' .rela.eh_frame ' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x1f0 \u542b\u6709 1 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported. Symbol table ' .symtab ' contains 9 entries: Num: Value Size Type Bind Vis Ndx Name 0 : 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1 : 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2 : 0000000000000000 0 SECTION LOCAL DEFAULT 1 3 : 0000000000000000 0 SECTION LOCAL DEFAULT 2 4 : 0000000000000000 0 SECTION LOCAL DEFAULT 3 5 : 0000000000000000 0 SECTION LOCAL DEFAULT 5 6 : 0000000000000000 0 SECTION LOCAL DEFAULT 6 7 : 0000000000000000 0 SECTION LOCAL DEFAULT 4 8 : 0000000000000000 7 FUNC GLOBAL DEFAULT 1 test_a No version information found in this file. \u4e0b\u9762\u7ed3\u5408\u8fd9\u4e2a\u8f93\u51fa\u7ed3\u679c\u548cELF\u5b98\u65b9\u6587\u6863\u8fdb\u884c\u8be6\u7ec6\u7684\u5206\u6790\u3002 Section Header\u7684sh_offset\u6210\u5458\u548cELF Header\u7684e_shoff\u6210\u5458 \u4e0a\u8ff0\u8f93\u51fa\u7ed3\u679c\u6765\u770b\uff0cELF Header\u7684e_shoff\u7684\u6210\u5458\u7684\u503c520\uff0c\u5982\u4e0b\uff1a Start of section headers: 520 ( bytes into file ) \u8fd9\u8868\u540dsection header table\u4f4d\u4e8e\u8ddd\u79bb\u6587\u4ef6\u5176\u5b9e\u4f4d\u7f6e520\u5b57\u8282\u5904\u3002 \u518d\u6765\u5f00section header table\u7684\u5185\u5bb9\uff1a \u8282\u5934\uff1a [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 0 ] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1 ] .text PROGBITS 0000000000000000 00000040 0000000000000007 0000000000000000 AX 0 0 1 [ 2 ] .data PROGBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 3 ] .bss NOBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 4 ] .comment PROGBITS 0000000000000000 00000047 000000000000002e 0000000000000001 MS 0 0 1 [ 5 ] .note.GNU-stack PROGBITS 0000000000000000 00000075 0000000000000000 0000000000000000 0 0 1 [ 6 ] .eh_frame PROGBITS 0000000000000000 00000078 0000000000000038 0000000000000000 A 0 0 8 [ 7 ] .rela.eh_frame RELA 0000000000000000 000001f0 0000000000000018 0000000000000018 I 9 6 8 [ 8 ] .shstrtab STRTAB 0000000000000000 000000b0 0000000000000054 0000000000000000 0 0 1 [ 9 ] .symtab SYMTAB 0000000000000000 00000108 00000000000000d8 0000000000000018 10 8 8 [ 10 ] .strtab STRTAB 0000000000000000 000001e0 000000000000000c 0000000000000000 0 0 1 \u6211\u4eec\u770b\u770b.text section\u7684\u4f4d\u7f6e\uff0c\u5b83\u7684Offset\u503c\u4e3aox40\uff0c\u7ffb\u8bd1\u4e3a\u5341\u8fdb\u5236\u5c31\u662f64\uff0c\u4e5f\u5c31\u662f\u5b83\u7684\u4f4d\u7f6e\u662f\u8ddd\u79bb\u6587\u4ef6\u593464\u5b57\u8282\u5904\u3002ELF header\u7684\u5927\u5c0f\u662f64\u5b57\u8282\uff0c\u4e5f\u5c31\u662f.text section\u5c31\u7d27\u6328\u7740ELF header\u3002 Section Header\u7684sh_size \u8fd9\u4e2a\u5b57\u6bb5\u7528\u6765\u63cf\u8ff0\u8be5section\u7684\u5927\u5c0f\uff0c\u8fd8\u662f\u4ee5.text section\u4e3a\u4f8b\uff0c\u5b83\u7684\u5927\u5c0f\u662f7\u5b57\u8282\uff0c\u5982\u4e0b: [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 1 ] .text PROGBITS 0000000000000000 00000040 0000000000000007 0000000000000000 AX 0 0 1 Section Types \u4e0b\u9762\u6839\u636esection type\u5bf9\u8fd9\u4e9bsection\u8fdb\u884c\u5206\u6790\u3002 PROGBITS \u7c7b\u578b\u4e3aPROGBITS\u7684section\u5982\u4e0b\uff1a [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 0 ] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1 ] .text PROGBITS 0000000000000000 00000040 0000000000000007 0000000000000000 AX 0 0 1 [ 2 ] .data PROGBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 3 ] .bss NOBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 4 ] .comment PROGBITS 0000000000000000 00000047 000000000000002e 0000000000000001 MS 0 0 1 [ 5 ] .note.GNU-stack PROGBITS 0000000000000000 00000075 0000000000000000 0000000000000000 0 0 1 [ 6 ] .eh_frame PROGBITS 0000000000000000 00000078 0000000000000038 0000000000000000 A 0 0 8 \u53ef\u4ee5\u770b\u5230.data\u6bb5\uff0c.text\u6bb5\u90fd\u662f\u6ca1\u6709\u6570\u636e\u7684\u3002 ### SYMTAB\u548cDYNSYM \u7c7b\u578b\u4e3a\u8fd9\u4e24\u79cd\u7684section\u5982\u4e0b\uff1a [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 9 ] .symtab SYMTAB 0000000000000000 00000108 00000000000000d8 0000000000000018 10 8 8 \u6ce8\u610f\u4e00\u4e0b\u8be5section\u7684EntSize\u5b57\u6bb5\uff0c\u5176\u503c\u4e3a0X18\uff0cELF\u89c4\u8303\u6587\u6863\u4e2d\u5bf9\u8be5\u5b57\u6bb5\u7684\u89e3\u91ca\u5982\u4e0b: Some sections hold a table of fixed-size entries, such as a symbol table. For such a section, this member gives the size in bytes of each entry. The member contains 0 if the section does not hold a table of fixed-size entries. \u4e5f\u5c31\u662f\u8bf4\u5728.symtab\u4e2d\u6bcf\u4e00\u9879\u7684\u957f\u5ea6\u4e3a0x18\u4e2a\u5b57\u8282\u3002 \u8be5symbol table\u7684\u5185\u5bb9\u5982\u4e0b\uff1a Symbol table '.symtab' contains 9 entries: Num: Value Size Type Bind Vis Ndx Name 0 : 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1 : 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2 : 0000000000000000 0 SECTION LOCAL DEFAULT 1 3 : 0000000000000000 0 SECTION LOCAL DEFAULT 2 4 : 0000000000000000 0 SECTION LOCAL DEFAULT 3 5 : 0000000000000000 0 SECTION LOCAL DEFAULT 5 6 : 0000000000000000 0 SECTION LOCAL DEFAULT 6 7 : 0000000000000000 0 SECTION LOCAL DEFAULT 4 8 : 0000000000000000 7 FUNC GLOBAL DEFAULT 1 test_a RELA \u5c5e\u4e8e\u8be5\u7c7b\u7684section\u5982\u4e0b\uff1a [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 7 ] .rela.eh_frame RELA 0000000000000000 000001f0 0000000000000018 0000000000000018 I 9 6 8 \u8be5section\u7684\u5185\u5bb9\u5982\u4e0b\uff1a \u91cd\u5b9a\u4f4d\u8282 '.rela.eh_frame' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x1f0 \u542b\u6709 1 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 STRTAB \u5c5e\u4e8e\u8be5\u7c7b\u7684section\u5982\u4e0b: [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 8 ] .shstrtab STRTAB 0000000000000000 000000b0 0000000000000054 0000000000000000 0 0 1 [ 10 ] .strtab STRTAB 0000000000000000 000001e0 000000000000000c 0000000000000000 0 0 1 Section Attribute Flags \u770b\u4e86\u6587\u6863\u5bf9\u8fd9\u4e2a\u5b57\u6bb5\u7684\u89e3\u91ca\uff0c\u611f\u89c9\u8fd9\u4e2a\u5b57\u6bb5\u867d\u7136\u540d\u5b57\u6bd4\u8f83\u5c0f\uff0c\u6bd4\u8f83\u6ee1\u610f\u5b58\u5728\u611f\uff0c\u4f46\u662f\u5b83\u7684\u4f5c\u7528\u786e\u5b9e\u5f88\u5927\u7684\uff0c\u5b83\u548c\u7a0b\u5e8f\u7684\u6267\u884c\u5bc6\u5207\u76f8\u5173\u3002\u5b83\u7684\u53d6\u503c\u5982\u4e0b: W ( write ) A ( alloc ) X ( execute ) M ( merge ) S ( strings ) l ( large ) I ( info ) L ( link order ) G ( group ) T ( TLS ) E ( exclude ) x ( unknown ) O ( extra OS processing required ) o ( OS specific ) p ( processor specific )","title":"20180318"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections/#20180318","text":"\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u65b9\u5f0f\u6765\u89c2\u5bdfrelocatable file\u7684section\u4fe1\u606f\u3002\u7a0b\u5e8f\u5982\u4e0b: void test_a () //\u5b9a\u4e49\u51fd\u6570test_a { printf ( \"test_a\" ); return ; } \u53ea\u8fdb\u884c\u7f16\u8bd1\uff0c\u4e0d\u8fdb\u884c\u94fe\u63a5\uff0c\u8fd9\u6837\u5c31\u80fd\u591f\u751f\u6210relocatable file\uff0c\u547d\u4ee4\u5982\u4e0b\uff1a gcc -c a.c -o a.o \u73b0\u5728\u5c31\u53ef\u4ee5\u901a\u8fc7readelf\u547d\u4ee4\u6765\u67e5\u770b\u8fd9\u4e2arelocatable file\u4e86\uff0c\u547d\u4ee4\u5982\u4e0b: readelf -a a.o \u7a0b\u5e8f\u7684\u8f93\u51fa\uff0c\u5373\u5bf9\u8be5relocatable file\u7684\u89e3\u91ca\u5982\u4e0b\uff1a ELF \u5934\uff1a Magic\uff1a 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2 's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6) Machine: Advanced Micro Devices X86-64 Version: 0x1 \u5165\u53e3\u70b9\u5730\u5740\uff1a 0x0 \u7a0b\u5e8f\u5934\u8d77\u70b9\uff1a 0 (bytes into file) Start of section headers: 520 (bytes into file) \u6807\u5fd7\uff1a 0x0 \u672c\u5934\u7684\u5927\u5c0f\uff1a 64 (\u5b57\u8282) \u7a0b\u5e8f\u5934\u5927\u5c0f\uff1a 0 (\u5b57\u8282) Number of program headers: 0 \u8282\u5934\u5927\u5c0f\uff1a 64 (\u5b57\u8282) \u8282\u5934\u6570\u91cf\uff1a 11 \u5b57\u7b26\u4e32\u8868\u7d22\u5f15\u8282\u5934\uff1a 8 \u8282\u5934\uff1a [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000007 0000000000000000 AX 0 0 1 [ 2] .data PROGBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 3] .bss NOBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 4] .comment PROGBITS 0000000000000000 00000047 000000000000002e 0000000000000001 MS 0 0 1 [ 5] .note.GNU-stack PROGBITS 0000000000000000 00000075 0000000000000000 0000000000000000 0 0 1 [ 6] .eh_frame PROGBITS 0000000000000000 00000078 0000000000000038 0000000000000000 A 0 0 8 [ 7] .rela.eh_frame RELA 0000000000000000 000001f0 0000000000000018 0000000000000018 I 9 6 8 [ 8] .shstrtab STRTAB 0000000000000000 000000b0 0000000000000054 0000000000000000 0 0 1 [ 9] .symtab SYMTAB 0000000000000000 00000108 00000000000000d8 0000000000000018 10 8 8 [10] .strtab STRTAB 0000000000000000 000001e0 000000000000000c 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) There are no section groups in this file. \u672c\u6587\u4ef6\u4e2d\u6ca1\u6709\u7a0b\u5e8f\u5934\u3002 \u91cd\u5b9a\u4f4d\u8282 ' .rela.eh_frame ' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x1f0 \u542b\u6709 1 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported. Symbol table ' .symtab ' contains 9 entries: Num: Value Size Type Bind Vis Ndx Name 0 : 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1 : 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2 : 0000000000000000 0 SECTION LOCAL DEFAULT 1 3 : 0000000000000000 0 SECTION LOCAL DEFAULT 2 4 : 0000000000000000 0 SECTION LOCAL DEFAULT 3 5 : 0000000000000000 0 SECTION LOCAL DEFAULT 5 6 : 0000000000000000 0 SECTION LOCAL DEFAULT 6 7 : 0000000000000000 0 SECTION LOCAL DEFAULT 4 8 : 0000000000000000 7 FUNC GLOBAL DEFAULT 1 test_a No version information found in this file. \u4e0b\u9762\u7ed3\u5408\u8fd9\u4e2a\u8f93\u51fa\u7ed3\u679c\u548cELF\u5b98\u65b9\u6587\u6863\u8fdb\u884c\u8be6\u7ec6\u7684\u5206\u6790\u3002","title":"20180318"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections/#section#headersh_offsetelf#headere_shoff","text":"\u4e0a\u8ff0\u8f93\u51fa\u7ed3\u679c\u6765\u770b\uff0cELF Header\u7684e_shoff\u7684\u6210\u5458\u7684\u503c520\uff0c\u5982\u4e0b\uff1a Start of section headers: 520 ( bytes into file ) \u8fd9\u8868\u540dsection header table\u4f4d\u4e8e\u8ddd\u79bb\u6587\u4ef6\u5176\u5b9e\u4f4d\u7f6e520\u5b57\u8282\u5904\u3002 \u518d\u6765\u5f00section header table\u7684\u5185\u5bb9\uff1a \u8282\u5934\uff1a [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 0 ] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1 ] .text PROGBITS 0000000000000000 00000040 0000000000000007 0000000000000000 AX 0 0 1 [ 2 ] .data PROGBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 3 ] .bss NOBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 4 ] .comment PROGBITS 0000000000000000 00000047 000000000000002e 0000000000000001 MS 0 0 1 [ 5 ] .note.GNU-stack PROGBITS 0000000000000000 00000075 0000000000000000 0000000000000000 0 0 1 [ 6 ] .eh_frame PROGBITS 0000000000000000 00000078 0000000000000038 0000000000000000 A 0 0 8 [ 7 ] .rela.eh_frame RELA 0000000000000000 000001f0 0000000000000018 0000000000000018 I 9 6 8 [ 8 ] .shstrtab STRTAB 0000000000000000 000000b0 0000000000000054 0000000000000000 0 0 1 [ 9 ] .symtab SYMTAB 0000000000000000 00000108 00000000000000d8 0000000000000018 10 8 8 [ 10 ] .strtab STRTAB 0000000000000000 000001e0 000000000000000c 0000000000000000 0 0 1 \u6211\u4eec\u770b\u770b.text section\u7684\u4f4d\u7f6e\uff0c\u5b83\u7684Offset\u503c\u4e3aox40\uff0c\u7ffb\u8bd1\u4e3a\u5341\u8fdb\u5236\u5c31\u662f64\uff0c\u4e5f\u5c31\u662f\u5b83\u7684\u4f4d\u7f6e\u662f\u8ddd\u79bb\u6587\u4ef6\u593464\u5b57\u8282\u5904\u3002ELF header\u7684\u5927\u5c0f\u662f64\u5b57\u8282\uff0c\u4e5f\u5c31\u662f.text section\u5c31\u7d27\u6328\u7740ELF header\u3002","title":"Section Header\u7684sh_offset\u6210\u5458\u548cELF Header\u7684e_shoff\u6210\u5458"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections/#section#headersh_size","text":"\u8fd9\u4e2a\u5b57\u6bb5\u7528\u6765\u63cf\u8ff0\u8be5section\u7684\u5927\u5c0f\uff0c\u8fd8\u662f\u4ee5.text section\u4e3a\u4f8b\uff0c\u5b83\u7684\u5927\u5c0f\u662f7\u5b57\u8282\uff0c\u5982\u4e0b: [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 1 ] .text PROGBITS 0000000000000000 00000040 0000000000000007 0000000000000000 AX 0 0 1","title":"Section Header\u7684sh_size"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections/#section#types","text":"\u4e0b\u9762\u6839\u636esection type\u5bf9\u8fd9\u4e9bsection\u8fdb\u884c\u5206\u6790\u3002","title":"Section Types"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections/#progbits","text":"\u7c7b\u578b\u4e3aPROGBITS\u7684section\u5982\u4e0b\uff1a [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 0 ] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1 ] .text PROGBITS 0000000000000000 00000040 0000000000000007 0000000000000000 AX 0 0 1 [ 2 ] .data PROGBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 3 ] .bss NOBITS 0000000000000000 00000047 0000000000000000 0000000000000000 WA 0 0 1 [ 4 ] .comment PROGBITS 0000000000000000 00000047 000000000000002e 0000000000000001 MS 0 0 1 [ 5 ] .note.GNU-stack PROGBITS 0000000000000000 00000075 0000000000000000 0000000000000000 0 0 1 [ 6 ] .eh_frame PROGBITS 0000000000000000 00000078 0000000000000038 0000000000000000 A 0 0 8 \u53ef\u4ee5\u770b\u5230.data\u6bb5\uff0c.text\u6bb5\u90fd\u662f\u6ca1\u6709\u6570\u636e\u7684\u3002 ### SYMTAB\u548cDYNSYM \u7c7b\u578b\u4e3a\u8fd9\u4e24\u79cd\u7684section\u5982\u4e0b\uff1a [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 9 ] .symtab SYMTAB 0000000000000000 00000108 00000000000000d8 0000000000000018 10 8 8 \u6ce8\u610f\u4e00\u4e0b\u8be5section\u7684EntSize\u5b57\u6bb5\uff0c\u5176\u503c\u4e3a0X18\uff0cELF\u89c4\u8303\u6587\u6863\u4e2d\u5bf9\u8be5\u5b57\u6bb5\u7684\u89e3\u91ca\u5982\u4e0b: Some sections hold a table of fixed-size entries, such as a symbol table. For such a section, this member gives the size in bytes of each entry. The member contains 0 if the section does not hold a table of fixed-size entries. \u4e5f\u5c31\u662f\u8bf4\u5728.symtab\u4e2d\u6bcf\u4e00\u9879\u7684\u957f\u5ea6\u4e3a0x18\u4e2a\u5b57\u8282\u3002 \u8be5symbol table\u7684\u5185\u5bb9\u5982\u4e0b\uff1a Symbol table '.symtab' contains 9 entries: Num: Value Size Type Bind Vis Ndx Name 0 : 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1 : 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2 : 0000000000000000 0 SECTION LOCAL DEFAULT 1 3 : 0000000000000000 0 SECTION LOCAL DEFAULT 2 4 : 0000000000000000 0 SECTION LOCAL DEFAULT 3 5 : 0000000000000000 0 SECTION LOCAL DEFAULT 5 6 : 0000000000000000 0 SECTION LOCAL DEFAULT 6 7 : 0000000000000000 0 SECTION LOCAL DEFAULT 4 8 : 0000000000000000 7 FUNC GLOBAL DEFAULT 1 test_a","title":"PROGBITS"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections/#rela","text":"\u5c5e\u4e8e\u8be5\u7c7b\u7684section\u5982\u4e0b\uff1a [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 7 ] .rela.eh_frame RELA 0000000000000000 000001f0 0000000000000018 0000000000000018 I 9 6 8 \u8be5section\u7684\u5185\u5bb9\u5982\u4e0b\uff1a \u91cd\u5b9a\u4f4d\u8282 '.rela.eh_frame' \u4f4d\u4e8e\u504f\u79fb\u91cf 0x1f0 \u542b\u6709 1 \u4e2a\u6761\u76ee\uff1a Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0","title":"RELA"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections/#strtab","text":"\u5c5e\u4e8e\u8be5\u7c7b\u7684section\u5982\u4e0b: [ Nr ] Name Type Address Offset Size EntSize Flags Link Info Align [ 8 ] .shstrtab STRTAB 0000000000000000 000000b0 0000000000000054 0000000000000000 0 0 1 [ 10 ] .strtab STRTAB 0000000000000000 000001e0 000000000000000c 0000000000000000 0 0 1","title":"STRTAB"},{"location":"Programming/Object-file/ELF/draft/ELF-from-learn-cpp/sections/observe-elf-sections/#section#attribute#flags","text":"\u770b\u4e86\u6587\u6863\u5bf9\u8fd9\u4e2a\u5b57\u6bb5\u7684\u89e3\u91ca\uff0c\u611f\u89c9\u8fd9\u4e2a\u5b57\u6bb5\u867d\u7136\u540d\u5b57\u6bd4\u8f83\u5c0f\uff0c\u6bd4\u8f83\u6ee1\u610f\u5b58\u5728\u611f\uff0c\u4f46\u662f\u5b83\u7684\u4f5c\u7528\u786e\u5b9e\u5f88\u5927\u7684\uff0c\u5b83\u548c\u7a0b\u5e8f\u7684\u6267\u884c\u5bc6\u5207\u76f8\u5173\u3002\u5b83\u7684\u53d6\u503c\u5982\u4e0b: W ( write ) A ( alloc ) X ( execute ) M ( merge ) S ( strings ) l ( large ) I ( info ) L ( link order ) G ( group ) T ( TLS ) E ( exclude ) x ( unknown ) O ( extra OS processing required ) o ( OS specific ) p ( processor specific )","title":"Section Attribute Flags"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF/","text":"ELF cnblogs \u53ef\u6267\u884c\u6587\u4ef6\uff08ELF\uff09\u683c\u5f0f\u7684\u7406\u89e3 ELF(Executable and Linking Format)\u662f\u4e00\u79cd\u5bf9\u8c61\u6587\u4ef6\u7684\u683c\u5f0f\uff0c\u7528\u4e8e\u5b9a\u4e49\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u6587\u4ef6(Object files)\u4e2d\u90fd\u653e\u4e86\u4ec0\u4e48\u4e1c\u897f\u3001\u4ee5\u53ca\u90fd\u4ee5\u4ec0\u4e48\u6837\u7684\u683c\u5f0f\u53bb\u653e\u8fd9\u4e9b\u4e1c\u897f\u3002\u5b83\u81ea\u6700\u65e9\u5728 System V \u7cfb\u7edf\u4e0a\u51fa\u73b0\u540e\uff0c\u88ab xNIX \u4e16\u754c\u6240\u5e7f\u6cdb\u63a5\u53d7\uff0c\u4f5c\u4e3a\u7f3a\u7701\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u683c\u5f0f\u6765\u4f7f\u7528\u3002\u53ef\u4ee5\u8bf4\uff0cELF\u662f\u6784\u6210\u4f17\u591axNIX\u7cfb\u7edf\u7684\u57fa\u7840\u4e4b\u4e00\uff0c\u6240\u4ee5\u4f5c\u4e3a\u5d4c\u5165\u5f0fLinux\u7cfb\u7edf\u4e43\u81f3\u5185\u6838\u9a71\u52a8\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\uff0c\u4f60\u6700\u597d\u719f\u6089\u5e76\u638c\u63e1\u5b83\u3002 \u5176\u5b9e\uff0c\u5173\u4e8eELF\u8fd9\u4e2a\u4e3b\u9898\uff0c\u7f51\u7edc\u4e0a\u5df2\u7ecf\u6709\u76f8\u5f53\u591a\u7684\u6587\u7ae0\u5b58\u5728\uff0c\u4f46\u662f\u5176\u4ecb\u7ecd\u7684\u5185\u5bb9\u6bd4\u8f83\u5206\u6563\uff0c\u4f7f\u5f97\u521d\u5b66\u8005\u4e0d\u592a\u5bb9\u6613\u4ece\u4e2d\u5f97\u5230\u4e00\u4e2a\u7cfb\u7edf\u6027\u7684\u8ba4\u8bc6\u3002\u4e3a\u4e86\u5e2e\u52a9\u5927\u5bb6\u5b66\u4e60\uff0c\u6211\u8fd9\u91cc\u6253\u7b97\u5199\u4e00\u7cfb\u5217\u8fde\u8d2f\u7684\u6587\u7ae0\u6765\u4ecb\u7ecdELF\u4ee5\u53ca\u76f8\u5173\u7684\u5e94\u7528\u3002\u8fd9\u662f\u8fd9\u4e2a\u7cfb\u5217\u4e2d\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\uff0c\u4e3b\u8981\u662f\u901a\u8fc7\u4e0d\u540c\u5de5\u5177\u7684\u4f7f\u7528\u6765\u719f\u6089ELF\u6587\u4ef6\u7684\u5185\u90e8\u7ed3\u6784\u4ee5\u53ca\u76f8\u5173\u7684\u57fa\u672c\u6982\u5ff5\u3002\u540e\u9762\u7684\u6587\u7ae0\uff0c\u6211\u4eec\u4f1a\u4ecb\u7ecd\u5f88\u591a\u9ad8\u7ea7\u7684\u6982\u5ff5\u548c\u5e94\u7528\uff0c\u6bd4\u65b9\u52a8\u6001\u94fe\u63a5\u548c\u52a0\u8f7d\uff0c\u52a8\u6001\u5e93\u7684\u5f00\u53d1\uff0cC\u8bed\u8a00Main\u51fd\u6570\u662f\u88ab\u8c01\u4ee5\u53ca\u5982\u4f55\u88ab\u8c03\u7528\u7684\uff0cELF\u683c\u5f0f\u5728\u5185\u6838\u4e2d\u7684\u652f\u6301\uff0cLinux\u5185\u6838\u4e2d\u5bf9ELF section\u7684\u6269\u5c55\u4f7f\u7528\u7b49\u7b49\u3002 \u597d\u7684\uff0c\u5f00\u59cb\u6211\u4eec\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\u3002\u5728\u8be6\u7ec6\u8fdb\u5165\u6b63\u9898\u4e4b\u524d\uff0c\u5148\u7ed9\u5927\u5bb6\u4ecb\u7ecd\u4e00\u70b9ELF\u6587\u4ef6\u683c\u5f0f\u7684\u53c2\u8003\u8d44\u6599\u3002\u5728ELF\u683c\u5f0f\u51fa\u6765\u4e4b\u540e\uff0cTISC(Tool Interface Standard Committee)\u59d4\u5458\u4f1a\u5b9a\u4e49\u4e86\u4e00\u5957ELF\u6807\u51c6\u3002\u4f60\u53ef\u4ee5\u4ece\u8fd9\u91cc( http://refspecs.freestandards.org/elf/)\u627e\u5230\u8be6\u7ec6\u7684\u6807\u51c6\u6587\u6863 \u3002TISC\u59d4\u5458\u4f1a\u524d\u540e\u51fa\u4e86\u4e24\u4e2a\u7248\u672c\uff0cv1.1\u548cv1.2\u3002\u4e24\u4e2a\u7248\u672c\u5185\u5bb9\u4e0a\u5dee\u4e0d\u591a\uff0c\u4f46\u5c31\u53ef\u8bfb\u6027\u4e0a\u6765\u8bb2\uff0c\u6211\u8fd8\u662f\u63a8\u8350\u4f60\u8bfb v1.2\u7684\u3002\u56e0\u4e3a\u5728v1.2\u7248\u672c\u4e2d\uff0cTISC\u91cd\u65b0\u7ec4\u7ec7\u539f\u672c\u5728v1.1\u7248\u672c\u4e2d\u7684\u5185\u5bb9\uff0c\u5c06\u5b83\u4eec\u5206\u6210\u4e3a\u4e09\u4e2a\u90e8\u5206(books)\uff1a a) Book I \u4ecb\u7ecd\u4e86\u901a\u7528\u7684\u9002\u7528\u4e8e\u6240\u670932\u4f4d\u67b6\u6784\u5904\u7406\u5668\u7684ELF\u76f8\u5173\u5185\u5bb9 b) Book II \u4ecb\u7ecd\u4e86\u5904\u7406\u5668\u7279\u5b9a\u7684ELF\u76f8\u5173\u5185\u5bb9\uff0c\u8fd9\u91cc\u662f\u4ee5Intel x86 \u67b6\u6784\u5904\u7406\u5668\u4f5c\u4e3a\u4f8b\u5b50\u4ecb\u7ecd c) Book III \u4ecb\u7ecd\u4e86\u64cd\u4f5c\u7cfb\u7edf\u7279\u5b9a\u7684ELF\u76f8\u5173\u5185\u5bb9\uff0c\u8fd9\u91cc\u662f\u4ee5\u8fd0\u884c\u5728x86\u4e0a\u9762\u7684 UNIX System V.4 \u4f5c\u4e3a\u4f8b\u5b50\u4ecb\u7ecd \u503c\u5f97\u4e00\u8bf4\u7684\u662f\uff0c\u867d\u7136TISC\u662f\u4ee5x86\u4e3a\u4f8b\u5b50\u4ecb\u7ecdELF\u89c4\u8303\u7684\uff0c\u4f46\u662f\u5982\u679c\u4f60\u662f\u60f3\u77e5\u9053\u975ex86\u4e0b\u9762\u7684ELF\u5b9e\u73b0\u60c5\u51b5\uff0c\u90a3\u4e5f\u53ef\u4ee5\u5728http://refspecs.freestandards.org/elf/\u4e2d\u627e\u5230\u7279\u5b9a\u5904\u7406\u5668\u76f8\u5173\u7684Supplment\u6587\u6863\u3002\u6bd4\u65b9ARM\u76f8\u5173\u7684\uff0c\u6216\u8005MIPS\u76f8\u5173\u7684\u7b49\u7b49\u3002\u53e6\u5916\uff0c\u76f8\u6bd4\u8f83UNIX\u7cfb\u7edf\u7684\u53e6\u5916\u4e00\u4e2a\u5206\u652fBSD Unix\uff0cLinux\u7cfb\u7edf\u66f4\u9760\u8fd1 System V \u7cfb\u7edf\u3002\u6240\u4ee5\u5173\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7279\u5b9a\u7684ELF\u5185\u5bb9\uff0c\u4f60\u53ef\u4ee5\u76f4\u63a5\u53c2\u8003v1.2\u6807\u51c6\u4e2d\u7684\u5185\u5bb9\u3002 \u8fd9\u91cc\u591a\u8bf4\u4e9b\u5e9f\u8bdd\uff1a\u522b\u5fd8\u4e86 Linus \u5728\u5b9e\u73b0Linux\u7684\u7b2c\u4e00\u4e2a\u7248\u672c\u7684\u65f6\u5019\uff0c\u5c31\u662f\u770b\u4e86\u4ecb\u7ecdUnix\u5185\u90e8\u7ec6\u8282\u7684\u4e66\uff1a\u300aThe of the Unix Operating System\u300b\uff0c\u5f97\u5230\u5f88\u591a\u542f\u53d1\u3002\u8fd9\u672c\u4e66\u5bf9\u5e94\u7684\u64cd\u4f5c\u7cfb\u7edf\u662fSystem V \u7684\u7b2c\u4e8c\u4e2aRelease\u3002\u8fd9\u672c\u4e66\u4ecb\u7ecd\u4e86\u64cd\u4f5c\u7cfb\u7edf\u7684\u5f88\u591a\u8bbe\u8ba1\u89c2\u5ff5\uff0c\u5e76\u4e14\u884c\u6587\u7b80\u5355\u6613\u61c2\u3002\u6240\u4ee5\u867d\u7136\u73b0\u5728\u7684Linux\u4e5f\u5438\u53d6\u4e86\u5176\u4ed6\u5f88\u591aUnix\u53d8\u79cd\u7684\u8bbe\u8ba1\u7406\u5ff5\uff0c\u4f46\u662f\u5982\u679c\u4f60\u60f3\u7814\u7a76\u5b66\u4e60Linux\u5185\u6838\uff0c\u90a3\u8fd8\u662f\u4ee5\u770b\u8fd9\u672c\u4e66\u4f5c\u4e3a\u5f00\u59cb\u4e3a\u597d\u3002\u8fd9\u672c\u4e66\u4e5f\u662f\u6211\u5728\u63a5\u89e6Linux\u5185\u6838\u4e4b\u524d\u6240\u770b\u7684\u7b2c\u4e00\u672c\u4ecb\u7ecd\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e66\uff0c\u6240\u4ee5\u6211\u6781\u529b\u5411\u5927\u5bb6\u63a8\u8350\u3002 \u597d\u4e86\uff0c\u8fd8\u662f\u56de\u6765\u5f00\u59cb\u6211\u4eec\u7b2c\u4e00\u7bc7ELF\u4e3b\u9898\u76f8\u5173\u7684\u6587\u7ae0\u5427\u3002\u8fd9\u7bc7\u6587\u7ae0\u4e3b\u8981\u662f\u901a\u8fc7\u4f7f\u7528\u4e0d\u540c\u7684\u5de5\u5177\u6765\u5206\u6790\u5bf9\u8c61\u6587\u4ef6\uff0c\u6765\u4f7f\u4f60\u638c\u63e1ELF\u6587\u4ef6\u7684\u57fa\u672c\u683c\u5f0f\uff0c\u4ee5\u53ca\u4e86\u89e3\u76f8\u5173\u7684\u57fa\u672c\u6982\u5ff5\u3002\u4f60\u5728\u8bfb\u8fd9\u7bc7\u6587\u7ae0\u7684\u65f6\u5019\uff0c\u5e0c\u671b\u4f60\u5728\u7535\u8111\u4e0a\u5df2\u7ecf\u6253\u5f00\u4e86\u90a3\u4e2a v1.2 \u7248\u672c\u7684ELF\u89c4\u8303\uff0c\u5e76\u5bf9\u7167\u7740\u6587\u7ae0\u5185\u5bb9\u770b\u89c4\u8303\u91cc\u7684\u6587\u5b57\u3002 Object files\u5206\u7c7b \u9996\u5148\uff0c\u4f60\u9700\u8981\u77e5\u9053\u7684\u662f\u6240\u8c13\u5bf9\u8c61\u6587\u4ef6(Object files)\u6709\u4e09\u4e2a\u79cd\u7c7b\uff1a Relocatable file \u8fd9\u662f\u7531**\u6c47\u7f16\u5668**\u6c47\u7f16\u751f\u6210\u7684 .o \u6587\u4ef6\uff08\u53c2\u89c1 linux\u4e0b\u7f16\u8bd1\u7684\u6b65\u9aa4 \uff09\u3002\u540e\u9762\u7684\u94fe\u63a5\u5668(link editor)\u62ff\u4e00\u4e2a\u6216\u4e00\u4e9b Relocatable object files \u4f5c\u4e3a\u8f93\u5165\uff0c\u7ecf\u94fe\u63a5\u5904\u7406\u540e\uff0c\u751f\u6210\u4e00\u4e2a**\u53ef\u6267\u884c\u7684\u5bf9\u8c61\u6587\u4ef6 (Executable file)** \u6216\u8005\u4e00\u4e2a**\u53ef\u88ab\u5171\u4eab\u7684\u5bf9\u8c61\u6587\u4ef6(Shared object file)**\u3002\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 **ar \u5de5\u5177**\u5c06\u4f17\u591a\u7684 .o Relocatable object files \u5f52\u6863(archive)\u6210 .a \u9759\u6001\u5e93\u6587\u4ef6\u3002\u5982\u4f55\u4ea7\u751f Relocatable file\uff0c\u4f60\u5e94\u8be5\u5f88\u719f\u6089\u4e86\u3002\u53e6\u5916\uff0c\u53ef\u4ee5\u9884\u5148\u544a\u8bc9\u5927\u5bb6\u7684\u662f\u6211\u4eec\u7684\u5185\u6838\u53ef\u52a0\u8f7d\u6a21\u5757 .ko \u6587\u4ef6\u4e5f\u662f Relocatable object file\u3002 Executable file \u53ef\u6267\u884c\u7684\u5bf9\u8c61\u6587\u4ef6\uff0c\u8fd9\u6211\u4eec\u89c1\u7684\u591a\u4e86\u3002\u6587\u672c\u7f16\u8f91\u5668vi\u3001\u8c03\u5f0f\u7528\u7684\u5de5\u5177gdb\u3001\u64ad\u653emp3\u6b4c\u66f2\u7684\u8f6f\u4ef6mplayer\u7b49\u7b49\u90fd\u662fExecutable object file\u3002\u4f60\u5e94\u8be5\u5df2\u7ecf\u77e5\u9053\uff0c\u5728\u6211\u4eec\u7684 Linux \u7cfb\u7edf\u91cc\u9762\uff0c\u5b58\u5728\u4e24\u79cd\u53ef\u6267\u884c\u7684\u4e1c\u897f\u3002\u9664\u4e86\u8fd9\u91cc\u8bf4\u7684 Executable object file\uff0c\u53e6\u5916\u4e00\u79cd\u5c31\u662f\u53ef\u6267\u884c\u7684\u811a\u672c(\u5982shell\u811a\u672c)\u3002\u6ce8\u610f\u8fd9\u4e9b\u811a\u672c\u4e0d\u662f Executable object file\uff0c\u5b83\u4eec\u53ea\u662f\u6587\u672c\u6587\u4ef6\uff0c\u4f46\u662f\u6267\u884c\u8fd9\u4e9b\u811a\u672c\u6240\u7528\u7684\u89e3\u91ca\u5668\u5c31\u662f Executable object file\uff0c\u6bd4\u5982 bash shell \u7a0b\u5e8f\u3002 Shared object file \u53ef\u88ab\u5171\u4eab\u7684\u5bf9\u8c61\u6587\u4ef6\u5c31\u662f\u6240\u8c13\u7684**\u52a8\u6001\u5e93\u6587\u4ef6**\uff0c\u4e5f\u5373 .so \u6587\u4ef6\u3002\u5982\u679c\u62ff\u524d\u9762\u7684**\u9759\u6001\u5e93**\u6765\u751f\u6210\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u90a3\u6bcf\u4e2a\u751f\u6210\u7684**\u53ef\u6267\u884c\u7a0b\u5e8f**\u4e2d\u90fd\u4f1a\u6709\u4e00\u4efd\u5e93\u4ee3\u7801\u7684\u62f7\u8d1d\u3002\u5982\u679c\u5728\u78c1\u76d8\u4e2d\u5b58\u50a8\u8fd9\u4e9b\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u90a3\u5c31\u4f1a\u5360\u7528\u989d\u5916\u7684\u78c1\u76d8\u7a7a\u95f4\uff1b\u53e6\u5916\u5982\u679c\u62ff\u5b83\u4eec\u653e\u5230Linux\u7cfb\u7edf\u4e0a\u4e00\u8d77\u8fd0\u884c\uff0c\u4e5f\u4f1a\u6d6a\u8d39\u6389\u5b9d\u8d35\u7684\u7269\u7406\u5185\u5b58\u3002\u5982\u679c\u5c06\u9759\u6001\u5e93\u6362\u6210\u52a8\u6001\u5e93\uff0c\u90a3\u4e48\u8fd9\u4e9b\u95ee\u9898\u90fd\u4e0d\u4f1a\u51fa\u73b0\u3002\u52a8\u6001\u5e93\u5728\u53d1\u6325\u4f5c\u7528\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5fc5\u987b\u7ecf\u8fc7\u4e24\u4e2a\u6b65\u9aa4\uff1a a) \u94fe\u63a5\u7f16\u8f91\u5668(link editor\uff0c\u5373linux\u4e2d\u7684ld\u7a0b\u5e8f)\u62ff\u5b83\u548c\u5176\u4ed6Relocatable object file\u4ee5\u53ca\u5176\u4ed6shared object file\u4f5c\u4e3a\u8f93\u5165\uff0c\u7ecf\u94fe\u63a5\u5904\u7406\u540e\uff0c\u751f\u5b58\u53e6\u5916\u7684 shared object file \u6216\u8005 executable file\u3002 b) \u5728\u8fd0\u884c\u65f6\uff0c\u52a8\u6001\u94fe\u63a5\u5668(dynamic linker)\u62ff\u5b83\u548c\u4e00\u4e2aExecutable file\u4ee5\u53ca\u53e6\u5916\u4e00\u4e9b Shared object file \u6765\u4e00\u8d77\u5904\u7406\uff0c\u5728Linux\u7cfb\u7edf\u91cc\u9762\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u6620\u50cf\u3002","title":"ELF"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF/#elf","text":"","title":"ELF"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF/#cnblogs#elf","text":"ELF(Executable and Linking Format)\u662f\u4e00\u79cd\u5bf9\u8c61\u6587\u4ef6\u7684\u683c\u5f0f\uff0c\u7528\u4e8e\u5b9a\u4e49\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u6587\u4ef6(Object files)\u4e2d\u90fd\u653e\u4e86\u4ec0\u4e48\u4e1c\u897f\u3001\u4ee5\u53ca\u90fd\u4ee5\u4ec0\u4e48\u6837\u7684\u683c\u5f0f\u53bb\u653e\u8fd9\u4e9b\u4e1c\u897f\u3002\u5b83\u81ea\u6700\u65e9\u5728 System V \u7cfb\u7edf\u4e0a\u51fa\u73b0\u540e\uff0c\u88ab xNIX \u4e16\u754c\u6240\u5e7f\u6cdb\u63a5\u53d7\uff0c\u4f5c\u4e3a\u7f3a\u7701\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u683c\u5f0f\u6765\u4f7f\u7528\u3002\u53ef\u4ee5\u8bf4\uff0cELF\u662f\u6784\u6210\u4f17\u591axNIX\u7cfb\u7edf\u7684\u57fa\u7840\u4e4b\u4e00\uff0c\u6240\u4ee5\u4f5c\u4e3a\u5d4c\u5165\u5f0fLinux\u7cfb\u7edf\u4e43\u81f3\u5185\u6838\u9a71\u52a8\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\uff0c\u4f60\u6700\u597d\u719f\u6089\u5e76\u638c\u63e1\u5b83\u3002 \u5176\u5b9e\uff0c\u5173\u4e8eELF\u8fd9\u4e2a\u4e3b\u9898\uff0c\u7f51\u7edc\u4e0a\u5df2\u7ecf\u6709\u76f8\u5f53\u591a\u7684\u6587\u7ae0\u5b58\u5728\uff0c\u4f46\u662f\u5176\u4ecb\u7ecd\u7684\u5185\u5bb9\u6bd4\u8f83\u5206\u6563\uff0c\u4f7f\u5f97\u521d\u5b66\u8005\u4e0d\u592a\u5bb9\u6613\u4ece\u4e2d\u5f97\u5230\u4e00\u4e2a\u7cfb\u7edf\u6027\u7684\u8ba4\u8bc6\u3002\u4e3a\u4e86\u5e2e\u52a9\u5927\u5bb6\u5b66\u4e60\uff0c\u6211\u8fd9\u91cc\u6253\u7b97\u5199\u4e00\u7cfb\u5217\u8fde\u8d2f\u7684\u6587\u7ae0\u6765\u4ecb\u7ecdELF\u4ee5\u53ca\u76f8\u5173\u7684\u5e94\u7528\u3002\u8fd9\u662f\u8fd9\u4e2a\u7cfb\u5217\u4e2d\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\uff0c\u4e3b\u8981\u662f\u901a\u8fc7\u4e0d\u540c\u5de5\u5177\u7684\u4f7f\u7528\u6765\u719f\u6089ELF\u6587\u4ef6\u7684\u5185\u90e8\u7ed3\u6784\u4ee5\u53ca\u76f8\u5173\u7684\u57fa\u672c\u6982\u5ff5\u3002\u540e\u9762\u7684\u6587\u7ae0\uff0c\u6211\u4eec\u4f1a\u4ecb\u7ecd\u5f88\u591a\u9ad8\u7ea7\u7684\u6982\u5ff5\u548c\u5e94\u7528\uff0c\u6bd4\u65b9\u52a8\u6001\u94fe\u63a5\u548c\u52a0\u8f7d\uff0c\u52a8\u6001\u5e93\u7684\u5f00\u53d1\uff0cC\u8bed\u8a00Main\u51fd\u6570\u662f\u88ab\u8c01\u4ee5\u53ca\u5982\u4f55\u88ab\u8c03\u7528\u7684\uff0cELF\u683c\u5f0f\u5728\u5185\u6838\u4e2d\u7684\u652f\u6301\uff0cLinux\u5185\u6838\u4e2d\u5bf9ELF section\u7684\u6269\u5c55\u4f7f\u7528\u7b49\u7b49\u3002 \u597d\u7684\uff0c\u5f00\u59cb\u6211\u4eec\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\u3002\u5728\u8be6\u7ec6\u8fdb\u5165\u6b63\u9898\u4e4b\u524d\uff0c\u5148\u7ed9\u5927\u5bb6\u4ecb\u7ecd\u4e00\u70b9ELF\u6587\u4ef6\u683c\u5f0f\u7684\u53c2\u8003\u8d44\u6599\u3002\u5728ELF\u683c\u5f0f\u51fa\u6765\u4e4b\u540e\uff0cTISC(Tool Interface Standard Committee)\u59d4\u5458\u4f1a\u5b9a\u4e49\u4e86\u4e00\u5957ELF\u6807\u51c6\u3002\u4f60\u53ef\u4ee5\u4ece\u8fd9\u91cc( http://refspecs.freestandards.org/elf/)\u627e\u5230\u8be6\u7ec6\u7684\u6807\u51c6\u6587\u6863 \u3002TISC\u59d4\u5458\u4f1a\u524d\u540e\u51fa\u4e86\u4e24\u4e2a\u7248\u672c\uff0cv1.1\u548cv1.2\u3002\u4e24\u4e2a\u7248\u672c\u5185\u5bb9\u4e0a\u5dee\u4e0d\u591a\uff0c\u4f46\u5c31\u53ef\u8bfb\u6027\u4e0a\u6765\u8bb2\uff0c\u6211\u8fd8\u662f\u63a8\u8350\u4f60\u8bfb v1.2\u7684\u3002\u56e0\u4e3a\u5728v1.2\u7248\u672c\u4e2d\uff0cTISC\u91cd\u65b0\u7ec4\u7ec7\u539f\u672c\u5728v1.1\u7248\u672c\u4e2d\u7684\u5185\u5bb9\uff0c\u5c06\u5b83\u4eec\u5206\u6210\u4e3a\u4e09\u4e2a\u90e8\u5206(books)\uff1a a) Book I \u4ecb\u7ecd\u4e86\u901a\u7528\u7684\u9002\u7528\u4e8e\u6240\u670932\u4f4d\u67b6\u6784\u5904\u7406\u5668\u7684ELF\u76f8\u5173\u5185\u5bb9 b) Book II \u4ecb\u7ecd\u4e86\u5904\u7406\u5668\u7279\u5b9a\u7684ELF\u76f8\u5173\u5185\u5bb9\uff0c\u8fd9\u91cc\u662f\u4ee5Intel x86 \u67b6\u6784\u5904\u7406\u5668\u4f5c\u4e3a\u4f8b\u5b50\u4ecb\u7ecd c) Book III \u4ecb\u7ecd\u4e86\u64cd\u4f5c\u7cfb\u7edf\u7279\u5b9a\u7684ELF\u76f8\u5173\u5185\u5bb9\uff0c\u8fd9\u91cc\u662f\u4ee5\u8fd0\u884c\u5728x86\u4e0a\u9762\u7684 UNIX System V.4 \u4f5c\u4e3a\u4f8b\u5b50\u4ecb\u7ecd \u503c\u5f97\u4e00\u8bf4\u7684\u662f\uff0c\u867d\u7136TISC\u662f\u4ee5x86\u4e3a\u4f8b\u5b50\u4ecb\u7ecdELF\u89c4\u8303\u7684\uff0c\u4f46\u662f\u5982\u679c\u4f60\u662f\u60f3\u77e5\u9053\u975ex86\u4e0b\u9762\u7684ELF\u5b9e\u73b0\u60c5\u51b5\uff0c\u90a3\u4e5f\u53ef\u4ee5\u5728http://refspecs.freestandards.org/elf/\u4e2d\u627e\u5230\u7279\u5b9a\u5904\u7406\u5668\u76f8\u5173\u7684Supplment\u6587\u6863\u3002\u6bd4\u65b9ARM\u76f8\u5173\u7684\uff0c\u6216\u8005MIPS\u76f8\u5173\u7684\u7b49\u7b49\u3002\u53e6\u5916\uff0c\u76f8\u6bd4\u8f83UNIX\u7cfb\u7edf\u7684\u53e6\u5916\u4e00\u4e2a\u5206\u652fBSD Unix\uff0cLinux\u7cfb\u7edf\u66f4\u9760\u8fd1 System V \u7cfb\u7edf\u3002\u6240\u4ee5\u5173\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7279\u5b9a\u7684ELF\u5185\u5bb9\uff0c\u4f60\u53ef\u4ee5\u76f4\u63a5\u53c2\u8003v1.2\u6807\u51c6\u4e2d\u7684\u5185\u5bb9\u3002 \u8fd9\u91cc\u591a\u8bf4\u4e9b\u5e9f\u8bdd\uff1a\u522b\u5fd8\u4e86 Linus \u5728\u5b9e\u73b0Linux\u7684\u7b2c\u4e00\u4e2a\u7248\u672c\u7684\u65f6\u5019\uff0c\u5c31\u662f\u770b\u4e86\u4ecb\u7ecdUnix\u5185\u90e8\u7ec6\u8282\u7684\u4e66\uff1a\u300aThe of the Unix Operating System\u300b\uff0c\u5f97\u5230\u5f88\u591a\u542f\u53d1\u3002\u8fd9\u672c\u4e66\u5bf9\u5e94\u7684\u64cd\u4f5c\u7cfb\u7edf\u662fSystem V \u7684\u7b2c\u4e8c\u4e2aRelease\u3002\u8fd9\u672c\u4e66\u4ecb\u7ecd\u4e86\u64cd\u4f5c\u7cfb\u7edf\u7684\u5f88\u591a\u8bbe\u8ba1\u89c2\u5ff5\uff0c\u5e76\u4e14\u884c\u6587\u7b80\u5355\u6613\u61c2\u3002\u6240\u4ee5\u867d\u7136\u73b0\u5728\u7684Linux\u4e5f\u5438\u53d6\u4e86\u5176\u4ed6\u5f88\u591aUnix\u53d8\u79cd\u7684\u8bbe\u8ba1\u7406\u5ff5\uff0c\u4f46\u662f\u5982\u679c\u4f60\u60f3\u7814\u7a76\u5b66\u4e60Linux\u5185\u6838\uff0c\u90a3\u8fd8\u662f\u4ee5\u770b\u8fd9\u672c\u4e66\u4f5c\u4e3a\u5f00\u59cb\u4e3a\u597d\u3002\u8fd9\u672c\u4e66\u4e5f\u662f\u6211\u5728\u63a5\u89e6Linux\u5185\u6838\u4e4b\u524d\u6240\u770b\u7684\u7b2c\u4e00\u672c\u4ecb\u7ecd\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e66\uff0c\u6240\u4ee5\u6211\u6781\u529b\u5411\u5927\u5bb6\u63a8\u8350\u3002 \u597d\u4e86\uff0c\u8fd8\u662f\u56de\u6765\u5f00\u59cb\u6211\u4eec\u7b2c\u4e00\u7bc7ELF\u4e3b\u9898\u76f8\u5173\u7684\u6587\u7ae0\u5427\u3002\u8fd9\u7bc7\u6587\u7ae0\u4e3b\u8981\u662f\u901a\u8fc7\u4f7f\u7528\u4e0d\u540c\u7684\u5de5\u5177\u6765\u5206\u6790\u5bf9\u8c61\u6587\u4ef6\uff0c\u6765\u4f7f\u4f60\u638c\u63e1ELF\u6587\u4ef6\u7684\u57fa\u672c\u683c\u5f0f\uff0c\u4ee5\u53ca\u4e86\u89e3\u76f8\u5173\u7684\u57fa\u672c\u6982\u5ff5\u3002\u4f60\u5728\u8bfb\u8fd9\u7bc7\u6587\u7ae0\u7684\u65f6\u5019\uff0c\u5e0c\u671b\u4f60\u5728\u7535\u8111\u4e0a\u5df2\u7ecf\u6253\u5f00\u4e86\u90a3\u4e2a v1.2 \u7248\u672c\u7684ELF\u89c4\u8303\uff0c\u5e76\u5bf9\u7167\u7740\u6587\u7ae0\u5185\u5bb9\u770b\u89c4\u8303\u91cc\u7684\u6587\u5b57\u3002","title":"cnblogs \u53ef\u6267\u884c\u6587\u4ef6\uff08ELF\uff09\u683c\u5f0f\u7684\u7406\u89e3"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF/#object#files","text":"\u9996\u5148\uff0c\u4f60\u9700\u8981\u77e5\u9053\u7684\u662f\u6240\u8c13\u5bf9\u8c61\u6587\u4ef6(Object files)\u6709\u4e09\u4e2a\u79cd\u7c7b\uff1a","title":"Object files\u5206\u7c7b"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF/#relocatable#file","text":"\u8fd9\u662f\u7531**\u6c47\u7f16\u5668**\u6c47\u7f16\u751f\u6210\u7684 .o \u6587\u4ef6\uff08\u53c2\u89c1 linux\u4e0b\u7f16\u8bd1\u7684\u6b65\u9aa4 \uff09\u3002\u540e\u9762\u7684\u94fe\u63a5\u5668(link editor)\u62ff\u4e00\u4e2a\u6216\u4e00\u4e9b Relocatable object files \u4f5c\u4e3a\u8f93\u5165\uff0c\u7ecf\u94fe\u63a5\u5904\u7406\u540e\uff0c\u751f\u6210\u4e00\u4e2a**\u53ef\u6267\u884c\u7684\u5bf9\u8c61\u6587\u4ef6 (Executable file)** \u6216\u8005\u4e00\u4e2a**\u53ef\u88ab\u5171\u4eab\u7684\u5bf9\u8c61\u6587\u4ef6(Shared object file)**\u3002\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 **ar \u5de5\u5177**\u5c06\u4f17\u591a\u7684 .o Relocatable object files \u5f52\u6863(archive)\u6210 .a \u9759\u6001\u5e93\u6587\u4ef6\u3002\u5982\u4f55\u4ea7\u751f Relocatable file\uff0c\u4f60\u5e94\u8be5\u5f88\u719f\u6089\u4e86\u3002\u53e6\u5916\uff0c\u53ef\u4ee5\u9884\u5148\u544a\u8bc9\u5927\u5bb6\u7684\u662f\u6211\u4eec\u7684\u5185\u6838\u53ef\u52a0\u8f7d\u6a21\u5757 .ko \u6587\u4ef6\u4e5f\u662f Relocatable object file\u3002","title":"Relocatable file"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF/#executable#file","text":"\u53ef\u6267\u884c\u7684\u5bf9\u8c61\u6587\u4ef6\uff0c\u8fd9\u6211\u4eec\u89c1\u7684\u591a\u4e86\u3002\u6587\u672c\u7f16\u8f91\u5668vi\u3001\u8c03\u5f0f\u7528\u7684\u5de5\u5177gdb\u3001\u64ad\u653emp3\u6b4c\u66f2\u7684\u8f6f\u4ef6mplayer\u7b49\u7b49\u90fd\u662fExecutable object file\u3002\u4f60\u5e94\u8be5\u5df2\u7ecf\u77e5\u9053\uff0c\u5728\u6211\u4eec\u7684 Linux \u7cfb\u7edf\u91cc\u9762\uff0c\u5b58\u5728\u4e24\u79cd\u53ef\u6267\u884c\u7684\u4e1c\u897f\u3002\u9664\u4e86\u8fd9\u91cc\u8bf4\u7684 Executable object file\uff0c\u53e6\u5916\u4e00\u79cd\u5c31\u662f\u53ef\u6267\u884c\u7684\u811a\u672c(\u5982shell\u811a\u672c)\u3002\u6ce8\u610f\u8fd9\u4e9b\u811a\u672c\u4e0d\u662f Executable object file\uff0c\u5b83\u4eec\u53ea\u662f\u6587\u672c\u6587\u4ef6\uff0c\u4f46\u662f\u6267\u884c\u8fd9\u4e9b\u811a\u672c\u6240\u7528\u7684\u89e3\u91ca\u5668\u5c31\u662f Executable object file\uff0c\u6bd4\u5982 bash shell \u7a0b\u5e8f\u3002","title":"Executable file"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF/#shared#object#file","text":"\u53ef\u88ab\u5171\u4eab\u7684\u5bf9\u8c61\u6587\u4ef6\u5c31\u662f\u6240\u8c13\u7684**\u52a8\u6001\u5e93\u6587\u4ef6**\uff0c\u4e5f\u5373 .so \u6587\u4ef6\u3002\u5982\u679c\u62ff\u524d\u9762\u7684**\u9759\u6001\u5e93**\u6765\u751f\u6210\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u90a3\u6bcf\u4e2a\u751f\u6210\u7684**\u53ef\u6267\u884c\u7a0b\u5e8f**\u4e2d\u90fd\u4f1a\u6709\u4e00\u4efd\u5e93\u4ee3\u7801\u7684\u62f7\u8d1d\u3002\u5982\u679c\u5728\u78c1\u76d8\u4e2d\u5b58\u50a8\u8fd9\u4e9b\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u90a3\u5c31\u4f1a\u5360\u7528\u989d\u5916\u7684\u78c1\u76d8\u7a7a\u95f4\uff1b\u53e6\u5916\u5982\u679c\u62ff\u5b83\u4eec\u653e\u5230Linux\u7cfb\u7edf\u4e0a\u4e00\u8d77\u8fd0\u884c\uff0c\u4e5f\u4f1a\u6d6a\u8d39\u6389\u5b9d\u8d35\u7684\u7269\u7406\u5185\u5b58\u3002\u5982\u679c\u5c06\u9759\u6001\u5e93\u6362\u6210\u52a8\u6001\u5e93\uff0c\u90a3\u4e48\u8fd9\u4e9b\u95ee\u9898\u90fd\u4e0d\u4f1a\u51fa\u73b0\u3002\u52a8\u6001\u5e93\u5728\u53d1\u6325\u4f5c\u7528\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5fc5\u987b\u7ecf\u8fc7\u4e24\u4e2a\u6b65\u9aa4\uff1a a) \u94fe\u63a5\u7f16\u8f91\u5668(link editor\uff0c\u5373linux\u4e2d\u7684ld\u7a0b\u5e8f)\u62ff\u5b83\u548c\u5176\u4ed6Relocatable object file\u4ee5\u53ca\u5176\u4ed6shared object file\u4f5c\u4e3a\u8f93\u5165\uff0c\u7ecf\u94fe\u63a5\u5904\u7406\u540e\uff0c\u751f\u5b58\u53e6\u5916\u7684 shared object file \u6216\u8005 executable file\u3002 b) \u5728\u8fd0\u884c\u65f6\uff0c\u52a8\u6001\u94fe\u63a5\u5668(dynamic linker)\u62ff\u5b83\u548c\u4e00\u4e2aExecutable file\u4ee5\u53ca\u53e6\u5916\u4e00\u4e9b Shared object file \u6765\u4e00\u8d77\u5904\u7406\uff0c\u5728Linux\u7cfb\u7edf\u91cc\u9762\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u6620\u50cf\u3002","title":"Shared object file"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/bss/","text":"\u9996\u5148\u770b\u4e00\u4e2a\u5c0f\u4f8b\u5b50\uff0c\u6211\u5728\u67e5\u627e\u8fd9\u4e2a\u95ee\u9898\u7684\u65f6\u5019\u53d1\u73b0\u7684\uff1a http://bbs.chinaunix.net/thread-1719587-1-1.html \u5173\u4e8ebss\u6bb5\uff0c\u8bf7\u6559\u4e2a\u95ee\u9898\uff0c\u5b83\u662f\u4e0d\u662f\u5e76\u4e0d\u5360\u7528\u53ef\u6267\u884c\u7a0b\u5e8f\u7684\u786c\u76d8\u7a7a\u95f4\uff1f hello.c\u6587\u4ef6\u5185\u5bb9\u5982\u4e0b 1. #include 2. int main() 3. { 4. return 0; 5. } \u590d\u5236\u4ee3\u7801 \u7f16\u8bd1\u540e [root @localhost ctest]# ll hello -rwxr-xr-x 1 root root 4613 06-10 16:06 hello [root @localhost ctest]# size hello text data bss dec hex filename 803 248 8 1059 423 hello \u53ef\u89c1\u8fd9\u65f6hello\u7684\u5927\u5c0f\u4e3a 4613\u5b57\u8282\uff0c\u7528size\u53bb\u770bhello\uff0c\u5176bss\u6bb5\u4e3a8\u5b57\u8282 \u7136\u540e\u4fee\u6539\u4ee3\u7801\uff0c\u586b\u4e0a\u4e00\u884c int bss[1000]; (\u8be5\u6570\u7ec4\u5728\u8fd0\u884c\u65f6\u5e94\u53604000\u5b57\u8282 \uff09 1. #include 2. 3. int bss[1000];//\u8fd9\u884c\u662f\u589e\u52a0\u7684\uff0c\u5b83\u5e94\u4f4d\u4e8ebss\u6bb5 4. 5. int main() 6. { 7. return 0; 8. } \u590d\u5236\u4ee3\u7801 [root @localhost ctest]# ll hello -rwxr-xr-x 1 root root 4633 06-10 16:07 hello [root @localhost ctest]# size hello text data bss dec hex filename 803 248 4032 5083 13db hello \u53d1\u73b0hello\u7684\u5927\u5c0f\u53d8\u4e3a4633,\u6bd44613\u589e\u52a0\u4e8620\u5b57\u8282\uff0c\u800c\u4e0d\u662f\u589e\u52a0\u4e864000\u5b57\u8282\uff0c\u8fd9\u5e94\u8be5\u5c31\u8bf4\u660e\u4e86bss\u6bb5\u7684\u6570\u636e\u5e76\u4e0d\u5360\u7528\u53ef\u6267\u884c\u6587\u4ef6\u7684\u7a7a\u95f4\u5427\uff1f \u4f46\u5947\u602a\u7684\u662f \u7b2c\u4e8c\u6b21\u5bf9hello\u6267\u884csize\u547d\u4ee4\u65f6\uff0c \u5176bss\u6bb5\u5927\u5c0f\u53d8\u4e3a4032,\u800c\u7b2c\u4e00\u6b21\u65f6\u662f8 \u7b2c\u4e00\u6b21 [root @localhost ctest]# size hello text data bss dec hex filename 803 248 8 1059 423 hello \u7b2c\u4e8c\u6b21 [root @localhost ctest]# size hello text data bss dec hex filename 803 248 4032 5083 13db hello \u5b9e\u9645\u4e0ahello\u4ec5\u589e\u52a0\u4e8620\u5b57\u8282 \uff0c\u662f\u4e0d\u662fsize\u547d\u4ee4\u5f97\u5230\u7684bss\u6bb5\u7684\u5927\u5c0f\u662f\u6307\u7a0b\u5e8f\u8fd0\u884c\u540e\uff0c\u6620\u5c04\u5230\u865a\u62df\u5185\u5b58\u7a7a\u95f4\u540e\uff0cbss\u6bb5\u5b9e\u9645\u6240\u5360\u7a7a\u95f4\u7684\u5927\u5c0f\uff1f\u800c\u4e0d\u662f\u8bf4\u5728\u786c\u76d8\u4e0a\u7684\u5927\u5c0f\uff1f \u8fd9\u6837\u7406\u89e3\u5bf9\u4e48\uff1f","title":"Bss"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81/","text":"","title":"\u4f4d\u7f6e\u65e0\u5173\u4ee3\u7801"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/","text":"Book I:Executable and Linking Format (ELF) Introduction\u4ecb\u7ecd \u8fd9\u4e00\u8282\u63cf\u8ff0object file\u7684\u683c\u5f0f\uff0c\u5b83\u88ab\u79f0\u4e3aELF(Executable and Linking Format).\u4e3b\u8981\u6709\u4e09\u79cd\u7c7b\u578b\u7684object file\uff1a relocatable file**\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6\uff1a\u8fd9\u79cd\u7c7b\u578b\u7684\u6587\u4ef6\u7528\u4e8e\u4fdd\u5b58\u4e0e\u5176\u4ed6object file**\u94fe\u63a5**\u4ee5\u521b\u5efa**executable object file**\u53ef\u6267\u884c\u6587\u4ef6\u6216**shared object file**\u53ef\u5171\u4eab\u5bf9\u8c61\u6587\u4ef6\u7684**\u4ee3\u7801**\u548c**\u6570\u636e \u3002\u6709link editor\u6765\u5b9e\u73b0\u94fe\u63a5\u3002 **executable file**\u53ef\u6267\u884c\u6587\u4ef6\uff1a\u4fdd\u5b58\u9002\u5408\u4e8e\u6267\u884c\u7684\u7a0b\u5e8f\u3002 shared object file**\u53ef\u5171\u4eab\u5bf9\u8c61\u6587\u4ef6\uff1a\u7528\u4e8e\u4fdd\u5b58\u9002\u4e8e\u5728\u4e24\u79cd\u4e0a\u4e0b\u6587\u73af\u5883\u4e2d\u8fdb\u884c\u94fe\u63a5\u7684\u4ee3\u7801\u548c\u6570\u636e\u3002\u7b2c\u4e00\u79cd\uff0c**link editor**\u94fe\u63a5\u7f16\u8f91\u5668\u53ef\u4ee5**link**\u94fe\u63a5\u5b83\u548c\u5176\u4ed6**relocatable object file\u53ef\u91cd\u5b9a\u4f4d\u6216**shared** object file\u53ef\u5171\u4eab\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684object file\u3002\u7b2c\u4e8c\u79cd\uff0c**dynamic linker**\u52a8\u6001\u94fe\u63a5\u5668\u5c06\u5b83\u4e0e**executable file**\u53ef\u6267\u884c\u6587\u4ef6\u548c\u5176\u4ed6**shared objects**\u53ef\u5171\u4eab\u5bf9\u8c61\u8fdb\u884c\u7ec4\u5408\u6765\u521b\u5efa\u8fc7\u7a0b\u6620\u50cf\u3002 **object file**\u7531**assembler**\u6c47\u7f16\u5668\u548c**link editor**\u94fe\u63a5\u7f16\u8f91\u5668\u521b\u5efa\uff0c\u5b83\u662f\u80fd\u591f\u76f4\u63a5\u5728\u5904\u7406\u5668\u4e0a\u6267\u884c\u7684\u7a0b\u5e8f\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u3002 \u5728\u4ecb\u7ecd\u4e4b\u540e\uff0c\u672c\u7ae0\u91cd\u70b9\u4ecb\u7ecdobject file\u4ee5\u53ca\u5b83\u4e0e\u6784\u5efa\u7a0b\u5e8f\u7684\u5173\u7cfb\u3002\u7b2c2\u7ae0\u4e5f\u63cf\u8ff0\u4e86object file\u7684\u90e8\u5206\u5185\u5bb9\uff0c\u96c6\u4e2d\u4ecb\u7ecd\u4e8e\u6267\u884c\u7a0b\u5e8f\u6240\u9700\u7684\u4fe1\u606f\u3002 Object File\u7684\u683c\u5f0f **object file**\u53ef\u4ee5\u53c2\u4e0e\u7a0b\u5e8f\u94fe\u63a5\uff08\u6784\u5efa\u7a0b\u5e8f\uff09\u548c\u7a0b\u5e8f\u6267\u884c\uff08\u8fd0\u884c\u7a0b\u5e8f\uff09\u3002\u4e3a\u4e86\u65b9\u4fbf\u548c\u9ad8\u6548\uff0c**object file**\u7684\u683c\u5f0f\u540c\u65f6\u63d0\u4f9b\u4e86\u5c55\u793a\u6587\u4ef6\u5185\u5bb9\u7684\u4e24\u79cd\u89c6\u56fe\uff1a \u94fe\u63a5\u89c6\u56fe \u6267\u884c\u89c6\u56fe \u4f7f\u7528\u4e24\u79cd\u89c6\u56fe\u662f\u4e3a\u4e86\u6ee1\u8db3\u8fd9\u4e24\u79cd\u6d3b\u52a8\uff08\u6784\u5efa\u7a0b\u5e8f\u548c\u8fd0\u884c\u7a0b\u5e8f\uff09\u7684\u4e0d\u540c\u9700\u6c42\u3002\u5982\u56fe1-1\u6240\u793a\u4e00\u4e2a**object file**\u7684\u7ec4\u7ec7\u3002 ELF header ELF header**\u4f4d\u4e8eobject file\u7684\u5f00\u59cb\u5904\uff0c\u5b83\u4fdd\u5b58\u63cf\u8ff0**object file**\u7684\u7ec4\u7ec7\u7ed3\u6784\u7684\u201c\u8def\u7ebf\u56fe\u201d\u3002**Section**\u5305\u542b\u7528\u4e8e**\u94fe\u63a5\u89c6\u56fe**\u7684\u4fe1\u606f\uff1a\u6307\u4ee4Section (instructions)\uff0c\u6570\u636eSection (data)\uff0c\u7b26\u53f7\u8868Section (symbol table)\uff0c\u91cd\u5b9a\u4f4d\u4fe1\u606fSection (relocation information)\uff0c\u7b49\u7b49\u3002\u672c\u8282\u540e\u9762\u5bf9\u5404\u4e2aSection\u8fdb\u884c\u8be6\u7ec6\u63cf\u8ff0\u3002\u7b2c\u4e8c\u7ae0\u4e5f\u5c06\u4ecb\u7ecd\u5404\u4e2aSegments\u548cobject file\u7684**\u6267\u884c\u89c6\u56fe \u3002 program header table \u7a0b\u5e8f\u5934\u8868\uff08program header table\uff09\uff08\u5982\u679c\u5b58\u5728\u7684\u8bdd\uff09\u544a\u8bc9\u7cfb\u7edf\u5982\u4f55\u521b\u5efa\u8fdb\u7a0b\u6620\u50cf\u3002\u7528\u4e8e\u6784\u5efa\u8fdb\u7a0b\u6620\u50cf\u7684object file\uff08\u6267\u884c\u7a0b\u5e8f\uff09\u5fc5\u987b\u6709\u7a0b\u5e8f\u5934\u8868\uff08program header table\uff09\u3002\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6\uff08relocatable file\uff09\u5219\u5e76\u4e0d\u9700\u8981\u7a0b\u5e8f\u5934\u8868\uff08program header table\uff09\u3002 section header table section header table\u5305\u542b\u63cf\u8ff0\u5404\u4e2asection\u7684\u4fe1\u606f\u3002\u6bcf\u4e2asection\u5728section header table\u4e2d\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684**\u6761\u76ee**\uff08\u76f8\u5f53\u4e8e\u4e00\u6761\u8bb0\u5f55\uff09; \u6bcf\u4e2a\u6761\u76ee\u7ed9\u51fa\u8be5section\u7684\u540d\u79f0\uff0c\u5927\u5c0f\u7b49\u4fe1\u606f\u3002\u7528\u4e8e**\u94fe\u63a5**\u671f\u95f4\u4f7f\u7528\u7684object file\u5fc5\u987b\u5177\u6709section header table; \u5176\u4ed6object file\u53ef\u80fd\u6709\u4e5f\u53ef\u80fd\u6ca1\u6709\u3002 NOTE\u3002\u867d\u7136\u56fe\u4e2d\u663e\u793a\u4e86program header table\u4f4d\u4e8eELF header\u7684\u540e\u9762\uff0csection header table\u4f4d\u4e8e\u5404section\u7684\u540e\u9762\uff0c\u5b9e\u9645\u7684\u76ee\u6807\u6587\u4ef6\u8fd9\u51e0\u4e2a\u90e8\u5206\u7684\u987a\u5e8f\u5173\u7cfb\u53ef\u80fd\u4e0e\u4e0a\u56fe\u4e2d\u5c55\u793a\u7684\u4e0d\u540c\uff0c\u53ef\u4ee5\u786e\u5b9a\u7684\u662fELF header\u4e00\u5b9a\u4f4d\u4e8e\u6587\u4ef6\u7684\u5934\u90e8\u3002 Data Representation\u6570\u636e\u8868\u793a \u5982\u8fd9\u91cc\u6240\u63cf\u8ff0\u7684\uff0cobject file\u7684\u683c\u5f0f\u652f\u6301\u5177\u67098\u4f4d\u5b57\u8282\u548c32\u4f4d\u67b6\u6784\u7684\u5404\u79cd\u5904\u7406\u5668\u3002\u7136\u800c\uff0c\u5b83\u65e8\u5728\u53ef\u6269\u5c55\u5230\u66f4\u5927\uff08\u6216\u66f4\u5c0f\uff09\u7684\u67b6\u6784\u3002\u56e0\u6b64\uff0cobject file\u4f7f\u7528**\u4e0e\u673a\u5668\u65e0\u5173**\u7684\u683c\u5f0f\u6765\u8868\u793a\u5b83\u7684**control data**\uff0c\u4f7f\u5f97\u53ef\u4ee5\u4ee5**\u901a\u7528\u65b9\u5f0f**\u6765\u8bc6\u522bobject file\u5e76\u89e3\u91ca\u5176\u5185\u5bb9\u3002object file\u4e2d\u7684\u5269\u4f59\u6570\u636e\u4f7f\u7528**\u76ee\u6807\u5904\u7406\u5668**\u7684\u7f16\u7801\uff0c\u800c\u4e0d\u7528\u8003\u8651\u521b\u5efa\u8be5object file\u7684\u8ba1\u7b97\u673a\u3002\u8fd9\u6837\u5728A\u673a\u5668\u4e0a\u521b\u5efa\u7684object file\u5c31\u53ef\u4ee5\u62ff\u5230B\u673a\u5668\u4e0a\u8fdb\u884c\u8fd0\u884c\u6216\u94fe\u63a5\uff0c\u5373\u4f7fA\u4e0eB\u7684\u67b6\u6784\u4e0d\u76f8\u540c\u3002 object file\u683c\u5f0f\u5b9a\u4e49\u7684\u6240\u6709\u6570\u636e\u7ed3\u6784\u90fd\u9075\u5faa\u76f8\u5173\u7c7b\u7684\u201c\u81ea\u7136\u201d\u5927\u5c0f\u548c\u5bf9\u9f50\u51c6\u5219\u3002\u5982\u679c\u5fc5\u8981\uff0c\u6570\u636e\u7ed3\u6784\u5305\u542b\u663e\u5f0f\u586b\u5145\uff0c\u4ee5\u786e\u4fdd4\u5b57\u8282\u5bf9\u8c61\u76844\u5b57\u8282\u5bf9\u9f50\uff0832\u4f4d\u5904\u7406\u5668\u4e00\u6b21\u8bfb\u53d632\u4f4d\uff09\uff0c\u5c06\u7ed3\u6784\u5927\u5c0f\u5f3a\u5236\u4e3a4\u7684\u500d\u6570\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\u6570\u636e\u4e5f\u4ece\u6587\u4ef6\u7684\u5f00\u5934\u5177\u6709\u9002\u5f53\u7684\u5bf9\u9f50\u3002\u56e0\u6b64\uff0c\u4f8b\u5982\uff0c\u5305\u542bElf32_Addr\u6210\u5458\u7684\u7ed3\u6784\u5c06\u5728\u6587\u4ef6\u5185\u76844\u5b57\u8282\u8fb9\u754c\u4e0a\u5bf9\u9f50\u3002 \u51fa\u4e8e\u53ef\u79fb\u690d\u6027\u7684\u539f\u56e0\uff0cELF\u4e0d\u4f7f\u7528\u4f4d\u5b57\u6bb5\u3002 Character Representations\u5b57\u7b26\u8868\u793a \u672c\u8282\u4ecb\u7ecdELF\u9ed8\u8ba4\u7684\u5b57\u7b26\u8868\u793a\uff0c\u5e76\u4e3a\u80fd\u591f\u5728\u4e0d\u540c\u7cfb\u7edf\u4e4b\u95f4\u79fb\u690d\u7684\u5916\u90e8\u6587\u4ef6\u5b9a\u4e49\u6807\u51c6\u5b57\u7b26\u96c6\u3002\u4e00\u4e9b\u5916\u90e8\u6587\u4ef6\u683c\u5f0f\u4f7f\u7528\u5b57\u7b26\u6765\u8868\u793a\u63a7\u5236\u4fe1\u606f\u3002\u8fd9\u4e9b\u5355\u5b57\u8282\u5b57\u7b26\u4f7f\u75287\u4f4dASCII\u5b57\u7b26\u96c6\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5f53ELF\u63a5\u53e3\u6587\u6863\u63d0\u5230**\u5b57\u7b26\u5e38\u91cf**\uff0c\u4f8b\u5982'/'\u6216' n'\u65f6\uff0c\u5b83\u4eec\u7684**\u6570\u503c**\u5e94\u9075\u5faa7\u4f4dASCII\u7801\u3002\u5bf9\u4e8e\u524d\u9762\u7684\u5b57\u7b26\u5e38\u91cf\uff0c\u5355\u5b57\u8282\u503c\u5c06\u662f47 \u548c10\u3002 \u6839\u636e\u5b57\u7b26\u7f16\u7801\uff0c0\u5230127\u8303\u56f4\u4e4b\u5916\u7684\u5b57\u7b26\u503c\u53ef\u80fd\u5360\u7528\u4e00\u4e2a\u6216\u591a\u4e2a\u5b57\u8282\u3002\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5bf9\u4e0d\u540c\u7684\u8bed\u8a00\u4f7f\u7528\u4e0d\u540c\u7684\u5b57\u7b26\u96c6\u6269\u5c55\u6765\u63a7\u5236\u5b83\u7684\u5b57\u7b26\u96c6\u3002\u867d\u7136TIS-conformance\u4e0d\u9650\u5236\u5b57\u7b26\u96c6\uff0c\u4f46\u5b83\u4eec\u901a\u5e38\u5e94\u9075\u5faa\u4e00\u4e9b\u7b80\u5355\u7684\u51c6\u5219\uff1a 0\u5230127\u4e4b\u95f4\u7684\u5b57\u7b26\u503c\u5e94\u5bf9\u5e94\u4e8e7\u4f4dASCII\u7801\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5177\u6709\u9ad8\u4e8e127\u7684\u7f16\u7801\u7684\u5b57\u7b26\u96c6\u5e94\u8be5\u5c06\u76847\u4f4dASCII\u7801\u4f5c\u4e3a\u5b50\u96c6\u3002 \u503c\u5927\u4e8e127\u7684\u591a\u5b57\u8282\u5b57\u7b26\u7f16\u7801\u5e94\u8be5\u53ea\u5305\u542b\u503c\u57280\u5230127\u8303\u56f4\u4e4b\u5916\u7684\u5b57\u8282\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u6bcf\u4e2a\u5b57\u7b26\u4f7f\u7528\u591a\u4e2a\u5b57\u8282\u7684\u5b57\u7b26\u96c6\u4e0d\u5e94\u8be5\u201c\u5d4c\u5165\u201d\u7c7b\u4f3c\u4e8e7\u4f4dASCII\u5b57\u7b26\u7684\u5b57\u8282\u5728\u4e00\u4e2a\u591a\u5b57\u8282\uff0c\u975eASCII\u5b57\u7b26\u5185\u3002 \u591a\u5b57\u8282\u5b57\u7b26\u5e94\u8be5\u662f\u81ea\u8bc6\u522b\u7684\u3002 \u8fd9\u5141\u8bb8\u4f8b\u5982\u5728\u4efb\u4f55\u591a\u5b57\u8282\u5b57\u7b26\u5bf9\u4e4b\u95f4\u63d2\u5165\u4efb\u4f55\u591a\u5b57\u8282\u5b57\u7b26\uff0c\u800c\u4e0d\u6539\u53d8\u5b57\u7b26\u7684\u89e3\u91ca\u3002 \u8fd9\u4e9b\u6ce8\u610f\u4e8b\u9879\u4e0e\u591a\u8bed\u8a00\u5e94\u7528\u7a0b\u5e8f\u7279\u522b\u76f8\u5173\u3002 ELF Header \u6839\u636e\u8be5\u7ed3\u6784\u4e2d\u5404\u4e2a\u53d8\u91cf\u7684\u547d\u540d\u5176\u5b9e\u90fd\u53ef\u4ee5\u63a8\u65ad\u51fa\u8fd9\u4e9b\u53d8\u91cf\u5404\u81ea\u7684\u542b\u4e49\uff0cident\u5bf9\u5e94\u7684\u662fidentity\uff0c\u5373\u6807\u8bc6\uff0c\u540e\u9762\u4f1a\u8fdb\u884c\u5177\u4f53\u7684\u63cf\u8ff0\u3002e_entry\u5373\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740\uff0ce_phoff\u7684\u542b\u4e49\u9700\u8981\u62c6\u89e3\u5f00\u6765\uff0cph\u5373program header table\uff0coff\u5373offset\uff0c\u504f\u79fb\u91cf\uff1be_shoff\u7684\u5206\u89e3\u548ce_phoff\u7c7b\u4f3c\uff0csh\u5373section header table\uff0coff\u5373offset\uff0c\u504f\u79fb\u91cf\uff1be_phentsize\u7684\u542b\u4e49\u4e5f\u9700\u8981\u62c6\u89e3\u5f00\u6765\u8fdb\u884c\u4e86\u89e3\uff0cph\u5373program header table\uff0cent\u5373entity\uff0c\u6761\u76ee\uff0csize\u5373\u5927\u5c0f\uff0c\u90a3\u4e48\u8fd9\u4e2a\u53d8\u91cf\u7684\u542b\u4e49\u5c31\u597d\u7406\u89e3\u4e86\uff0c\u5b83\u7528\u6765\u6807\u8bc6program header table\u4e2d\u4e00\u4e2a\u6761\u76ee\u7684\u5927\u5c0f\u3002e_phnum\u5373program header entity number\uff0c\u8868\u793aprogram header table\u4e2d\u8bb0\u5f55\u7684\u4e2a\u6570\u3002e_ehsize\u7684\u542b\u4e49\u662fELF header size\uff0c\u5373ELF header\u7684\u5927\u5c0f\u3002 1. e_ident object file\u7684\u521d\u59cb\u5b57\u8282\u4e3b\u8981\u7528\u4e8e\u5c06\u6587\u4ef6\u6807\u8bb0\u4e3aobject file\uff0c\u5e76\u63d0\u4f9b\u4e0e\u673a\u5668\u65e0\u5173\u7684\u6570\u636e\uff0c\u7528\u4e8e\u89e3\u7801\u548c\u89e3\u91ca\u6587\u4ef6\u7684\u5185\u5bb9\u3002\u5b8c\u6574\u7684\u63cf\u8ff0\u663e\u793a\u5728\u4e0b\u9762\u7684\u201cELF Identification\u201d\u7ae0\u8282\u3002 2. e_type \u6b64\u6210\u5458\u6807\u8bc6\u5bf9\u8c61\u6587\u4ef6\u7684\u7c7b\u578b\u3002 \u867d\u7136Core\u6587\u4ef6\u7684\u5185\u5bb9\u672a\u6307\u5b9a\uff0c\u4f46\u4fdd\u7559\u7c7b\u578bET_CORE\u4ee5\u6807\u8bb0\u8fd9\u79cd\u6587\u4ef6\u7c7b\u578b\u3002\u4eceET_LOPROC\u5230ET_HIPROC\uff08\u5305\u62ec\uff09\u7684\u503c\u4fdd\u7559\u7528\u4e8e\u5904\u7406\u5668\u7279\u5b9a\u7684\u8bed\u4e49\u3002\u4fdd\u7559\u5176\u4ed6\u503c\uff0c\u5e76\u6839\u636e\u9700\u8981\u5c06\u5176\u5206\u914d\u7ed9\u65b0\u7684\u5bf9\u8c61\u6587\u4ef6\u7c7b\u578b\u3002 3. e_machine \u6b64\u6210\u5458\u7684\u503c\u6307\u5b9a\u5355\u4e2a\u6587\u4ef6\u6240\u9700\u7684CPU\u4f53\u7cfb\u7ed3\u6784\u3002 \u4fdd\u7559\u5176\u4ed6\u503c\uff0c\u5e76\u6839\u636e\u9700\u8981\u5c06\u5176\u5206\u914d\u7ed9\u65b0\u8ba1\u7b97\u673a\u3002\u7279\u5b9a\u4e8e\u5904\u7406\u5668\u7684ELF\u540d\u79f0\u4f7f\u7528\u8ba1\u7b97\u673a\u540d\u79f0\u6765\u533a\u5206\u5b83\u4eec\u3002\u4f8b\u5982\uff0c\u4e0b\u9762\u63d0\u5230\u7684\u6807\u5fd7\u4f7f\u7528\u524d\u7f00EF_; \u4e00\u4e2a\u540d\u4e3aWIDGET\u7684\u6807\u5fd7 EM_XYZ\u673a\u5668\u5c06\u88ab\u79f0\u4e3aEF_XYZ_WIDGET\u3002 4. e_version \u6b64\u6210\u5458\u6807\u8bc6\u5bf9\u8c61\u6587\u4ef6\u7248\u672c\u3002 \u503c1\u8868\u793a\u539f\u59cb\u6587\u4ef6\u683c\u5f0f; \u6269\u5c55\u5c06\u521b\u5efa\u5177\u6709\u66f4\u9ad8\u6570\u5b57\u7684\u65b0\u7248\u672c\u3002 EV_CURRENT\u7684\u503c\uff0c\u5c3d\u7ba1\u5728\u4e0a\u9762\u7ed9\u51fa\u4e3a1\uff0c\u5c06\u6839\u636e\u9700\u8981\u66f4\u6539\u4ee5\u53cd\u6620\u5f53\u524d\u7248\u672c\u53f7\u3002 5. e_entry \u8be5\u6210\u5458\u7ed9\u51fa\u7cfb\u7edf\u9996\u6b21\u4f20\u8f93\u63a7\u5236\u7684\u865a\u62df\u5730\u5740\uff0c\u4ece\u800c\u542f\u52a8\u8fdb\u7a0b\u3002 \u5982\u679c\u6587\u4ef6\u6ca1\u6709\u5173\u8054\u7684\u5165\u53e3\u70b9\uff08entrypoint\uff09\uff0c\u5219\u6b64\u6210\u5458\u4fdd\u5b58\u4e3a\u96f6\u3002 6. e_phoff \u8be5\u6210\u5458\u4fdd\u5b58program header table\u7684\u6587\u4ef6\u504f\u79fb\u91cf\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002\u5982\u679c\u6587\u4ef6\u6ca1\u6709program header table\uff0c\u5219\u6b64\u6210\u5458\u4fdd\u5b58\u4e3a\u96f6\u3002 7. e_shoff \u8be5\u6210\u5458\u4fdd\u5b58section header table\u7684\u6587\u4ef6\u504f\u79fb\u91cf\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002 \u5982\u679c\u6587\u4ef6\u6ca1\u6709sectionheader table\uff0c\u5219\u6b64\u6210\u5458\u4fdd\u5b58\u4e3a\u96f6\u3002 8. e_flags \u6b64\u6210\u5458\u4fdd\u5b58\u4e0e\u6587\u4ef6\u76f8\u5173\u8054\u7684\u5904\u7406\u5668\u7279\u5b9a\u6807\u5fd7\u3002 \u6807\u5fd7\u540d\u7684\u683c\u5f0f\u4e3aEF_machine_flag\u3002 9. e_ehsize \u8be5\u6210\u5458\u4fdd\u5b58ELF\u5934\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002 10. e_phentsize \u8be5\u6210\u5458\u4fdd\u5b58\u6587\u4ef6\u7a0b\u5e8f\u5934\u8868\uff08programheader table\uff09\u4e2d\u4e00\u4e2a\u6761\u76ee\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09;\u6240\u6709\u6761\u76ee\u7684\u5927\u5c0f\u76f8\u540c\u3002 11. e_phnum \u6b64\u6210\u5458\u4fdd\u5b58\u7a0b\u5e8f\u5934\u8868\uff08programheader table\uff09\u4e2d\u7684\u6761\u76ee\u6570\u3002\u56e0\u6b64\uff0ce_phentsize\u548ce_phnum\u7684\u4e58\u79ef\u7ed9\u51fa\u4e86program header table\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002\u5982\u679c\u6587\u4ef6\u6ca1\u6709program header table\uff0ce_phnum\u4fdd\u6301\u503c\u4e3a\u96f6\u3002 12. e_shentsize \u8be5\u6210\u5458\u4fdd\u5b58\u6bb5\u5934section header\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002 \u6bb5\u5934sectionheader\u662fsection header table\u4e2d\u7684\u4e00\u4e2a\u6761\u76ee; \u6240\u6709\u6761\u76ee\u7684\u5927\u5c0f\u76f8\u540c\u3002 13. e_shnum \u6b64\u6210\u5458\u4fdd\u5b58section headertable\u4e2d\u7684\u6761\u76ee\u6570\u3002\u56e0\u6b64\uff0ce_shentsize\u548ce_shnum\u7684\u4e58\u79ef\u7ed9\u51fa\u4e86section header table\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002\u5982\u679c\u6587\u4ef6\u6ca1\u6709section header table\uff0ce_shnum\u4fdd\u6301\u503c\u4e3a\u96f6\u3002 14. e_shstrndx \u6b64\u6210\u5458\u4fdd\u5b58\u4e0e\u8282\u540d\u79f0\u5b57\u7b26\u4e32\u8868\uff08section name string table\uff09\u76f8\u5173\u8054\u7684\u6761\u76ee\u5728\u8282\u6807\u9898\u8868\uff08section header table\uff09\u4e2d\u7684\u7d22\u5f15\u503c\u3002\u5982\u679c\u6587\u4ef6\u6ca1\u6709\u8282\u540d\u79f0\u5b57\u7b26\u4e32\u8868\uff08section name string table\uff09\uff0c\u5219\u6b64\u6210\u5458\u4fdd\u5b58\u503cSHN_UNDEF\u3002 \u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684\u201cSections\u201d\u548c\u201cStringTable\u201d\u7ae0\u8282\u3002 ELF Identification \u5982\u4e0a\u6240\u8ff0\uff0cELF\u63d0\u4f9b\u4e86\u4e00\u4e2aobject file\u6846\u67b6\u6765\u652f\u6301\u591a\u79cd\u5904\u7406\u5668\uff0c\u591a\u79cd\u6570\u636e\u7f16\u7801\u548c\u591a\u7c7b\u673a\u5668\u3002\u4e3a\u4e86\u652f\u6301\u8be5object file family\uff0c\u67d0\u4e2aobject file\u7684\u521d\u59cb\u5b57\u8282\u6307\u5b9a\u5982\u4f55\u89e3\u91ca\u8be5\u6587\u4ef6\uff0c\u8fd9\u51e0\u4e2a\u5b57\u8282\u7684\u5185\u5bb9\u72ec\u7acb\u4e8e\u8fdb\u884c\u67e5\u8be2\u7684\u5904\u7406\u5668\uff0c\u5e76\u4e14\u72ec\u7acb\u4e8e\u6587\u4ef6\u7684\u5269\u4f59\u5185\u5bb9\u3002ELF header\u7684\u521d\u59cb\u5b57\u8282\u5bf9\u5e94\u4e8ee_ident\u6210\u5458\uff0c\u4ece\u4e0a\u9762ELF Header\u7684\u63cf\u8ff0\u6765\u770b\uff0ce_ident\u662f\u4e00\u4e2a\u957f\u5ea6\u4e3a16\u5b57\u8282\u7684\u6570\u7ec4\u3002\u56fe1-4\u5c55\u793a\u4e86\u8be5\u6570\u7ec4\u7684\u5404\u4e2a\u7d22\u5f15\u7684\u540d\u79f0\u548c\u6570\u7ec4\u4e2d\u8be5\u4f4d\u7f6e\u7684\u7528\u9014\u3002 \u8fd9\u4e9b\u7d22\u5f15\u8bbf\u95ee\u5305\u542b\u4ee5\u4e0b\u503c\u7684\u5b57\u8282\u3002 EI_MAG0\u5230EI_MAG3 \u6587\u4ef6\u7684\u524d4\u4e2a\u5b57\u8282\u7ec4\u5408\u8d77\u6765\u8868\u793a\u6587\u4ef6\u7684\u201cmagicnumber\u201d\uff0c\u5c06\u8be5\u6587\u4ef6\u6807\u8bc6\u4e3aELF\u5bf9\u8c61\u6587\u4ef6\u3002 EI_CLASS \u4e0b\u4e00\u4e2a\u5b57\u8282e_ident [EI_CLASS]\u6807\u8bc6\u6587\u4ef6\u7684\u7c7b\u6216\u5bb9\u91cf\u3002 Sections object file\u7684section header table\uff08\u6bb5\u5934\u8868\uff09\u5141\u8bb8\u5b9a\u4f4d\u8be5\u6587\u4ef6\u6240\u6709\u7684section\u6bb5\u3002section header table\uff08\u6bb5\u5934\u8868\uff09\u662f\u5982\u4e0b\u6240\u8ff0\u7684Elf32_Shdr\u7ed3\u6784\u7684\u6570\u7ec4\uff0csectionheader table\u7684\u7d22\u5f15\u662f\u8fd9\u4e2a\u6570\u7ec4\u7684\u4e0b\u6807\u3002ELF header\u7684e_shoff\u6210\u5458\u7ed9\u51fa\u4ece\u6587\u4ef6\u5f00\u5934\u5230section header table\u7684\u5b57\u8282\u504f\u79fb; e_shnum\u544a\u8bc9section header table\u5305\u542b\u591a\u5c11\u6761\u76ee; e_shentsize\u7ed9\u51fa\u6bcf\u4e2a\u6761\u76ee\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002 SHN_UNDEF SHN_LORESERVE \u6b64\u503c\u6307\u5b9a\u4fdd\u7559\u7d22\u5f15\u8303\u56f4\u7684\u4e0b\u9650\u503c\u3002 SHN_LOPROC through SHN_HIPROC \u5728SHN_LOPROC\u5230SHN_HIPROC\u8303\u56f4\u4e2d\u7684\u503c\u4e3a\u5904\u7406\u5668\u7279\u5b9a\u7684\u8bed\u4e49\u6240\u4fdd\u7559\u3002 SHN_ABS \u6b64\u503c\u6307\u5b9a\u76f8\u5e94\u5f15\u7528\u7684\u7edd\u5bf9\u503c\u3002\u4f8b\u5982\uff0c\u76f8\u5bf9\u4e8esection\u53f7SHN_ABS\u5b9a\u4e49\u7684\u7b26\u53f7\u5177\u6709\u7edd\u5bf9\u503c\uff0c\u5e76\u4e14\u4e0d\u53d7\u91cd\u5b9a\u4f4d\u7684\u5f71\u54cd\u3002 SHN_COMMON \u76f8\u5bf9\u4e8e\u6b64section\u5b9a\u4e49\u7684symbols\u7b26\u53f7\u662fcommon symbols,\u5e38\u7528\u7b26\u53f7\uff0c\u4f8b\u5982FORTRAN \u8bed\u8a00\u4e2d\u7684COMMON\u6216C\u8bed\u8a00\u4e2d\u672a\u5206\u914d\u7684\u5916\u90e8\u53d8\u91cf\u3002 SHN_HIRESERVE \u6b64\u503c\u6307\u5b9areserved indexes\u4fdd\u7559\u7d22\u5f15\u8303\u56f4\u7684\u4e0a\u9650\u3002\u7cfb\u7edf\u4fdd\u7559SHN_LORESERVE\u548cSHN_HIRESERVE\u4e4b\u95f4\u7684\u7d22\u5f15\uff0c\u5305\u62ec; \u8fd9\u4e9b\u503c\u4e0d\u88absection header table\u6bb5\u5934\u8868\u5f15\u7528\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u6bb5\u5934\u8868\u4e0d\u5305\u542b\u4fdd\u7559\u7d22\u5f15\u7684\u6761\u76ee\u3002 \u5728\u76ee\u6807\u6587\u4ef6\u4e2d\uff0c\u9664\u4e86ELF\u5934\uff0cprogram header table\u7a0b\u5e8f\u5934\u8868\u548csection header table\u6bb5\u5934\u8868\uff0c\u5176\u5b83\u8282\u7684\u6240\u6709\u4fe1\u606f\u5305\u542b\u5728section\u4e2d\u3002\u6b64\u5916\uff0c\u76ee\u6807\u6587\u4ef6\u6bb5\u6ee1\u8db3\u51e0\u4e2a\u6761\u4ef6\u3002 l \u5bf9\u8c61\u6587\u4ef6\u4e2d\u7684\u6bcf\u4e2a\u8282\u90fd\u6709\u4e00\u4e2a\u63cf\u8ff0\u5b83\u7684section header\u8282\u5934\u3002\u53ef\u80fd\u5b58\u5728\u6ca1\u6709section\u7684section header\u3002 l \u6bcf\u4e2asection\u5360\u636e\u6587\u4ef6\u4e2d\u7684\u4e00\u4e2a\u8fde\u7eed\uff08\u53ef\u80fd\u4e3a\u7a7a\uff09\u5b57\u8282\u5e8f\u5217\u3002 l \u6587\u4ef6\u4e2d\u7684section\u4e0d\u80fd\u91cd\u53e0\u3002 \u6587\u4ef6\u4e2d\u6ca1\u6709\u5b57\u8282\u9a7b\u7559\u5728\u591a\u4e2asection\u4e2d\u3002 l \u5bf9\u8c61\u6587\u4ef6\u53ef\u80fd\u5177\u6709inactivespace\u672a\u4f7f\u7528\u7684\u7a7a\u95f4\u3002\u5404\u79cdheader\u5934\u548csection\u53ef\u80fd\u4e0d\u4f1a\u201c\u8986\u76d6\u201d\u76ee\u6807\u6587\u4ef6\u4e2d\u7684\u6bcf\u4e2a\u5b57\u8282\u3002\u672a\u4f7f\u7528\u7684\u7a7a\u95f4\u7684\u6570\u636e\u7684\u5185\u5bb9\u662f\u672a\u6307\u5b9a\u7684\u3002 Section header\u7684\u7ed3\u6784\u5982\u4e0b\uff1a sh_name \u6b64\u6210\u5458\u6307\u5b9asection\u7684\u540d\u79f0\u3002\u5b83\u7684\u503c\u662fsection header string table section\u7684\u7d22\u5f15[\u89c1\u4e0b\u9762\u7684\u201c\u5b57\u7b26\u4e32\u8868\u201d\uff09\uff0c\u7ed9\u51fa\u4e00\u4e2a\u4ee5null\u7ed3\u675f\u7684\u5b57\u7b26\u4e32\u7684\u4f4d\u7f6e\u3002 sh_type \u6b64\u6210\u5458\u5bf9section\u7684content\u5185\u5bb9\u548csemantic\u8bed\u4e49\u8fdb\u884c\u5206\u7c7b\u3002Section\u7c7b\u578b\u53ca\u5176\u8bf4\u660e\u5982\u4e0b\u6240\u793a\u3002 Special Sections String Table \u672c\u8282\u4ecb\u7ecdstring table\u5b57\u7b26\u4e32\u8868\u3002string table\u5b57\u7b26\u4e32\u8868\u6bb5\u4fdd\u5b58\u4ee5\u7a7a\u5b57\u7b26\u7ec8\u6b62\u7684\u5b57\u7b26\u5e8f\u5217\uff0c\u901a\u5e38\u79f0\u4e3astring\u5b57\u7b26\u4e32\u3002object file\u4f7f\u7528\u8fd9\u4e9bstring\u5b57\u7b26\u4e32\u6765\u8868\u793asymbol\u548csection name\u3002\u901a\u8fc7string table section\u7684\u4e0b\u6807\u6765\u5f15\u7528\u4e00\u4e2a\u5c06\u5b57\u7b26\u4e32\u3002 \u7b2c\u4e00\u4e2a\u5b57\u8282\uff0c\u5373\u7d22\u5f15\u4e3a\u96f6\uff0c\u5b9a\u4e49\u4e3a\u4fdd\u5b58\u4e00\u4e2a\u7a7a\u5b57\u7b26\u3002\u540c\u6837\uff0cstring table\u5b57\u7b26\u4e32\u8868\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u88ab\u5b9a\u4e49\u4e3a\u4fdd\u6301\u4e00\u4e2a\u7a7a\u5b57\u7b26\uff0c\u786e\u4fdd\u6240\u6709\u5b57\u7b26\u4e32\u7684\u4ee5\u7a7a\u5b57\u7b26\u7ec8\u6b62\u3002\u7d22\u5f15\u4e3a\u96f6\u7684**\u5b57\u7b26\u4e32**\u6307\u5b9a\u65e0\u540d\u79f0\u6216\u7a7a\u540d\u79f0\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u4e0a\u4e0b\u6587\u3002\u5141\u8bb8\u4f7f\u7528\u7a7a\u7684string table section\u5b57\u7b26\u4e32\u8868\u90e8\u5206; \u5b83\u7684section header\u6bb5\u5934\u7684sh_size\u6210\u5458\u5c06\u4e3a\u96f6\u3002\u975e\u96f6\u7d22\u5f15\u5bf9\u4e8e\u7a7astring table section\u65e0\u6548\u3002 section header\u7684sh_name\u6210\u5458\u8868\u793a\u8be5section\u7684\u540d\u79f0\uff0c\u5b83\u7684\u503c\u662f\u4e00\u4e2a\u7d22\u5f15\uff0c\u8868\u793a\u8be5section\u7684\u540d\u79f0\u5728section name string table\u4e2d\u7684\u7d22\u5f15\u503c\uff0csection namestring table\u5728section header\u7684\u7d22\u5f15\u503c\uff08\u4f4d\u7f6e\uff09\u7531ELF\u5934\u90e8\u7684e_shstrndx\u6210\u5458\u6307\u5b9a\u3002\u4e0b\u56fe\u663e\u793a\u4e86\u5177\u670925\u4e2a\u5b57\u8282\u7684\u5b57\u7b26\u4e32\u8868\u4ee5\u53ca\u4e0e\u5404\u79cd\u7d22\u5f15\u5173\u8054\u7684\u5b57\u7b26\u4e32\u3002 \u5982\u793a\u4f8b\u6240\u793a\uff0cstring table index\u5b57\u7b26\u4e32\u8868\u7d22\u5f15\u53ef\u4ee5\u5f15\u7528section\u6bb5\u4e2d\u7684\u4efb\u4f55\u5b57\u8282\u3002\u5b57\u7b26\u4e32\u53ef\u80fd\u51fa\u73b0\u591a\u6b21; \u53ef\u80fd\u5b58\u5728\u5bf9\u5b50\u5b57\u7b26\u7684\u5f15\u7528; \u5e76\u4e14\u5355\u4e2a\u5b57\u7b26\u4e32\u53ef\u4ee5\u88ab\u5f15\u7528\u591a\u6b21\u3002\u8fd8\u5141\u8bb8\u672a\u88ab\u5f15\u7528\u7684\u5b57\u7b26\u4e32\u3002 \u5728\u7a0b\u5e8f\u4e2d\u5b9a\u4e49\u7684\u51fd\u6570\u540d\u79f0\uff0c\u53d8\u91cf\u540d\u79f0\u5c31\u5305\u542b\u5728\u6b64section\u4e2d\uff0csymbol table\u662f\u5bf9\u8fd9\u4e9b\u5b57\u7b26\u4e32\u7684\u89e3\u91ca\u3002\u5176\u4ed6section\u662f\u901a\u8fc7index\u6765\u5f15\u7528string section\u4e2d\u7684 \u5b57\u7b26\u4e32\u7684\u3002 Symbol Table object file\u7684symbol table\u5305\u542b\u9700\u8981\u88ab\u5b9a\u4f4d\u548c\u91cd\u5b9a\u4f4d\u7684\u4fe1\u606f\uff08\u7a0b\u5e8f\u7b26\u53f7\u5b9a\u4e49\u548c\u5f15\u7528\uff09\uff0c\u4e00\u4e2a\u7b26\u53f7\u8868\u7d22\u5f15\u662f\u8fd9\u4e2a\u6570\u7ec4\u7684\u4e0b\u6807\u3002\u7d22\u5f150\u6307\u5b9a\u4e86\u8868\u7684\u7b2c\u4e00\u4e2a\u5165\u53e3\uff0c\u5145\u5f53\u672a\u5b9a\u4e49\u7b26\u53f7\u7d22\u5f15\u3002\u8fd9\u4e2a\u521d\u59cb\u5316\u5165\u53e3\u7684\u5185\u5bb9\u4f1a\u5728\u672c\u8282\u540e\u9762\u90e8\u5206\u6307\u5b9a\u3002 \u7b26\u53f7\u8868\u6761\u76ee\u7684\u683c\u5f0f\u5982\u4e0b\uff1a st_name \u6b64\u6210\u5458\u7684\u503c\u662f\u5728object file\u7684symbol string table\u4e2d\u7684\u7d22\u5f15\uff0csymbol string table\u4fdd\u5b58\u4e86symbol\u7684\u5b57\u7b26\u8868\u793a\u3002 st_value \u8be5\u6210\u5458\u7ed9\u51fa\u4e86\u76f8\u5173\u8054\u7684symbol\u7684\u503c\u3002\u4e00\u4e2asymbol\u7684\u503c\u53ef\u4ee5\u662f\u662fabsolute value\uff0c\u5730\u5740\u7b49\u7b49\uff0c\u5b83\u7684\u503c\u53d6\u51b3\u4e8e\u4e0a\u4e0b\u6587\u3002 \u5173\u4e8esymbol\u7684\u503c\u8be6\u7ec6\u4fe1\u606f\u4f1a\u5728\u4e0b\u9762\u8fdb\u884c\u89e3\u91ca\u3002 st_size \u8bb8\u591asymbol\u5177\u6709\u5927\u5c0f\u3002\u4f8b\u5982\uff0c\u6570\u636e\u5bf9\u8c61\u7684\u5927\u5c0f\u662f\u5bf9\u8c61\u4e2d\u5305\u542b\u7684\u5b57\u8282\u6570\u3002\u5982\u679c\u7b26\u53f7\u6ca1\u6709\u5927\u5c0f\u6216\u672a\u77e5\u5927\u5c0f\uff0c\u5219\u6b64\u6210\u5458\u4fdd\u75590\u3002 st_info \u6b64\u6210\u5458\u6307\u5b9a\u7b26\u53f7\u7684type\u7c7b\u578b\u548cbinding attributes\u7ed1\u5b9a\u5c5e\u6027\u3002\u4e0b\u9762\u663e\u793a\u4e86\u503c\u548c\u542b\u4e49\u7684\u5217\u8868\u3002\u4ee5\u4e0b\u4ee3\u7801\u663e\u793a\u5982\u4f55\u5904\u7406\u503c\u3002 st_shndx \u6bcf\u4e2asymbol table entry\u7b26\u53f7\u8868\u6761\u76ee\u90fd\u662f\u76f8\u5bf9\u4e8e\u67d0\u4e2asection\u6bb5\u201c\u5b9a\u4e49\u201d\u7684;\u8fd9\u4e2a\u6210\u5458\u8868\u793a\u76f8\u5173\u8054\u7684section\u5728section header table\u8282\u5934\u8868\u7684\u7d22\u5f15\u503c\u3002\u5982\u56fe1-7\u548c\u76f8\u5173\u6587\u672c\u6240\u8ff0\uff0c\u4e00\u4e9b\u6bb5\u7d22\u5f15\u8868\u793a\u7279\u6b8a\u542b\u4e49\u3002 A symbol's binding determines the linkage visibility and behavior.\u7b26\u53f7\u7684\u7ed1\u5b9a\u51b3\u5b9a\u4e86\u94fe\u63a5\u7684\u53ef\u89c1\u6027\u548c\u884c\u4e3a\u3002 symbol binding STB_LOCAL Local symbols are not visible outside the object file containing their definition\u5728\u5305\u542b\u6b64symbol\u5b9a\u4e49\u7684object file\u4e4b\u5916\u7684object file\u4e2d\u6b64symbol\u662f\u4e0d\u53ef\u89c1\u7684. Local symbols of the same name may exist in multiple files without interfering with each other\u663e\u7136\u5728\u4e0d\u540c\u7684object file\u4e2d\u662f\u53ef\u4ee5\u5b58\u5728\u76f8\u540c\u540d\u5b57\u7684local symbol\u7684\u3002 STB_GLOBAL Global symbols are visible to all object files being combined global symbol\u662f\u5168\u5c40\u53ef\u89c1\u7684. One file's definition of a global symbol will satisfy another file's undefined reference to the same global symbol. STB_WEAK Weak symbols resemble global symbols, but their definitions have lower precedence . STB_LOPROC through STB_HIPROC Values in this inclusive range are reserved for processor-specific semantics. In each symbol table, all symbols with STB_LOCAL binding precede the weak and global symbols . A symbol's type provides a general classification for the associated entity. symbol type STT_NOTYPE The symbol's type is not specified. STT_OBJECT The symbol is associated with a data object, such as a variable , an array ,and so on. STT_FUNC The symbol is associated with a function or other executable code . STT_SECTION The symbol is associated with a section . Symbol table entries of this type exist primarily for relocation and normally have STB_LOCAL binding . STT_LOPROC through STT_HIPROC Values in this inclusive range are reserved for processor-specific semantics. If a symbol's value refers to a specific location within a section, its section index member, st_shndx , holds an index into the section header table.As the section moves during relocation, the symbol's value changes as well,and references to the symbol continue to \"point'' to the same location in the program. Some special section index values give other semantics. STT_FILE A file symbol has STB_LOCAL binding, its section index is SHN_ABS , and it precedes the other STB_LOCAL symbols for the file, if it is present. The symbols in ELF object files convey specific information to the linker and loader. See the operating system sections for a description of the actual linking model used in the system. SHN_ABS The symbol has an absolute value that will not change because of relocation. SHN_COMMON The symbol labels a common block that has not yet been allocated. The symbol's value gives alignment constraints, similar to a section's sh_addralign member. That is, the link editor will allocate the storage for the symbol at an address that is a multiple of st_value . The symbol's size tells how many bytes are required. SHN_UNDEF This section table index means the symbol is undefined. When the link editor combines this object file with another that defines the indicated symbol, this file's references to the symbol will be linked to the actual definition.","title":"ELF"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#book#iexecutable#and#linking#format#elf","text":"","title":"Book I:Executable and Linking Format (ELF)"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#introduction","text":"\u8fd9\u4e00\u8282\u63cf\u8ff0object file\u7684\u683c\u5f0f\uff0c\u5b83\u88ab\u79f0\u4e3aELF(Executable and Linking Format).\u4e3b\u8981\u6709\u4e09\u79cd\u7c7b\u578b\u7684object file\uff1a relocatable file**\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6\uff1a\u8fd9\u79cd\u7c7b\u578b\u7684\u6587\u4ef6\u7528\u4e8e\u4fdd\u5b58\u4e0e\u5176\u4ed6object file**\u94fe\u63a5**\u4ee5\u521b\u5efa**executable object file**\u53ef\u6267\u884c\u6587\u4ef6\u6216**shared object file**\u53ef\u5171\u4eab\u5bf9\u8c61\u6587\u4ef6\u7684**\u4ee3\u7801**\u548c**\u6570\u636e \u3002\u6709link editor\u6765\u5b9e\u73b0\u94fe\u63a5\u3002 **executable file**\u53ef\u6267\u884c\u6587\u4ef6\uff1a\u4fdd\u5b58\u9002\u5408\u4e8e\u6267\u884c\u7684\u7a0b\u5e8f\u3002 shared object file**\u53ef\u5171\u4eab\u5bf9\u8c61\u6587\u4ef6\uff1a\u7528\u4e8e\u4fdd\u5b58\u9002\u4e8e\u5728\u4e24\u79cd\u4e0a\u4e0b\u6587\u73af\u5883\u4e2d\u8fdb\u884c\u94fe\u63a5\u7684\u4ee3\u7801\u548c\u6570\u636e\u3002\u7b2c\u4e00\u79cd\uff0c**link editor**\u94fe\u63a5\u7f16\u8f91\u5668\u53ef\u4ee5**link**\u94fe\u63a5\u5b83\u548c\u5176\u4ed6**relocatable object file\u53ef\u91cd\u5b9a\u4f4d\u6216**shared** object file\u53ef\u5171\u4eab\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684object file\u3002\u7b2c\u4e8c\u79cd\uff0c**dynamic linker**\u52a8\u6001\u94fe\u63a5\u5668\u5c06\u5b83\u4e0e**executable file**\u53ef\u6267\u884c\u6587\u4ef6\u548c\u5176\u4ed6**shared objects**\u53ef\u5171\u4eab\u5bf9\u8c61\u8fdb\u884c\u7ec4\u5408\u6765\u521b\u5efa\u8fc7\u7a0b\u6620\u50cf\u3002 **object file**\u7531**assembler**\u6c47\u7f16\u5668\u548c**link editor**\u94fe\u63a5\u7f16\u8f91\u5668\u521b\u5efa\uff0c\u5b83\u662f\u80fd\u591f\u76f4\u63a5\u5728\u5904\u7406\u5668\u4e0a\u6267\u884c\u7684\u7a0b\u5e8f\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u3002 \u5728\u4ecb\u7ecd\u4e4b\u540e\uff0c\u672c\u7ae0\u91cd\u70b9\u4ecb\u7ecdobject file\u4ee5\u53ca\u5b83\u4e0e\u6784\u5efa\u7a0b\u5e8f\u7684\u5173\u7cfb\u3002\u7b2c2\u7ae0\u4e5f\u63cf\u8ff0\u4e86object file\u7684\u90e8\u5206\u5185\u5bb9\uff0c\u96c6\u4e2d\u4ecb\u7ecd\u4e8e\u6267\u884c\u7a0b\u5e8f\u6240\u9700\u7684\u4fe1\u606f\u3002","title":"Introduction\u4ecb\u7ecd"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#object#file","text":"**object file**\u53ef\u4ee5\u53c2\u4e0e\u7a0b\u5e8f\u94fe\u63a5\uff08\u6784\u5efa\u7a0b\u5e8f\uff09\u548c\u7a0b\u5e8f\u6267\u884c\uff08\u8fd0\u884c\u7a0b\u5e8f\uff09\u3002\u4e3a\u4e86\u65b9\u4fbf\u548c\u9ad8\u6548\uff0c**object file**\u7684\u683c\u5f0f\u540c\u65f6\u63d0\u4f9b\u4e86\u5c55\u793a\u6587\u4ef6\u5185\u5bb9\u7684\u4e24\u79cd\u89c6\u56fe\uff1a \u94fe\u63a5\u89c6\u56fe \u6267\u884c\u89c6\u56fe \u4f7f\u7528\u4e24\u79cd\u89c6\u56fe\u662f\u4e3a\u4e86\u6ee1\u8db3\u8fd9\u4e24\u79cd\u6d3b\u52a8\uff08\u6784\u5efa\u7a0b\u5e8f\u548c\u8fd0\u884c\u7a0b\u5e8f\uff09\u7684\u4e0d\u540c\u9700\u6c42\u3002\u5982\u56fe1-1\u6240\u793a\u4e00\u4e2a**object file**\u7684\u7ec4\u7ec7\u3002","title":"Object File\u7684\u683c\u5f0f"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#elf#header","text":"ELF header**\u4f4d\u4e8eobject file\u7684\u5f00\u59cb\u5904\uff0c\u5b83\u4fdd\u5b58\u63cf\u8ff0**object file**\u7684\u7ec4\u7ec7\u7ed3\u6784\u7684\u201c\u8def\u7ebf\u56fe\u201d\u3002**Section**\u5305\u542b\u7528\u4e8e**\u94fe\u63a5\u89c6\u56fe**\u7684\u4fe1\u606f\uff1a\u6307\u4ee4Section (instructions)\uff0c\u6570\u636eSection (data)\uff0c\u7b26\u53f7\u8868Section (symbol table)\uff0c\u91cd\u5b9a\u4f4d\u4fe1\u606fSection (relocation information)\uff0c\u7b49\u7b49\u3002\u672c\u8282\u540e\u9762\u5bf9\u5404\u4e2aSection\u8fdb\u884c\u8be6\u7ec6\u63cf\u8ff0\u3002\u7b2c\u4e8c\u7ae0\u4e5f\u5c06\u4ecb\u7ecd\u5404\u4e2aSegments\u548cobject file\u7684**\u6267\u884c\u89c6\u56fe \u3002","title":"ELF header"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#program#header#table","text":"\u7a0b\u5e8f\u5934\u8868\uff08program header table\uff09\uff08\u5982\u679c\u5b58\u5728\u7684\u8bdd\uff09\u544a\u8bc9\u7cfb\u7edf\u5982\u4f55\u521b\u5efa\u8fdb\u7a0b\u6620\u50cf\u3002\u7528\u4e8e\u6784\u5efa\u8fdb\u7a0b\u6620\u50cf\u7684object file\uff08\u6267\u884c\u7a0b\u5e8f\uff09\u5fc5\u987b\u6709\u7a0b\u5e8f\u5934\u8868\uff08program header table\uff09\u3002\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6\uff08relocatable file\uff09\u5219\u5e76\u4e0d\u9700\u8981\u7a0b\u5e8f\u5934\u8868\uff08program header table\uff09\u3002","title":"program header table"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#section#header#table","text":"section header table\u5305\u542b\u63cf\u8ff0\u5404\u4e2asection\u7684\u4fe1\u606f\u3002\u6bcf\u4e2asection\u5728section header table\u4e2d\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684**\u6761\u76ee**\uff08\u76f8\u5f53\u4e8e\u4e00\u6761\u8bb0\u5f55\uff09; \u6bcf\u4e2a\u6761\u76ee\u7ed9\u51fa\u8be5section\u7684\u540d\u79f0\uff0c\u5927\u5c0f\u7b49\u4fe1\u606f\u3002\u7528\u4e8e**\u94fe\u63a5**\u671f\u95f4\u4f7f\u7528\u7684object file\u5fc5\u987b\u5177\u6709section header table; \u5176\u4ed6object file\u53ef\u80fd\u6709\u4e5f\u53ef\u80fd\u6ca1\u6709\u3002 NOTE\u3002\u867d\u7136\u56fe\u4e2d\u663e\u793a\u4e86program header table\u4f4d\u4e8eELF header\u7684\u540e\u9762\uff0csection header table\u4f4d\u4e8e\u5404section\u7684\u540e\u9762\uff0c\u5b9e\u9645\u7684\u76ee\u6807\u6587\u4ef6\u8fd9\u51e0\u4e2a\u90e8\u5206\u7684\u987a\u5e8f\u5173\u7cfb\u53ef\u80fd\u4e0e\u4e0a\u56fe\u4e2d\u5c55\u793a\u7684\u4e0d\u540c\uff0c\u53ef\u4ee5\u786e\u5b9a\u7684\u662fELF header\u4e00\u5b9a\u4f4d\u4e8e\u6587\u4ef6\u7684\u5934\u90e8\u3002","title":"section header table"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#data#representation","text":"\u5982\u8fd9\u91cc\u6240\u63cf\u8ff0\u7684\uff0cobject file\u7684\u683c\u5f0f\u652f\u6301\u5177\u67098\u4f4d\u5b57\u8282\u548c32\u4f4d\u67b6\u6784\u7684\u5404\u79cd\u5904\u7406\u5668\u3002\u7136\u800c\uff0c\u5b83\u65e8\u5728\u53ef\u6269\u5c55\u5230\u66f4\u5927\uff08\u6216\u66f4\u5c0f\uff09\u7684\u67b6\u6784\u3002\u56e0\u6b64\uff0cobject file\u4f7f\u7528**\u4e0e\u673a\u5668\u65e0\u5173**\u7684\u683c\u5f0f\u6765\u8868\u793a\u5b83\u7684**control data**\uff0c\u4f7f\u5f97\u53ef\u4ee5\u4ee5**\u901a\u7528\u65b9\u5f0f**\u6765\u8bc6\u522bobject file\u5e76\u89e3\u91ca\u5176\u5185\u5bb9\u3002object file\u4e2d\u7684\u5269\u4f59\u6570\u636e\u4f7f\u7528**\u76ee\u6807\u5904\u7406\u5668**\u7684\u7f16\u7801\uff0c\u800c\u4e0d\u7528\u8003\u8651\u521b\u5efa\u8be5object file\u7684\u8ba1\u7b97\u673a\u3002\u8fd9\u6837\u5728A\u673a\u5668\u4e0a\u521b\u5efa\u7684object file\u5c31\u53ef\u4ee5\u62ff\u5230B\u673a\u5668\u4e0a\u8fdb\u884c\u8fd0\u884c\u6216\u94fe\u63a5\uff0c\u5373\u4f7fA\u4e0eB\u7684\u67b6\u6784\u4e0d\u76f8\u540c\u3002 object file\u683c\u5f0f\u5b9a\u4e49\u7684\u6240\u6709\u6570\u636e\u7ed3\u6784\u90fd\u9075\u5faa\u76f8\u5173\u7c7b\u7684\u201c\u81ea\u7136\u201d\u5927\u5c0f\u548c\u5bf9\u9f50\u51c6\u5219\u3002\u5982\u679c\u5fc5\u8981\uff0c\u6570\u636e\u7ed3\u6784\u5305\u542b\u663e\u5f0f\u586b\u5145\uff0c\u4ee5\u786e\u4fdd4\u5b57\u8282\u5bf9\u8c61\u76844\u5b57\u8282\u5bf9\u9f50\uff0832\u4f4d\u5904\u7406\u5668\u4e00\u6b21\u8bfb\u53d632\u4f4d\uff09\uff0c\u5c06\u7ed3\u6784\u5927\u5c0f\u5f3a\u5236\u4e3a4\u7684\u500d\u6570\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\u6570\u636e\u4e5f\u4ece\u6587\u4ef6\u7684\u5f00\u5934\u5177\u6709\u9002\u5f53\u7684\u5bf9\u9f50\u3002\u56e0\u6b64\uff0c\u4f8b\u5982\uff0c\u5305\u542bElf32_Addr\u6210\u5458\u7684\u7ed3\u6784\u5c06\u5728\u6587\u4ef6\u5185\u76844\u5b57\u8282\u8fb9\u754c\u4e0a\u5bf9\u9f50\u3002 \u51fa\u4e8e\u53ef\u79fb\u690d\u6027\u7684\u539f\u56e0\uff0cELF\u4e0d\u4f7f\u7528\u4f4d\u5b57\u6bb5\u3002","title":"Data Representation\u6570\u636e\u8868\u793a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#character#representations","text":"\u672c\u8282\u4ecb\u7ecdELF\u9ed8\u8ba4\u7684\u5b57\u7b26\u8868\u793a\uff0c\u5e76\u4e3a\u80fd\u591f\u5728\u4e0d\u540c\u7cfb\u7edf\u4e4b\u95f4\u79fb\u690d\u7684\u5916\u90e8\u6587\u4ef6\u5b9a\u4e49\u6807\u51c6\u5b57\u7b26\u96c6\u3002\u4e00\u4e9b\u5916\u90e8\u6587\u4ef6\u683c\u5f0f\u4f7f\u7528\u5b57\u7b26\u6765\u8868\u793a\u63a7\u5236\u4fe1\u606f\u3002\u8fd9\u4e9b\u5355\u5b57\u8282\u5b57\u7b26\u4f7f\u75287\u4f4dASCII\u5b57\u7b26\u96c6\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5f53ELF\u63a5\u53e3\u6587\u6863\u63d0\u5230**\u5b57\u7b26\u5e38\u91cf**\uff0c\u4f8b\u5982'/'\u6216' n'\u65f6\uff0c\u5b83\u4eec\u7684**\u6570\u503c**\u5e94\u9075\u5faa7\u4f4dASCII\u7801\u3002\u5bf9\u4e8e\u524d\u9762\u7684\u5b57\u7b26\u5e38\u91cf\uff0c\u5355\u5b57\u8282\u503c\u5c06\u662f47 \u548c10\u3002 \u6839\u636e\u5b57\u7b26\u7f16\u7801\uff0c0\u5230127\u8303\u56f4\u4e4b\u5916\u7684\u5b57\u7b26\u503c\u53ef\u80fd\u5360\u7528\u4e00\u4e2a\u6216\u591a\u4e2a\u5b57\u8282\u3002\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5bf9\u4e0d\u540c\u7684\u8bed\u8a00\u4f7f\u7528\u4e0d\u540c\u7684\u5b57\u7b26\u96c6\u6269\u5c55\u6765\u63a7\u5236\u5b83\u7684\u5b57\u7b26\u96c6\u3002\u867d\u7136TIS-conformance\u4e0d\u9650\u5236\u5b57\u7b26\u96c6\uff0c\u4f46\u5b83\u4eec\u901a\u5e38\u5e94\u9075\u5faa\u4e00\u4e9b\u7b80\u5355\u7684\u51c6\u5219\uff1a 0\u5230127\u4e4b\u95f4\u7684\u5b57\u7b26\u503c\u5e94\u5bf9\u5e94\u4e8e7\u4f4dASCII\u7801\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5177\u6709\u9ad8\u4e8e127\u7684\u7f16\u7801\u7684\u5b57\u7b26\u96c6\u5e94\u8be5\u5c06\u76847\u4f4dASCII\u7801\u4f5c\u4e3a\u5b50\u96c6\u3002 \u503c\u5927\u4e8e127\u7684\u591a\u5b57\u8282\u5b57\u7b26\u7f16\u7801\u5e94\u8be5\u53ea\u5305\u542b\u503c\u57280\u5230127\u8303\u56f4\u4e4b\u5916\u7684\u5b57\u8282\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u6bcf\u4e2a\u5b57\u7b26\u4f7f\u7528\u591a\u4e2a\u5b57\u8282\u7684\u5b57\u7b26\u96c6\u4e0d\u5e94\u8be5\u201c\u5d4c\u5165\u201d\u7c7b\u4f3c\u4e8e7\u4f4dASCII\u5b57\u7b26\u7684\u5b57\u8282\u5728\u4e00\u4e2a\u591a\u5b57\u8282\uff0c\u975eASCII\u5b57\u7b26\u5185\u3002 \u591a\u5b57\u8282\u5b57\u7b26\u5e94\u8be5\u662f\u81ea\u8bc6\u522b\u7684\u3002 \u8fd9\u5141\u8bb8\u4f8b\u5982\u5728\u4efb\u4f55\u591a\u5b57\u8282\u5b57\u7b26\u5bf9\u4e4b\u95f4\u63d2\u5165\u4efb\u4f55\u591a\u5b57\u8282\u5b57\u7b26\uff0c\u800c\u4e0d\u6539\u53d8\u5b57\u7b26\u7684\u89e3\u91ca\u3002 \u8fd9\u4e9b\u6ce8\u610f\u4e8b\u9879\u4e0e\u591a\u8bed\u8a00\u5e94\u7528\u7a0b\u5e8f\u7279\u522b\u76f8\u5173\u3002","title":"Character Representations\u5b57\u7b26\u8868\u793a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#elf#header_1","text":"\u6839\u636e\u8be5\u7ed3\u6784\u4e2d\u5404\u4e2a\u53d8\u91cf\u7684\u547d\u540d\u5176\u5b9e\u90fd\u53ef\u4ee5\u63a8\u65ad\u51fa\u8fd9\u4e9b\u53d8\u91cf\u5404\u81ea\u7684\u542b\u4e49\uff0cident\u5bf9\u5e94\u7684\u662fidentity\uff0c\u5373\u6807\u8bc6\uff0c\u540e\u9762\u4f1a\u8fdb\u884c\u5177\u4f53\u7684\u63cf\u8ff0\u3002e_entry\u5373\u7a0b\u5e8f\u7684\u5165\u53e3\u5730\u5740\uff0ce_phoff\u7684\u542b\u4e49\u9700\u8981\u62c6\u89e3\u5f00\u6765\uff0cph\u5373program header table\uff0coff\u5373offset\uff0c\u504f\u79fb\u91cf\uff1be_shoff\u7684\u5206\u89e3\u548ce_phoff\u7c7b\u4f3c\uff0csh\u5373section header table\uff0coff\u5373offset\uff0c\u504f\u79fb\u91cf\uff1be_phentsize\u7684\u542b\u4e49\u4e5f\u9700\u8981\u62c6\u89e3\u5f00\u6765\u8fdb\u884c\u4e86\u89e3\uff0cph\u5373program header table\uff0cent\u5373entity\uff0c\u6761\u76ee\uff0csize\u5373\u5927\u5c0f\uff0c\u90a3\u4e48\u8fd9\u4e2a\u53d8\u91cf\u7684\u542b\u4e49\u5c31\u597d\u7406\u89e3\u4e86\uff0c\u5b83\u7528\u6765\u6807\u8bc6program header table\u4e2d\u4e00\u4e2a\u6761\u76ee\u7684\u5927\u5c0f\u3002e_phnum\u5373program header entity number\uff0c\u8868\u793aprogram header table\u4e2d\u8bb0\u5f55\u7684\u4e2a\u6570\u3002e_ehsize\u7684\u542b\u4e49\u662fELF header size\uff0c\u5373ELF header\u7684\u5927\u5c0f\u3002","title":"ELF Header"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#1#e_ident","text":"object file\u7684\u521d\u59cb\u5b57\u8282\u4e3b\u8981\u7528\u4e8e\u5c06\u6587\u4ef6\u6807\u8bb0\u4e3aobject file\uff0c\u5e76\u63d0\u4f9b\u4e0e\u673a\u5668\u65e0\u5173\u7684\u6570\u636e\uff0c\u7528\u4e8e\u89e3\u7801\u548c\u89e3\u91ca\u6587\u4ef6\u7684\u5185\u5bb9\u3002\u5b8c\u6574\u7684\u63cf\u8ff0\u663e\u793a\u5728\u4e0b\u9762\u7684\u201cELF Identification\u201d\u7ae0\u8282\u3002","title":"1.   e_ident"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#2#e_type","text":"\u6b64\u6210\u5458\u6807\u8bc6\u5bf9\u8c61\u6587\u4ef6\u7684\u7c7b\u578b\u3002 \u867d\u7136Core\u6587\u4ef6\u7684\u5185\u5bb9\u672a\u6307\u5b9a\uff0c\u4f46\u4fdd\u7559\u7c7b\u578bET_CORE\u4ee5\u6807\u8bb0\u8fd9\u79cd\u6587\u4ef6\u7c7b\u578b\u3002\u4eceET_LOPROC\u5230ET_HIPROC\uff08\u5305\u62ec\uff09\u7684\u503c\u4fdd\u7559\u7528\u4e8e\u5904\u7406\u5668\u7279\u5b9a\u7684\u8bed\u4e49\u3002\u4fdd\u7559\u5176\u4ed6\u503c\uff0c\u5e76\u6839\u636e\u9700\u8981\u5c06\u5176\u5206\u914d\u7ed9\u65b0\u7684\u5bf9\u8c61\u6587\u4ef6\u7c7b\u578b\u3002","title":"2.   e_type"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#3#e_machine","text":"\u6b64\u6210\u5458\u7684\u503c\u6307\u5b9a\u5355\u4e2a\u6587\u4ef6\u6240\u9700\u7684CPU\u4f53\u7cfb\u7ed3\u6784\u3002 \u4fdd\u7559\u5176\u4ed6\u503c\uff0c\u5e76\u6839\u636e\u9700\u8981\u5c06\u5176\u5206\u914d\u7ed9\u65b0\u8ba1\u7b97\u673a\u3002\u7279\u5b9a\u4e8e\u5904\u7406\u5668\u7684ELF\u540d\u79f0\u4f7f\u7528\u8ba1\u7b97\u673a\u540d\u79f0\u6765\u533a\u5206\u5b83\u4eec\u3002\u4f8b\u5982\uff0c\u4e0b\u9762\u63d0\u5230\u7684\u6807\u5fd7\u4f7f\u7528\u524d\u7f00EF_; \u4e00\u4e2a\u540d\u4e3aWIDGET\u7684\u6807\u5fd7 EM_XYZ\u673a\u5668\u5c06\u88ab\u79f0\u4e3aEF_XYZ_WIDGET\u3002","title":"3.   e_machine"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#4#e_version","text":"\u6b64\u6210\u5458\u6807\u8bc6\u5bf9\u8c61\u6587\u4ef6\u7248\u672c\u3002 \u503c1\u8868\u793a\u539f\u59cb\u6587\u4ef6\u683c\u5f0f; \u6269\u5c55\u5c06\u521b\u5efa\u5177\u6709\u66f4\u9ad8\u6570\u5b57\u7684\u65b0\u7248\u672c\u3002 EV_CURRENT\u7684\u503c\uff0c\u5c3d\u7ba1\u5728\u4e0a\u9762\u7ed9\u51fa\u4e3a1\uff0c\u5c06\u6839\u636e\u9700\u8981\u66f4\u6539\u4ee5\u53cd\u6620\u5f53\u524d\u7248\u672c\u53f7\u3002","title":"4.   e_version"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#5#e_entry","text":"\u8be5\u6210\u5458\u7ed9\u51fa\u7cfb\u7edf\u9996\u6b21\u4f20\u8f93\u63a7\u5236\u7684\u865a\u62df\u5730\u5740\uff0c\u4ece\u800c\u542f\u52a8\u8fdb\u7a0b\u3002 \u5982\u679c\u6587\u4ef6\u6ca1\u6709\u5173\u8054\u7684\u5165\u53e3\u70b9\uff08entrypoint\uff09\uff0c\u5219\u6b64\u6210\u5458\u4fdd\u5b58\u4e3a\u96f6\u3002","title":"5.   e_entry"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#6#e_phoff","text":"\u8be5\u6210\u5458\u4fdd\u5b58program header table\u7684\u6587\u4ef6\u504f\u79fb\u91cf\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002\u5982\u679c\u6587\u4ef6\u6ca1\u6709program header table\uff0c\u5219\u6b64\u6210\u5458\u4fdd\u5b58\u4e3a\u96f6\u3002","title":"6.   e_phoff"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#7#e_shoff","text":"\u8be5\u6210\u5458\u4fdd\u5b58section header table\u7684\u6587\u4ef6\u504f\u79fb\u91cf\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002 \u5982\u679c\u6587\u4ef6\u6ca1\u6709sectionheader table\uff0c\u5219\u6b64\u6210\u5458\u4fdd\u5b58\u4e3a\u96f6\u3002","title":"7.   e_shoff"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#8#e_flags","text":"\u6b64\u6210\u5458\u4fdd\u5b58\u4e0e\u6587\u4ef6\u76f8\u5173\u8054\u7684\u5904\u7406\u5668\u7279\u5b9a\u6807\u5fd7\u3002 \u6807\u5fd7\u540d\u7684\u683c\u5f0f\u4e3aEF_machine_flag\u3002","title":"8.   e_flags"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#9#e_ehsize","text":"\u8be5\u6210\u5458\u4fdd\u5b58ELF\u5934\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002","title":"9.  e_ehsize"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#10#e_phentsize","text":"\u8be5\u6210\u5458\u4fdd\u5b58\u6587\u4ef6\u7a0b\u5e8f\u5934\u8868\uff08programheader table\uff09\u4e2d\u4e00\u4e2a\u6761\u76ee\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09;\u6240\u6709\u6761\u76ee\u7684\u5927\u5c0f\u76f8\u540c\u3002","title":"10. e_phentsize"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#11#e_phnum","text":"\u6b64\u6210\u5458\u4fdd\u5b58\u7a0b\u5e8f\u5934\u8868\uff08programheader table\uff09\u4e2d\u7684\u6761\u76ee\u6570\u3002\u56e0\u6b64\uff0ce_phentsize\u548ce_phnum\u7684\u4e58\u79ef\u7ed9\u51fa\u4e86program header table\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002\u5982\u679c\u6587\u4ef6\u6ca1\u6709program header table\uff0ce_phnum\u4fdd\u6301\u503c\u4e3a\u96f6\u3002","title":"11. e_phnum"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#12#e_shentsize","text":"\u8be5\u6210\u5458\u4fdd\u5b58\u6bb5\u5934section header\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002 \u6bb5\u5934sectionheader\u662fsection header table\u4e2d\u7684\u4e00\u4e2a\u6761\u76ee; \u6240\u6709\u6761\u76ee\u7684\u5927\u5c0f\u76f8\u540c\u3002","title":"12.        e_shentsize"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#13#e_shnum","text":"\u6b64\u6210\u5458\u4fdd\u5b58section headertable\u4e2d\u7684\u6761\u76ee\u6570\u3002\u56e0\u6b64\uff0ce_shentsize\u548ce_shnum\u7684\u4e58\u79ef\u7ed9\u51fa\u4e86section header table\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002\u5982\u679c\u6587\u4ef6\u6ca1\u6709section header table\uff0ce_shnum\u4fdd\u6301\u503c\u4e3a\u96f6\u3002","title":"13.        e_shnum"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#14#e_shstrndx","text":"\u6b64\u6210\u5458\u4fdd\u5b58\u4e0e\u8282\u540d\u79f0\u5b57\u7b26\u4e32\u8868\uff08section name string table\uff09\u76f8\u5173\u8054\u7684\u6761\u76ee\u5728\u8282\u6807\u9898\u8868\uff08section header table\uff09\u4e2d\u7684\u7d22\u5f15\u503c\u3002\u5982\u679c\u6587\u4ef6\u6ca1\u6709\u8282\u540d\u79f0\u5b57\u7b26\u4e32\u8868\uff08section name string table\uff09\uff0c\u5219\u6b64\u6210\u5458\u4fdd\u5b58\u503cSHN_UNDEF\u3002 \u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684\u201cSections\u201d\u548c\u201cStringTable\u201d\u7ae0\u8282\u3002","title":"14.        e_shstrndx"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#elf#identification","text":"\u5982\u4e0a\u6240\u8ff0\uff0cELF\u63d0\u4f9b\u4e86\u4e00\u4e2aobject file\u6846\u67b6\u6765\u652f\u6301\u591a\u79cd\u5904\u7406\u5668\uff0c\u591a\u79cd\u6570\u636e\u7f16\u7801\u548c\u591a\u7c7b\u673a\u5668\u3002\u4e3a\u4e86\u652f\u6301\u8be5object file family\uff0c\u67d0\u4e2aobject file\u7684\u521d\u59cb\u5b57\u8282\u6307\u5b9a\u5982\u4f55\u89e3\u91ca\u8be5\u6587\u4ef6\uff0c\u8fd9\u51e0\u4e2a\u5b57\u8282\u7684\u5185\u5bb9\u72ec\u7acb\u4e8e\u8fdb\u884c\u67e5\u8be2\u7684\u5904\u7406\u5668\uff0c\u5e76\u4e14\u72ec\u7acb\u4e8e\u6587\u4ef6\u7684\u5269\u4f59\u5185\u5bb9\u3002ELF header\u7684\u521d\u59cb\u5b57\u8282\u5bf9\u5e94\u4e8ee_ident\u6210\u5458\uff0c\u4ece\u4e0a\u9762ELF Header\u7684\u63cf\u8ff0\u6765\u770b\uff0ce_ident\u662f\u4e00\u4e2a\u957f\u5ea6\u4e3a16\u5b57\u8282\u7684\u6570\u7ec4\u3002\u56fe1-4\u5c55\u793a\u4e86\u8be5\u6570\u7ec4\u7684\u5404\u4e2a\u7d22\u5f15\u7684\u540d\u79f0\u548c\u6570\u7ec4\u4e2d\u8be5\u4f4d\u7f6e\u7684\u7528\u9014\u3002 \u8fd9\u4e9b\u7d22\u5f15\u8bbf\u95ee\u5305\u542b\u4ee5\u4e0b\u503c\u7684\u5b57\u8282\u3002","title":"ELF Identification"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#ei_mag0ei_mag3","text":"\u6587\u4ef6\u7684\u524d4\u4e2a\u5b57\u8282\u7ec4\u5408\u8d77\u6765\u8868\u793a\u6587\u4ef6\u7684\u201cmagicnumber\u201d\uff0c\u5c06\u8be5\u6587\u4ef6\u6807\u8bc6\u4e3aELF\u5bf9\u8c61\u6587\u4ef6\u3002","title":"EI_MAG0\u5230EI_MAG3"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#ei_class","text":"\u4e0b\u4e00\u4e2a\u5b57\u8282e_ident [EI_CLASS]\u6807\u8bc6\u6587\u4ef6\u7684\u7c7b\u6216\u5bb9\u91cf\u3002","title":"EI_CLASS"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#sections","text":"object file\u7684section header table\uff08\u6bb5\u5934\u8868\uff09\u5141\u8bb8\u5b9a\u4f4d\u8be5\u6587\u4ef6\u6240\u6709\u7684section\u6bb5\u3002section header table\uff08\u6bb5\u5934\u8868\uff09\u662f\u5982\u4e0b\u6240\u8ff0\u7684Elf32_Shdr\u7ed3\u6784\u7684\u6570\u7ec4\uff0csectionheader table\u7684\u7d22\u5f15\u662f\u8fd9\u4e2a\u6570\u7ec4\u7684\u4e0b\u6807\u3002ELF header\u7684e_shoff\u6210\u5458\u7ed9\u51fa\u4ece\u6587\u4ef6\u5f00\u5934\u5230section header table\u7684\u5b57\u8282\u504f\u79fb; e_shnum\u544a\u8bc9section header table\u5305\u542b\u591a\u5c11\u6761\u76ee; e_shentsize\u7ed9\u51fa\u6bcf\u4e2a\u6761\u76ee\u7684\u5927\u5c0f\uff08\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\uff09\u3002","title":"Sections"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#shn_undef","text":"","title":"SHN_UNDEF"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#shn_loreserve","text":"\u6b64\u503c\u6307\u5b9a\u4fdd\u7559\u7d22\u5f15\u8303\u56f4\u7684\u4e0b\u9650\u503c\u3002","title":"SHN_LORESERVE"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#shn_loproc#through#shn_hiproc","text":"\u5728SHN_LOPROC\u5230SHN_HIPROC\u8303\u56f4\u4e2d\u7684\u503c\u4e3a\u5904\u7406\u5668\u7279\u5b9a\u7684\u8bed\u4e49\u6240\u4fdd\u7559\u3002","title":"SHN_LOPROC through SHN_HIPROC"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#shn_abs","text":"\u6b64\u503c\u6307\u5b9a\u76f8\u5e94\u5f15\u7528\u7684\u7edd\u5bf9\u503c\u3002\u4f8b\u5982\uff0c\u76f8\u5bf9\u4e8esection\u53f7SHN_ABS\u5b9a\u4e49\u7684\u7b26\u53f7\u5177\u6709\u7edd\u5bf9\u503c\uff0c\u5e76\u4e14\u4e0d\u53d7\u91cd\u5b9a\u4f4d\u7684\u5f71\u54cd\u3002","title":"SHN_ABS"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#shn_common","text":"\u76f8\u5bf9\u4e8e\u6b64section\u5b9a\u4e49\u7684symbols\u7b26\u53f7\u662fcommon symbols,\u5e38\u7528\u7b26\u53f7\uff0c\u4f8b\u5982FORTRAN \u8bed\u8a00\u4e2d\u7684COMMON\u6216C\u8bed\u8a00\u4e2d\u672a\u5206\u914d\u7684\u5916\u90e8\u53d8\u91cf\u3002","title":"SHN_COMMON"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#shn_hireserve","text":"\u6b64\u503c\u6307\u5b9areserved indexes\u4fdd\u7559\u7d22\u5f15\u8303\u56f4\u7684\u4e0a\u9650\u3002\u7cfb\u7edf\u4fdd\u7559SHN_LORESERVE\u548cSHN_HIRESERVE\u4e4b\u95f4\u7684\u7d22\u5f15\uff0c\u5305\u62ec; \u8fd9\u4e9b\u503c\u4e0d\u88absection header table\u6bb5\u5934\u8868\u5f15\u7528\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u6bb5\u5934\u8868\u4e0d\u5305\u542b\u4fdd\u7559\u7d22\u5f15\u7684\u6761\u76ee\u3002 \u5728\u76ee\u6807\u6587\u4ef6\u4e2d\uff0c\u9664\u4e86ELF\u5934\uff0cprogram header table\u7a0b\u5e8f\u5934\u8868\u548csection header table\u6bb5\u5934\u8868\uff0c\u5176\u5b83\u8282\u7684\u6240\u6709\u4fe1\u606f\u5305\u542b\u5728section\u4e2d\u3002\u6b64\u5916\uff0c\u76ee\u6807\u6587\u4ef6\u6bb5\u6ee1\u8db3\u51e0\u4e2a\u6761\u4ef6\u3002 l \u5bf9\u8c61\u6587\u4ef6\u4e2d\u7684\u6bcf\u4e2a\u8282\u90fd\u6709\u4e00\u4e2a\u63cf\u8ff0\u5b83\u7684section header\u8282\u5934\u3002\u53ef\u80fd\u5b58\u5728\u6ca1\u6709section\u7684section header\u3002 l \u6bcf\u4e2asection\u5360\u636e\u6587\u4ef6\u4e2d\u7684\u4e00\u4e2a\u8fde\u7eed\uff08\u53ef\u80fd\u4e3a\u7a7a\uff09\u5b57\u8282\u5e8f\u5217\u3002 l \u6587\u4ef6\u4e2d\u7684section\u4e0d\u80fd\u91cd\u53e0\u3002 \u6587\u4ef6\u4e2d\u6ca1\u6709\u5b57\u8282\u9a7b\u7559\u5728\u591a\u4e2asection\u4e2d\u3002 l \u5bf9\u8c61\u6587\u4ef6\u53ef\u80fd\u5177\u6709inactivespace\u672a\u4f7f\u7528\u7684\u7a7a\u95f4\u3002\u5404\u79cdheader\u5934\u548csection\u53ef\u80fd\u4e0d\u4f1a\u201c\u8986\u76d6\u201d\u76ee\u6807\u6587\u4ef6\u4e2d\u7684\u6bcf\u4e2a\u5b57\u8282\u3002\u672a\u4f7f\u7528\u7684\u7a7a\u95f4\u7684\u6570\u636e\u7684\u5185\u5bb9\u662f\u672a\u6307\u5b9a\u7684\u3002","title":"SHN_HIRESERVE"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#section#header","text":"","title":"Section header\u7684\u7ed3\u6784\u5982\u4e0b\uff1a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#sh_name","text":"\u6b64\u6210\u5458\u6307\u5b9asection\u7684\u540d\u79f0\u3002\u5b83\u7684\u503c\u662fsection header string table section\u7684\u7d22\u5f15[\u89c1\u4e0b\u9762\u7684\u201c\u5b57\u7b26\u4e32\u8868\u201d\uff09\uff0c\u7ed9\u51fa\u4e00\u4e2a\u4ee5null\u7ed3\u675f\u7684\u5b57\u7b26\u4e32\u7684\u4f4d\u7f6e\u3002","title":"sh_name"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#sh_type","text":"\u6b64\u6210\u5458\u5bf9section\u7684content\u5185\u5bb9\u548csemantic\u8bed\u4e49\u8fdb\u884c\u5206\u7c7b\u3002Section\u7c7b\u578b\u53ca\u5176\u8bf4\u660e\u5982\u4e0b\u6240\u793a\u3002","title":"sh_type"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#special#sections","text":"","title":"Special Sections"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#string#table","text":"\u672c\u8282\u4ecb\u7ecdstring table\u5b57\u7b26\u4e32\u8868\u3002string table\u5b57\u7b26\u4e32\u8868\u6bb5\u4fdd\u5b58\u4ee5\u7a7a\u5b57\u7b26\u7ec8\u6b62\u7684\u5b57\u7b26\u5e8f\u5217\uff0c\u901a\u5e38\u79f0\u4e3astring\u5b57\u7b26\u4e32\u3002object file\u4f7f\u7528\u8fd9\u4e9bstring\u5b57\u7b26\u4e32\u6765\u8868\u793asymbol\u548csection name\u3002\u901a\u8fc7string table section\u7684\u4e0b\u6807\u6765\u5f15\u7528\u4e00\u4e2a\u5c06\u5b57\u7b26\u4e32\u3002 \u7b2c\u4e00\u4e2a\u5b57\u8282\uff0c\u5373\u7d22\u5f15\u4e3a\u96f6\uff0c\u5b9a\u4e49\u4e3a\u4fdd\u5b58\u4e00\u4e2a\u7a7a\u5b57\u7b26\u3002\u540c\u6837\uff0cstring table\u5b57\u7b26\u4e32\u8868\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u88ab\u5b9a\u4e49\u4e3a\u4fdd\u6301\u4e00\u4e2a\u7a7a\u5b57\u7b26\uff0c\u786e\u4fdd\u6240\u6709\u5b57\u7b26\u4e32\u7684\u4ee5\u7a7a\u5b57\u7b26\u7ec8\u6b62\u3002\u7d22\u5f15\u4e3a\u96f6\u7684**\u5b57\u7b26\u4e32**\u6307\u5b9a\u65e0\u540d\u79f0\u6216\u7a7a\u540d\u79f0\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u4e0a\u4e0b\u6587\u3002\u5141\u8bb8\u4f7f\u7528\u7a7a\u7684string table section\u5b57\u7b26\u4e32\u8868\u90e8\u5206; \u5b83\u7684section header\u6bb5\u5934\u7684sh_size\u6210\u5458\u5c06\u4e3a\u96f6\u3002\u975e\u96f6\u7d22\u5f15\u5bf9\u4e8e\u7a7astring table section\u65e0\u6548\u3002 section header\u7684sh_name\u6210\u5458\u8868\u793a\u8be5section\u7684\u540d\u79f0\uff0c\u5b83\u7684\u503c\u662f\u4e00\u4e2a\u7d22\u5f15\uff0c\u8868\u793a\u8be5section\u7684\u540d\u79f0\u5728section name string table\u4e2d\u7684\u7d22\u5f15\u503c\uff0csection namestring table\u5728section header\u7684\u7d22\u5f15\u503c\uff08\u4f4d\u7f6e\uff09\u7531ELF\u5934\u90e8\u7684e_shstrndx\u6210\u5458\u6307\u5b9a\u3002\u4e0b\u56fe\u663e\u793a\u4e86\u5177\u670925\u4e2a\u5b57\u8282\u7684\u5b57\u7b26\u4e32\u8868\u4ee5\u53ca\u4e0e\u5404\u79cd\u7d22\u5f15\u5173\u8054\u7684\u5b57\u7b26\u4e32\u3002 \u5982\u793a\u4f8b\u6240\u793a\uff0cstring table index\u5b57\u7b26\u4e32\u8868\u7d22\u5f15\u53ef\u4ee5\u5f15\u7528section\u6bb5\u4e2d\u7684\u4efb\u4f55\u5b57\u8282\u3002\u5b57\u7b26\u4e32\u53ef\u80fd\u51fa\u73b0\u591a\u6b21; \u53ef\u80fd\u5b58\u5728\u5bf9\u5b50\u5b57\u7b26\u7684\u5f15\u7528; \u5e76\u4e14\u5355\u4e2a\u5b57\u7b26\u4e32\u53ef\u4ee5\u88ab\u5f15\u7528\u591a\u6b21\u3002\u8fd8\u5141\u8bb8\u672a\u88ab\u5f15\u7528\u7684\u5b57\u7b26\u4e32\u3002 \u5728\u7a0b\u5e8f\u4e2d\u5b9a\u4e49\u7684\u51fd\u6570\u540d\u79f0\uff0c\u53d8\u91cf\u540d\u79f0\u5c31\u5305\u542b\u5728\u6b64section\u4e2d\uff0csymbol table\u662f\u5bf9\u8fd9\u4e9b\u5b57\u7b26\u4e32\u7684\u89e3\u91ca\u3002\u5176\u4ed6section\u662f\u901a\u8fc7index\u6765\u5f15\u7528string section\u4e2d\u7684 \u5b57\u7b26\u4e32\u7684\u3002","title":"String Table"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#symbol#table","text":"object file\u7684symbol table\u5305\u542b\u9700\u8981\u88ab\u5b9a\u4f4d\u548c\u91cd\u5b9a\u4f4d\u7684\u4fe1\u606f\uff08\u7a0b\u5e8f\u7b26\u53f7\u5b9a\u4e49\u548c\u5f15\u7528\uff09\uff0c\u4e00\u4e2a\u7b26\u53f7\u8868\u7d22\u5f15\u662f\u8fd9\u4e2a\u6570\u7ec4\u7684\u4e0b\u6807\u3002\u7d22\u5f150\u6307\u5b9a\u4e86\u8868\u7684\u7b2c\u4e00\u4e2a\u5165\u53e3\uff0c\u5145\u5f53\u672a\u5b9a\u4e49\u7b26\u53f7\u7d22\u5f15\u3002\u8fd9\u4e2a\u521d\u59cb\u5316\u5165\u53e3\u7684\u5185\u5bb9\u4f1a\u5728\u672c\u8282\u540e\u9762\u90e8\u5206\u6307\u5b9a\u3002 \u7b26\u53f7\u8868\u6761\u76ee\u7684\u683c\u5f0f\u5982\u4e0b\uff1a","title":"Symbol Table"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#st_name","text":"\u6b64\u6210\u5458\u7684\u503c\u662f\u5728object file\u7684symbol string table\u4e2d\u7684\u7d22\u5f15\uff0csymbol string table\u4fdd\u5b58\u4e86symbol\u7684\u5b57\u7b26\u8868\u793a\u3002","title":"st_name"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#st_value","text":"\u8be5\u6210\u5458\u7ed9\u51fa\u4e86\u76f8\u5173\u8054\u7684symbol\u7684\u503c\u3002\u4e00\u4e2asymbol\u7684\u503c\u53ef\u4ee5\u662f\u662fabsolute value\uff0c\u5730\u5740\u7b49\u7b49\uff0c\u5b83\u7684\u503c\u53d6\u51b3\u4e8e\u4e0a\u4e0b\u6587\u3002 \u5173\u4e8esymbol\u7684\u503c\u8be6\u7ec6\u4fe1\u606f\u4f1a\u5728\u4e0b\u9762\u8fdb\u884c\u89e3\u91ca\u3002","title":"st_value"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#st_size","text":"\u8bb8\u591asymbol\u5177\u6709\u5927\u5c0f\u3002\u4f8b\u5982\uff0c\u6570\u636e\u5bf9\u8c61\u7684\u5927\u5c0f\u662f\u5bf9\u8c61\u4e2d\u5305\u542b\u7684\u5b57\u8282\u6570\u3002\u5982\u679c\u7b26\u53f7\u6ca1\u6709\u5927\u5c0f\u6216\u672a\u77e5\u5927\u5c0f\uff0c\u5219\u6b64\u6210\u5458\u4fdd\u75590\u3002","title":"st_size"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#st_info","text":"\u6b64\u6210\u5458\u6307\u5b9a\u7b26\u53f7\u7684type\u7c7b\u578b\u548cbinding attributes\u7ed1\u5b9a\u5c5e\u6027\u3002\u4e0b\u9762\u663e\u793a\u4e86\u503c\u548c\u542b\u4e49\u7684\u5217\u8868\u3002\u4ee5\u4e0b\u4ee3\u7801\u663e\u793a\u5982\u4f55\u5904\u7406\u503c\u3002","title":"st_info"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#st_shndx","text":"\u6bcf\u4e2asymbol table entry\u7b26\u53f7\u8868\u6761\u76ee\u90fd\u662f\u76f8\u5bf9\u4e8e\u67d0\u4e2asection\u6bb5\u201c\u5b9a\u4e49\u201d\u7684;\u8fd9\u4e2a\u6210\u5458\u8868\u793a\u76f8\u5173\u8054\u7684section\u5728section header table\u8282\u5934\u8868\u7684\u7d22\u5f15\u503c\u3002\u5982\u56fe1-7\u548c\u76f8\u5173\u6587\u672c\u6240\u8ff0\uff0c\u4e00\u4e9b\u6bb5\u7d22\u5f15\u8868\u793a\u7279\u6b8a\u542b\u4e49\u3002 A symbol's binding determines the linkage visibility and behavior.\u7b26\u53f7\u7684\u7ed1\u5b9a\u51b3\u5b9a\u4e86\u94fe\u63a5\u7684\u53ef\u89c1\u6027\u548c\u884c\u4e3a\u3002","title":"st_shndx"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#symbol#binding","text":"","title":"symbol binding"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#stb_local","text":"Local symbols are not visible outside the object file containing their definition\u5728\u5305\u542b\u6b64symbol\u5b9a\u4e49\u7684object file\u4e4b\u5916\u7684object file\u4e2d\u6b64symbol\u662f\u4e0d\u53ef\u89c1\u7684. Local symbols of the same name may exist in multiple files without interfering with each other\u663e\u7136\u5728\u4e0d\u540c\u7684object file\u4e2d\u662f\u53ef\u4ee5\u5b58\u5728\u76f8\u540c\u540d\u5b57\u7684local symbol\u7684\u3002","title":"STB_LOCAL"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#stb_global","text":"Global symbols are visible to all object files being combined global symbol\u662f\u5168\u5c40\u53ef\u89c1\u7684. One file's definition of a global symbol will satisfy another file's undefined reference to the same global symbol.","title":"STB_GLOBAL"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#stb_weak","text":"Weak symbols resemble global symbols, but their definitions have lower precedence .","title":"STB_WEAK"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#stb_loproc#through#stb_hiproc","text":"Values in this inclusive range are reserved for processor-specific semantics. In each symbol table, all symbols with STB_LOCAL binding precede the weak and global symbols . A symbol's type provides a general classification for the associated entity.","title":"STB_LOPROC through STB_HIPROC"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#symbol#type","text":"","title":"symbol type"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#stt_notype","text":"The symbol's type is not specified.","title":"STT_NOTYPE"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#stt_object","text":"The symbol is associated with a data object, such as a variable , an array ,and so on.","title":"STT_OBJECT"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#stt_func","text":"The symbol is associated with a function or other executable code .","title":"STT_FUNC"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#stt_section","text":"The symbol is associated with a section . Symbol table entries of this type exist primarily for relocation and normally have STB_LOCAL binding .","title":"STT_SECTION"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#stt_loproc#through#stt_hiproc","text":"Values in this inclusive range are reserved for processor-specific semantics. If a symbol's value refers to a specific location within a section, its section index member, st_shndx , holds an index into the section header table.As the section moves during relocation, the symbol's value changes as well,and references to the symbol continue to \"point'' to the same location in the program. Some special section index values give other semantics.","title":"STT_LOPROC through STT_HIPROC"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#stt_file","text":"A file symbol has STB_LOCAL binding, its section index is SHN_ABS , and it precedes the other STB_LOCAL symbols for the file, if it is present. The symbols in ELF object files convey specific information to the linker and loader. See the operating system sections for a description of the actual linking model used in the system.","title":"STT_FILE"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I/ELF/#shn_abs_1","text":"The symbol has an absolute value that will not change because of relocation. SHN_COMMON The symbol labels a common block that has not yet been allocated. The symbol's value gives alignment constraints, similar to a section's sh_addralign member. That is, the link editor will allocate the storage for the symbol at an address that is a multiple of st_value . The symbol's size tells how many bytes are required. SHN_UNDEF This section table index means the symbol is undefined. When the link editor combines this object file with another that defines the indicated symbol, this file's references to the symbol will be linked to the actual definition.","title":"SHN_ABS"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I%20program%20loading%20and%20dynamic%20linking/program%20loading%20and%20dynamic%20linking/","text":"Introduction This chapter describes the object file information and system actions that create running programs. Executable and shared object files statically represent programs. To execute such programs, the system uses the files to create dynamic program representations, or process images. A process image has segments that hold its text, data, stack, and so on. This section describes the program header and complements Chapter 1, by describing object file structures that relate directly to program execution. The primary data structure, a program header table, locates segment images within the file and contains other information necessary to create the memory image for the program. \u4e00\u4e2aprocess image\u4f7f\u7528segment\u6765\u88c5\u8f7dtext\uff0cdata\uff0cstack\u7b49\u7b49\u3002 Given an object file, the system must load it into memory for the program to run. After the system loads the program, it must complete the process image by resolving symbolic references among the object files that compose the process. \u7ed9\u5b9a\u4e00\u4e2aobject file\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5fc5\u987b\u628a\u5b83\u88c5\u8f7d\u5230\u5185\u5b58\u4e2d\u624d\u80fd\u591f\u6267\u884c\u6b64\u7a0b\u5e8f\u3002\u5728\u64cd\u4f5c\u7cfb\u7edf\u5c06\u7a0b\u5e8f\u88c5\u8f7d\u5b8c\u6210\u540e\uff0c\u5b83\u5fc5\u987b\u89e3\u6790symbolic reference\uff0c\u8fd9\u6837\u624d\u80fd\u591f\u5b8c\u6210\u8fdb\u7a0b\u7684\u521b\u5efa\u3002 Program Header An executable or shared object file's program header table is an array of structures, each describing a segment or other information the system needs to prepare the program for execution. An object file segment contains one or more sections. Program headers are meaningful only for executable and shared object files. A file specifies its own program header size with the ELF header's e_phentsize and e_phnum members [see \"ELF Header'' in Chapter 1]. program header table\u662f\u4e00\u4e2a\u6570\u7ec4\uff0c\u6570\u7ec4\u7684\u5143\u7d20\u7c7b\u578b\u662f\u5982\u4e0b\u5b9a\u4e49\u7684Program Header\uff0c\u901a\u8fc7Program Header\u6765\u63cf\u8ff0\u4e00\u4e2asegment\u6216\u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u7528\u6765\u6267\u884c\u7a0b\u5e8f\u7684\u4fe1\u606f\u3002\u4e00\u4e2aobject file\u7684segment\u5305\u542b\u4e00\u4e2a\u6216\u591a\u4e2asection\u3002 Figure 2-1. Program Header typedef struct { Elf32_Word p_type ; Elf32_Off p_offset ; Elf32_Addr p_vaddr ; Elf32_Addr p_paddr ; Elf32_Word p_filesz ; Elf32_Word p_memsz ; Elf32_Word p_flags ; Elf32_Word p_align ; } Elf32_Phdr p_type This member tells what kind of segment this array element describes or how to interpret the array element's information. Type values and their meanings appear below. p_offset This member gives the offset from the beginning of the file at which the first byte of the segment resides. \u6b64\u53d8\u91cf\u7ed9\u51fa\u7684\u662fsegment\u5728file image\u4e2d\u7684\u4f4d\u7f6e p_vaddr This member gives the virtual address at which the first byte of the segment resides in memory. \u6b64\u53d8\u91cf\u7ed9\u51fa\u7684\u662fsegment\u5728process image\u4e2d\u7684\u4f4d\u7f6e p_paddr On systems for which physical addressing is relevant, this member is reserved for the segment's physical address. This member requires operating system specific information, which is described in the appendix at the end of Book III. \u6b64\u53d8\u91cf\u7ed9\u51fa\u7684\u662fsegment\u5728process image\u4e2d\u7684\u4f4d\u7f6e p_filesz This member gives the number of bytes in the file image of the segment; it may be zero. \u6b64\u53d8\u91cf\u7ed9\u51fa\u7684\u662fsegment\u5728file image\u4e2d\u7684\u5927\u5c0f p_memsz This member gives the number of bytes in the memory image of the segment; it may be zero. \u6b64\u53d8\u91cf\u7ed9\u51fa\u7684\u662fsegment\u5728process image\u4e2d\u7684\u5927\u5c0f","title":"Program loading and dynamic linking"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I%20program%20loading%20and%20dynamic%20linking/program%20loading%20and%20dynamic%20linking/#introduction","text":"This chapter describes the object file information and system actions that create running programs. Executable and shared object files statically represent programs. To execute such programs, the system uses the files to create dynamic program representations, or process images. A process image has segments that hold its text, data, stack, and so on. This section describes the program header and complements Chapter 1, by describing object file structures that relate directly to program execution. The primary data structure, a program header table, locates segment images within the file and contains other information necessary to create the memory image for the program. \u4e00\u4e2aprocess image\u4f7f\u7528segment\u6765\u88c5\u8f7dtext\uff0cdata\uff0cstack\u7b49\u7b49\u3002 Given an object file, the system must load it into memory for the program to run. After the system loads the program, it must complete the process image by resolving symbolic references among the object files that compose the process. \u7ed9\u5b9a\u4e00\u4e2aobject file\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5fc5\u987b\u628a\u5b83\u88c5\u8f7d\u5230\u5185\u5b58\u4e2d\u624d\u80fd\u591f\u6267\u884c\u6b64\u7a0b\u5e8f\u3002\u5728\u64cd\u4f5c\u7cfb\u7edf\u5c06\u7a0b\u5e8f\u88c5\u8f7d\u5b8c\u6210\u540e\uff0c\u5b83\u5fc5\u987b\u89e3\u6790symbolic reference\uff0c\u8fd9\u6837\u624d\u80fd\u591f\u5b8c\u6210\u8fdb\u7a0b\u7684\u521b\u5efa\u3002","title":"Introduction"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/ELF%E6%96%87%E6%A1%A3-book%20I%20program%20loading%20and%20dynamic%20linking/program%20loading%20and%20dynamic%20linking/#program#header","text":"An executable or shared object file's program header table is an array of structures, each describing a segment or other information the system needs to prepare the program for execution. An object file segment contains one or more sections. Program headers are meaningful only for executable and shared object files. A file specifies its own program header size with the ELF header's e_phentsize and e_phnum members [see \"ELF Header'' in Chapter 1]. program header table\u662f\u4e00\u4e2a\u6570\u7ec4\uff0c\u6570\u7ec4\u7684\u5143\u7d20\u7c7b\u578b\u662f\u5982\u4e0b\u5b9a\u4e49\u7684Program Header\uff0c\u901a\u8fc7Program Header\u6765\u63cf\u8ff0\u4e00\u4e2asegment\u6216\u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u7528\u6765\u6267\u884c\u7a0b\u5e8f\u7684\u4fe1\u606f\u3002\u4e00\u4e2aobject file\u7684segment\u5305\u542b\u4e00\u4e2a\u6216\u591a\u4e2asection\u3002 Figure 2-1. Program Header typedef struct { Elf32_Word p_type ; Elf32_Off p_offset ; Elf32_Addr p_vaddr ; Elf32_Addr p_paddr ; Elf32_Word p_filesz ; Elf32_Word p_memsz ; Elf32_Word p_flags ; Elf32_Word p_align ; } Elf32_Phdr p_type This member tells what kind of segment this array element describes or how to interpret the array element's information. Type values and their meanings appear below. p_offset This member gives the offset from the beginning of the file at which the first byte of the segment resides. \u6b64\u53d8\u91cf\u7ed9\u51fa\u7684\u662fsegment\u5728file image\u4e2d\u7684\u4f4d\u7f6e p_vaddr This member gives the virtual address at which the first byte of the segment resides in memory. \u6b64\u53d8\u91cf\u7ed9\u51fa\u7684\u662fsegment\u5728process image\u4e2d\u7684\u4f4d\u7f6e p_paddr On systems for which physical addressing is relevant, this member is reserved for the segment's physical address. This member requires operating system specific information, which is described in the appendix at the end of Book III. \u6b64\u53d8\u91cf\u7ed9\u51fa\u7684\u662fsegment\u5728process image\u4e2d\u7684\u4f4d\u7f6e p_filesz This member gives the number of bytes in the file image of the segment; it may be zero. \u6b64\u53d8\u91cf\u7ed9\u51fa\u7684\u662fsegment\u5728file image\u4e2d\u7684\u5927\u5c0f p_memsz This member gives the number of bytes in the memory image of the segment; it may be zero. \u6b64\u53d8\u91cf\u7ed9\u51fa\u7684\u662fsegment\u5728process image\u4e2d\u7684\u5927\u5c0f","title":"Program Header"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/Segment%20Permissions/","text":"Segment Permissions A program to be loaded by the system must have at least one loadable segment (although this is not required by the file format). When the system creates loadable segments' memory images, it gives access permissions as specified in the p_flags member. \u4e00\u4e2a\u7a0b\u5e8f\u81f3\u5c11\u6709\u4e00\u4e2aloadable segment\u624d\u80fd\u591f\u88ab\u64cd\u4f5c\u7cfb\u7edf\u88c5\u8f7d\u3002\u5f53\u64cd\u4f5c\u7cfb\u7edf\u521b\u5efaloadable segment\u7684memory image\u7684\u65f6\u5019\uff0c\u5b83\u4f1a\u6309\u7167p_flags\u6210\u5458\u6765\u8bbe\u7f6e\u8fd9\u4e2a\u5df2\u7ecf\u88c5\u8f7d\u5230\u5185\u5b58\u4e2d\u7684segment\u7684\u8bbf\u95ee\u6743\u9650\u3002 Figure 2-2. Segment Flag Bits, p_flags Name Value Meaning PF_X 0x1 Execute PF_W 0x2 Write PF_R 0x4 Read PF_MASKPROC 0xf0000000 Unspecified All bits included in the PF_MASKPROC mask are reserved for processor-specific semantics. If meanings are specified, the processor supplement explains them. If a permission bit is 0, that type of access is denied. Actual memory permissions depend on the memory management unit, which may vary from one system to another. Although all flag combinations are valid, the system may grant more access than requested. In no case, however,will a segment have write permission unless it is specified explicitly. The following table shows both the exact flag interpretation and the allowable flag interpretation. TIS-conforming systems may provide either. \u5982\u679c\u4e00\u4e2apermission bit\u8bbe\u7f6e\u4e3a0\uff0c\u90a3\u4e48\u5b83\u5bf9\u5e94\u7684access type\u662f\u88ab\u62d2\u7edd\u7684\u3002\u9664\u975e\u663e\u5f0f\u5730\u7ed9\u4e00\u4e2asegment\u6307\u5b9awrite permission\uff0c\u5426\u5219\u5b83\u662f\u4e0d\u4f1a\u6709write permission\u7684\u3002 Figure 2-3. Segment Permissions For example, typical text segments have read and execute \u2014but not write \u2014permissions. Data segments normally have read, write, and execute permissions. \u53ef\u7528\u770b\u5230segment permission\u7684\u53d6\u503c\u4e3a\u4ece0\u52307\uff0c\u5176\u5b9e\u8fd9\u4e9b\u53d6\u503c\u6b63\u5f0fPF_X\uff0cPF_W\uff0cPF_R\u7684\u7ec4\u5408\u3002 \u5176\u5b9e\u5173\u4e8e Segment Permissions\u548cSegment Flag \u6211\u6709\u4e00\u4e2a\u7591\u95ee\uff1a \u5728program header\u4e2d\u4fdd\u5b58\u7684\u5230\u5e95\u662f0\u52307\uff0c\u8fd8\u662fPF_X\uff0cPF_W\uff0cPF_R\uff1f\uff1f","title":"Segment Permissions"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/Segment%20Permissions/#segment#permissions","text":"A program to be loaded by the system must have at least one loadable segment (although this is not required by the file format). When the system creates loadable segments' memory images, it gives access permissions as specified in the p_flags member. \u4e00\u4e2a\u7a0b\u5e8f\u81f3\u5c11\u6709\u4e00\u4e2aloadable segment\u624d\u80fd\u591f\u88ab\u64cd\u4f5c\u7cfb\u7edf\u88c5\u8f7d\u3002\u5f53\u64cd\u4f5c\u7cfb\u7edf\u521b\u5efaloadable segment\u7684memory image\u7684\u65f6\u5019\uff0c\u5b83\u4f1a\u6309\u7167p_flags\u6210\u5458\u6765\u8bbe\u7f6e\u8fd9\u4e2a\u5df2\u7ecf\u88c5\u8f7d\u5230\u5185\u5b58\u4e2d\u7684segment\u7684\u8bbf\u95ee\u6743\u9650\u3002 Figure 2-2. Segment Flag Bits, p_flags Name Value Meaning PF_X 0x1 Execute PF_W 0x2 Write PF_R 0x4 Read PF_MASKPROC 0xf0000000 Unspecified All bits included in the PF_MASKPROC mask are reserved for processor-specific semantics. If meanings are specified, the processor supplement explains them. If a permission bit is 0, that type of access is denied. Actual memory permissions depend on the memory management unit, which may vary from one system to another. Although all flag combinations are valid, the system may grant more access than requested. In no case, however,will a segment have write permission unless it is specified explicitly. The following table shows both the exact flag interpretation and the allowable flag interpretation. TIS-conforming systems may provide either. \u5982\u679c\u4e00\u4e2apermission bit\u8bbe\u7f6e\u4e3a0\uff0c\u90a3\u4e48\u5b83\u5bf9\u5e94\u7684access type\u662f\u88ab\u62d2\u7edd\u7684\u3002\u9664\u975e\u663e\u5f0f\u5730\u7ed9\u4e00\u4e2asegment\u6307\u5b9awrite permission\uff0c\u5426\u5219\u5b83\u662f\u4e0d\u4f1a\u6709write permission\u7684\u3002 Figure 2-3. Segment Permissions For example, typical text segments have read and execute \u2014but not write \u2014permissions. Data segments normally have read, write, and execute permissions. \u53ef\u7528\u770b\u5230segment permission\u7684\u53d6\u503c\u4e3a\u4ece0\u52307\uff0c\u5176\u5b9e\u8fd9\u4e9b\u53d6\u503c\u6b63\u5f0fPF_X\uff0cPF_W\uff0cPF_R\u7684\u7ec4\u5408\u3002 \u5176\u5b9e\u5173\u4e8e Segment Permissions\u548cSegment Flag \u6211\u6709\u4e00\u4e2a\u7591\u95ee\uff1a \u5728program header\u4e2d\u4fdd\u5b58\u7684\u5230\u5e95\u662f0\u52307\uff0c\u8fd8\u662fPF_X\uff0cPF_W\uff0cPF_R\uff1f\uff1f","title":"Segment Permissions"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20ELF%E6%96%87%E4%BB%B6%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E6%98%AF%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E5%80%BC%E8%80%8C%E4%B8%8D%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E5%80%BC%E7%9A%84/","text":"SHN_ABS This value specifies absolute values for the corresponding reference. For example, symbols defined relative to section number SHN_ABS have absolute values and are not affected by relocation. \u76f8\u5bf9\u4e8e\u8fd9\u4e2asection\u5b9a\u4e49\u7684symbol\u662f\u4e0d\u53d7relocation\u5f71\u54cd\u7684 \u5728\u9605\u8bfbSymbol Types\u7684\u4ecb\u7ecd\u4e2d\u53d1\u73b0\u6709\u4e00\u7c7bsymbol\u662f\u76f8\u5bf9\u4e8eSHN_ABS\u5b9a\u4e49\uff1aSTT_FILE\uff0c\u5b83\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a STT_FILE A file symbol has STB_LOCAL binding, its section index is SHN_ABS , and it precedes the other STB_LOCAL symbols for the file, if it is present. SHN_COMMON Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables. \u516c\u5171symbol","title":"TODO ELF\u6587\u4ef6\u4e2d\u54ea\u4e9b\u6570\u636e\u662f\u5fc5\u987b\u8981\u4f7f\u7528\u7edd\u5bf9\u503c\u800c\u4e0d\u80fd\u591f\u4f7f\u7528\u76f8\u5bf9\u503c\u7684"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20ELF%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E6%98%AF%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%9C%89%E5%85%B3%E7%9A%84/","text":"ELF Header\u7684e_entry\u6210\u5458 \u5bf9\u4e8e\u53ef\u6267\u884c\u6587\u4ef6\u548c\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5b83\u4eec\u7684e_entry\u662f\u6709\u503c\u7684\uff0c\u6211\u770bELF\u6587\u6863\u4e2d\u5bf9\u4e8e\u8fd9\u4e2a\u5b57\u6bb5\u7684\u89e3\u91ca\u5982\u4e0b\uff1a e_entry This member gives the virtual address to which the system first transfers control,thus starting the process. If the file has no associated entry point, this member holds zero. \u770b\u6211\u8fd9\u6bb5\u8bdd\u6211\u7684\u7406\u89e3\u662f\uff0c\u5f53\u6211\u4eec\u7f16\u8bd1\u751f\u6210\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\u540e\uff0c\u5982\u679c\u6267\u884c\u8fd9\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u8fd9\u4e2a\u5730\u5740\u5c31\u662f\u8fdb\u7a0b\u5f00\u59cb\u7684\u865a\u5730\u5740\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u4e00\u4e2a\u8fdb\u7a0b\u7684\u5f00\u59cb\u5730\u5740\u662f\u5728\u7f16\u8bd1\u5b8c\u6210\u540e\u5c31\u5df2\u7ecf\u786e\u5b9a\u4e86\uff0c\u5e76\u4e14\u4e00\u76f4\u4e0d\u53d8\u3002\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u6709\u5982\u6b64\u4e4b\u591a\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u4ed6\u4eec\u7684\u5f00\u59cb\u5730\u5740\u90fd\u662f\u63d0\u524d\u786e\u5b9a\u7684\uff0c\u96be\u9053\u4e0d\u4f1a\u51b2\u7a81\u5417\uff1f\u5e76\u4e14\u6211\u4eec\u7f16\u8bd1\u751f\u6210\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u662f\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u673a\u5668\u4e0a\u8fdb\u884c\u6267\u884c\u7684\uff0c\u90a3\u4e48\u5728\u5728\u53e6\u5916\u4e00\u53f0\u673a\u5668\u4e0a\uff0c\u5c31\u6709\u53ef\u80fd\u51b2\u7a81\u4e86\u3002 Section Header\u7684sh_addr\u6210\u5458 \u5728section\u7684\u7ed3\u6784\u4e2d\u4e5f\u6709\u7c7b\u4f3c\u7684\u6210\u5458\u53d8\u91cf\uff1ash_addr\uff0c\u8fd9\u4e2a\u53d8\u91cf\u7ed9\u51fa\u4e86\u8fd9\u4e2asection\u5728\u5185\u5b58\u4e2d\u7684\u4f4d\u7f6e\u3002\u5173\u4e8e\u8fd9\u4e2a\u6210\u5458\uff0c\u6587\u6863\u7684\u89e3\u91ca\u5982\u4e0b\uff1a sh_addr If the section will appear in the memory image of a process, this member gives the address at which the section's first byte should reside. Otherwise,the member contains 0. Section Header\u7684sh_flags\u6210\u5458 \u663e\u7136\u8fd9\u4e2a\u5b57\u6bb5\u7684\u503c\u5f71\u54cd\u4e86\u5728\u8be5section\u88ab\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\u540e\uff0c\u8fdb\u7a0b\u5f00\u59cb\u6267\u884c\u65f6\uff0c\u5bf9\u8fd9\u4e2asection\u7684\u64cd\u4f5c\u3002 \u53c2\u8003 ELF\u6587\u4ef6\u7684\u52a0\u8f7d\u548c\u52a8\u6001\u94fe\u63a5\u8fc7\u7a0b","title":"ELF Header\u7684e_entry\u6210\u5458"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20ELF%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E6%98%AF%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%9C%89%E5%85%B3%E7%9A%84/#elf#headere_entry","text":"\u5bf9\u4e8e\u53ef\u6267\u884c\u6587\u4ef6\u548c\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5b83\u4eec\u7684e_entry\u662f\u6709\u503c\u7684\uff0c\u6211\u770bELF\u6587\u6863\u4e2d\u5bf9\u4e8e\u8fd9\u4e2a\u5b57\u6bb5\u7684\u89e3\u91ca\u5982\u4e0b\uff1a e_entry This member gives the virtual address to which the system first transfers control,thus starting the process. If the file has no associated entry point, this member holds zero. \u770b\u6211\u8fd9\u6bb5\u8bdd\u6211\u7684\u7406\u89e3\u662f\uff0c\u5f53\u6211\u4eec\u7f16\u8bd1\u751f\u6210\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\u540e\uff0c\u5982\u679c\u6267\u884c\u8fd9\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u8fd9\u4e2a\u5730\u5740\u5c31\u662f\u8fdb\u7a0b\u5f00\u59cb\u7684\u865a\u5730\u5740\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u4e00\u4e2a\u8fdb\u7a0b\u7684\u5f00\u59cb\u5730\u5740\u662f\u5728\u7f16\u8bd1\u5b8c\u6210\u540e\u5c31\u5df2\u7ecf\u786e\u5b9a\u4e86\uff0c\u5e76\u4e14\u4e00\u76f4\u4e0d\u53d8\u3002\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u6709\u5982\u6b64\u4e4b\u591a\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u4ed6\u4eec\u7684\u5f00\u59cb\u5730\u5740\u90fd\u662f\u63d0\u524d\u786e\u5b9a\u7684\uff0c\u96be\u9053\u4e0d\u4f1a\u51b2\u7a81\u5417\uff1f\u5e76\u4e14\u6211\u4eec\u7f16\u8bd1\u751f\u6210\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u662f\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u673a\u5668\u4e0a\u8fdb\u884c\u6267\u884c\u7684\uff0c\u90a3\u4e48\u5728\u5728\u53e6\u5916\u4e00\u53f0\u673a\u5668\u4e0a\uff0c\u5c31\u6709\u53ef\u80fd\u51b2\u7a81\u4e86\u3002","title":"ELF Header\u7684e_entry\u6210\u5458"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20ELF%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E6%98%AF%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%9C%89%E5%85%B3%E7%9A%84/#section#headersh_addr","text":"\u5728section\u7684\u7ed3\u6784\u4e2d\u4e5f\u6709\u7c7b\u4f3c\u7684\u6210\u5458\u53d8\u91cf\uff1ash_addr\uff0c\u8fd9\u4e2a\u53d8\u91cf\u7ed9\u51fa\u4e86\u8fd9\u4e2asection\u5728\u5185\u5b58\u4e2d\u7684\u4f4d\u7f6e\u3002\u5173\u4e8e\u8fd9\u4e2a\u6210\u5458\uff0c\u6587\u6863\u7684\u89e3\u91ca\u5982\u4e0b\uff1a sh_addr If the section will appear in the memory image of a process, this member gives the address at which the section's first byte should reside. Otherwise,the member contains 0.","title":"Section Header\u7684sh_addr\u6210\u5458"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20ELF%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E6%98%AF%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%9C%89%E5%85%B3%E7%9A%84/#section#headersh_flags","text":"\u663e\u7136\u8fd9\u4e2a\u5b57\u6bb5\u7684\u503c\u5f71\u54cd\u4e86\u5728\u8be5section\u88ab\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\u540e\uff0c\u8fdb\u7a0b\u5f00\u59cb\u6267\u884c\u65f6\uff0c\u5bf9\u8fd9\u4e2asection\u7684\u64cd\u4f5c\u3002 \u53c2\u8003 ELF\u6587\u4ef6\u7684\u52a0\u8f7d\u548c\u52a8\u6001\u94fe\u63a5\u8fc7\u7a0b","title":"Section Header\u7684sh_flags\u6210\u5458"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20SHT_RELA%E5%92%8CSHT_REL/","text":"","title":"TODO SHT RELA\u548cSHT REL"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20VMA%E5%92%8CLMA/","text":"","title":"TODO VMA\u548cLMA"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20base%20address/","text":"Base Address The virtual addresses in the program headers might not represent the actual virtual addresses of the program's memory image. Executable files typically contain absolute code . To let the process execute correctly, the segments must reside at the virtual addresses used to build the executable file. On the other hand, shared object segments typically contain position-independent code . This lets a segment's virtual address change from one process to another, without invalidating execution behavior. Though the system chooses virtual addresses for individual processes, it maintains the segments\u2019 relative positions . Because position-independent code uses relative addressing between segments , the difference between virtual addresses in memory must match the difference between virtual addresses in the file. The difference between the virtual address of any segment in memory and the corresponding virtual address in the file is thus a single constant value for any one executable or shared object in a given process . This difference is the base address . One use of the base address is to relocate the memory image of the program during dynamic linking . An executable or shared object file's base address is calculated during execution from three values: the virtual memory load address, the maximum page size, and the lowest virtual address of a program's loadable segment. To compute the base address, one determines the memory address associated with the lowest p_vaddr value for a PT_LOAD segment . This address is truncated to the nearest multiple of the maximum page size . The corresponding p_vaddr value itself is also truncated to the nearest multiple of the maximum page size . The base address is the difference between the truncated memory address and the truncated p_vaddr value . \u4e00\u4e2aexecutable file\u6216shared object file\u7684base address\u662f\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\u6839\u636e\u4e09\u4e2a\u503c\u8ba1\u7b97\u800c\u6765\u7684\uff1a the virtual memory load address\u88c5\u5165\u5730\u5740 the maximum page size the lowest virtual address of a program's loadable segment Q&A base address\u6709\u4f55\u7528\uff1f","title":"TODO base address"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20base%20address/#base#address","text":"The virtual addresses in the program headers might not represent the actual virtual addresses of the program's memory image. Executable files typically contain absolute code . To let the process execute correctly, the segments must reside at the virtual addresses used to build the executable file. On the other hand, shared object segments typically contain position-independent code . This lets a segment's virtual address change from one process to another, without invalidating execution behavior. Though the system chooses virtual addresses for individual processes, it maintains the segments\u2019 relative positions . Because position-independent code uses relative addressing between segments , the difference between virtual addresses in memory must match the difference between virtual addresses in the file. The difference between the virtual address of any segment in memory and the corresponding virtual address in the file is thus a single constant value for any one executable or shared object in a given process . This difference is the base address . One use of the base address is to relocate the memory image of the program during dynamic linking . An executable or shared object file's base address is calculated during execution from three values: the virtual memory load address, the maximum page size, and the lowest virtual address of a program's loadable segment. To compute the base address, one determines the memory address associated with the lowest p_vaddr value for a PT_LOAD segment . This address is truncated to the nearest multiple of the maximum page size . The corresponding p_vaddr value itself is also truncated to the nearest multiple of the maximum page size . The base address is the difference between the truncated memory address and the truncated p_vaddr value . \u4e00\u4e2aexecutable file\u6216shared object file\u7684base address\u662f\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\u6839\u636e\u4e09\u4e2a\u503c\u8ba1\u7b97\u800c\u6765\u7684\uff1a the virtual memory load address\u88c5\u5165\u5730\u5740 the maximum page size the lowest virtual address of a program's loadable segment","title":"Base Address"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20base%20address/#qa","text":"base address\u6709\u4f55\u7528\uff1f","title":"Q&amp;A"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20bss%E5%92%8Cdata%20section/","text":"bss .bss This section holds uninitialized data that contribute to the program's memory image. By definition, the system initializes the data with zeros when the program begins to run. The section occupies no file space, as indicated by the section type, SHT_NOBITS . \u6211\u7684\u7591\u60d1\u662f\uff1a \u5728\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f1a\u5728\u5168\u5c40\u5b9a\u4e49\u5168\u5c40\u53d8\u91cf\uff0c\u5728\u51fd\u6570\u5185\u5b9a\u4e49\u5c40\u90e8\u53d8\u91cf\uff0c\u662f\u5426\u6240\u6709\u8fd9\u4e9b\u672a\u521d\u59cb\u5316\u7684\u53d8\u91cf\u90fd\u4fdd\u5b58\u5728\u8fd9\u4e2asection\u4e2d\u3002\u540c\u6837\u7684\uff0c\u5bf9\u4e8edata\u6bb5\u4e5f\u662f\u5982\u6b64\u3002 data .data and .data1 These sections hold initialized data that contribute to the program's memory image. \u6211\u7684\u7591\u95ee\u662f\uff1a \u8fd9\u4e9b\u521d\u59cb\u5316\u8fc7\u7684\u53d8\u91cf\uff0c\u5728\u8fd9\u4e2asection\u4e2d\u662f\u5982\u4f55\u4fdd\u5b58\u7684 \u200b","title":"bss"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20bss%E5%92%8Cdata%20section/#bss","text":".bss This section holds uninitialized data that contribute to the program's memory image. By definition, the system initializes the data with zeros when the program begins to run. The section occupies no file space, as indicated by the section type, SHT_NOBITS . \u6211\u7684\u7591\u60d1\u662f\uff1a \u5728\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u4f1a\u5728\u5168\u5c40\u5b9a\u4e49\u5168\u5c40\u53d8\u91cf\uff0c\u5728\u51fd\u6570\u5185\u5b9a\u4e49\u5c40\u90e8\u53d8\u91cf\uff0c\u662f\u5426\u6240\u6709\u8fd9\u4e9b\u672a\u521d\u59cb\u5316\u7684\u53d8\u91cf\u90fd\u4fdd\u5b58\u5728\u8fd9\u4e2asection\u4e2d\u3002\u540c\u6837\u7684\uff0c\u5bf9\u4e8edata\u6bb5\u4e5f\u662f\u5982\u6b64\u3002","title":"bss"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20bss%E5%92%8Cdata%20section/#data","text":".data and .data1 These sections hold initialized data that contribute to the program's memory image. \u6211\u7684\u7591\u95ee\u662f\uff1a \u8fd9\u4e9b\u521d\u59cb\u5316\u8fc7\u7684\u53d8\u91cf\uff0c\u5728\u8fd9\u4e2asection\u4e2d\u662f\u5982\u4f55\u4fdd\u5b58\u7684 \u200b","title":"data"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20section%E5%92%8Csegment%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","text":"\u73b0\u5728\u8c08\u8d77section\u548csegment\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u6211\u7684\u5927\u8111\u4e2d\u6709\u5982\u4e0b\u5370\u8c61\uff1a \u4e00\u4e2asegment\u662f\u7531\u82e5\u5e72\u4e2asection\u6784\u6210\u7684\uff0csection\u662fELF\u4e2d\u4fdd\u5b58\u6570\u636e\u7684\u6700\u5c0f\u5355\u5143 loadable segment\u662f\u4f1a\u88c5\u5165\u5230\u5185\u5b58\u4e2d\u7684 \u5173\u4e8e\u5b83\u4eec\u4e24\u8005\u7684\u5173\u7cfb\uff0c\u53ef\u4ee5\u4ecesegment\u7684\u5185\u5bb9\u8c08\u8d77\u3002 Segment Contents An object file segment comprises one or more sections, though this fact is transparent to the program header. Whether the file segment holds one or many sections also is immaterial to program loading. Nonetheless , various data must be present for program execution, dynamic linking, and so on. \u867d\u7136\u8bf4file image\u4e2d\u7684segment\u6240\u5305\u542b\u7684section\u7684\u4e2a\u6570\u5bf9program loading\u6765\u8bf4\u5e76\u4e0d\u91cd\u8981\uff0c\u4f46\u662f\uff0c\u5728\u7a0b\u5e8f\u6267\u884c\uff0c\u52a8\u6001\u94fe\u63a5\u65f6\u5019\u6240\u9700\u8981\u7684\u6570\u636efile image\u662f\u5fc5\u987b\u8981\u63d0\u4f9b\u7684\u3002 The diagrams below illustrate segment contents in general terms. The order and membership of sections within a segment may vary; moreover, processor-specific constraints may alter the examples below. Text segments contain read-only instructions and data, typically including the following sections. Other sections may also reside in loadable segments ; these examples are not meant to give complete and exclusive segment contents. Figure 2-4. Text Segment Figure 2-5. Data Segment A PT_DYNAMIC program header element points at the .dynamic section , explained in \"Dynamic Section\" below. The .got and .plt sections also hold information related to**position-independent code** and dynamic linking . Although the .plt appears in a text segment above, it may reside in a text or a data segment, depending on the processor. As \"Sections\" describes, the .bss section has the type SHT_NOBITS . Although it occupies no space in the file, it contributes to the segment's memory image. Normally, these uninitialized data reside at the end of the segment, thereby making p_memsz larger than p_filesz \u867d\u7136bss section\u5728file image\u4e2d\u5e76\u4e0d\u5360\u7a7a\u95f4\uff0c\u4f46\u662f\u5b83\u5728memory image\u4e2d\u662f\u5360\u636e\u7a7a\u95f4\u7684\uff0c\u6240\u4ee5p_memsz\u5927\u4e8e\u7b49\u4e8ep_filesz\u3002 Q&A \u4e0a\u9762\u63d0\u5230\u4e86\u4e00\u4e2asegment\u5305\u542b\u4e00\u4e2a\u6216\u591a\u4e2asection\uff0c\u6211\u7684\u95ee\u9898\u662f\uff0c\u8fd9\u79cd\u5305\u542b\u5173\u7cfb\u662f\u5982\u4f55\u5b9e\u73b0\u7684\uff1f\uff1f","title":"TODO section\u548csegment\u4e4b\u95f4\u7684\u5173\u7cfb"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20section%E5%92%8Csegment%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/#segment#contents","text":"An object file segment comprises one or more sections, though this fact is transparent to the program header. Whether the file segment holds one or many sections also is immaterial to program loading. Nonetheless , various data must be present for program execution, dynamic linking, and so on. \u867d\u7136\u8bf4file image\u4e2d\u7684segment\u6240\u5305\u542b\u7684section\u7684\u4e2a\u6570\u5bf9program loading\u6765\u8bf4\u5e76\u4e0d\u91cd\u8981\uff0c\u4f46\u662f\uff0c\u5728\u7a0b\u5e8f\u6267\u884c\uff0c\u52a8\u6001\u94fe\u63a5\u65f6\u5019\u6240\u9700\u8981\u7684\u6570\u636efile image\u662f\u5fc5\u987b\u8981\u63d0\u4f9b\u7684\u3002 The diagrams below illustrate segment contents in general terms. The order and membership of sections within a segment may vary; moreover, processor-specific constraints may alter the examples below. Text segments contain read-only instructions and data, typically including the following sections. Other sections may also reside in loadable segments ; these examples are not meant to give complete and exclusive segment contents. Figure 2-4. Text Segment Figure 2-5. Data Segment A PT_DYNAMIC program header element points at the .dynamic section , explained in \"Dynamic Section\" below. The .got and .plt sections also hold information related to**position-independent code** and dynamic linking . Although the .plt appears in a text segment above, it may reside in a text or a data segment, depending on the processor. As \"Sections\" describes, the .bss section has the type SHT_NOBITS . Although it occupies no space in the file, it contributes to the segment's memory image. Normally, these uninitialized data reside at the end of the segment, thereby making p_memsz larger than p_filesz \u867d\u7136bss section\u5728file image\u4e2d\u5e76\u4e0d\u5360\u7a7a\u95f4\uff0c\u4f46\u662f\u5b83\u5728memory image\u4e2d\u662f\u5360\u636e\u7a7a\u95f4\u7684\uff0c\u6240\u4ee5p_memsz\u5927\u4e8e\u7b49\u4e8ep_filesz\u3002","title":"Segment Contents"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20section%E5%92%8Csegment%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/#qa","text":"\u4e0a\u9762\u63d0\u5230\u4e86\u4e00\u4e2asegment\u5305\u542b\u4e00\u4e2a\u6216\u591a\u4e2asection\uff0c\u6211\u7684\u95ee\u9898\u662f\uff0c\u8fd9\u79cd\u5305\u542b\u5173\u7cfb\u662f\u5982\u4f55\u5b9e\u73b0\u7684\uff1f\uff1f","title":"Q&amp;A"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/","text":"\u5728Section Types\u4e2d\u6709\u5982\u4e0b\u4e24\u79cd\u7c7b\u578b\u5f15\u8d77\u4e86\u6211\u7684\u6ce8\u610f\uff1a SHT_SYMTAB \u548cSHT_DYNSYM SHT_STRTAB \u5728ELF\u6587\u6863\u4e2d\u5bf9\u8fd9\u4e24\u79cd\u7c7b\u578b\u662f\u8fd9\u6837\u89e3\u91ca\u7684\uff1a SHT_SYMTAB and SHT_DYNSYM These sections hold a symbol table.\u5373\u8fd9\u4e24\u79cd\u7c7b\u578b\u7684section\u4fdd\u5b58\u7684\u662fsymbol table SHT_STRTAB The section holds a string table. \u8054\u7cfb\u5230\u6211\u4e4b\u524d\u5728\u9605\u8bfbsection header\u7684\u65f6\u5019\uff0c\u53d1\u73b0section header\u7684\u7ed3\u6784\u4e2d\u6709\u5982\u4e0b\u6210\u5458\u53d8\u91cf\uff1a sh_entsize Some sections hold a table of fixed-size entries, such as a symbol table . For such a section, this member gives the size in bytes of each entry. The member contains 0 if the section does not hold a table of fixed-size entries. \u663e\u7136\uff0c\u5bf9\u4e8e\u4e0a\u9762\u4e24\u79cd\u7c7b\u578b\u7684section\uff0c\u4ed6\u4eec\u90fd\u662f\u5305\u542btable\u7684\uff0c\u6240\u4ee5\u4ed6\u4eec\u7684section header\u7684sh_entsize\u6210\u5458\u5c31\u5fc5\u987b\u6709\u503c\u3002 \u5173\u4e8e\u8fd9\u4e24\u8005\uff0c\u6211\u6709\u5982\u4e0b\u7591\u95ee\uff1a \u5b83\u4eec\u5206\u522b\u5b58\u653e\u4e0a\u9762\u5185\u5bb9 \u5b83\u4eec\u5b58\u653e\u7684\u5185\u5bb9\u662f\u5426\u6709\u5173\u8054 string table ELF\u4e2d\u4e0d\u6b62\u4e00\u4e2astring table\uff0c\u6709.strtab\uff0c.shstrtab .strtab This section holds strings, most commonly the strings that represent the names associated with symbol table entries. If a file has a loadable segment that includes the symbol string table, the section's attributes will include the SHF_ALLOC bit; otherwise, that bit will be off. \u548cstring table\u6709\u5173\u7684\u6210\u5458\u53d8\u91cf\u6709\uff1a section header\u7684sh_name\u6210\u5458\u53d8\u91cf\u7684\u503c\u5c31\u662f string table section\u7684\u7d22\u5f15 ELF header\u7684e_shstrndx\u6210\u5458\u53d8\u91cf\u4e5f\u662fstring table section\u7684\u7d22\u5f15 Symbol Table Entry\u7684st_name\u6210\u5458\u53d8\u91cf\u662f symbol string table\u7684\u7d22\u5f15 symtab .symtab This section holds a symbol table, as \"Symbol Table'' in this chapter describes. If a file has a loadable segment that includes the symbol table,the section's attributes will include the SHF_ALLOC bit; otherwise, that bit will be off. Symbol Table Entry typedef struct { Elf32_Word st_name ; Elf32_Addr st_value ; Elf32_Word st_size ; unsigned char st_info ; unsigned char st_other ; Elf32_Half st_shndx ; } Elf32_Sym ; st_name This member holds an index into the object file's symbol string table, which holds the character representations of the symbol names. st_value This member gives the value of the associated symbol. Depending on the context,this may be an absolute value, an address, and so on; details appear below. st_value\u5230\u5e95\u4fdd\u5b58\u7684\u662fsymbol\u7684\u4ec0\u4e48\u5185\u5bb9\uff1f\u662f\u5730\u5740\u8fd8\u662f\u503c\uff1fsymbol\u7684\u503c\u662f\u5426\u4fdd\u5b58\u5728data section\u4e2d\uff1f\uff1f \u5728ELF\u6587\u6863\u7684Symbol Values\u7ae0\u8282\u4ecb\u7ecd\u4e86\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u662f\u5730\u5740\u3002 st_size Many symbols have associated sizes. For example, a data object's size is the number of bytes contained in the object. This member holds 0 if the symbol has no size or an unknown size. \u4e3a\u4ec0\u4e48symbol\u8981\u4fdd\u5b58size\uff1f\uff1f st_shndx Every symbol table entry is \"defined'' in relation to some section; this member holds the relevant section header table index. As Figure 1-7 and the related text describe,some section indexes indicate special meanings. \u6709\u7684symbol\u662f\u76f8\u5bf9\u4e8e\u67d0\u4e2asection\u5b9a\u4e49\u7684\uff0cElf32_Sym\u7684st_shndx\u6210\u5458\u5c31\u8868\u660e\u8be5symbol\u6240\u53c2\u7167\u7684section\u3002 st_info This member specifies the symbol's type and binding attributes. A list of the values and meanings appears below. The following code shows how to manipulate the values. \u8fd9\u91cc\u63d0\u5230\u4e86\u6bcf\u4e2a\u7b26\u53f7\u7684\u4e24\u4e2a\u91cd\u8981\u5c5e\u6027\uff1a type binding Symbol Binding, ELF32_ST_BIND Name Value STB_LOCAL 0 STB_GLOBAL 1 STB_WEAK 2 STB_LOPROC 13 STB_HIPROC 15 STB_LOCAL Local symbols are not visible outside the object file containing their definition. Local symbols of the same name may exist in multiple files without interfering with each other. STB_GLOBAL Global symbols are visible to all object files being combined. One file's definition of a global symbol will satisfy another file's undefined reference to the same global symbol. STB_WEAK Weak symbols resemble global symbols, but their definitions have lower precedence. STB_LOPROC through STB_HIPROC Values in this inclusive range are reserved for processor-specific semantics. In each symbol table, all symbols with STB_LOCAL binding precede the weak and global symbols. A symbol's type provides a general classification for the associated entity. Symbol Types, ELF32_ST_TYPE Name Value STT_NOTYPE 0 STT_OBJECT 1 STT_FUNC 2 STT_SECTION 3 STT_FILE 4 STT_LOPROC 13 STT_HIPROC 15 STT_NOTYPE The symbol's type is not specified. STT_OBJECT The symbol is associated with a data object, such as a variable, an array,and so on. STT_FUNC The symbol is associated with a function or other executable code. STT_SECTION The symbol is associated with a section. Symbol table entries of this type exist primarily for relocation and normally have STB_LOCAL binding.\u8fd9\u79cd\u7c7b\u578b\u7684symbol\u4e3b\u8981\u7528\u4e8erelocation STT_FILE A file symbol has STB_LOCAL binding, its section index is SHN_ABS , and it precedes the other STB_LOCAL symbols for the file, if it is present. \u663e\u7136STT_FILE\u662f\u76f8\u5bf9\u4e8eSHN_ABS section\u5b9a\u4e49\u7684","title":"TODO string table\u548csymbol table\u7684\u5173\u8054"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/#string#table","text":"ELF\u4e2d\u4e0d\u6b62\u4e00\u4e2astring table\uff0c\u6709.strtab\uff0c.shstrtab .strtab This section holds strings, most commonly the strings that represent the names associated with symbol table entries. If a file has a loadable segment that includes the symbol string table, the section's attributes will include the SHF_ALLOC bit; otherwise, that bit will be off. \u548cstring table\u6709\u5173\u7684\u6210\u5458\u53d8\u91cf\u6709\uff1a section header\u7684sh_name\u6210\u5458\u53d8\u91cf\u7684\u503c\u5c31\u662f string table section\u7684\u7d22\u5f15 ELF header\u7684e_shstrndx\u6210\u5458\u53d8\u91cf\u4e5f\u662fstring table section\u7684\u7d22\u5f15 Symbol Table Entry\u7684st_name\u6210\u5458\u53d8\u91cf\u662f symbol string table\u7684\u7d22\u5f15","title":"string table"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/#symtab","text":".symtab This section holds a symbol table, as \"Symbol Table'' in this chapter describes. If a file has a loadable segment that includes the symbol table,the section's attributes will include the SHF_ALLOC bit; otherwise, that bit will be off.","title":"symtab"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/#symbol#table#entry","text":"typedef struct { Elf32_Word st_name ; Elf32_Addr st_value ; Elf32_Word st_size ; unsigned char st_info ; unsigned char st_other ; Elf32_Half st_shndx ; } Elf32_Sym ;","title":"Symbol Table Entry"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/#st_name","text":"This member holds an index into the object file's symbol string table, which holds the character representations of the symbol names.","title":"st_name"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/#st_value","text":"This member gives the value of the associated symbol. Depending on the context,this may be an absolute value, an address, and so on; details appear below. st_value\u5230\u5e95\u4fdd\u5b58\u7684\u662fsymbol\u7684\u4ec0\u4e48\u5185\u5bb9\uff1f\u662f\u5730\u5740\u8fd8\u662f\u503c\uff1fsymbol\u7684\u503c\u662f\u5426\u4fdd\u5b58\u5728data section\u4e2d\uff1f\uff1f \u5728ELF\u6587\u6863\u7684Symbol Values\u7ae0\u8282\u4ecb\u7ecd\u4e86\u8fd9\u90e8\u5206\u5185\u5bb9\uff0c\u662f\u5730\u5740\u3002","title":"st_value"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/#st_size","text":"Many symbols have associated sizes. For example, a data object's size is the number of bytes contained in the object. This member holds 0 if the symbol has no size or an unknown size. \u4e3a\u4ec0\u4e48symbol\u8981\u4fdd\u5b58size\uff1f\uff1f","title":"st_size"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/#st_shndx","text":"Every symbol table entry is \"defined'' in relation to some section; this member holds the relevant section header table index. As Figure 1-7 and the related text describe,some section indexes indicate special meanings. \u6709\u7684symbol\u662f\u76f8\u5bf9\u4e8e\u67d0\u4e2asection\u5b9a\u4e49\u7684\uff0cElf32_Sym\u7684st_shndx\u6210\u5458\u5c31\u8868\u660e\u8be5symbol\u6240\u53c2\u7167\u7684section\u3002","title":"st_shndx"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/#st_info","text":"This member specifies the symbol's type and binding attributes. A list of the values and meanings appears below. The following code shows how to manipulate the values. \u8fd9\u91cc\u63d0\u5230\u4e86\u6bcf\u4e2a\u7b26\u53f7\u7684\u4e24\u4e2a\u91cd\u8981\u5c5e\u6027\uff1a type binding","title":"st_info"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/#symbol#binding#elf32_st_bind","text":"Name Value STB_LOCAL 0 STB_GLOBAL 1 STB_WEAK 2 STB_LOPROC 13 STB_HIPROC 15 STB_LOCAL Local symbols are not visible outside the object file containing their definition. Local symbols of the same name may exist in multiple files without interfering with each other. STB_GLOBAL Global symbols are visible to all object files being combined. One file's definition of a global symbol will satisfy another file's undefined reference to the same global symbol. STB_WEAK Weak symbols resemble global symbols, but their definitions have lower precedence. STB_LOPROC through STB_HIPROC Values in this inclusive range are reserved for processor-specific semantics. In each symbol table, all symbols with STB_LOCAL binding precede the weak and global symbols. A symbol's type provides a general classification for the associated entity.","title":"Symbol Binding,  ELF32_ST_BIND"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20string%20table%E5%92%8Csymbol%20table%E7%9A%84%E5%85%B3%E8%81%94/#symbol#types#elf32_st_type","text":"Name Value STT_NOTYPE 0 STT_OBJECT 1 STT_FUNC 2 STT_SECTION 3 STT_FILE 4 STT_LOPROC 13 STT_HIPROC 15 STT_NOTYPE The symbol's type is not specified. STT_OBJECT The symbol is associated with a data object, such as a variable, an array,and so on. STT_FUNC The symbol is associated with a function or other executable code. STT_SECTION The symbol is associated with a section. Symbol table entries of this type exist primarily for relocation and normally have STB_LOCAL binding.\u8fd9\u79cd\u7c7b\u578b\u7684symbol\u4e3b\u8981\u7528\u4e8erelocation STT_FILE A file symbol has STB_LOCAL binding, its section index is SHN_ABS , and it precedes the other STB_LOCAL symbols for the file, if it is present. \u663e\u7136STT_FILE\u662f\u76f8\u5bf9\u4e8eSHN_ABS section\u5b9a\u4e49\u7684","title":"Symbol Types, ELF32_ST_TYPE"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20symbol%20table%E5%92%8Chash%20table%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94/","text":"","title":"TODO symbol table\u548chash table\u4e4b\u95f4\u7684\u5173\u8054"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","text":"\u64cd\u4f5c\u7cfb\u7edf\u5185\u5b58\u7ba1\u7406\u2014\u2014\u5206\u533a\u3001\u9875\u5f0f\u3001\u6bb5\u5f0f\u7ba1\u7406 linux\u5185\u5b58\u7ba1\u7406 MIPS\u5b58\u50a8\u7ba1\u7406","title":"TODO \u64cd\u4f5c\u7cfb\u7edf\u5185\u5b58\u7ba1\u7406"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%AB%E5%AD%98%E5%82%A8%E5%9C%A8%E5%AD%97%E8%8A%82%E4%B8%AD%E7%9A%84ASCII%E7%A0%81%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84/","text":"","title":"TODO \u8ba1\u7b97\u673a\u662f\u5982\u4f55\u533a\u522b\u5b58\u50a8\u5728\u5b57\u8282\u4e2d\u7684ASCII\u7801\u548c\u6570\u5b57\u7684"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20%E9%87%8D%E5%AE%9A%E4%BD%8D/","text":"Relocation Relocation is the process of connecting symbolic references with symbolic definitions. For example, when a program calls a function, the associated call instruction must transfer control to the proper destination address at execution. In other words, relocatable files must have information that describes how to modify their section contents, thus allowing executable and shared object files to hold the right information for a process's program image. Relocation entries are these data. Relocation\u662f\u8054\u7cfbsymbolic references\uff08\u5f15\u7528\uff09\u548c symbolic definitions\uff08\u5b9a\u4e49\uff09\u7684\u8fc7\u7a0b\u3002\u4f8b\u5982\uff0c\u5f53\u4e00\u4e2a\u7a0b\u5e8f\u5728\u8fd0\u884c\u65f6\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\u65f6\uff0c\u8fd9\u4e2a\u8c03\u7528\u6307\u4ee4\u5fc5\u987b\u628a\u63a7\u5236\u4f20\u8f93\u5230\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u4f4d\u7f6e\uff0c\u4e5f\u5c31\u662f\u76ee\u7684\u5730\u5740\u3002\u6362\u53e5\u8bdd\u8bf4\uff0crelocatable\u6587\u4ef6\u5fc5\u987b\u8981\u5305\u542b\u5982\u4f55\u4fee\u6539\u5176section \u5185\u5bb9\u7684\u6d88\u606f\uff0c\u8fd9\u6837executable file\u548cshared object file\u624d\u80fd\u591f\u5305\u542b\u6b63\u786e\u7684\u6d88\u606f\uff0c\u8fd9\u6837\u7a0b\u5e8f\u624d\u80fd\u591f\u8fd0\u884c\u8d77\u6765\u3002 \u6211\u4eec\u4ee5\u6c47\u7f16\u8bed\u8a00\u6765\u770b\u8fd9\u4e2a\u95ee\u9898\uff0c\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\u4f7f\u7528\u6c47\u7f16\u6765\u63cf\u8ff0\u5c31\u662f\uff1a mov \u51fd\u6570\u5730\u5740 \u800c\u521a\u5f00\u59cb\uff0c\u5728relocatable file\u4e2d\uff0c\u8c03\u7528\u51fd\u6570\uff0c\u4f7f\u7528\u7684\u4ecd\u7136\u662f\u8fd9\u4e2a\u51fd\u6570\u7684symbolic reference\u3002 \u4e0b\u9762\u4ecb\u7ecd\u4e86Relocation Entries\u7684\u7ed3\u6784\u5b9a\u4e49\uff1a typedef struct { Elf32_Addr r_offset ; Elf32_Word r_info ; } Elf32_Rel ; typedef struct { Elf32_Addr r_offset ; Elf32_Word r_info ; Elf32_Sword r_addend ; } Elf32_Rela ; r_offset This member gives the location at which to apply the relocation action. For a relocatable file, the value is the byte offset from the beginning of the section to the storage unit affected by the relocation. For an executable file or a shared object, the value is the virtual address of the storage unit affected by the relocation. \u8fd9\u4e2a\u6210\u5458\u53d8\u91cf\u6307\u5b9a\u4e86\u8fd9\u4e2arelocation\u52a8\u4f5c\u6267\u884c\u7684\u4f4d\u7f6e\u3002\u5bf9\u4e8erelocatable file\uff0c\u8fd9\u4e2a\u503c\u662f\u4ece\u53d7relocation\u5f71\u54cd\u7684section\u7684\u5f00\u59cb\u4f4d\u7f6e\u8d77\u7684\u5b57\u8282\u504f\u79fb\u91cf\uff1b\u5bf9\u4e8eexecutable file\u548cshared object\uff0c\u8fd9\u4e2a\u503c\u662f\u53d7relocation\u5f71\u54cd\u7684\u5b58\u50a8\u5355\u5143\u7684virtual address\u3002 r_info This member gives both the symbol table index with respect to which the relocation must be made, and the type of relocation to apply. For example, a call instruction's relocation entry would hold the symbol table index of the function being called. If the index is STN_UNDEF , the undefined symbol index, the relocation uses 0 as the \"symbol value.'' Relocation types are processor-specific; descriptions of their behavior appear in the processor supplement. When the text in the processor supplement refers to a relocation entry's relocation type or symbol table index, it means the result of applying ELF32_R_TYPE or ELF32_R_SYM , respectively, to the entry's r_info member. \u6211\u4eec\u662f\u9700\u8981\u5bf9symbol\u8fdb\u884c\u91cd\u5b9a\u4f4d\uff0c\u56e0\u6b64\u8fd9\u4e2a\u6210\u5458\u6307\u5b9a\u4e86\u6267\u884c\u91cd\u5b9a\u4f4d\u7684symbol\u5728symbol table\u4e2d\u7684index\u548ctype of relocation\uff08\u91cd\u5b9a\u4f4d\u7c7b\u578b\uff09\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u6307\u4ee4\u7684relocation entry\uff08\u91cd\u5b9a\u4f4d\u9879\uff09\u4f1a\u6307\u5b9a\u88ab\u8c03\u51fd\u6570\u5728symbol table\u4e2d\u7684index\u3002 Relocation type\u662f\u5904\u7406\u5668\u76f8\u5173\u7684\uff0c\u901a\u8fc7\u8c03\u7528\u5982\u4e0b\u4e24\u4e2a\u51fd\u6570\u6765\u4ecer_info\u4e2d\u89e3\u6790\u51faindex\u548crelocation type\u3002 #define ELF32_R_SYM(i) ((i)>>8) #define ELF32_R_TYPE(i) ((unsigned char)(i)) #define ELF32_R_INFO(s,t) (((s)<<8)+(unsigned char)(t)) r_addend This member specifies a constant addend used to compute the value to be stored into the relocatable field Q&A \u89e3\u91ca\u5668\u5982\u4f55\u5f97\u77e5\u54ea\u4e9bsection\u662f\u9700\u8981\u8fdb\u884crelocation\u7684\uff1f sh_type sh_link sh_info SHT_REL\u548cSHT_RELA \u4fdd\u5b58\u7684\u662f\u76f8\u5173\u8054\u7684symbol table\u5728section header table\u4e2d\u7684\u7d22\u5f15 \u8fd9\u4e2a\u5b57\u6bb5\u7684\u542b\u4e49\u662frelocation\u5c06\u5728\u54ea\u4e2asection\u4e0a\u6267\u884c\uff0c\u8fd9\u4e2a\u5b57\u6bb5\u4fdd\u5b58\u7684\u662f\u76ee\u6807section\u5728section header table\u4e2d\u7684\u7d22\u5f15 \u7f16\u8bd1\u5668\u662f\u5426\u4f1a\u4e3a\u6bcf\u4e2a\u9700\u8981\u91cd\u5b9a\u4f4d\u7684section\u90fd\u751f\u6210\u4e00\u4e2a\u5bf9\u5e94\u7684relocation table\uff1f\uff1f","title":"TODO \u91cd\u5b9a\u4f4d"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20%E9%87%8D%E5%AE%9A%E4%BD%8D/#relocation","text":"Relocation is the process of connecting symbolic references with symbolic definitions. For example, when a program calls a function, the associated call instruction must transfer control to the proper destination address at execution. In other words, relocatable files must have information that describes how to modify their section contents, thus allowing executable and shared object files to hold the right information for a process's program image. Relocation entries are these data. Relocation\u662f\u8054\u7cfbsymbolic references\uff08\u5f15\u7528\uff09\u548c symbolic definitions\uff08\u5b9a\u4e49\uff09\u7684\u8fc7\u7a0b\u3002\u4f8b\u5982\uff0c\u5f53\u4e00\u4e2a\u7a0b\u5e8f\u5728\u8fd0\u884c\u65f6\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\u65f6\uff0c\u8fd9\u4e2a\u8c03\u7528\u6307\u4ee4\u5fc5\u987b\u628a\u63a7\u5236\u4f20\u8f93\u5230\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u4f4d\u7f6e\uff0c\u4e5f\u5c31\u662f\u76ee\u7684\u5730\u5740\u3002\u6362\u53e5\u8bdd\u8bf4\uff0crelocatable\u6587\u4ef6\u5fc5\u987b\u8981\u5305\u542b\u5982\u4f55\u4fee\u6539\u5176section \u5185\u5bb9\u7684\u6d88\u606f\uff0c\u8fd9\u6837executable file\u548cshared object file\u624d\u80fd\u591f\u5305\u542b\u6b63\u786e\u7684\u6d88\u606f\uff0c\u8fd9\u6837\u7a0b\u5e8f\u624d\u80fd\u591f\u8fd0\u884c\u8d77\u6765\u3002 \u6211\u4eec\u4ee5\u6c47\u7f16\u8bed\u8a00\u6765\u770b\u8fd9\u4e2a\u95ee\u9898\uff0c\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\u4f7f\u7528\u6c47\u7f16\u6765\u63cf\u8ff0\u5c31\u662f\uff1a mov \u51fd\u6570\u5730\u5740 \u800c\u521a\u5f00\u59cb\uff0c\u5728relocatable file\u4e2d\uff0c\u8c03\u7528\u51fd\u6570\uff0c\u4f7f\u7528\u7684\u4ecd\u7136\u662f\u8fd9\u4e2a\u51fd\u6570\u7684symbolic reference\u3002 \u4e0b\u9762\u4ecb\u7ecd\u4e86Relocation Entries\u7684\u7ed3\u6784\u5b9a\u4e49\uff1a typedef struct { Elf32_Addr r_offset ; Elf32_Word r_info ; } Elf32_Rel ; typedef struct { Elf32_Addr r_offset ; Elf32_Word r_info ; Elf32_Sword r_addend ; } Elf32_Rela ; r_offset This member gives the location at which to apply the relocation action. For a relocatable file, the value is the byte offset from the beginning of the section to the storage unit affected by the relocation. For an executable file or a shared object, the value is the virtual address of the storage unit affected by the relocation. \u8fd9\u4e2a\u6210\u5458\u53d8\u91cf\u6307\u5b9a\u4e86\u8fd9\u4e2arelocation\u52a8\u4f5c\u6267\u884c\u7684\u4f4d\u7f6e\u3002\u5bf9\u4e8erelocatable file\uff0c\u8fd9\u4e2a\u503c\u662f\u4ece\u53d7relocation\u5f71\u54cd\u7684section\u7684\u5f00\u59cb\u4f4d\u7f6e\u8d77\u7684\u5b57\u8282\u504f\u79fb\u91cf\uff1b\u5bf9\u4e8eexecutable file\u548cshared object\uff0c\u8fd9\u4e2a\u503c\u662f\u53d7relocation\u5f71\u54cd\u7684\u5b58\u50a8\u5355\u5143\u7684virtual address\u3002 r_info This member gives both the symbol table index with respect to which the relocation must be made, and the type of relocation to apply. For example, a call instruction's relocation entry would hold the symbol table index of the function being called. If the index is STN_UNDEF , the undefined symbol index, the relocation uses 0 as the \"symbol value.'' Relocation types are processor-specific; descriptions of their behavior appear in the processor supplement. When the text in the processor supplement refers to a relocation entry's relocation type or symbol table index, it means the result of applying ELF32_R_TYPE or ELF32_R_SYM , respectively, to the entry's r_info member. \u6211\u4eec\u662f\u9700\u8981\u5bf9symbol\u8fdb\u884c\u91cd\u5b9a\u4f4d\uff0c\u56e0\u6b64\u8fd9\u4e2a\u6210\u5458\u6307\u5b9a\u4e86\u6267\u884c\u91cd\u5b9a\u4f4d\u7684symbol\u5728symbol table\u4e2d\u7684index\u548ctype of relocation\uff08\u91cd\u5b9a\u4f4d\u7c7b\u578b\uff09\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u6307\u4ee4\u7684relocation entry\uff08\u91cd\u5b9a\u4f4d\u9879\uff09\u4f1a\u6307\u5b9a\u88ab\u8c03\u51fd\u6570\u5728symbol table\u4e2d\u7684index\u3002 Relocation type\u662f\u5904\u7406\u5668\u76f8\u5173\u7684\uff0c\u901a\u8fc7\u8c03\u7528\u5982\u4e0b\u4e24\u4e2a\u51fd\u6570\u6765\u4ecer_info\u4e2d\u89e3\u6790\u51faindex\u548crelocation type\u3002 #define ELF32_R_SYM(i) ((i)>>8) #define ELF32_R_TYPE(i) ((unsigned char)(i)) #define ELF32_R_INFO(s,t) (((s)<<8)+(unsigned char)(t)) r_addend This member specifies a constant addend used to compute the value to be stored into the relocatable field Q&A \u89e3\u91ca\u5668\u5982\u4f55\u5f97\u77e5\u54ea\u4e9bsection\u662f\u9700\u8981\u8fdb\u884crelocation\u7684\uff1f sh_type sh_link sh_info SHT_REL\u548cSHT_RELA \u4fdd\u5b58\u7684\u662f\u76f8\u5173\u8054\u7684symbol table\u5728section header table\u4e2d\u7684\u7d22\u5f15 \u8fd9\u4e2a\u5b57\u6bb5\u7684\u542b\u4e49\u662frelocation\u5c06\u5728\u54ea\u4e2asection\u4e0a\u6267\u884c\uff0c\u8fd9\u4e2a\u5b57\u6bb5\u4fdd\u5b58\u7684\u662f\u76ee\u6807section\u5728section header table\u4e2d\u7684\u7d22\u5f15 \u7f16\u8bd1\u5668\u662f\u5426\u4f1a\u4e3a\u6bcf\u4e2a\u9700\u8981\u91cd\u5b9a\u4f4d\u7684section\u90fd\u751f\u6210\u4e00\u4e2a\u5bf9\u5e94\u7684relocation table\uff1f\uff1f","title":"Relocation"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%BD%BD%E5%85%A5/","text":"\u94fe\u63a5 \u5176\u5b9e\u8bf4\u5230\u94fe\u63a5\u6211\u60f3\u5230\u4e86\u4e24\u4e2a\u95ee\u9898\uff1a \u6211\u4eec\u8c03\u7528GCC\u6765\u7f16\u8bd1\u4e00\u4e2a\u6e90\u4ee3\u7801\u6587\u4ef6\u7684\u65f6\u5019\uff0c\u6700\u540e\u4e00\u6b65\u5c31\u662f\u94fe\u63a5\uff0c\u8fd9\u4e00\u6b65\u6267\u884c\u7684\u64cd\u4f5c\u662f\u5c06\u51e0\u4e2a\u8f93\u5165\u7684\u76ee\u6807\u6587\u4ef6\u52a0\u5de5\u540e\u5408\u5e76\u4e3a\u4e00\u4e2a\u8f93\u51fa\u6587\u4ef6 \u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u5927\u91cf\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5373so\u6587\u4ef6\uff0c\u663e\u7136\uff0c\u7a0b\u5e8f\u5728\u6267\u884c\u7684\u65f6\u5019\u624d\u53bb\u94fe\u63a5\u8fd9\u4e9bso\u6587\u4ef6\uff0c\u6211\u7684\u7591\u60d1\u662f\u7a0b\u5e8f\u6267\u884c\u8fc7\u7a0b\u4e2d\u94fe\u63a5\u52a8\u6001\u94fe\u63a5\u5e93\u548c\u7f16\u8bd1\u6700\u540e\u4e00\u6b65\u7684\u94fe\u63a5\u662f\u5426\u76f8\u540c\uff0c\u5982\u679c\u4e0d\u76f8\u540c\uff0c\u90a3\u4e0d\u540c\u70b9\u5728\u54ea\u91cc\u3002 \u865a\u62df\u5185\u5b58\u5730\u5740VMA\u3001\u88c5\u8f7d\u5185\u5b58\u5730\u5740LMA\u548c\u4f4d\u7f6e\u65e0\u5173\u4ee3\u7801PIC \u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u53caLinux\u4e0b\u52a8\u6001\u94fe\u63a5\u7684\u5b9e\u73b0\u4e00 \u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u53caLinux\u4e0b\u52a8\u6001\u94fe\u63a5\u7684\u5b9e\u73b0\u4e8c","title":"\u94fe\u63a5"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%20%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%BD%BD%E5%85%A5/#_1","text":"\u5176\u5b9e\u8bf4\u5230\u94fe\u63a5\u6211\u60f3\u5230\u4e86\u4e24\u4e2a\u95ee\u9898\uff1a \u6211\u4eec\u8c03\u7528GCC\u6765\u7f16\u8bd1\u4e00\u4e2a\u6e90\u4ee3\u7801\u6587\u4ef6\u7684\u65f6\u5019\uff0c\u6700\u540e\u4e00\u6b65\u5c31\u662f\u94fe\u63a5\uff0c\u8fd9\u4e00\u6b65\u6267\u884c\u7684\u64cd\u4f5c\u662f\u5c06\u51e0\u4e2a\u8f93\u5165\u7684\u76ee\u6807\u6587\u4ef6\u52a0\u5de5\u540e\u5408\u5e76\u4e3a\u4e00\u4e2a\u8f93\u51fa\u6587\u4ef6 \u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u5927\u91cf\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5373so\u6587\u4ef6\uff0c\u663e\u7136\uff0c\u7a0b\u5e8f\u5728\u6267\u884c\u7684\u65f6\u5019\u624d\u53bb\u94fe\u63a5\u8fd9\u4e9bso\u6587\u4ef6\uff0c\u6211\u7684\u7591\u60d1\u662f\u7a0b\u5e8f\u6267\u884c\u8fc7\u7a0b\u4e2d\u94fe\u63a5\u52a8\u6001\u94fe\u63a5\u5e93\u548c\u7f16\u8bd1\u6700\u540e\u4e00\u6b65\u7684\u94fe\u63a5\u662f\u5426\u76f8\u540c\uff0c\u5982\u679c\u4e0d\u76f8\u540c\uff0c\u90a3\u4e0d\u540c\u70b9\u5728\u54ea\u91cc\u3002 \u865a\u62df\u5185\u5b58\u5730\u5740VMA\u3001\u88c5\u8f7d\u5185\u5b58\u5730\u5740LMA\u548c\u4f4d\u7f6e\u65e0\u5173\u4ee3\u7801PIC \u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u53caLinux\u4e0b\u52a8\u6001\u94fe\u63a5\u7684\u5b9e\u73b0\u4e00 \u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u53caLinux\u4e0b\u52a8\u6001\u94fe\u63a5\u7684\u5b9e\u73b0\u4e8c","title":"\u94fe\u63a5"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/TODO%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%8F%91%E5%B8%83/","text":"\u8c08\u8c08\u7a0b\u5e8f\u5728\u5185\u5b58\u4e2d\u7684\u5206\u5e03","title":"TODO\u8fdb\u7a0b\u5728\u5185\u5b58\u4e2d\u7684\u53d1\u5e03"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/section%20header%E7%9A%84sh_link%E5%92%8Csh_info/","text":"\u5bf9section header\u7684sh_link\u6210\u5458\uff0csh_info\u6210\u5458\u7684\u89e3\u91ca\u7531section\u7684\u7c7b\u578b\u6765\u51b3\u5b9a\uff0c\u4e0b\u9762\u8fdb\u884c\u8be6\u7ec6\u4ecb\u7ecd\u3002 sh_type sh_link sh_info SHT_DYNAMIC \u4fdd\u5b58\u7684\u662fstring table\u5728section header table\u4e2d\u7684\u7d22\u5f15 0 SHT_HASH \u8fd9\u4e2a\u5b57\u6bb5\u7684\u542b\u4e49\u662f\u8fd9\u4e2ahash table\u5c06\u4f5c\u7528\u4e8e\u54ea\u4e2asection\uff0c\u5b83\u4fdd\u5b58\u7684\u662f\u76ee\u6807symbol table\u5728section header table\u4e2d\u7684\u7d22\u5f15 SHT_REL\u548cSHT_RELA \u4fdd\u5b58\u7684\u662f\u76f8\u5173\u8054\u7684symbol table\u5728section header table\u4e2d\u7684\u7d22\u5f15 \u8fd9\u4e2a\u5b57\u6bb5\u7684\u542b\u4e49\u662frelocation\u5c06\u5728\u54ea\u4e2asection\u4e0a\u6267\u884c\uff0c\u8fd9\u4e2a\u5b57\u6bb5\u4fdd\u5b58\u7684\u662f\u76ee\u6807section\u5728section header table\u4e2d\u7684\u7d22\u5f15 SHT_SYMTAB\u548cSHT_DYNSYM \u5185\u5bb9\u7531\u64cd\u4f5c\u7cfb\u7edf\u6307\u5b9a \u5185\u5bb9\u7531\u64cd\u4f5c\u7cfb\u7edf\u6307\u5b9a other SHN_UNDEF 0","title":"Section header\u7684sh link\u548csh info"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/sh_size%E5%92%8Ce_shentsize/","text":"\u5173\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u662f\u9700\u8981\u9996\u5148\u641e\u6e05\u695aELF\u6587\u4ef6\u7684\u903b\u8f91\u7ed3\u6784\u7684\u3002\u603b\u7684\u6765\u8bf4ELF\u6587\u4ef6\u7684\u903b\u8f91\u7ed3\u6784\u53ef\u4ee5\u4f7f\u7528\u4e0b\u9762\u7684\u8fd9\u4e2a\u56fe\u6765\u8868\u793a\uff1a \u901a\u8fc7ELF header\u7684e_phoff\u6210\u5458\u53ef\u4ee5\u5b9a\u4f4d\u5230program header table\uff0c\u901a\u8fc7ELF header\u7684e_shoff\u6210\u5458\u53ef\u4ee5\u5b9a\u4f4d\u5230section header table\u3002 section header table\u662f\u4e00\u4e2a\u6570\u7ec4\uff0c\u6570\u7ec4\u5143\u7d20\u7684\u7c7b\u578b\u662fsection header\u3002ELF header\u7684e_shentsize\u63cf\u8ff0\u4e86\u8be5\u6570\u7ec4\u6bcf\u4e2a\u5143\u7d20\u7684\u957f\u5ea6\uff0c\u663e\u7136\u6bcf\u4e2a\u5143\u7d20\u7684\u957f\u5ea6\u5c31\u662fsection header\u7ed3\u6784\u7684\u957f\u5ea6\u3002 \u901a\u8fc7section header\u6765\u63cf\u8ff0\u4e00\u4e2asection\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u5728section header\u7ed3\u6784\u4e2d\u6709\u4e00\u4e2ash_offset\u6210\u5458\uff0c\u8fd9\u4e2a\u6210\u5458\u7ed9\u51fa\u4e86\u5bf9\u4e8esection\u5728ELF \u6587\u4ef6\u4e2d\u7684\u4f4d\u7f6e\uff1b\u5728section header\u7ed3\u6784\u4e2d\u6709\u4e00\u4e2ash_size\u6210\u5458\uff0c\u8fd9\u4e2a\u6210\u5458\u7ed9\u51fa\u4e86\u5bf9\u5e94section\u7684\u957f\u5ea6\u3002 program header table\u662f\u4e00\u4e2a\u6570\u7ec4\uff0c\u6570\u7ec4\u5143\u7d20\u7684\u7c7b\u578b\u662fsegment header\u3002ELF header\u7684e_phentsize\u63cf\u8ff0\u4e86\u8be5\u6570\u7ec4\u6bcf\u4e2a\u5143\u7d20\u7684\u957f\u5ea6\uff0c\u663e\u7136\u6bcf\u4e2a\u5143\u7d20\u7684\u957f\u5ea6\u5c31\u662fsegment header\u7ed3\u6784\u7684\u957f\u5ea6\u3002 \u901a\u8fc7segment header\u7ed3\u6784\u6765\u63cf\u8ff0\u4e00\u4e2asegment\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u5728segment \u901a\u8fc7\u4ee5\u4e0a\u7684\u5206\u6790\u5df2\u7ecf\u56de\u7b54\u4e86\u63d0\u95ee\u3002","title":"Sh size\u548ce shentsize"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/","text":"Dynamic Linking Program Interpreter An executable file that participates in dynamic linking shall have one PT_INTERP program header element. During exec (BA_OS), the system retrieves a path name from the PT_INTERP segment and creates the initial process image from the interpreter file's segments. That is, instead of using the original executable file's segment images, the system composes a memory image for the interpreter. It then is the interpreter's responsibility to receive control from the system and provide an environment for the application program. \u5bf9\u4e8e\u4e00\u4e2a\u53c2\u4e0e\u52a8\u6001\u94fe\u63a5\u7684executable file\uff0c\u5b83\u7684program header element\u5e94\u8be5\u6709\u4e00\u4e2aPT_INTERP\u6210\u5458\u3002\u5f53\u4f7f\u7528exec\u7cfb\u7edf\u8c03\u7528\u6765\u542f\u52a8\u4e00\u4e2a\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4ecePT_INTERP segment\u4e2d\u53d6\u51fainterpreter file\u7684\u8def\u5f84\uff0c\u7136\u540e\u4f7f\u7528interpreter file\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5e76\u4e0d\u662f\u9996\u5148\u521b\u5efa\u8fd9\u4e2aexecutable file\u7684process image\uff0c\u800c\u662f\u9996\u5148\u521b\u5efa\u7684\u662f\u8fd9\u4e2ainterpreter\u7684process image\u3002\u7136\u540e\u64cd\u4f5c\u7cfb\u7edf\u628a\u63a7\u5236\u4f20\u9012\u4e2a\u8fd9\u4e2ainterpreter\uff0c\u8fd9\u4e2ainterpreter\u7684\u804c\u8d23\u662f\u4e3a\u63a5\u4e0b\u6765\u8981\u6267\u884c\u7684executable file\u51c6\u5907\u597d\u73af\u5883\u3002 The interpreter receives control in one of two ways. First, it may receive a file descriptor to read the executable file, positioned at the beginning. It can use this file descriptor to read and/or map the executable file's segments into memory. Second, depending on the executable file format, the system may load the executable file into memory instead of giving the interpreter an open file descriptor. With the possible exception of the file descriptor, the interpreter's initial process state matches what the executable file would have received. The interpreter itself may not require a second interpreter. An interpreter may be either a shared object or an executable file. \u2022 A shared object (the normal case) is loaded as position-independent, with addresses that may vary from one process to another; the system creates its segments in the dynamic segment area used by mmap (KE_OS) and related services. Consequently, a shared object interpreter typically will not conflict with the original executable file's original segment addresses. \u2022 An executable file is loaded at fixed addresses; the system creates its segments using the virtual addresses from the program header table. Consequently, an executable file interpreter's virtual addresses may collide with the first executable file; the interpreter is responsible for resolving conflicts. interpreter\u6309\u7167\u5982\u4e0b\u4e24\u79cd\u65b9\u5f0f\u4e2d\u7684\u4e00\u79cd\u6765\u63a5\u6536\u63a7\u5236\u3002 \u7b2c\u4e00\u79cd\uff0c\u5b83\u53ef\u80fd\u4f1a\u63a5\u6536\u5230\u4e00\u4e2a\u6307\u5411\u8fd9\u4e2aexecutable file\u7684file descriptor\uff0c\u7136\u540e\u5b83\u4f7f\u7528\u8fd9\u4e2afile descriptor\u6765\u5c06\u6307\u5b9a\u7684executable file \u7684segment read \u6216map\u5230\u5185\u5b58\u4e2d\u3002 \u7b2c\u4e8c\u79cd\uff0c\u53d6\u51b3\u4e8e\u53ef\u6267\u884c\u6587\u4ef6\u683c\u5f0f\u5316\uff0c\u7cfb\u7edf\u53ef\u80fd\u5c06\u53ef\u6267\u884c\u6587\u4ef6\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\uff0c\u800c\u4e0d\u662f\u7ed9\u89e3\u91ca\u5668\u63d0\u4f9b\u4e00\u4e2a\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 \u9664\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e4b\u5916\uff0c\u89e3\u91ca\u5668\u7684\u521d\u59cb\u8fdb\u7a0b\u72b6\u6001\u4e0e\u53ef\u6267\u884c\u6587\u4ef6\u53ef\u80fd\u63a5\u6536\u7684\u5185\u5bb9\u76f8\u5339\u914d\u3002 \u89e3\u91ca\u5668\u672c\u8eab\u53ef\u80fd\u4e0d\u9700\u8981\u7b2c\u4e8c\u4e2a\u89e3\u91ca\u5668\u3002 \u89e3\u91ca\u5668\u53ef\u4ee5\u662f\u5171\u4eab\u5bf9\u8c61\u6216\u53ef\u6267\u884c\u6587\u4ef6\u3002 \u901a\u5e38\u60c5\u51b5\u4e0b\u8fd9\u4e2ainterpreter\u662f\u4e00\u4e2ashared object\uff0c\u5b83\u88ab\u88c5\u8f7d\u4e3a\u4e00\u4e2aposition-independent\uff0c\u56e0\u6b64\u5728\u4e0d\u540c\u7684\u8fdb\u7a0b\u4e2d\uff0c\u5730\u5740\u662f\u53ef\u80fd\u4e0d\u76f8\u540c\u7684\u3002\u4f7f\u7528\u8fd9\u79cd\u65b9\u5f0f\u7684\u4e00\u4e2a\u597d\u5904\u662fa shared object interpreter\u5c06\u4e0d\u4f1a\u4e0e\u539f\u6765\u7684executable file\u7684\u539fsegment\u5730\u5740\u51b2\u7a81\u3002 \uff1f\uff1f\u6211\u6709\u4e00\u4e2a\u7591\u95ee\uff0c\u6b64\u65f6\u7684interpreter\u662f\u4e00\u4e2aso\u6587\u4ef6\uff0c\u6b64\u65f6\u64cd\u4f5c\u7cfb\u7edf\u662f\u628a\u8fd9\u4e2aso\u4f5c\u4e3a\u5c06\u8981\u6267\u884c\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u6240\u94fe\u63a5\u7684\u641c\u6765\u8fdb\u884c\u52a0\u8f7d\u8fd8\u662f\uff1f\uff1f interpreter\u662f\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5728\u4e00\u4e2a\u5728\u56fa\u5b9a\u5bfc\u81f4\u52a0\u8f7d\u7684interpreter\u3002\u64cd\u4f5c\u7cfb\u7edf\u4f7f\u7528interpreter\u7684program header table\u7684 virtual addresses \u6765\u521b\u5efa\u5b83\u7684segment\u3002\u6240\u4ee5\uff0c\u4e00\u4e2aexecutable file interpreter\u7684virtual addresses\u662f\u53ef\u80fd\u548c\u539fexecutable file\u51b2\u7a81\u7684\u3002\u662f\u7531interpreter\u6765\u89e3\u51b3\u51b2\u7a81\u3002 \u6309\u7167\u8fd9\u79cd\u65b9\u5f0f\uff0c\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u6765\u5b9e\u73b0\u5728\u4e00\u4e2a\u56fa\u5b9a\u7684\u5bfc\u81f4\u4e0a\u52a0\u8f7d\u53ef\u6267\u884c\u7a0b\u5e8f\u7684\uff1f\uff1f Dynamic Linker When building an executable file that uses dynamic linking, the link editor adds a program header element of type PT_INTERP to an executable file, telling the system to invoke the dynamic linker as the program interpreter. \u5f53\u6784\u5efa\u4e00\u4e2a\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u7684\u7684\u53ef\u6267\u884c\u6587\u4ef6\u4f7f\uff0clink editor\u5f80\u8fd9\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\u7684program header table\u4e2d\u6dfb\u52a0\u7c7b\u578b\u4e3aPT_INTERP\u7684\u5143\u7d20\uff0c\u901a\u8fc7\u8fd9\u4e2a\u5143\u7d20\u6765\u544a\u8bc9\u64cd\u4f5c\u7cfb\u7edf\u8c03\u7528\u8fd9\u4e2adynamic linker\u6765\u4f5c\u4e3a\u8fd9\u4e2a\u7a0b\u5e8f\u7684interpreter\u3002 The executable file and the dynamic linker cooperate to create the process image for the program, which entails the following actions: Adding the executable file's memory segments to the process image;\u5f80process image\u4e2d\u6dfb\u52a0\u8fd9\u4e2aexecutable file\u7684memory segments Adding shared object memory segments to the process image;\u5f80process image\u4e2d\u6dfb\u52a0shared object memory segments Performing relocations for the executable file and its shared objects;\u4e3a\u8fd9\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\u548c\u5b83\u7684shared objects\u6267\u884crelocation Closing the file descriptor that was used to read the executable file, if one was given to the dynamic linker;\u5173\u95ed\u7528\u4e8e\u8bfb\u53d6\u8fd9\u4e2aexecutable file\u7684file descriptor Transferring control to the program, making it look as if the program had received control directly from the executable file.\u628a\u63a7\u5236\u4f20\u8f93\u7ed9\u8fd9\u4e2a\u7a0b\u5e8f The link editor also constructs various data that assist the dynamic linker for executable and shared object files. As shown above in \"Program Header,'' these data reside in loadable segments, making them available during execution. (Note that the exact segment contents are processor-specific.) As \"Program Loading\" explains in the appendix at the end of this book, shared objects may occupy virtual memory addresses that are different from the addresses recorded in the file's program header table. The dynamic linker relocates the memory image, updating absolute addresses before the application gains control. Although the absolute address values would be correct if the library were loaded at the addresses specified in the program header table, this normally is not the case. \u5728\u6587\u4ef6program header table\u4e2d\u8bb0\u5f55\u7684address\u548c\u7a0b\u5e8f\u771f\u6b63\u6267\u884c\u65f6\u4f7f\u7528\u7684virtual memory address\u662f\u53ef\u80fd\u4e0d\u76f8\u540c\u7684\u3002\u7531dynamic linker\u5728\u76ee\u6807\u7a0b\u5e8f\u83b7\u5f97\u63a7\u5236\u4e4b\u524d\u6765relocate memory image\uff0c\u66f4\u65b0\u7edd\u5bf9\u5730\u5740\u3002 The dynamic linker is permitted to evaluate procedure linkage table entries lazily, thus avoiding symbol resolution and relocation overhead for functions that are not called. Dynamic Section","title":"\u52a8\u6001\u94fe\u63a5"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/#dynamic#linking","text":"","title":"Dynamic Linking"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/#program#interpreter","text":"An executable file that participates in dynamic linking shall have one PT_INTERP program header element. During exec (BA_OS), the system retrieves a path name from the PT_INTERP segment and creates the initial process image from the interpreter file's segments. That is, instead of using the original executable file's segment images, the system composes a memory image for the interpreter. It then is the interpreter's responsibility to receive control from the system and provide an environment for the application program. \u5bf9\u4e8e\u4e00\u4e2a\u53c2\u4e0e\u52a8\u6001\u94fe\u63a5\u7684executable file\uff0c\u5b83\u7684program header element\u5e94\u8be5\u6709\u4e00\u4e2aPT_INTERP\u6210\u5458\u3002\u5f53\u4f7f\u7528exec\u7cfb\u7edf\u8c03\u7528\u6765\u542f\u52a8\u4e00\u4e2a\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4ecePT_INTERP segment\u4e2d\u53d6\u51fainterpreter file\u7684\u8def\u5f84\uff0c\u7136\u540e\u4f7f\u7528interpreter file\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5e76\u4e0d\u662f\u9996\u5148\u521b\u5efa\u8fd9\u4e2aexecutable file\u7684process image\uff0c\u800c\u662f\u9996\u5148\u521b\u5efa\u7684\u662f\u8fd9\u4e2ainterpreter\u7684process image\u3002\u7136\u540e\u64cd\u4f5c\u7cfb\u7edf\u628a\u63a7\u5236\u4f20\u9012\u4e2a\u8fd9\u4e2ainterpreter\uff0c\u8fd9\u4e2ainterpreter\u7684\u804c\u8d23\u662f\u4e3a\u63a5\u4e0b\u6765\u8981\u6267\u884c\u7684executable file\u51c6\u5907\u597d\u73af\u5883\u3002 The interpreter receives control in one of two ways. First, it may receive a file descriptor to read the executable file, positioned at the beginning. It can use this file descriptor to read and/or map the executable file's segments into memory. Second, depending on the executable file format, the system may load the executable file into memory instead of giving the interpreter an open file descriptor. With the possible exception of the file descriptor, the interpreter's initial process state matches what the executable file would have received. The interpreter itself may not require a second interpreter. An interpreter may be either a shared object or an executable file. \u2022 A shared object (the normal case) is loaded as position-independent, with addresses that may vary from one process to another; the system creates its segments in the dynamic segment area used by mmap (KE_OS) and related services. Consequently, a shared object interpreter typically will not conflict with the original executable file's original segment addresses. \u2022 An executable file is loaded at fixed addresses; the system creates its segments using the virtual addresses from the program header table. Consequently, an executable file interpreter's virtual addresses may collide with the first executable file; the interpreter is responsible for resolving conflicts. interpreter\u6309\u7167\u5982\u4e0b\u4e24\u79cd\u65b9\u5f0f\u4e2d\u7684\u4e00\u79cd\u6765\u63a5\u6536\u63a7\u5236\u3002 \u7b2c\u4e00\u79cd\uff0c\u5b83\u53ef\u80fd\u4f1a\u63a5\u6536\u5230\u4e00\u4e2a\u6307\u5411\u8fd9\u4e2aexecutable file\u7684file descriptor\uff0c\u7136\u540e\u5b83\u4f7f\u7528\u8fd9\u4e2afile descriptor\u6765\u5c06\u6307\u5b9a\u7684executable file \u7684segment read \u6216map\u5230\u5185\u5b58\u4e2d\u3002 \u7b2c\u4e8c\u79cd\uff0c\u53d6\u51b3\u4e8e\u53ef\u6267\u884c\u6587\u4ef6\u683c\u5f0f\u5316\uff0c\u7cfb\u7edf\u53ef\u80fd\u5c06\u53ef\u6267\u884c\u6587\u4ef6\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\uff0c\u800c\u4e0d\u662f\u7ed9\u89e3\u91ca\u5668\u63d0\u4f9b\u4e00\u4e2a\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 \u9664\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e4b\u5916\uff0c\u89e3\u91ca\u5668\u7684\u521d\u59cb\u8fdb\u7a0b\u72b6\u6001\u4e0e\u53ef\u6267\u884c\u6587\u4ef6\u53ef\u80fd\u63a5\u6536\u7684\u5185\u5bb9\u76f8\u5339\u914d\u3002 \u89e3\u91ca\u5668\u672c\u8eab\u53ef\u80fd\u4e0d\u9700\u8981\u7b2c\u4e8c\u4e2a\u89e3\u91ca\u5668\u3002 \u89e3\u91ca\u5668\u53ef\u4ee5\u662f\u5171\u4eab\u5bf9\u8c61\u6216\u53ef\u6267\u884c\u6587\u4ef6\u3002 \u901a\u5e38\u60c5\u51b5\u4e0b\u8fd9\u4e2ainterpreter\u662f\u4e00\u4e2ashared object\uff0c\u5b83\u88ab\u88c5\u8f7d\u4e3a\u4e00\u4e2aposition-independent\uff0c\u56e0\u6b64\u5728\u4e0d\u540c\u7684\u8fdb\u7a0b\u4e2d\uff0c\u5730\u5740\u662f\u53ef\u80fd\u4e0d\u76f8\u540c\u7684\u3002\u4f7f\u7528\u8fd9\u79cd\u65b9\u5f0f\u7684\u4e00\u4e2a\u597d\u5904\u662fa shared object interpreter\u5c06\u4e0d\u4f1a\u4e0e\u539f\u6765\u7684executable file\u7684\u539fsegment\u5730\u5740\u51b2\u7a81\u3002 \uff1f\uff1f\u6211\u6709\u4e00\u4e2a\u7591\u95ee\uff0c\u6b64\u65f6\u7684interpreter\u662f\u4e00\u4e2aso\u6587\u4ef6\uff0c\u6b64\u65f6\u64cd\u4f5c\u7cfb\u7edf\u662f\u628a\u8fd9\u4e2aso\u4f5c\u4e3a\u5c06\u8981\u6267\u884c\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u6240\u94fe\u63a5\u7684\u641c\u6765\u8fdb\u884c\u52a0\u8f7d\u8fd8\u662f\uff1f\uff1f interpreter\u662f\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5728\u4e00\u4e2a\u5728\u56fa\u5b9a\u5bfc\u81f4\u52a0\u8f7d\u7684interpreter\u3002\u64cd\u4f5c\u7cfb\u7edf\u4f7f\u7528interpreter\u7684program header table\u7684 virtual addresses \u6765\u521b\u5efa\u5b83\u7684segment\u3002\u6240\u4ee5\uff0c\u4e00\u4e2aexecutable file interpreter\u7684virtual addresses\u662f\u53ef\u80fd\u548c\u539fexecutable file\u51b2\u7a81\u7684\u3002\u662f\u7531interpreter\u6765\u89e3\u51b3\u51b2\u7a81\u3002 \u6309\u7167\u8fd9\u79cd\u65b9\u5f0f\uff0c\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u6765\u5b9e\u73b0\u5728\u4e00\u4e2a\u56fa\u5b9a\u7684\u5bfc\u81f4\u4e0a\u52a0\u8f7d\u53ef\u6267\u884c\u7a0b\u5e8f\u7684\uff1f\uff1f","title":"Program Interpreter"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/#dynamic#linker","text":"When building an executable file that uses dynamic linking, the link editor adds a program header element of type PT_INTERP to an executable file, telling the system to invoke the dynamic linker as the program interpreter. \u5f53\u6784\u5efa\u4e00\u4e2a\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u7684\u7684\u53ef\u6267\u884c\u6587\u4ef6\u4f7f\uff0clink editor\u5f80\u8fd9\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\u7684program header table\u4e2d\u6dfb\u52a0\u7c7b\u578b\u4e3aPT_INTERP\u7684\u5143\u7d20\uff0c\u901a\u8fc7\u8fd9\u4e2a\u5143\u7d20\u6765\u544a\u8bc9\u64cd\u4f5c\u7cfb\u7edf\u8c03\u7528\u8fd9\u4e2adynamic linker\u6765\u4f5c\u4e3a\u8fd9\u4e2a\u7a0b\u5e8f\u7684interpreter\u3002 The executable file and the dynamic linker cooperate to create the process image for the program, which entails the following actions: Adding the executable file's memory segments to the process image;\u5f80process image\u4e2d\u6dfb\u52a0\u8fd9\u4e2aexecutable file\u7684memory segments Adding shared object memory segments to the process image;\u5f80process image\u4e2d\u6dfb\u52a0shared object memory segments Performing relocations for the executable file and its shared objects;\u4e3a\u8fd9\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\u548c\u5b83\u7684shared objects\u6267\u884crelocation Closing the file descriptor that was used to read the executable file, if one was given to the dynamic linker;\u5173\u95ed\u7528\u4e8e\u8bfb\u53d6\u8fd9\u4e2aexecutable file\u7684file descriptor Transferring control to the program, making it look as if the program had received control directly from the executable file.\u628a\u63a7\u5236\u4f20\u8f93\u7ed9\u8fd9\u4e2a\u7a0b\u5e8f The link editor also constructs various data that assist the dynamic linker for executable and shared object files. As shown above in \"Program Header,'' these data reside in loadable segments, making them available during execution. (Note that the exact segment contents are processor-specific.) As \"Program Loading\" explains in the appendix at the end of this book, shared objects may occupy virtual memory addresses that are different from the addresses recorded in the file's program header table. The dynamic linker relocates the memory image, updating absolute addresses before the application gains control. Although the absolute address values would be correct if the library were loaded at the addresses specified in the program header table, this normally is not the case. \u5728\u6587\u4ef6program header table\u4e2d\u8bb0\u5f55\u7684address\u548c\u7a0b\u5e8f\u771f\u6b63\u6267\u884c\u65f6\u4f7f\u7528\u7684virtual memory address\u662f\u53ef\u80fd\u4e0d\u76f8\u540c\u7684\u3002\u7531dynamic linker\u5728\u76ee\u6807\u7a0b\u5e8f\u83b7\u5f97\u63a7\u5236\u4e4b\u524d\u6765relocate memory image\uff0c\u66f4\u65b0\u7edd\u5bf9\u5730\u5740\u3002 The dynamic linker is permitted to evaluate procedure linkage table entries lazily, thus avoiding symbol resolution and relocation overhead for functions that are not called.","title":"Dynamic Linker"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/#dynamic#section","text":"","title":"Dynamic Section"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6/","text":"\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6 \u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807 \u91cd\u5b9a\u4f4d**\u662f\u5c06EFL\u6587\u4ef6\u4e2d\u7684**\u672a\u5b9a\u4e49\u7b26\u53f7 \uff08\u5305\u62ec\u51fd\u6570\u548c\u53d8\u91cf\uff09\u5173\u8054\u5230**\u6709\u6548\u503c**\uff08\uff1f\uff1f\u4ec0\u4e48\u662f\u6709\u6548\u503c\uff09\u7684\u5904\u7406\u8fc7\u7a0b\u3002\u5728main.o\u4e2d\uff0c\u8fd9\u610f\u5473\u7740\u5bf9printf\u548cputs\u7684\u672a\u5b9a\u4e49\u7684\u5f15\u7528\u5fc5\u987b\u66ff\u6362\u4e3a\u8be5**\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u4e2d\u9002\u5f53\u7684**\u673a\u5668\u4ee3\u7801**\u6240\u5728\u7684**\u5730\u5740**\u3002\u5728\u76ee\u6807\u4e2d\u7528\u5230\u7684\u76f8\u5173**\u7b26\u53f7**\u4e4b\u5904\uff0c\u90fd\u5fc5\u987b\u66ff\u6362\u3002 \u5bf9*\u7528\u6237\u7a7a\u95f4* \u7a0b\u5e8f\u7b26\u53f7**\u7684\u66ff\u6362\uff0c**\u5185\u6838**\u5e76\u4e0d\u6d89\u53ca\u5176\u4e2d\uff0c\u56e0\u4e3a\u6240\u6709\u7684\u66ff\u6362\u64cd\u4f5c\u90fd\u662f\u7531**\u5916\u90e8\u5de5\u5177**\u5b8c\u6210\u7684\u3002\u5bf9\u5185\u6838\u6a21\u5757\u6765\u8bf4\uff0c\u60c5\u51b5\u6709\u6240\u4e0d\u540c\uff0c\u56e0\u4e3a\u5185\u6838\u6240\u6536\u5230\u7684**\u6a21\u5757\u88f8\u6570\u636e \uff0c\u4e0e\u5176\u5b58\u50a8\u5728\u4e8c\u7ea7\u5236\u6587\u4ef6\u4e2d\u7684\u5f62\u5f0f\u5b8c\u5168\u76f8\u540c\uff0c\u5185\u6838\u672c\u8eab\u9700\u8981\u8d1f\u8d23\u91cd\u5b9a\u4f4d\u64cd\u4f5c\u3002 \u5728\u6bcf\u4e2a**\u76ee\u6807\u6587\u4ef6**\u4e2d\uff0c\u90fd\u6709\u4e00\u4e2a\u4e13\u95e8\u7684\u8868\uff0c\u5305\u542b\u4e86**\u91cd\u5b9a\u4f4d\u9879**\uff0c\u6807\u8bc6\u4e86\u9700\u8981\u8fdb\u884c\u91cd\u5b9a\u4f4d\u7684\u3002\u6bcf\u4e2a**\u8868\u9879**\u90fd\u5305\u542b\u4e0b\u5217\u4fe1\u606f\uff1a \u200b 1\uff09\u4e00\u4e2a**\u504f\u79fb\u91cf**\uff0c\u6307\u5b9a\u4e86\u4fee\u6539\u7684\u9879\u7684\u4f4d\u7f6e \u200b 2\uff09\u5bf9**\u7b26\u53f7**\u7684**\u5f15\u7528**\uff08\u7b26\u53f7\u8868\u7684**\u7d22\u5f15**\uff09\uff0c\u63d0\u4f9b\u4e86\u9700\u8981\u63d2\u5165\u5230**\u91cd\u5b9a\u4f4d\u4f4d\u7f6e**\u7684\u6570\u636e \u91cd\u5b9a\u4f4d\u6b65\u9aa4 \u200b 1\uff09\u91cd\u5b9a\u4f4d\u8282(section)\u548c\u7b26\u53f7\u5b9a\u4e49\u3002 \u200b \u94fe\u63a5\u5668**\u5c06\u6240\u6709**\u76f8\u540c\u7c7b\u578b\u7684\u8282**\u5408\u5e76\u4e3a\u540c\u4e00\u7c7b\u578b\u7684\u65b0\u7684**\u805a\u5408\u8282 \u3002\u4f8b\u5982\u6765\u81ea\u8f93\u5165\u6a21\u5757\u7684.data\u8282\u5168\u90e8\u5408\u5e76\u6210\u4e00\u4e2a\u8282\uff0c\u8fd9\u4e2a\u8282\u6210\u4e3a\u8f93\u51fa\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684.data\u8282\u3002\u7136\u540e**\u94fe\u63a5\u5668**\u5c06\u8fd0\u884c\u65f6**\u5b58\u50a8\u5668\u5730\u5740**\u8d4b\u7ed9\u65b0\u7684**\u805a\u5408\u8282**\uff0c\u8d4b\u7ed9\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6bcf\u4e2a\u8282\uff0c\u4ee5\u53ca\u8d4b\u7ed9\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6bcf\u4e2a**\u7b26\u53f7**\u3002\u5f53\u8fd9\u4e00\u6b65\u5b8c\u6210\u65f6\uff0c\u7a0b\u5e8f\u4e2d\u7684\u6bcf\u4e2a**\u6307\u4ee4**\u548c**\u5168\u5c40\u53d8\u91cf**\u90fd\u6709\u552f\u4e00\u7684**\u8fd0\u884c\u65f6\u5b58\u50a8\u5668\u5730\u5740**\u4e86\u3002 \u200b 2\uff09\u91cd\u5b9a\u4f4d\u8282(section)\u4e2d\u7684\u7b26\u53f7\u5f15\u7528\u3002 \u200b \u5728\u8fd9\u4e00\u6b65\u4e2d\uff0c\u94fe\u63a5\u5668\u4fee\u6539**\u4ee3\u7801\u8282**\u548c**\u6570\u636e\u8282**\u4e2d\u5bf9\u6bcf\u4e2a**\u7b26\u53f7**\u7684**\u5f15\u7528**(\uff1f\uff1f\u6b64\u5904\u7684\u5f15\u7528\u8981\u5982\u4f55\u7406\u89e3\uff09\uff0c\u4f7f\u5f97\u4ed6\u4eec\u6307\u5411**\u6b63\u786e\u7684\u8fd0\u884c\u65f6\u5730\u5740**\u3002\u4e3a\u4e86\u6267\u884c\u8fd9\u4e00\u6b65\uff0c\u94fe\u63a5\u5668\u4f9d\u8d56\u4e8e\u79f0\u4e4b\u4e3a**\u91cd\u5b9a\u4f4d\u6761\u76ee**\u7684\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6a21\u5757\u4e2d\u7684\u6570\u636e\u7ed3\u6784\u3002 \u91cd\u5b9a\u5411\u6761\u76ee \u5f53**\u6c47\u7f16\u5668**\u751f\u6210\u4e00\u4e2a**\u76ee\u6807\u6a21\u5757**\u65f6\uff0c\u5b83\u5e76\u4e0d\u77e5\u9053**\u6570\u636e**\u548c**\u4ee3\u7801**\u6700\u7ec8\u5c06\u5b58\u653e\u5728**\u5b58\u50a8\u5668**\u4e2d\u7684\u4ec0\u4e48\u4f4d\u7f6e\u3002\u5b83\u4e5f\u4e0d\u77e5\u9053\u8fd9\u4e2a\u6a21\u5757\u5f15\u7528\u7684\u4efb\u4f55\u5916\u90e8\u5b9a\u4e49\u7684**\u51fd\u6570**\u548c**\u5168\u5c40\u53d8\u91cf**\u3002\u6240\u4ee5\uff0c\u65e0\u8bba\u4f55\u65f6**\u6c47\u7f16\u5668**\u9047\u5230\u5bf9\u6700\u7ec8\u4f4d\u7f6e\u672a\u6307\u5b9a**\u76ee\u6807\u5f15\u7528**\uff08\uff1f\uff1f\u6b64\u5904\u7684\u76ee\u6807\u5f15\u7528\u8981\u5982\u4f55\u7406\u89e3\uff09\uff0c\u5b83\u5c31\u4f1a\u751f\u6210\u4e00\u4e2a**\u91cd\u5b9a\u4f4d\u6761\u76ee**\uff0c\u544a\u8bc9**\u94fe\u63a5\u5668**\u5728\u5c06**\u76ee\u6807\u6587\u4ef6**\u5408\u5e76**\u53ef\u6267\u884c\u6587\u4ef6**\u65f6\u5982\u4f55\u4fee\u6539\u8fd9\u4e2a**\u5f15\u7528**\u3002**\u4ee3\u7801\u91cd\u5b9a\u4f4d\u6761\u76ee**\u653e\u5728.rel.text\uff08**SHT_REL\u7c7b\u578b**\u7684\u8282\uff08section\uff09\uff09\u4e2d\u3002**\u5df2\u7ecf\u521d\u59cb\u5316\u6570\u636e\u7684\u91cd\u5b9a\u4f4d\u6761\u76ee**\u653e\u5728.rel.data(**SHT_REL\u7c7b\u578b**\u7684\u8282\uff08section\uff09)\u4e2d\u3002 \u6570\u636e\u7ed3\u6784 \u200b \u7531\u4e8e\u6280\u672f\u539f\u56e0\uff0c\u6709\u4e24\u79cd\u7c7b\u578b\u7684\u91cd\u5b9a\u4f4d\u4fe1\u606f\uff0c\u7531\u4e24\u79cd\u7a0d\u6709\u4e0d\u540c\u7684\u6570\u636e\u7ed3\u6784\u8868\u793a\u3002\u7b2c\u4e00\u79cd\u7c7b\u578b\u79f0\u4e4b\u4e3a**\u666e\u901a\u91cd\u5b9a\u4f4d**\u3002**SHT_REL\u7c7b\u578b**\u7684\u8282\uff08section\uff09\u4e2d\u7684**\u91cd\u5b9a\u4f4d\u9879**\u7531\u4ee5\u4e0b\u6570\u636e\u7ed3\u6784\u5b9a\u4e49\uff1a /*Relocation table entry without addend (in section of type SHT_REL). */ typedef struct { Elf32_Addr r_offset ; /* Address \u6307\u5b9a\u9700\u8981\u91cd\u5b9a\u4f4d\u7684\u9879\u7684\u4f4d\u7f6e*/ Elf32_Word r_info ; /* Relocation type andsymbol index \u63d0\u4f9b\u4e86\u7b26\u53f7\u8868\u4e2d\u7684\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u540c\u65f6\u8fd8\u5305\u62ec\u91cd\u5b9a\u4f4d\u7c7b\u578b\u7684\u6709\u4e2a\u4fe1\u606f\u3002\u8fd9\u662f\u901a\u8fc7\u5c06\u503c\u5212\u5206\u4e3a\u4e24\u90e8\u5206\u6765\u8fbe\u5230\u7684\u3002\u8be5\u5b57\u6bb5\u7684\u7ed3\u6784\u5982\u4e0b\uff1a r_info == int symbol:24,type:8;*/ } Elf32_Rel ; \u53e6\u4e00\u79cd\u7c7b\u578b\uff0c\u79f0\u4e4b\u4e3a\u9700\u8981\u6dfb\u52a0\u5e38\u6570\u7684**\u91cd\u5b9a\u4f4d\u9879**\uff0c\u53ea\u51fa\u73b0\u5728SHT_RELA\u7c7b\u578b\u7684\u8282\u4e2d\u3002\u6570\u636e\u7ed3\u6784\u5982\u4e0b\uff1a /* Relocation table entry with addend (insection of type SHT_RELA). */ typedef struct { Elf32_Addr r_offset ; /* Address */ Elf32_Word r_info ; /* Relocation type andsymbol index */ Elf32_Sword r_addend ; /* Addend \u52a0\u6570\uff0c\u8ba1\u7b97\u91cd\u5b9a\u4f4d\u662f\uff0c\u5c06\u6839\u636e\u91cd\u5b9a\u4f4d\u7c7b\u578b\uff0c\u5bf9\u8be5\u503c\u8fdb\u884c\u4e0d\u540c\u7684\u5904\u7406\u3002*/ } Elf32_Rela ;","title":"[\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6](https://blog.csdn.net/ylcangel/article/details/18188921)"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6/#_1","text":"","title":"\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6/#_2","text":"\u91cd\u5b9a\u4f4d**\u662f\u5c06EFL\u6587\u4ef6\u4e2d\u7684**\u672a\u5b9a\u4e49\u7b26\u53f7 \uff08\u5305\u62ec\u51fd\u6570\u548c\u53d8\u91cf\uff09\u5173\u8054\u5230**\u6709\u6548\u503c**\uff08\uff1f\uff1f\u4ec0\u4e48\u662f\u6709\u6548\u503c\uff09\u7684\u5904\u7406\u8fc7\u7a0b\u3002\u5728main.o\u4e2d\uff0c\u8fd9\u610f\u5473\u7740\u5bf9printf\u548cputs\u7684\u672a\u5b9a\u4e49\u7684\u5f15\u7528\u5fc5\u987b\u66ff\u6362\u4e3a\u8be5**\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u4e2d\u9002\u5f53\u7684**\u673a\u5668\u4ee3\u7801**\u6240\u5728\u7684**\u5730\u5740**\u3002\u5728\u76ee\u6807\u4e2d\u7528\u5230\u7684\u76f8\u5173**\u7b26\u53f7**\u4e4b\u5904\uff0c\u90fd\u5fc5\u987b\u66ff\u6362\u3002 \u5bf9*\u7528\u6237\u7a7a\u95f4* \u7a0b\u5e8f\u7b26\u53f7**\u7684\u66ff\u6362\uff0c**\u5185\u6838**\u5e76\u4e0d\u6d89\u53ca\u5176\u4e2d\uff0c\u56e0\u4e3a\u6240\u6709\u7684\u66ff\u6362\u64cd\u4f5c\u90fd\u662f\u7531**\u5916\u90e8\u5de5\u5177**\u5b8c\u6210\u7684\u3002\u5bf9\u5185\u6838\u6a21\u5757\u6765\u8bf4\uff0c\u60c5\u51b5\u6709\u6240\u4e0d\u540c\uff0c\u56e0\u4e3a\u5185\u6838\u6240\u6536\u5230\u7684**\u6a21\u5757\u88f8\u6570\u636e \uff0c\u4e0e\u5176\u5b58\u50a8\u5728\u4e8c\u7ea7\u5236\u6587\u4ef6\u4e2d\u7684\u5f62\u5f0f\u5b8c\u5168\u76f8\u540c\uff0c\u5185\u6838\u672c\u8eab\u9700\u8981\u8d1f\u8d23\u91cd\u5b9a\u4f4d\u64cd\u4f5c\u3002 \u5728\u6bcf\u4e2a**\u76ee\u6807\u6587\u4ef6**\u4e2d\uff0c\u90fd\u6709\u4e00\u4e2a\u4e13\u95e8\u7684\u8868\uff0c\u5305\u542b\u4e86**\u91cd\u5b9a\u4f4d\u9879**\uff0c\u6807\u8bc6\u4e86\u9700\u8981\u8fdb\u884c\u91cd\u5b9a\u4f4d\u7684\u3002\u6bcf\u4e2a**\u8868\u9879**\u90fd\u5305\u542b\u4e0b\u5217\u4fe1\u606f\uff1a \u200b 1\uff09\u4e00\u4e2a**\u504f\u79fb\u91cf**\uff0c\u6307\u5b9a\u4e86\u4fee\u6539\u7684\u9879\u7684\u4f4d\u7f6e \u200b 2\uff09\u5bf9**\u7b26\u53f7**\u7684**\u5f15\u7528**\uff08\u7b26\u53f7\u8868\u7684**\u7d22\u5f15**\uff09\uff0c\u63d0\u4f9b\u4e86\u9700\u8981\u63d2\u5165\u5230**\u91cd\u5b9a\u4f4d\u4f4d\u7f6e**\u7684\u6570\u636e","title":"\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6/#_3","text":"\u200b 1\uff09\u91cd\u5b9a\u4f4d\u8282(section)\u548c\u7b26\u53f7\u5b9a\u4e49\u3002 \u200b \u94fe\u63a5\u5668**\u5c06\u6240\u6709**\u76f8\u540c\u7c7b\u578b\u7684\u8282**\u5408\u5e76\u4e3a\u540c\u4e00\u7c7b\u578b\u7684\u65b0\u7684**\u805a\u5408\u8282 \u3002\u4f8b\u5982\u6765\u81ea\u8f93\u5165\u6a21\u5757\u7684.data\u8282\u5168\u90e8\u5408\u5e76\u6210\u4e00\u4e2a\u8282\uff0c\u8fd9\u4e2a\u8282\u6210\u4e3a\u8f93\u51fa\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684.data\u8282\u3002\u7136\u540e**\u94fe\u63a5\u5668**\u5c06\u8fd0\u884c\u65f6**\u5b58\u50a8\u5668\u5730\u5740**\u8d4b\u7ed9\u65b0\u7684**\u805a\u5408\u8282**\uff0c\u8d4b\u7ed9\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6bcf\u4e2a\u8282\uff0c\u4ee5\u53ca\u8d4b\u7ed9\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6bcf\u4e2a**\u7b26\u53f7**\u3002\u5f53\u8fd9\u4e00\u6b65\u5b8c\u6210\u65f6\uff0c\u7a0b\u5e8f\u4e2d\u7684\u6bcf\u4e2a**\u6307\u4ee4**\u548c**\u5168\u5c40\u53d8\u91cf**\u90fd\u6709\u552f\u4e00\u7684**\u8fd0\u884c\u65f6\u5b58\u50a8\u5668\u5730\u5740**\u4e86\u3002 \u200b 2\uff09\u91cd\u5b9a\u4f4d\u8282(section)\u4e2d\u7684\u7b26\u53f7\u5f15\u7528\u3002 \u200b \u5728\u8fd9\u4e00\u6b65\u4e2d\uff0c\u94fe\u63a5\u5668\u4fee\u6539**\u4ee3\u7801\u8282**\u548c**\u6570\u636e\u8282**\u4e2d\u5bf9\u6bcf\u4e2a**\u7b26\u53f7**\u7684**\u5f15\u7528**(\uff1f\uff1f\u6b64\u5904\u7684\u5f15\u7528\u8981\u5982\u4f55\u7406\u89e3\uff09\uff0c\u4f7f\u5f97\u4ed6\u4eec\u6307\u5411**\u6b63\u786e\u7684\u8fd0\u884c\u65f6\u5730\u5740**\u3002\u4e3a\u4e86\u6267\u884c\u8fd9\u4e00\u6b65\uff0c\u94fe\u63a5\u5668\u4f9d\u8d56\u4e8e\u79f0\u4e4b\u4e3a**\u91cd\u5b9a\u4f4d\u6761\u76ee**\u7684\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6a21\u5757\u4e2d\u7684\u6570\u636e\u7ed3\u6784\u3002","title":"\u91cd\u5b9a\u4f4d\u6b65\u9aa4"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6/#_4","text":"\u5f53**\u6c47\u7f16\u5668**\u751f\u6210\u4e00\u4e2a**\u76ee\u6807\u6a21\u5757**\u65f6\uff0c\u5b83\u5e76\u4e0d\u77e5\u9053**\u6570\u636e**\u548c**\u4ee3\u7801**\u6700\u7ec8\u5c06\u5b58\u653e\u5728**\u5b58\u50a8\u5668**\u4e2d\u7684\u4ec0\u4e48\u4f4d\u7f6e\u3002\u5b83\u4e5f\u4e0d\u77e5\u9053\u8fd9\u4e2a\u6a21\u5757\u5f15\u7528\u7684\u4efb\u4f55\u5916\u90e8\u5b9a\u4e49\u7684**\u51fd\u6570**\u548c**\u5168\u5c40\u53d8\u91cf**\u3002\u6240\u4ee5\uff0c\u65e0\u8bba\u4f55\u65f6**\u6c47\u7f16\u5668**\u9047\u5230\u5bf9\u6700\u7ec8\u4f4d\u7f6e\u672a\u6307\u5b9a**\u76ee\u6807\u5f15\u7528**\uff08\uff1f\uff1f\u6b64\u5904\u7684\u76ee\u6807\u5f15\u7528\u8981\u5982\u4f55\u7406\u89e3\uff09\uff0c\u5b83\u5c31\u4f1a\u751f\u6210\u4e00\u4e2a**\u91cd\u5b9a\u4f4d\u6761\u76ee**\uff0c\u544a\u8bc9**\u94fe\u63a5\u5668**\u5728\u5c06**\u76ee\u6807\u6587\u4ef6**\u5408\u5e76**\u53ef\u6267\u884c\u6587\u4ef6**\u65f6\u5982\u4f55\u4fee\u6539\u8fd9\u4e2a**\u5f15\u7528**\u3002**\u4ee3\u7801\u91cd\u5b9a\u4f4d\u6761\u76ee**\u653e\u5728.rel.text\uff08**SHT_REL\u7c7b\u578b**\u7684\u8282\uff08section\uff09\uff09\u4e2d\u3002**\u5df2\u7ecf\u521d\u59cb\u5316\u6570\u636e\u7684\u91cd\u5b9a\u4f4d\u6761\u76ee**\u653e\u5728.rel.data(**SHT_REL\u7c7b\u578b**\u7684\u8282\uff08section\uff09)\u4e2d\u3002","title":"\u91cd\u5b9a\u5411\u6761\u76ee"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6/#_5","text":"\u200b \u7531\u4e8e\u6280\u672f\u539f\u56e0\uff0c\u6709\u4e24\u79cd\u7c7b\u578b\u7684\u91cd\u5b9a\u4f4d\u4fe1\u606f\uff0c\u7531\u4e24\u79cd\u7a0d\u6709\u4e0d\u540c\u7684\u6570\u636e\u7ed3\u6784\u8868\u793a\u3002\u7b2c\u4e00\u79cd\u7c7b\u578b\u79f0\u4e4b\u4e3a**\u666e\u901a\u91cd\u5b9a\u4f4d**\u3002**SHT_REL\u7c7b\u578b**\u7684\u8282\uff08section\uff09\u4e2d\u7684**\u91cd\u5b9a\u4f4d\u9879**\u7531\u4ee5\u4e0b\u6570\u636e\u7ed3\u6784\u5b9a\u4e49\uff1a /*Relocation table entry without addend (in section of type SHT_REL). */ typedef struct { Elf32_Addr r_offset ; /* Address \u6307\u5b9a\u9700\u8981\u91cd\u5b9a\u4f4d\u7684\u9879\u7684\u4f4d\u7f6e*/ Elf32_Word r_info ; /* Relocation type andsymbol index \u63d0\u4f9b\u4e86\u7b26\u53f7\u8868\u4e2d\u7684\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u540c\u65f6\u8fd8\u5305\u62ec\u91cd\u5b9a\u4f4d\u7c7b\u578b\u7684\u6709\u4e2a\u4fe1\u606f\u3002\u8fd9\u662f\u901a\u8fc7\u5c06\u503c\u5212\u5206\u4e3a\u4e24\u90e8\u5206\u6765\u8fbe\u5230\u7684\u3002\u8be5\u5b57\u6bb5\u7684\u7ed3\u6784\u5982\u4e0b\uff1a r_info == int symbol:24,type:8;*/ } Elf32_Rel ; \u53e6\u4e00\u79cd\u7c7b\u578b\uff0c\u79f0\u4e4b\u4e3a\u9700\u8981\u6dfb\u52a0\u5e38\u6570\u7684**\u91cd\u5b9a\u4f4d\u9879**\uff0c\u53ea\u51fa\u73b0\u5728SHT_RELA\u7c7b\u578b\u7684\u8282\u4e2d\u3002\u6570\u636e\u7ed3\u6784\u5982\u4e0b\uff1a /* Relocation table entry with addend (insection of type SHT_RELA). */ typedef struct { Elf32_Addr r_offset ; /* Address */ Elf32_Word r_info ; /* Relocation type andsymbol index */ Elf32_Sword r_addend ; /* Addend \u52a0\u6570\uff0c\u8ba1\u7b97\u91cd\u5b9a\u4f4d\u662f\uff0c\u5c06\u6839\u636e\u91cd\u5b9a\u4f4d\u7c7b\u578b\uff0c\u5bf9\u8be5\u503c\u8fdb\u884c\u4e0d\u540c\u7684\u5904\u7406\u3002*/ } Elf32_Rela ;","title":"\u6570\u636e\u7ed3\u6784"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/","text":"\u539f\u7531\uff1a \u591a\u9053\u7a0b\u5e8f\u73af\u5883\u4e0b\uff0c\u7a0b\u5e8f\u662f**\u5e76\u53d1**\u6267\u884c\u7684\uff0c\u6240\u4ee5\u8981\u4f7f\u7a0b\u5e8f\u8fd0\u884c\uff0c\u5fc5\u987b\u5148\u4e3a\u4e4b\u521b\u5efa**\u8fdb\u7a0b**\uff0c\u800c\u521b\u5efa\u8fdb\u7a0b\u7684\u7b2c\u4e00\u4ef6\u4e8b\u5c31\u662f\u5c06**\u7a0b\u5e8f**\u548c**\u6570\u636e**\u88c5\u5165\u5185\u5b58 \u76ee\u7684\uff1a \u7528\u6237\u7a0b\u5e8f\u5230\u5185\u5b58\u53ef\u6267\u884c\u7a0b\u5e8f\u7684\u6b65\u9aa4\uff1a \u5373 \u4e0b\u9762\u5f00\u59cb\u5c06\u7a0b\u5e8f\u201c\u94fe\u63a5\u201d\u548c\u201c\u88c5\u5165\u201d\u7684\u5177\u4f53\u60c5\u51b5\uff1a \u7a0b\u5e8f\u7684\u94fe\u63a5\uff1a \u6e90\u7a0b\u5e8f\u7ecf\u8fc7\u7f16\u8bd1\u540e\uff0c\u5f97\u5230**\u4e00\u7ec4**\u76ee\u6807\u6a21\u5757\uff0c\u518d\u5229\u7528\u201c\u94fe\u63a5\u7a0b\u5e8f\u201d\u5c06\u8fd9\u7ec4\u76ee\u6807\u6a21\u5757\u94fe\u63a5\u8d77\u6765\uff0c\u5f62\u6210**\u4e00\u4e2a**\u5b8c\u6574\u7684\u88c5\u5165\u6a21\u5757\uff08\u5373**\u53ef\u6267\u884c\u6587\u4ef6**\uff09 \u5982\u4e0b\u56fe\uff1a\u6e90\u7a0b\u5e8f\u7f16\u8bd1\u540e\u5f97\u5230\u4e09\u4e2a\u76ee\u6807\u6a21\u5757A\u3001B\u3001C\uff0c\u957f\u5ea6\u5206\u522b\u4e3aL\u3001M\u3001N\uff0c\u94fe\u63a5\u540e\u5f62\u6210\u53f3\u4fa7\u7684\u88c5\u5165\u6a21\u5757\uff1a \u94fe\u63a5\u65f6\u9700\u8981\u505a\u4e24\u4e2a\u5de5\u4f5c\uff1a \u00d8 \u76f8\u5bf9\u5730\u5740\u8fdb\u884c\u4fee\u6539 \uff08\u53d8\u5316\u4ee5\u540e\u8fd8\u662f**\u76f8\u5bf9**\u5730\u5740\uff09\uff0c\u5730\u5740\u90fd\u53d8\u4e3a\u76f8\u5bf9\u6700\u4e0a\u5c42\u6a21\u5757\u7684\u8d77\u59cb\u5730\u5740\u6765\u8ba1\u7b97\u3002 \u00d8 \u53d8\u5316\u5916\u90e8\u8c03\u7528\u7b26\u53f7 \uff0c\u5982CALL B------> JSR\u201cL\u201d CALL B\u4e3a\u8c03\u7528B\u6a21\u5757\uff0cJSR\u201cL\u201d\u4e3a\u8df3\u8f6c\u5230\uff2c\u884c \u94fe\u63a5\u524dA\u548cB\u4e3a\u4e24\u4e2a\u4e0d\u540c\u7684\u6a21\u5757\uff0c\u5728A\u6a21\u5757\u4e2d\u60f3\u6267\u884c\uff22\u6a21\u5757\uff0c\u8981\u4f7f\u7528\u8c03\u7528\uff08CALL\uff09\u8bed\u53e5\uff1b\u94fe\u63a5\u540eA\u548cB\u4e3a\u540c\u4e00\u6a21\u5757\uff0c\u82e5\u60f3\u8fbe\u5230\u540c\u6837\u5730\u6548\u679c\uff0c\u53ea\u9700\u5728\u672c\u6a21\u5757\u4e2d\u4f7f\u7528\u8df3\u8f6c\u8bed\u53e5\uff08JSR\uff09\u8df3\u8f6c\u5230\u60f3\u6267\u884c\u7684\u5730\u65b9\u5373\u53ef\u3002 \u94fe\u63a5\u5206\u4e3a\u9759\u6001\u94fe\u63a5\u548c\u52a8\u6001\u94fe\u63a5\u3002\u76f8\u5e94\u7684\u91cd\u5b9a\u4f4d\u5373\u4e3a\u9759\u6001\u91cd\u5b9a\u4f4d\u548c\u52a8\u6001\u91cd\u5b9a\u4f4d\u3002 \u7a0b\u5e8f\u7684\u88c5\u5165\uff1a \u5373\u5c06\u94fe\u63a5\u597d\u7684\u6a21\u5757\u88c5\u5165\u5185\u5b58 \u903b\u8f91\u5730\u5740\u4e0e\u7269\u7406\u5730\u5740 \u200b \u7528\u6237\u7a0b\u5e8f\u7f16\u8bd1\u4e3a\u76ee\u6807\u6a21\u5757\u540e\uff0c\u4f1a\u5bf9\u6bcf\u4e2a\u6a21\u5757\u5185\u90e8\uff08\u7a0b\u5e8f\u6570\u636e\u7b49\uff09\u8fdb\u884c\u7f16\u5740\uff0c\u6b64\u65f6\u7f16\u597d\u7684\u5730\u5740\u53eb\u505a**\u903b\u8f91\u5730\u5740\u6216\u76f8\u5bf9\u5730\u5740**\uff08\u4e0b\u9762\u7684**\u7edd\u5bf9\u88c5\u5165\u65b9\u5f0f**\u9664\u5916\uff09\uff0c\u90fd\u662f\u76f8\u5bf9\u4e8e**\u672c\u6a21\u5757\u7684**\u8d77\u59cb\u5730\u5740\uff08\u4e00\u822c\u4ece0\u5f00\u59cb\uff09\u8ba1\u7b97\u7684\u3002\u8fdb\u884c\u94fe\u63a5\u540e\u67d0\u4e9b\u6a21\u5757\u7684\u76f8\u5bf9\u5730\u5740\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u5730\u5740\u90fd\u53d8\u4e3a**\u76f8\u5bf9\u4e8e\u88c5\u5165\u6a21\u5757**\u7684\u8d77\u59cb\u5730\u5740\u8fdb\u884c\u8ba1\u7b97\uff08\u663e\u7136\u6b64\u65f6\u8fd8\u662f\u76f8\u5bf9\u5730\u5740\uff09\u3002 \u3000 \u200b \u901a\u5e38\u5c06\u5185\u5b58\u7684\u5b9e\u9645\u5730\u5740\u79f0\u4e3a**\u7269\u7406\u5730\u5740** ** \u5206\u7c7b \u00d8 \u7edd\u5bf9\u88c5\u5165\u65b9\u5f0f \u00d8 \u53ef\u91cd\u5b9a\u4f4d\u88c5\u5165\u65b9\u5f0f\uff08\u9759\u6001\u91cd\u5b9a\u4f4d\uff09 \u00d8 \u52a8\u6001\u8fd0\u884c\u65f6\u88c5\u5165\u65b9\u5f0f\uff08\u52a8\u6001\u91cd\u5b9a\u4f4d\uff09 \u89e3\u6790 \uff081\uff09\u7edd\u5bf9\u88c5\u5165\u65b9\u5f0f \u7a0b\u5e8f\u7f16\u8bd1\u65f6\uff0c\u5982\u679c\u77e5\u9053\u7a0b\u5e8f\u5c06\u9a7b\u7559\u5728\u5185\u5b58\u7684\u4ec0\u4e48\u4f4d\u7f6e\uff08\u8d77\u59cb\u5730\u5740\uff09\uff0c\u90a3\u4e48\u7f16\u8bd1\u751f\u6210\u7684\u76ee\u6807\u4ee3\u7801\uff0c\u5c06\u91c7\u7528**\u7edd\u5730\u5730\u5740\u8fdb\u884c\u7f16\u5740\uff0c \u5373\u8d77\u59cb\u5730\u5740**\u4e0d\u4ece0\u5f00\u59cb \uff0c\u4ece\u4e0a\u9762\u6240\u77e5\u7684\u5185\u5b58\u8d77\u59cb\u5730\u5740\u5f00\u59cb\u7f16\u5740\u3002 \u4f8b\u5982\uff1a\u4e8b\u5148\u5df2\u77e5\u7528\u6237\u7a0b\u5e8f(\u8fdb\u7a0b)\u9a7b\u7559\u5728\u4ece1000\u53f7\u5355\u5143\u5904\u5f00\u59cb\u7684\u4f4d\u7f6e\uff0c\u5219\u7f16\u8bd1\u7a0b\u5e8f\u6240\u4ea7\u751f\u7684\u76ee\u6807\u6a21\u5757(\u5373\u88c5\u5165\u6a21\u5757)\u4fbf\u4ece1000\u5904\u5f00\u59cb\u5411\u4e0a\u6269\u5c55\uff1a \u7531\u4e8e\u91c7\u7528\u7684\u662f\u7edd\u5bf9\u5730\u5740\uff0c\u6240\u4ee5\u5c06\u88c5\u5165\u6a21\u5757\u76f4\u63a5\u88c5\u5165\u5185\u5b58\u5373\u53ef\uff0c\u65e0\u9700\u8fdb\u884c\u5730\u5740\u53d8\u6362\u3002 \uff082\uff09\u53ef\u91cd\u5b9a\u4f4d\u88c5\u5165\u65b9\u5f0f\uff08\u9759\u6001\u91cd\u5b9a\u4f4d\uff09 \u00d8 \u51fa\u73b0\uff1a \u7f16\u8bd1\u65f6\u5c06\u7a0b\u5e8f\u88c5\u5165\u6307\u5b9a\u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u5fc5\u987b\u9700\u8981\u7a0b\u5e8f\u5458\u719f\u6089\u5185\u5b58\u7684\u4f7f\u7528\u60c5\u51b5 \u7edd\u5bf9\u88c5\u5165\u65b9\u5f0f\u53ea\u80fd\u5c06\u76ee\u6807\u6a21\u5757\u88c5\u5165\u5230\u5185\u5b58\u4e2d\u4e8b\u5148\u6307\u5b9a\u7684\u4f4d\u7f6e\u3002\u800c\u5728\u591a\u9053\u7a0b\u5e8f\u73af\u5883\u4e0b\uff0c\u7f16\u8bd1\u7a0b\u5e8f\u4e0d\u53ef\u80fd\u9884\u77e5\u6240\u7f16\u8bd1\u7684\u76ee\u6807\u6a21\u5757\u5e94\u653e\u5728\u5185\u5b58\u7684\u4f55\u5904 \u53ef\u91cd\u5b9a\u4f4d\u65b9\u5f0f\u53ef\u6839\u636e\u5185\u5b58\u7684\u5f53\u524d\u60c5\u51b5\uff0c\u5c06\u88c5\u5165\u6a21\u5757\u88c5\u5165\u5230\u5185\u5b58\u7684**\u9002\u5f53\u4f4d\u7f6e** \u00d8 \u539f\u7406\uff1a \u6e90\u7a0b\u5e8f\u7f16\u8bd1\u751f\u6210\u7684\u76ee\u6807\u6a21\u5757\u90fd\u91c7\u7528**\u76f8\u5bf9\u5730\u5740**\u8fdb\u884c\u7f16\u5740\uff0c\u5373\u6bcf\u4e2a\u6a21\u5757\u90fd\u4ece0\u5f00\u59cb\u7f16\u5740\uff0c\u5f53\u7136\u94fe\u63a5\u540e\u7684\u6a21\u5757\u4e5f\u91c7\u7528\u76f8\u5bf9\u5730\u5740\u7f16\u5740 \u5c06\u88c5\u5165\u6a21\u5757\u88c5\u5165\u5185\u5b58\u540e\uff0c\u6a21\u5757\u4e2d\u7684\u7a0b\u5e8f\u548c\u6570\u636e\u7b49\uff0c\u5728\u5185\u5b58\u4e2d\u90fd\u5c06\u5177\u6709\u4e00\u4e2a\u7269\u7406\u5730\u5740\uff0c\u6b64\u7269\u7406\u5730\u5740\u662f\u76f8\u5bf9\u4e8e\u5185\u5b58\u7684\u8d77\u59cb\u5730\u5740\u8fdb\u884c\u7f16\u5740\u7684\uff0c\u6240\u4ee5\u4e0e\u539f\u5148\u6a21\u5757\u4e2d\u7684\u903b\u8f91\u5730\u5740\uff08\u76f8\u5bf9\u4e8e\u6a21\u5757\u7684\u8d77\u59cb\u5730\u5740\u8fdb\u884c\u7f16\u5740\uff09\u4e0d\u540c\uff0c\u6240\u4ee5\u4e3a\u4e86\u5f97\u5230\u7269\u7406\u5730\u5740\u9700\u8981\u5bf9\u903b\u8f91\u5730\u5740\u8fdb\u884c\u6539\u53d8\u3002\u800c\u6b64\u5730\u5740\u53d8\u5316\u7684\u8fc7\u7a0b\u5c31\u53eb\u505a**\u91cd\u5b9a\u4f4d**\uff0c\u53c8\u56e0\u4e3a\u5730\u5740\u53d8\u6362\u901a\u5e38\u662f\u5728\u88c5\u5165\u65f6\u4e00\u6b21\u5b8c\u6210\u7684\uff0c\u4ee5\u540e\u4e0d\u518d\u6539\u53d8\uff0c\u6545\u79f0\u4e3a**\u9759\u6001\u91cd\u5b9a\u4f4d\u3002**\u5982\u4e0b\u56fe\uff1a \uff083\uff09\u52a8\u6001\u8fd0\u884c\u65f6\u88c5\u5165\u65b9\u5f0f\uff08\u52a8\u6001\u91cd\u5b9a\u4f4d\uff09 \u53ea\u662f\u628a**\u76f8\u5bf9\u5730\u5740\u5230\u7edd\u5bf9\u5730\u5740\u7684\u8f6c\u6362**\u63a8\u8fdf\u5230\u7a0b\u5e8f\u771f\u6b63\u6267\u884c\u65f6\u624d\u8fdb\u884c \u603b\u7ed3\uff1a Q&A","title":"\u539f\u7531\uff1a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#_1","text":"\u591a\u9053\u7a0b\u5e8f\u73af\u5883\u4e0b\uff0c\u7a0b\u5e8f\u662f**\u5e76\u53d1**\u6267\u884c\u7684\uff0c\u6240\u4ee5\u8981\u4f7f\u7a0b\u5e8f\u8fd0\u884c\uff0c\u5fc5\u987b\u5148\u4e3a\u4e4b\u521b\u5efa**\u8fdb\u7a0b**\uff0c\u800c\u521b\u5efa\u8fdb\u7a0b\u7684\u7b2c\u4e00\u4ef6\u4e8b\u5c31\u662f\u5c06**\u7a0b\u5e8f**\u548c**\u6570\u636e**\u88c5\u5165\u5185\u5b58","title":"\u539f\u7531\uff1a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#_2","text":"","title":"\u76ee\u7684\uff1a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#_3","text":"\u5373 \u4e0b\u9762\u5f00\u59cb\u5c06\u7a0b\u5e8f\u201c\u94fe\u63a5\u201d\u548c\u201c\u88c5\u5165\u201d\u7684\u5177\u4f53\u60c5\u51b5\uff1a","title":"\u7528\u6237\u7a0b\u5e8f\u5230\u5185\u5b58\u53ef\u6267\u884c\u7a0b\u5e8f\u7684\u6b65\u9aa4\uff1a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#_4","text":"\u6e90\u7a0b\u5e8f\u7ecf\u8fc7\u7f16\u8bd1\u540e\uff0c\u5f97\u5230**\u4e00\u7ec4**\u76ee\u6807\u6a21\u5757\uff0c\u518d\u5229\u7528\u201c\u94fe\u63a5\u7a0b\u5e8f\u201d\u5c06\u8fd9\u7ec4\u76ee\u6807\u6a21\u5757\u94fe\u63a5\u8d77\u6765\uff0c\u5f62\u6210**\u4e00\u4e2a**\u5b8c\u6574\u7684\u88c5\u5165\u6a21\u5757\uff08\u5373**\u53ef\u6267\u884c\u6587\u4ef6**\uff09 \u5982\u4e0b\u56fe\uff1a\u6e90\u7a0b\u5e8f\u7f16\u8bd1\u540e\u5f97\u5230\u4e09\u4e2a\u76ee\u6807\u6a21\u5757A\u3001B\u3001C\uff0c\u957f\u5ea6\u5206\u522b\u4e3aL\u3001M\u3001N\uff0c\u94fe\u63a5\u540e\u5f62\u6210\u53f3\u4fa7\u7684\u88c5\u5165\u6a21\u5757\uff1a \u94fe\u63a5\u65f6\u9700\u8981\u505a\u4e24\u4e2a\u5de5\u4f5c\uff1a \u00d8 \u76f8\u5bf9\u5730\u5740\u8fdb\u884c\u4fee\u6539 \uff08\u53d8\u5316\u4ee5\u540e\u8fd8\u662f**\u76f8\u5bf9**\u5730\u5740\uff09\uff0c\u5730\u5740\u90fd\u53d8\u4e3a\u76f8\u5bf9\u6700\u4e0a\u5c42\u6a21\u5757\u7684\u8d77\u59cb\u5730\u5740\u6765\u8ba1\u7b97\u3002 \u00d8 \u53d8\u5316\u5916\u90e8\u8c03\u7528\u7b26\u53f7 \uff0c\u5982CALL B------> JSR\u201cL\u201d CALL B\u4e3a\u8c03\u7528B\u6a21\u5757\uff0cJSR\u201cL\u201d\u4e3a\u8df3\u8f6c\u5230\uff2c\u884c \u94fe\u63a5\u524dA\u548cB\u4e3a\u4e24\u4e2a\u4e0d\u540c\u7684\u6a21\u5757\uff0c\u5728A\u6a21\u5757\u4e2d\u60f3\u6267\u884c\uff22\u6a21\u5757\uff0c\u8981\u4f7f\u7528\u8c03\u7528\uff08CALL\uff09\u8bed\u53e5\uff1b\u94fe\u63a5\u540eA\u548cB\u4e3a\u540c\u4e00\u6a21\u5757\uff0c\u82e5\u60f3\u8fbe\u5230\u540c\u6837\u5730\u6548\u679c\uff0c\u53ea\u9700\u5728\u672c\u6a21\u5757\u4e2d\u4f7f\u7528\u8df3\u8f6c\u8bed\u53e5\uff08JSR\uff09\u8df3\u8f6c\u5230\u60f3\u6267\u884c\u7684\u5730\u65b9\u5373\u53ef\u3002 \u94fe\u63a5\u5206\u4e3a\u9759\u6001\u94fe\u63a5\u548c\u52a8\u6001\u94fe\u63a5\u3002\u76f8\u5e94\u7684\u91cd\u5b9a\u4f4d\u5373\u4e3a\u9759\u6001\u91cd\u5b9a\u4f4d\u548c\u52a8\u6001\u91cd\u5b9a\u4f4d\u3002","title":"\u7a0b\u5e8f\u7684\u94fe\u63a5\uff1a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#_5","text":"\u5373\u5c06\u94fe\u63a5\u597d\u7684\u6a21\u5757\u88c5\u5165\u5185\u5b58","title":"\u7a0b\u5e8f\u7684\u88c5\u5165\uff1a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#_6","text":"\u200b \u7528\u6237\u7a0b\u5e8f\u7f16\u8bd1\u4e3a\u76ee\u6807\u6a21\u5757\u540e\uff0c\u4f1a\u5bf9\u6bcf\u4e2a\u6a21\u5757\u5185\u90e8\uff08\u7a0b\u5e8f\u6570\u636e\u7b49\uff09\u8fdb\u884c\u7f16\u5740\uff0c\u6b64\u65f6\u7f16\u597d\u7684\u5730\u5740\u53eb\u505a**\u903b\u8f91\u5730\u5740\u6216\u76f8\u5bf9\u5730\u5740**\uff08\u4e0b\u9762\u7684**\u7edd\u5bf9\u88c5\u5165\u65b9\u5f0f**\u9664\u5916\uff09\uff0c\u90fd\u662f\u76f8\u5bf9\u4e8e**\u672c\u6a21\u5757\u7684**\u8d77\u59cb\u5730\u5740\uff08\u4e00\u822c\u4ece0\u5f00\u59cb\uff09\u8ba1\u7b97\u7684\u3002\u8fdb\u884c\u94fe\u63a5\u540e\u67d0\u4e9b\u6a21\u5757\u7684\u76f8\u5bf9\u5730\u5740\u4f1a\u53d1\u751f\u53d8\u5316\uff0c\u5730\u5740\u90fd\u53d8\u4e3a**\u76f8\u5bf9\u4e8e\u88c5\u5165\u6a21\u5757**\u7684\u8d77\u59cb\u5730\u5740\u8fdb\u884c\u8ba1\u7b97\uff08\u663e\u7136\u6b64\u65f6\u8fd8\u662f\u76f8\u5bf9\u5730\u5740\uff09\u3002 \u3000 \u200b \u901a\u5e38\u5c06\u5185\u5b58\u7684\u5b9e\u9645\u5730\u5740\u79f0\u4e3a**\u7269\u7406\u5730\u5740** **","title":"\u903b\u8f91\u5730\u5740\u4e0e\u7269\u7406\u5730\u5740"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#_7","text":"\u00d8 \u7edd\u5bf9\u88c5\u5165\u65b9\u5f0f \u00d8 \u53ef\u91cd\u5b9a\u4f4d\u88c5\u5165\u65b9\u5f0f\uff08\u9759\u6001\u91cd\u5b9a\u4f4d\uff09 \u00d8 \u52a8\u6001\u8fd0\u884c\u65f6\u88c5\u5165\u65b9\u5f0f\uff08\u52a8\u6001\u91cd\u5b9a\u4f4d\uff09","title":"\u5206\u7c7b"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#_8","text":"","title":"\u89e3\u6790"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#1","text":"\u7a0b\u5e8f\u7f16\u8bd1\u65f6\uff0c\u5982\u679c\u77e5\u9053\u7a0b\u5e8f\u5c06\u9a7b\u7559\u5728\u5185\u5b58\u7684\u4ec0\u4e48\u4f4d\u7f6e\uff08\u8d77\u59cb\u5730\u5740\uff09\uff0c\u90a3\u4e48\u7f16\u8bd1\u751f\u6210\u7684\u76ee\u6807\u4ee3\u7801\uff0c\u5c06\u91c7\u7528**\u7edd\u5730\u5730\u5740\u8fdb\u884c\u7f16\u5740\uff0c \u5373\u8d77\u59cb\u5730\u5740**\u4e0d\u4ece0\u5f00\u59cb \uff0c\u4ece\u4e0a\u9762\u6240\u77e5\u7684\u5185\u5b58\u8d77\u59cb\u5730\u5740\u5f00\u59cb\u7f16\u5740\u3002 \u4f8b\u5982\uff1a\u4e8b\u5148\u5df2\u77e5\u7528\u6237\u7a0b\u5e8f(\u8fdb\u7a0b)\u9a7b\u7559\u5728\u4ece1000\u53f7\u5355\u5143\u5904\u5f00\u59cb\u7684\u4f4d\u7f6e\uff0c\u5219\u7f16\u8bd1\u7a0b\u5e8f\u6240\u4ea7\u751f\u7684\u76ee\u6807\u6a21\u5757(\u5373\u88c5\u5165\u6a21\u5757)\u4fbf\u4ece1000\u5904\u5f00\u59cb\u5411\u4e0a\u6269\u5c55\uff1a \u7531\u4e8e\u91c7\u7528\u7684\u662f\u7edd\u5bf9\u5730\u5740\uff0c\u6240\u4ee5\u5c06\u88c5\u5165\u6a21\u5757\u76f4\u63a5\u88c5\u5165\u5185\u5b58\u5373\u53ef\uff0c\u65e0\u9700\u8fdb\u884c\u5730\u5740\u53d8\u6362\u3002","title":"\uff081\uff09\u7edd\u5bf9\u88c5\u5165\u65b9\u5f0f"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#2","text":"\u00d8 \u51fa\u73b0\uff1a \u7f16\u8bd1\u65f6\u5c06\u7a0b\u5e8f\u88c5\u5165\u6307\u5b9a\u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u5fc5\u987b\u9700\u8981\u7a0b\u5e8f\u5458\u719f\u6089\u5185\u5b58\u7684\u4f7f\u7528\u60c5\u51b5 \u7edd\u5bf9\u88c5\u5165\u65b9\u5f0f\u53ea\u80fd\u5c06\u76ee\u6807\u6a21\u5757\u88c5\u5165\u5230\u5185\u5b58\u4e2d\u4e8b\u5148\u6307\u5b9a\u7684\u4f4d\u7f6e\u3002\u800c\u5728\u591a\u9053\u7a0b\u5e8f\u73af\u5883\u4e0b\uff0c\u7f16\u8bd1\u7a0b\u5e8f\u4e0d\u53ef\u80fd\u9884\u77e5\u6240\u7f16\u8bd1\u7684\u76ee\u6807\u6a21\u5757\u5e94\u653e\u5728\u5185\u5b58\u7684\u4f55\u5904 \u53ef\u91cd\u5b9a\u4f4d\u65b9\u5f0f\u53ef\u6839\u636e\u5185\u5b58\u7684\u5f53\u524d\u60c5\u51b5\uff0c\u5c06\u88c5\u5165\u6a21\u5757\u88c5\u5165\u5230\u5185\u5b58\u7684**\u9002\u5f53\u4f4d\u7f6e** \u00d8 \u539f\u7406\uff1a \u6e90\u7a0b\u5e8f\u7f16\u8bd1\u751f\u6210\u7684\u76ee\u6807\u6a21\u5757\u90fd\u91c7\u7528**\u76f8\u5bf9\u5730\u5740**\u8fdb\u884c\u7f16\u5740\uff0c\u5373\u6bcf\u4e2a\u6a21\u5757\u90fd\u4ece0\u5f00\u59cb\u7f16\u5740\uff0c\u5f53\u7136\u94fe\u63a5\u540e\u7684\u6a21\u5757\u4e5f\u91c7\u7528\u76f8\u5bf9\u5730\u5740\u7f16\u5740 \u5c06\u88c5\u5165\u6a21\u5757\u88c5\u5165\u5185\u5b58\u540e\uff0c\u6a21\u5757\u4e2d\u7684\u7a0b\u5e8f\u548c\u6570\u636e\u7b49\uff0c\u5728\u5185\u5b58\u4e2d\u90fd\u5c06\u5177\u6709\u4e00\u4e2a\u7269\u7406\u5730\u5740\uff0c\u6b64\u7269\u7406\u5730\u5740\u662f\u76f8\u5bf9\u4e8e\u5185\u5b58\u7684\u8d77\u59cb\u5730\u5740\u8fdb\u884c\u7f16\u5740\u7684\uff0c\u6240\u4ee5\u4e0e\u539f\u5148\u6a21\u5757\u4e2d\u7684\u903b\u8f91\u5730\u5740\uff08\u76f8\u5bf9\u4e8e\u6a21\u5757\u7684\u8d77\u59cb\u5730\u5740\u8fdb\u884c\u7f16\u5740\uff09\u4e0d\u540c\uff0c\u6240\u4ee5\u4e3a\u4e86\u5f97\u5230\u7269\u7406\u5730\u5740\u9700\u8981\u5bf9\u903b\u8f91\u5730\u5740\u8fdb\u884c\u6539\u53d8\u3002\u800c\u6b64\u5730\u5740\u53d8\u5316\u7684\u8fc7\u7a0b\u5c31\u53eb\u505a**\u91cd\u5b9a\u4f4d**\uff0c\u53c8\u56e0\u4e3a\u5730\u5740\u53d8\u6362\u901a\u5e38\u662f\u5728\u88c5\u5165\u65f6\u4e00\u6b21\u5b8c\u6210\u7684\uff0c\u4ee5\u540e\u4e0d\u518d\u6539\u53d8\uff0c\u6545\u79f0\u4e3a**\u9759\u6001\u91cd\u5b9a\u4f4d\u3002**\u5982\u4e0b\u56fe\uff1a","title":"\uff082\uff09\u53ef\u91cd\u5b9a\u4f4d\u88c5\u5165\u65b9\u5f0f\uff08\u9759\u6001\u91cd\u5b9a\u4f4d\uff09"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#3","text":"\u53ea\u662f\u628a**\u76f8\u5bf9\u5730\u5740\u5230\u7edd\u5bf9\u5730\u5740\u7684\u8f6c\u6362**\u63a8\u8fdf\u5230\u7a0b\u5e8f\u771f\u6b63\u6267\u884c\u65f6\u624d\u8fdb\u884c","title":"\uff083\uff09\u52a8\u6001\u8fd0\u884c\u65f6\u88c5\u5165\u65b9\u5f0f\uff08\u52a8\u6001\u91cd\u5b9a\u4f4d\uff09"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#_9","text":"","title":"\u603b\u7ed3\uff1a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E5%85%A5/#qa","text":"","title":"Q&amp;A"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/","text":"\u6700\u8fd1\u4e00\u6bb5\u65f6\u95f4\u505a\u4e86\u5173\u4e8e\u4e00\u4e9b\u8f6f\u4ef6\u7684\u4ea4\u53c9\u7f16\u8bd1\u5de5\u4f5c\uff0c\u7531\u4e8e\u89c9\u5f97\u5e76\u6ca1\u6709\u5b66\u5230\u8bb8\u591a\u4e1c\u897f\uff0c\u6240\u4ee5\u62bd\u65f6\u95f4\u770b\u4e86\u5173\u4e8e\u9759\u6001\u94fe\u63a5\u65b9\u9762\u7684\u5185\u5bb9\uff0c\u8bfb\u4e86\u4e00\u90e8\u5206\u300a\u7a0b\u5e8f\u5458\u7684\u81ea\u6211\u4fee\u517b\u2014\u2014\u94fe\u63a5\u3001\u88c5\u8f7d\u4e0e\u5e93\u300b\uff0c\u8bb0\u5f55\u4e00\u4e9b\u8bfb\u4e66\u7b14\u8bb0\u53ca\u81ea\u5df1\u7684\u603b\u7ed3\u3002 \u4e00\u3001GCC\u505a\u4e86\u4ec0\u4e48\uff1f \u6211\u4eec\u5728 Linux \u4e2d\u7ecf\u5e38\u4f7f\u7528 gcc \u6e90\u6587\u4ef6\u540d.c -o \u76ee\u6807\u53ef\u6267\u884c\u6587\u4ef6\u540d \u5bf9\u4e00\u4e2a\u7f16\u5199\u597d\u7684C\u6587\u4ef6\u8fdb\u884c\u7f16\u8bd1\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u90a3\u4e48\u8fd9\u4e4b\u95f4\u7684\u7ec6\u8282\u5462\uff1f \u8fd9\u91cc\u6e90\u6587\u4ef6\u540d\u4e3a hello.c \uff0c\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\u540d\u4e3a hello \u4e3a\u4f8b\u5b50 gcc\u4e00\u4e2aC\u6e90\u6587\u4ef6\u65f6\u5bf9\u8fc7\u7a0b\u8fdb\u884c\u4e86\u9690\u85cf\uff0c\u5b9e\u9645\u4e3a\uff1a\u9884\u7f16\u8bd1 cpp\u3001\u7f16\u8bd1 cc1\u3001\u6c47\u7f16 as\u3001\u94fe\u63a5 ld\uff0c\u5176\u4e2d\u6bcf\u4e00\u6b65\u540e\u7684\u82f1\u6587\u540d\u662f\u6240\u4f7f\u7528\u7684\u5de5\u5177\u7684\u540d\u79f0\u3002 \u90a3\u4e48\u5404\u81ea\u7684\u6b65\u9aa4\u5230\u5e95\u5e72\u4e86\u4ec0\u4e48\u5462\uff1f 1\u3001\u9884\u7f16\u8bd1\uff1a\u5904\u7406.c\u6587\u4ef6\u4e2d\u4ee5\u201c#\u201d\u5f00\u5934\u7684\u9884\u7f16\u8bd1\u6307\u4ee4\u3002 \u8fd9\u4e9b**\u9884\u7f16\u8bd1\u6307\u4ee4**\u5305\u62ec\u4e86**\u5b8f\u5b9a\u4e49**\u3001**\u6761\u4ef6\u9884\u7f16\u8bd1\u6307\u4ee4**\u7b49\u7b49\uff0c\u6b64\u6b65\u4e2d\u4e5f\u4f1a\u8fdb\u884c\u5220\u9664\u6389\u6240\u6709\u7684\u6ce8\u91ca\u7b49\u64cd\u4f5c\u3002\u5f53\u65e0\u6cd5\u5224\u65ad\u4e00\u4e2a**\u5b8f\u5b9a\u4e49**\u662f\u5426\u6b63\u786e\u6216\u8005**\u5934\u6587\u4ef6**\u662f\u5426\u6b63\u786e\u5305\u542b\u7684\u8bdd\uff0c\u53ef\u4ee5\u76f4\u63a5\u6253\u5f00\u6b64\u6b65\u751f\u6210\u7684\u6587\u4ef6\u8fdb\u884c\u68c0\u67e5\u3002 gcc -E hello.c -o hello.i 2\u3001\u7f16\u8bd1\uff1a\u8fdb\u884c\u8bcd\u6cd5\u5206\u6790\u3001\u8bed\u6cd5\u5206\u6790\u3001\u8bed\u4e49\u5206\u6790\u7b49\u5de5\u4f5c\uff0c\u6b64\u6b65\u6240\u751f\u6210\u7684\u6587\u4ef6\u662f\u4ee5\u6c47\u7f16\u4ee3\u7801\u6784\u6210\u7684\u3002 \u8fd9\u4e00\u6b65\u662f\u7531\u7f16\u8bd1\u5668cc1\u5b8c\u6210\uff08gcc\u4e2d\uff09\uff0c\u4e3b\u8981\u5206\u4e3a\u8bcd\u6cd5\u5206\u6790\u3001\u8bed\u6cd5\u5206\u6790\u3001\u8bed\u4e49\u5206\u6790\u3001\u4e2d\u95f4\u8bed\u8a00\u751f\u6210\u3001\u76ee\u6807\u4ee3\u7801\u751f\u6210\u4e0e\u4f18\u5316\u51e0\u6b65\u3002 a.\u8bcd\u6cd5\u5206\u6790\uff1a\u5c06\u6240\u6709\u7684 C\u8bed\u8a00 \u6e90\u4ee3\u7801\u5206\u5272\u4e3a\u4e00\u7cfb\u5217\u7684token\u8bb0\u53f7\uff0c\u8fd9\u4e9btoken\u8bb0\u53f7\u4e3b\u8981\u4e3a\u5173\u952e\u5b57\u3001\u6807\u8bc6\u7b26\u3001\u5e38\u91cf\u53ca\u7279\u6b8a\u7b26\u53f7\uff0c\u6bd4\u5982\u8868\u8fbe\u5f0f a+b \u5728\u8fd9\u6b65\u4e2d\u5c31\u4f1a\u88ab\u62c6\u5206\u4e3a a \u548c b \u4e24\u4e2a\u6807\u8bc6\u7b26\u53ca + \u8fd9\u4e2a\u7279\u6b8a\u7b26\u53f7\u3002 b.\u8bed\u6cd5\u5206\u6790\uff1a\u4ea7\u751f**\u8bed\u6cd5\u6811**\uff0c\u5173\u4e8e\u8fd9\u6b65\u9700\u8981\u6709\u4e00\u4e9b\u6570\u7406\u903b\u8f91\u7684\u77e5\u8bc6\uff0c\u5373\u751f\u6210\u4ee5\u8868\u8fbe\u5f0f\u4e3a\u8282\u70b9\u7684\u6811\uff0c\u5bf9\u5e94\u4e0a\u9762 a+b \u7684\u60c5\u51b5\u662f + \u4e3a\u4e00\u4e2a\u8282\u70b9\uff0c\u800c a \u548c b \u5206\u522b\u4e3a\u5de6\u53f3\u5b50\u6811\u7684\u8282\u70b9\u3002 c.\u8bed\u4e49\u5206\u6790\uff1a\u786e\u5b9a\u6bcf\u4e2a\u8282\u70b9\u7684\u7c7b\u578b\uff0c\u6bd4\u5982\u6574\u578b\u3001\u5b57\u7b26\u578b\u7b49\u3002 \u53ef\u4ee5\u7406\u89e3\u4e3a\u5728\u524d\u4e00\u6b65\u7684\u6811\u7684\u57fa\u7840\u4e0a\u5728\u6bcf\u4e2a\u8282\u70b9\u4e0a\u90fd\u6807\u793a\u597d**\u7c7b\u578b**\uff0c\u5bf9\u4e8e\u4e00\u4e9b\u9690\u5f0f\u8f6c\u6362\u53ca\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\u90fd\u4f1a\u5728\u8fd9\u6b65\u4e2d\u8fdb\u884c\u5904\u7406\u3002 d.\u4e2d\u95f4\u8bed\u8a00\u751f\u6210\uff1a\u8fdb\u884c\u4e24\u6b65\u64cd\u4f5c\uff0c\u9996\u5148\u5c06**\u8bed\u6cd5\u6811**\u8f6c\u5316\u4e3a**\u4e2d\u95f4\u4ee3\u7801**\uff0c\u7136\u540e\u5728**\u4e2d\u95f4\u4ee3\u7801**\u4e2d\u5bf9\u5df2\u7ecf\u80fd\u591f\u786e\u5b9a\u503c\u7684\u8868\u8fbe\u5f0f\u8fdb\u884c\u6c42\u503c\u3002 \u5176\u4e2d\u4e2d\u95f4\u4ee3\u7801\u4e00\u822c\u4e3a\u4e09\u5730\u5740\u7801\uff0c\u5373 x = y op z \u7684\u5f62\u5f0f\uff0c\u5176\u4e2dop\u4ee3\u8868\u7279\u6b8a\u7b26\u53f7\uff0c\u7136\u540e\u5982\u679c\u6709\u4e9b\u8868\u8fbe\u5f0f\u80fd\u591f\u786e\u5b9a\u5176\u503c\uff0c\u6bd4\u5982 t1=5+6 \u8fd9\u79cd\u4e24\u4e2a\u5e38\u91cf\u76f8\u52a0\u7684\u8bed\u53e5\u5c31\u76f4\u63a5\u8fdb\u884c\u8ba1\u7b97\u3002 e.\u76ee\u6807\u4ee3\u7801\u751f\u6210\u4e0e\u4f18\u5316\uff1a\u5982\u5b57\u9762\u610f\u601d\uff0c\u8fdb\u884c\u76ee\u6807\u4ee3\u7801\u7684\u751f\u6210\u4e0e\u4f18\u5316\u3002 \u5173\u4e8e\u76ee\u6807\u4ee3\u7801\u7684\u751f\u6210\u4e0e\u5177\u4f53\u7684\u786c\u4ef6\u5e73\u53f0\u6709\u5173\uff0c\u800c\u4f18\u5316\u90e8\u5206\u6709\u90e8\u5206\u64cd\u4f5c\uff0c\u6bd4\u5982\u5408\u9002\u7684\u5bfb\u5740\u65b9\u5f0f\u3001\u5bf9\u4e8e\u4e58\u6cd5\u8fd0\u7b97\u4f7f\u7528\u4f4d\u79fb\u8fdb\u884c\u4ee3\u66ff\uff0c\u8fd9\u4e9b\u5982\u679c\u6709\u63a5\u89e6\u6c47\u7f16\u4ee3\u7801\u4f1a\u6bd4\u8f83\u4e86\u89e3\u3002 \u7f16\u8bd1\u5668\u6d41\u7a0b\u56fe\uff1a \u6b64\u6b65\u4e2d\u751f\u6210\u7684\u6587\u4ef6\u5982\u679c\u61c2\u5f97\u6c47\u7f16\u4ee3\u7801\u7684\u8bdd\u4ecd\u7136\u662f\u53ef\u8bfb\u7684 gcc -S hello.c -o hello.s 3\u3001\u6c47\u7f16\uff1a\u5c06\u6c47\u7f16\u4ee3\u7801\u8f6c\u53d8\u6210\u673a\u5668\u53ef\u4ee5\u6267\u884c\u7684\u6307\u4ee4\u3002 \u6b64\u6b65\u4e2d\u662f\u6839\u636e**\u6c47\u7f16\u6307\u4ee4**\u4e0e**\u673a\u5668\u6307\u4ee4**\u7684**\u5bf9\u7167\u8868**\u8fdb\u884c\u4e00\u4e00\u7ffb\u8bd1\uff0c\u57fa\u672c\u4e0a\u4e00\u4e2a\u6c47\u7f16\u8bed\u53e5\u5bf9\u5e94\u4e00\u6761\u673a\u5668\u6307\u4ee4\u3002 \u6b64\u6b65\u751f\u6210\u7684\u6587\u4ef6\u5df2\u7ecf\u6ca1\u6cd5\u8bfb\u4e86\uff0c\u6253\u5f00\u540e\u5168\u90e8\u662f\u4e71\u7801\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5168\u90e8\u673a\u5236\u6307\u4ee4\u4e86\u3002 gcc -c hello.s -o hello.o \u6216 gcc -c hello.c -o hello.o \u6216 as hello.s -o hello.o 4\u3001\u94fe\u63a5\uff1a\u5c06\u51e0\u4e2a\u8f93\u5165\u7684\u76ee\u6807\u6587\u4ef6\u52a0\u5de5\u540e\u5408\u5e76\u4e3a\u4e00\u4e2a\u8f93\u51fa\u6587\u4ef6\u3002 \u7b80\u5355\u6765\u8bf4\uff0c\u53ef\u4ee5\u770b\u4f5c\u62fc**\u62fc\u56fe**\u7684\u8fc7\u7a0b\uff0c\u6bcf\u4e2a.o\u6587\u4ef6\u90fd\u662f\u4e00\u5757\u62fc\u56fe\u788e\u7247\uff0c\u94fe\u63a5\u5c31\u662f\u5c06\u5b83\u4eec\u62fc\u63a5\u6210\u4e00\u5e45\u56fe\uff08\u53ef\u6267\u884c\u6587\u4ef6\uff09\u7684\u8fc7\u7a0b\u3002 linux \u4e2d\u53ef\u6267\u884c\u6587\u4ef6\u90fd\u79f0\u4e3aELF\u6587\u4ef6\uff0cWindows\u4e2d\u4e3aPE\u6587\u4ef6\uff0c\u4e4b\u540e\u90fd\u4f1a\u8fd9\u6837\u79f0\u547c \u603b\u7ed3\uff1a \u7ecf\u8fc7\u4e0a\u9762\u7684\u51e0\u6b65\u6211\u4eec\u5927\u81f4\u4e86\u89e3\u4e86\u7f16\u8bd1\u7684\u8fc7\u7a0b\uff0c\u5c24\u5176\u662fgcc\u7684\u7f16\u8bd1\u5668cc1\u5bf9\u6e90\u6587\u4ef6\u7684\u64cd\u4f5c\u6b65\u9aa4\u3002 \u4e0b\u9762\u662f\u572832\u4f4d\u7684Ubuntu\u4e2d\u5bf9 hello.c \u6587\u4ef6\u8fdb\u884c\u52a8\u6001\u7f16\u8bd1\u663e\u793a\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u9759\u6001\u7f16\u8bd1\u4e0e\u4e4b\u7c7b\u4f3c\uff1a gcc --verbose -fno-builtin hello.c //--verbose \u8868\u793a\u663e\u793a\u7f16\u8bd1\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c-fno-builtin\u8868\u793a\u5173\u95ed\u5185\u7f6e\u51fd\u6570\u4f18\u5316\u9009\u9879\uff0c\u56e0\u4e3ahello.c\u6587\u4ef6\u4e2d\u7528printf\u53ea\u5bf9\u4e00\u4e2a\u5b57\u7b26\u4e32\u8fdb\u884c\u8f93\u51fa\uff0c\u6b64\u65f6GCC\u4f1a\u5c06\u5176\u81ea\u52a8\u66ff\u6362\u4e3aputs\u51fd\u6570\u3002 Using built-in specs. COLLECT_GCC=gcc COLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/4.8/lto-wrapper Target: i686-linux-gnu Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.4-2ubuntu1~14.04.1' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-i386/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-i386 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-i386 --with-arch-directory=i386 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-targets=all --enable-multiarch --disable-werror --with-arch-32=i686 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=i686-linux-gnu --host=i686-linux-gnu --target=i686-linux-gnu Thread model: posix gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.1) COLLECT_GCC_OPTIONS='-v' '-fno-builtin' '-mtune=generic' '-march=i686' /usr/lib/gcc/i686-linux-gnu/4.8/cc1 -quiet -v -imultiarch i386-linux-gnu hello.c -quiet -dumpbase hello.c -mtune=generic -march=i686 -auxbase hello -version -fno-builtin -fstack-protector -Wformat -Wformat-security -o /tmp/ccM5JRqF.s GNU C (Ubuntu 4.8.4-2ubuntu1~14.04.1) version 4.8.4 (i686-linux-gnu) compiled by GNU C version 4.8.4, GMP version 5.1.3, MPFR version 3.1.2-p3, MPC version 1.0.1 GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072 ignoring nonexistent directory \"/usr/local/include/i386-linux-gnu\" ignoring nonexistent directory \"/usr/lib/gcc/i686-linux-gnu/4.8/../../../../i686-linux-gnu/include\" #include \"...\" search starts here: #include <...> search starts here: /usr/lib/gcc/i686-linux-gnu/4.8/include /usr/local/include /usr/lib/gcc/i686-linux-gnu/4.8/include-fixed /usr/include/i386-linux-gnu /usr/include End of search list. GNU C (Ubuntu 4.8.4-2ubuntu1~14.04.1) version 4.8.4 (i686-linux-gnu) compiled by GNU C version 4.8.4, GMP version 5.1.3, MPFR version 3.1.2-p3, MPC version 1.0.1 GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072 Compiler executable checksum: aaaa08c6fefb26a9d107c18441ada1ef COLLECT_GCC_OPTIONS='-v' '-fno-builtin' '-mtune=generic' '-march=i686' as -v --32 -o /tmp/ccs3h630.o /tmp/ccM5JRqF.s GNU\u6c47\u7f16\u7248\u672c 2.24 (i686-linux-gnu) \u4f7f\u7528BFD\u7248\u672c (GNU Binutils for Ubuntu) 2.24 COMPILER_PATH=/usr/lib/gcc/i686-linux-gnu/4.8/:/usr/lib/gcc/i686-linux-gnu/4.8/:/usr/lib/gcc/i686-linux-gnu/:/usr/lib/gcc/i686-linux-gnu/4.8/:/usr/lib/gcc/i686-linux-gnu/ LIBRARY_PATH=/usr/lib/gcc/i686-linux-gnu/4.8/:/usr/lib/gcc/i686-linux-gnu/4.8/../../../i386-linux-gnu/:/usr/lib/gcc/i686-linux-gnu/4.8/../../../../lib/:/lib/i386-linux-gnu/:/lib/../lib/:/usr/lib/i386-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/i686-linux-gnu/4.8/../../../:/lib/:/usr/lib/ COLLECT_GCC_OPTIONS='-v' '-fno-builtin' '-mtune=generic' '-march=i686' /usr/lib/gcc/i686-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_i386 --hash-style=gnu --as-needed -dynamic-linker /lib/ld-linux.so.2 -z relro /usr/lib/gcc/i686-linux-gnu/4.8/../../../i386-linux-gnu/crt1.o /usr/lib/gcc/i686-linux-gnu/4.8/../../../i386-linux-gnu/crti.o /usr/lib/gcc/i686-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/i686-linux-gnu/4.8 -L/usr/lib/gcc/i686-linux-gnu/4.8/../../../i386-linux-gnu -L/usr/lib/gcc/i686-linux-gnu/4.8/../../../../lib -L/lib/i386-linux-gnu -L/lib/../lib -L/usr/lib/i386-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/i686-linux-gnu/4.8/../../.. /tmp/ccs3h630.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/i686-linux-gnu/4.8/crtend.o /usr/lib/gcc/i686-linux-gnu/4.8/../../../i386-linux-gnu/crtn.o \u5176\u4e2d\u6700\u91cd\u8981\u7684\u4e09\u53e5\u5df2\u7ecf\u7528\u7ea2\u5b57\u8868\u793a\u4e86\u51fa\u6765\uff0c\u53ef\u4ee5\u770b\u5230\u4e00\u4e2a\u6700\u7b80\u5355\u7684helloworld\u7a0b\u5e8f\u90fd\u9700\u8981\u94fe\u63a5\u8bb8\u591a.o\u76ee\u6807\u6587\u4ef6\u624d\u80fd\u591f\u5f97\u5230ELF\u6587\u4ef6\u3002 \u4ece\u4e0a\u770b\u51fa\uff0cgcc\u5b9e\u9645\u4e0a\u662f\u5bf9**cpp\u3001cc1\u3001as\u3001ld**\u51e0\u4e2a\u540e\u53f0\u7a0b\u5e8f\u7684\u5305\u88c5\uff0c\u6267\u884c\u5b83\u65f6\u4f1a\u6839\u636e\u5177\u4f53\u7684\u53c2\u6570\u8981\u6c42\u53bb\u8c03\u7528\u8fd9\u51e0\u4e2a\u540e\u53f0\u7a0b\u5e8f\uff0c\u4ece\u800c\u5f97\u5230\u6211\u4eec\u6240\u9700\u8981\u7f16\u8bd1\u51fa\u7684ELF\u6587\u4ef6\u3002 \u4e8c\u3001\u9759\u6001\u94fe\u63a5 \u521a\u521a\u5c06gcc\u7684\u51e0\u4e2a\u6b65\u9aa4\u62c6\u5f00\u4e86\u4e86\u89e3\u5404\u6b65\u9aa4\u4f5c\u7528\uff0c\u5177\u4f53\u5206\u6790\u4e86\u5176\u4e2dcc1\u7f16\u8bd1\u7684\u90e8\u5206\uff0c\u5173\u4e8e\u9884\u7f16\u8bd1\u4e0e\u6c47\u7f16\u7684\u90e8\u5206\u4e0d\u7ec6\u7a76\uff0c\u63a5\u4e0b\u6765\u5c31\u5269\u94fe\u63a5ld\u4e86\u3002 \u4ece\u521a\u521a\u7684gcc\u8be6\u7ec6\u4fe1\u606f\u53ef\u4ee5\u770b\u51fa\uff0c\u5b9e\u9645\u8fc7\u7a0b\u4e2d\u94fe\u63a5\u7684.o\u6587\u4ef6\u6709\u5f88\u591a\uff0c\u90a3\u4e48\u4e3a\u4ec0\u4e48\u4f1a\u8fd9\u4e48\u591a\uff0c\u5b83\u4eec\u5728\u54ea\u5462\uff1f \u63a5\u7740\u521a\u521agcc\u4e2d\u7b2c\u56db\u4e2a\u90e8\u5206\u94fe\u63a5\u7684\u90e8\u5206\u8bf4\u4e0b\u53bb\uff0c\u8fd9\u91cc\u5f00\u59cb\u5206\u4e3a\u4e86\u4e24\u4e2a\u5206\u652f\uff1a \u52a8\u6001\u94fe\u63a5**\u4e0e**\u9759\u6001\u94fe\u63a5 \uff0c \u9759\u6001\u94fe\u63a5**\u4e00\u822c\u7528\u4e8e**\u4ea4\u53c9\u7f16\u8bd1**\u7b49\u60c5\u51b5\uff0c\u800c\u52a8\u6001\u94fe\u63a5\u5219\u8f83\u4e3a\u5e38\u7528\uff0c\u5f53\u6211\u4eec\u9700\u8981\u9759\u6001\u94fe\u63a5\u65f6\u9700\u8981\u6307\u5b9a -static \u53c2\u6570\uff0c\u5426\u5219\u90fd\u9ed8\u8ba4\u4e3a**\u52a8\u6001\u94fe\u63a5 \u3002 **\u52a8\u6001\u94fe\u63a5**\u4e0e**\u9759\u6001\u94fe\u63a5**\u6709\u4ec0\u4e48\u4e0d\u540c\uff1f \u52a8\u6001\u7f16\u8bd1\u7684\u6587\u4ef6\u9700\u8981\u9644\u5e26\u4e00\u4e2a**\u52a8\u6001\u94fe\u63a5\u5e93**\uff0c\u5728\u6587\u4ef6\u6267\u884c\u65f6\u9700\u8981\u8c03\u7528**\u52a8\u6001\u94fe\u63a5\u5e93**\u4e2d\u7684\u4e00\u4e9b\u547d\u4ee4\uff0c\u6240\u4ee5\u6ca1\u6709\u8fd9\u4e2a\u5e93\u5c31\u6ca1\u529e\u6cd5\u8fd0\u884c\u3002\u4f18\u70b9\uff1a\u65e2\u7f29\u5c0f\u4e86\u6267\u884c\u6587\u4ef6\u672c\u8eab\u7684\u4f53\u79ef\uff0c\u53c8\u52a0\u5feb\u4e86\u7f16\u8bd1\u7684\u901f\u5ea6\uff1b\u7f3a\u70b9\uff1a\u9996\u5148\u5373\u4fbf\u7a0b\u5e8f\u53ea\u7528\u5230\u4e86\u94fe\u63a5\u5e93\u5f88\u5c11\u7684\u547d\u4ee4\u4e5f\u9700\u8981\u643a\u5e26\u4e00\u4e2a\u5e9e\u5927\u7684\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5426\u5219\u7a0b\u5e8f\u65e0\u6cd5\u6267\u884c\uff0c\u800c\u4e14\u5f53\u5176\u4ed6\u8bbe\u5907\u4e0a\u6ca1\u6709\u6b64\u94fe\u63a5\u5e93\u65f6\u5c31\u65e0\u6cd5\u8fd0\u884c\u3002 \u9759\u6001\u7f16\u8bd1**\u4f1a\u5728\u7f16\u8bd1\u6587\u4ef6\u65f6\u5c06\u6587\u4ef6\u6240\u9700\u8981\u8c03\u7528\u7684\u5bf9\u5e94**\u94fe\u63a5\u5e93**\u4e2d\u7684\u90e8\u5206\u63d0\u53d6\u51fa\u6765\uff0c\u94fe\u63a5\u5230**\u53ef\u6267\u884c\u6587\u4ef6**\u4e2d\u53bb\uff0c\u4f7f\u7a0b\u5e8f\u5728\u6267\u884c\u65f6\u4e0d\u4f9d\u8d56**\u94fe\u63a5\u5e93 \u3002 \u53ef\u4ee5\u770b\u51fa\u52a8\u6001\u7f16\u8bd1\u4e0e\u9759\u6001\u7f16\u8bd1\u7684\u4f18\u70b9\u4e0e\u7f3a\u70b9\u57fa\u672c\u662f\u4e92\u8865\u7684\uff0c\u53ef\u79fb\u690d\u6027\u548c\u7f16\u8bd1\u901f\u5ea6\u4e24\u8005\u5bf9\u7acb\u3002 \u8fd9\u91cc\u6211\u4eec\u53ea\u8ba8\u8bba**\u9759\u6001\u94fe\u63a5**\u3002 \u524d\u9762\u8bf4\u8fc7\u94fe\u63a5\u5668\u8fdb\u884c\u4e0d\u540c\u6a21\u5757\u4e4b\u95f4\u7684\u62fc\u63a5\u5de5\u4f5c\uff0c\u4e3b\u8981\u5305\u62ec\u5730\u5740\u548c\u7a7a\u95f4\u5206\u914d\u3001\u7b26\u53f7\u51b3\u8bae\u53ca\u91cd\u5b9a\u4f4d\u6b65\u9aa4\uff0c\u4e0b\u9762\u6765\u770b\u8fd9\u4e9b\u6b65\u9aa4\u5230\u5e95\u505a\u4e86\u4ec0\u4e48\u3002 1\u3001\u5730\u5740\u4e0e\u7a7a\u95f4\u5206\u914d \u5bf9\u4e8e\u94fe\u63a5\u5668ld\u6765\u8bf4\uff0c\u5176\u9700\u8981\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u628a\u591a\u4e2a\u8f93\u5165\u7684\u76ee\u6807\u6587\u4ef6\uff08.o\u6587\u4ef6\uff09\u5408\u5e76\u4e3a\u4e00\u4e2a\u6587\u4ef6\uff0c\u5373**ELF\u53ef\u6267\u884c\u6587\u4ef6**\u3002 \u90a3\u4e48\u5bf9\u4e8e\u591a\u4e2a\u76ee\u6807\u6587\u4ef6\uff0c\u5982\u4f55\u5408\u5e76\uff1f\u6216\u8005\u8bf4\uff0c\u7a7a\u95f4\u5982\u4f55\u5206\u914d\uff1f \u4e0b\u9762\u63d0\u4f9b\u4e86\u4e24\u79cd\u65b9\u6cd5\uff1a a.\u6309\u5e8f\u53e0\u52a0 \u53ef\u4ee5\u770b\u5230\u56fe\u4e2d\u6709\u7740A\u3001B\u4e24\u4e2a\u76ee\u6807\u6587\u4ef6\uff0c\u5c06\u5b83\u4eec\u7ec4\u5408\u8d77\u6765\u65f6\u6309\u7167\u5404\u81ea\u7684\u4ee3\u7801\u6bb5\u3001\u6570\u636e\u6bb5\u3001bss\u6bb5\u4f9d\u6b21\u53e0\u52a0\uff0c\u4e8e\u662f\u5f62\u6210\u7684ELF\u53ef\u6267\u884c\u6587\u4ef6\u4e2d\u6709\u7740\u591a\u4e2a\u4ee3\u7801\u6bb5\u3001\u6570\u636e\u6bb5\u7b49 \u6b64\u79cd\u65b9\u6cd5\u5f88\u660e\u663e\u662f\u975e\u5e38\u6d6a\u8d39\u7a7a\u95f4\u7684\uff0c\u5728\u8fdb\u884c\u5730\u5740\u4e0e\u7a7a\u95f4\u5206\u914d\u65f6\uff0c\u90fd\u9700\u8981\u4e00\u5b9a\u7684\u5bf9\u9f50\uff0c\u90a3\u4e48\u8fd9\u6837\u5c31\u4f1a\u9020\u6210\u5185\u5b58\u4e2d\u5b58\u5728\u5927\u91cf\u7684\u5185\u90e8\u788e\u7247\uff0c\u56e0\u6b64\u63d0\u51fa\u4e86\u7b2c\u4e8c\u79cd\u65b9\u6848\u3002 b.\u76f8\u4f3c\u6bb5\u5408\u5e76 \u6b64\u79cd\u65b9\u6cd5\u5c06\u591a\u4e2a\u76ee\u6807\u6587\u4ef6\u76f8\u4f3c\u6bb5\u7ec4\u5408\u5728\u4e00\u8d77\uff0c\u5373\u4ee3\u7801\u6bb5\u3001\u6570\u636e\u6bb5\u7b49\u90fd\u5c06\u5b83\u4eec\u5408\u5e76\u7136\u540e\u8fdb\u884c\u5206\u914d\u3002 \u8fd9\u79cd\u65b9\u6cd5\u6bd4**\u6309\u5e8f\u53e0\u52a0**\u7684\u65b9\u6cd5\u8981\u51cf\u5c11\u8bb8\u591a\u6d6a\u8d39\u7684\u7a7a\u95f4\uff0c\u4e14\u4e00\u4e2aELF\u6587\u4ef6\u4e2d\u4ee3\u7801\u6bb5\u3001\u6570\u636e\u6bb5\u7b49\u90fd\u53ea\u6709\u4e00\u4e2a\uff0c\u66f4\u6613\u67e5\u770b\uff0c\u56e0\u6b64\u94fe\u63a5\u5668\u57fa\u672c\u4f7f\u7528\u7b2c\u4e8c\u79cd\u7b56\u7565\u8fdb\u884c\u94fe\u63a5\u3002 \u4f7f\u7528\u6b64\u79cd\u7b56\u7565\u7684\u94fe\u63a5\u5668\u90fd\u91c7\u7528\u4e24\u6b65\u94fe\u63a5\u6cd5\u7684\u65b9\u6cd5\u8fdb\u884c\u94fe\u63a5\uff0c\u7b2c\u4e00\u6b65\u4e3a**\u7a7a\u95f4\u4e0e\u5730\u5740\u5206\u914d**\uff0c\u7b2c\u4e8c\u6b65\u4e3a**\u7b26\u53f7\u89e3\u6790\u4e0e\u91cd\u5b9a\u4f4d**\uff0c\u8fd9\u4e5f\u662f\u4e4b\u524d\u6240\u8bf4\u7684\u94fe\u63a5\u7684\u4e3b\u8981\u6b65\u9aa4\u3002 \u4e0a\u9762\u662f\u4e24\u79cd\u5408\u5e76\u76ee\u6807\u6587\u4ef6\u7684\u7b56\u7565\uff0c\u90a3\u4e48\u73b0\u5728\u6765\u770b\u770b\u5230\u5e95\u4ec0\u4e48\u53eb\u505a**\u5730\u5740\u4e0e\u7a7a\u95f4**\u7684\u5206\u914d\uff1f \u4e8b\u5b9e\u4e0a\u8fd9\u91cc\u7684**\u5730\u5740\u4e0e\u7a7a\u95f4**\u5305\u542b\u4e86\u4e24\u5c42\u610f\u601d\uff0c\u4e00\u4e2a\u662f\u6307**ELF\u6587\u4ef6**\u4e2d\u7684\u7a7a\u95f4\uff0c\u53e6\u4e00\u4e2a\u5c31\u662f\u6307\u6587\u4ef6\u88c5\u8f7d\u540e\u5728**\u865a\u62df\u5730\u5740**\u4e2d\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff0c\u4e24\u8005\u4e4b\u95f4\u6709\u4ec0\u4e48\u533a\u522b\u5462\uff1f\u6211\u7406\u89e3\u662f\u4e00\u4e2a\u662f\u5b58\u653e\u6587\u4ef6\u6240\u9700\u8981\u7684\u7a7a\u95f4\uff0c\u800c\u53e6\u4e00\u4e2a\u662f\u6267\u884c\u65f6\u6240\u9700\u8981\u7684\u7a7a\u95f4\u3002\u770b\u4e0bbss\u6bb5\u4e0e\u4ee3\u7801\u6bb5\u7b49\u6bb5\u7684\u533a\u522b\u5c31\u77e5\u9053\u4e86\uff0c**bss\u6bb5**\u53ea\u6709\u5728\u6267\u884c\u65f6\u624d\u4f1a\u7528\u5230\uff0c\u6240\u4ee5\u5728\u5b9e\u9645\u7684\u76ee\u6807\u6587\u4ef6\u53caELF\u6587\u4ef6\u4e2d\uff0cbss\u6bb5\u662f\u4e0d\u4f1a\u5206\u914d\u7a7a\u95f4\u7684\uff0c\u4f46\u662f\u5728\u88c5\u8f7d\u540e\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2dbss\u6bb5\u5c31\u4f1a\u4e3a\u5176\u5206\u914d\u76f8\u5e94\u7684\u7a7a\u95f4\uff0c\u800c\u4ee3\u7801\u6bb5\u5219\u4e24\u79cd\u7a7a\u95f4\u90fd\u4f1a\u5206\u914d\u3002 \u6211\u4eec\u6765\u770b\u4e0b\u4e24\u4e2a\u76ee\u6807\u6587\u4ef6\u7684\u94fe\u63a5\u8fc7\u7a0b\u4ee5\u53ca\u5176\u4e2d\u7684\u6bb5\u7684\u5730\u5740\u7a7a\u95f4\u5206\u914d\uff1a /*a.c*/ extern int shared ; int main () { int a = 100 ; swap ( & a , & shared ); } /*b.c*/ int shared = 1 ; void swap ( int * a , int * b ) { * a ^= * b ^= * a ^= * b ; } \u6211\u4eec\u4e0d\u9700\u8981\u53bb\u7ec6\u7a76\u4e24\u4e2a\u6587\u4ef6\u5230\u5e95\u5e72\u4e86\u4ec0\u4e48\uff0c\u53ea\u9700\u8981\u77e5\u9053 a.c\u4e2d\u8c03\u7528\u4e86\u5b9a\u4e49\u5728b.c\u4e2d\u7684shared\u53d8\u91cf\u4ee5\u53caswap\u51fd\u6570\uff0c\u63a5\u4e0b\u6765\u5c06\u4e24\u8005\u5206\u522b\u7f16\u8bd1\uff0c\u7136\u540e\u94fe\u63a5 gcc -c a.c b.c //\u7f16\u8bd1\u6210\u76ee\u6807\u6587\u4ef6\uff0c\u4ea7\u751fa.o\u3001b.o ld a.o b.o -e main -o ab //\u94fe\u63a5a.o\u3001b.o\u5f97\u5230\u53ef\u6267\u884c\u6587\u4ef6ab\uff0c\u5176\u4e2d-e\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u7a0b\u5e8f\u5165\u53e3\uff0cld\u7684\u9ed8\u8ba4\u7a0b\u5e8f\u5165\u53e3\u4e3a_start \u4f7f\u7528objdump\u5de5\u5177\u67e5\u770b\u94fe\u63a5\u524d\u540e\u7684\u5730\u5740\u5206\u914d\u60c5\u51b5\uff1a \u8bf4\u660e\u4e00\u4e0b\u53c2\u6570\uff0c VMA**\u4ee3\u8868**\u865a\u62df\u5730\u5740 \uff0cSize\u4ee3\u8868\u5927\u5c0f\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5173\u6ce8\u8fd9\u4e24\u5904\u5373\u53ef\u3002 \u8fd9\u91cc\u4f7f\u7528\u7684\u662f32\u4f4d\u7684Linux\u7cfb\u7edf\uff0c64\u4f4d\u4e0b\u53ef\u80fd\u60c5\u51b5\u6709\u4e9b\u4e0d\u540c\uff0c\u4e0d\u8fc7\u603b\u7684\u9053\u7406\u662f\u4e00\u6837\u7684\u3002 a.o\uff1a \u5176\u4e2d\u4ee3\u7801\u6bb5\u5927\u5c0f\u4e3a0x27\u5b57\u8282\uff0c\u6570\u636e\u6bb5\u5927\u5c0f\u4e3a0\u5b57\u8282\uff0cbss\u6bb5\u4e5f\u4e3a0\u3002 VMA\u4e3a0\u662f\u56e0\u4e3a\u5176\u662f\u76ee\u6807\u6587\u4ef6\uff0c\u865a\u62df\u7a7a\u95f4\u8fd8\u6ca1\u6709\u88ab\u5206\u914d\uff0c\u9ed8\u8ba4\u4e3a0\u3002 b.o\uff1a \u5176\u4e2d\u4ee3\u7801\u6bb5\u5927\u5c0f\u4e3a0x3a\u5b57\u8282\uff0c\u6570\u636e\u6bb5\u5927\u5c0f\u4e3a0x04\u5b57\u8282\uff0c\u6570\u636e\u6bb5\u5927\u5c0f\u4e3a0x04\u5b57\u8282\uff0cbss\u6bb5\u4e3a0\u5b57\u8282\u3002 \u6700\u540e\u6765\u770b\u94fe\u63a5\u540e\u7684ELF\u6587\u4ef6ab\uff1a \u53ef\u4ee5\u770b\u5230\uff0c\u4ee3\u7801\u6bb5\u7684\u5927\u5c0f\u4e3a0x61\u5b57\u8282\uff0c\u6570\u636e\u6bb5\u4e3a0x04\u5b57\u8282\uff0c\u662fa.o\u4e0eb.o\u4e24\u4e2a\u76ee\u6807\u6587\u4ef6\u7684\u4ee3\u7801\u6bb5\u4e0e\u6570\u636e\u6bb5\u4e4b\u548c\u3002 \u5728\u6b64\u6587\u4ef6\u4e2d\u4e5f\u53ef\u4ee5\u770b\u5230**VMA**\u6709\u4e86\u5b9e\u9645\u7684\u503c\uff0c0x08048094\u662f\u5176\u5728\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u7684**\u8d77\u59cb\u5730\u5740**\uff0c\u5176\u5b9e\u572832\u4f4d\u7684Linux\u4e2dELF\u6587\u4ef6\u9ed8\u8ba4\u5e94\u4ece\u5730\u57400x08048000\u5f00\u59cb\u5206\u914d\uff0c\u4e3a\u4ec0\u4e48\u8fd9\u91cc\u662f0x08048094\u6211\u4e5f\u4e0d\u660e\u767d\u3002\u3002\u3002 \u793a\u610f\u56fe\uff1a \u7ecf\u8fc7\u4e0a\u9762\u7684\u6b65\u9aa4\u62c6\u5206\uff0c\u5bf9\u4e8e\u5730\u5740\u548c\u7a7a\u95f4\u7684\u5206\u914d\u5e94\u8be5\u6709\u4e00\u4e2a\u76f4\u89c2\u7684\u4e86\u89e3\u4e86\uff0c\u603b\u7ed3\u4e00\u4e0b\uff0c\u5176\u5b9e\u5c31\u662f\u5c06\u76ee\u6807\u6587\u4ef6\u6309\u76f8\u4f3c\u6bb5\u5408\u5e76\u7684\u7b56\u7565\u5408\u5e76\u540e\u8ba1\u7b97\u5176\u6bcf\u4e2a\u6bb5\u7684\u957f\u5ea6\u3001\u5c5e\u6027\uff0c\u8fdb\u800c\u5bf9\u5176\u8fdb\u884c\u5730\u5740\u5206\u914d\u3002 2\u3001\u7b26\u53f7\u89e3\u6790\u4e0e\u91cd\u5b9a\u4f4d \u4e4b\u524d\u8bf4\u8fc7\u7684\u4e24\u90e8\u94fe\u63a5\u6cd5\uff0c\u524d\u9762\u8bf4\u4e86\u7a7a\u95f4\u4e0e\u5730\u5740\u5206\u914d\uff0c\u73b0\u5728\u89e3\u91ca\u4ec0\u4e48\u53eb\u505a**\u7b26\u53f7\u89e3\u6790\u4e0e\u91cd\u5b9a\u4f4d**\uff0c\u8fd9\u662f\u9759\u6001\u94fe\u63a5\u7684\u6838\u5fc3\u5185\u5bb9\u3002 \u9996\u5148\u89e3\u91ca\u4ec0\u4e48\u53eb\u505a**\u91cd\u5b9a\u4f4d** \u94fe\u63a5\u65f6\u6839\u636e\u7b26\u53f7\u627e\u5bfb\u76f8\u5e94\u6a21\u5757\u4e2d\u7684\u5730\u5740\uff0c\u7136\u540e\u5c06\u5730\u5740\u5168\u90e8\u4fee\u6b63\uff0c\u5c31\u662f**\u91cd\u5b9a\u4f4d**\u3002\u800c\u4fee\u6b63\u7684\u5730\u65b9\u5c31\u79f0\u4e3a**\u91cd\u5b9a\u4f4d\u5165\u53e3**\u3002 \u7b80\u5355\u7684\u6765\u8bf4\uff0c\u6211\u4eec\u5728\u7f16\u8bd1a.c\u6587\u4ef6\u5f97\u5230a.o\u6587\u4ef6\u65f6\uff0c\u6240\u4f7f\u7528\u7684shared\u53d8\u91cf\u4ee5\u53caswap\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u5bf9\u5b83\u4eec\u4e00\u65e0\u6240\u77e5\uff0c\u4e0d\u77e5\u9053\u4f4d\u7f6e\u4e5f\u4e0d\u77e5\u9053\u5b83\u4eec\u505a\u4e86\u4ec0\u4e48\uff0c\u7f16\u8bd1\u5668\u7f16\u8bd1\u65f6\u5047\u8bbe\u5b83\u4eec\u5728\u522b\u7684\u6587\u4ef6\u4e2d\uff0c\u5c31\u5148\u4e0d\u7ba1\u5b83\u4eec\uff0c\u5728\u76f8\u5e94\u7684\u5730\u5740\u4f4d\u7f6e\u4e0a\u586b\u5145\u9519\u8bef\u5730\u5740\u3002\u90a3\u4e48\u5728\u94fe\u63a5\u7684\u8fc7\u7a0b\u4e2d\u7531\u4e8e\u4e0b\u4e00\u6b65\u8981\u76f4\u63a5\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u5c31\u4e0d\u80fd\u518d\u653e\u4efb\u8fd9\u4e9b\u95ee\u9898\uff0c\u4e5f\u5c31\u662f\u8981\u627e\u5230\u5b83\u4eec\u5b9a\u4e49\u7684\u4f4d\u7f6e\u5bf9\u9519\u8bef\u5730\u5740\u8fdb\u884c\u4fee\u6b63\uff0c\u4ece\u800c\u6b63\u786e\u6267\u884c\u3002 \u4e3a\u4e86\u5bf9\u8fd9\u6b65\u8fdb\u884c\u7406\u89e3\uff0c\u5bf9a.o\u4e0eab\u53ef\u6267\u884c\u6587\u4ef6\u8fdb\u884c\u53cd\u6c47\u7f16\uff1a a.o\uff1a \u5176\u4e2d\u6709\u4e24\u4e2a**\u91cd\u5b9a\u4f4d\u5165\u53e3**\uff0c\u5c31\u662f\u6807\u8bb015\u4e0e21\u7684\u5730\u65b9\uff0c\u53ef\u4ee5\u770b\u5230\u4ece15\u5f00\u59cb\u5230\u4e0b\u4e00\u6b65\u6307\u4ee4\u4e4b\u95f4\u5177\u4f53\u4e3a0x00000000\uff0c\u8868\u793ashared\u53d8\u91cf\u7684\u5730\u5740\u662f0x00000000\uff0c\u5f88\u660e\u663e\u9519\u8bef\u3002\u800c21\u5f00\u59cb\u7684\u5b57\u8282\u4e3a0xfc ff ff ff\uff0c\u8fd9\u91cc\u76840xfc ff ff ff\u662f\u7528\u5c0f\u7aef\u65b9\u5f0f\u4fdd\u5b58\u7684\uff0c\u8bfb\u53d6\u51fa\u6765\u7684\u503c\u5e94\u4e3a0xff ff ff fc\uff0c\u8868\u793a\u503c\u4e3a-3\uff0c\u8fd9\u91cc\u6240\u8bb0\u5f55\u7684\u503c\u5e94\u4e3acall\u8fd9\u6761\u6307\u4ee4\u6240\u8df3\u8f6c\u7684\u76ee\u6807\u5730\u5740\u4e0e\u5176\u4e0b\u4e00\u6761\u6307\u4ee4\u5730\u5740\u7684\u504f\u79fb\u91cf\uff0c\u8fd9\u91cc\u504f\u79fb-3\u5373\u8df3\u8f6c\u5730\u5740\u4e3a21\uff0c\u90a3\u4e48\u80af\u5b9a\u9519\u8bef\u3002 ab\uff1a \u94fe\u63a5\u540e\u7684ab\u53ef\u6267\u884c\u6587\u4ef6\u4e2d\uff0c\u53ef\u4ee5\u770b\u5230\u539f\u672c\u6807\u8bb0\u7684\u91cd\u5b9a\u4f4d\u5165\u53e3\u5904\u7684\u5730\u5740\u90fd\u88ab\u4fee\u6539\uff0c0x00000000\u6539\u4e3a0x08049154\uff0c\u6839\u636e\u524d\u9762\u6211\u4eec\u5bf9ab\u8fd9\u4e2a\u6587\u4ef6\u865a\u62df\u5730\u5740\u7a7a\u95f4\u6240\u753b\u7684\u793a\u610f\u56fe\u53ef\u4ee5\u770b\u51fa\uff0c\u4f4d\u4e8e\u6570\u636e\u6bb5\u4e2d\u3002\u800c\u53e6\u4e00\u4e2a0xfc ff ff ff \u6539\u4e3a\u4e860x 02 00 00 00\uff0c\u6309\u7167\u521a\u624d\u7684\u5c0f\u7aef\u65b9\u5f0f\u6765\u8bfb\u5373\u504f\u79fb\u91cf\u4e3a2\uff0c\u5373\u6240\u8df3\u8f6c\u7684\u5730\u5740\u4e0e\u5176\u4e0b\u4e00\u6b65\u7684\u6307\u4ee4\u5730\u5740\u7684\u504f\u79fb\u91cf\u4e3a2\uff0c\u53ef\u5f97\u51faswap\u51fd\u6570\u7684\u8d77\u59cb\u5730\u5740\u4e3a0x080480b9+0x00000002=0x080480bb\uff0c\u5728\u56fe\u4e2d\u53ef\u4ee5\u770b\u5230\u6b63\u662fswap\u7684\u8d77\u59cb\u5730\u5740\u3002 \u6839\u636e\u4e0a\u9762\u7684\u8fc7\u7a0b\u5bf9\u4e8e\u91cd\u5b9a\u4f4d\u7684\u6982\u5ff5\u5e94\u8be5\u5df2\u7ecf\u4e86\u89e3\u4e86\uff0c\u5176\u5b9e\u5c31\u662f\u5728\u8f93\u5165\u7684\u76ee\u6807\u6587\u4ef6\u4e2d\u627e\u5bfb\u9700\u8981\u91cd\u5b9a\u4f4d\u5373\u5730\u5740\u9519\u8bef\u7684\u5730\u65b9\uff0c\u5c06\u5176\u5730\u5740\u8fdb\u884c\u4fee\u6b63\u3002 \u90a3\u4e48**\u94fe\u63a5\u5668**\u5982\u4f55\u77e5\u9053\u54ea\u4e9b\u5730\u65b9\u9700\u8981\u88ab\u4fee\u6b63\uff1f\u7b54\u6848\u662f**\u91cd\u5b9a\u4f4d\u8868**\uff0c\u8fd9\u662f\u5728ELF\u6587\u4ef6\u4e2d\u7684\u4e00\u4e2a\u7ed3\u6784\uff0c\u4e13\u95e8\u7528\u6765\u4fdd\u5b58\u4e0e\u91cd\u5b9a\u4f4d\u76f8\u5173\u7684\u4fe1\u606f\u3002\u6bcf\u4e00\u4e2a\u9700\u8981\u88ab\u91cd\u5b9a\u4f4d\u7684**\u6bb5**\u90fd\u6709\u7740\u5176**\u91cd\u5b9a\u4f4d\u8868**\uff0c\u4e00\u4e2a**\u91cd\u5b9a\u4f4d\u8868**\u5f80\u5f80\u5c31\u662f\u4e00\u4e2aELF\u6587\u4ef6\u4e2d\u7684\u6bb5\uff0c\u90a3\u4e48\u5c31\u53ef\u80fd\u4f1a\u6709\u591a\u4e2a\u91cd\u5b9a\u4f4d\u6bb5\uff0c\u4e3e\u4e2a\u4f8b\u5b50\uff1a\u5982\u679c.text\u6bb5\u4e0e.data\u6bb5\u90fd\u8981\u91cd\u5b9a\u4f4d\uff0c\u90a3\u4e48\u5c31\u4f1a\u5b58\u5728.rel.text\u4ee5\u53ca.rel.data\u4e24\u4e2a\u6bb5\u3002 \u6211\u4eec\u6765\u770b\u770b\u91cd\u5b9a\u4f4d\u8868\uff0c\u4ee5\u5bf9\u5176\u6709\u4e2a\u76f4\u89c2\u7684\u4e86\u89e3\uff1a \u5bf9\u4e8e.eh_frame\u8fd9\u6bb5\u6211\u4eec\u4e0d\u8ba8\u8bba\uff0c\u8fd9\u5e94\u8be5\u662f\u8f85\u52a9\u6bb5\u3002\u53ef\u4ee5\u770b\u5230.text\u6bb5\u7684\u91cd\u5b9a\u4f4d\u8868\u4e2d\u6709\u4e24\u4e2a**\u91cd\u5b9a\u4f4d\u5165\u53e3**shared\u4e0eswap\uff0c**\u94fe\u63a5\u5668**\u4e5f\u6b63\u662f\u6839\u636e\u91cd\u5b9a\u4f4d\u8868\u6765\u5bf9a.o\u6587\u4ef6\u4e2d\u7684shared\u4e0eswap\u8fdb\u884c\u6807\u8bb0\u5e76\u4ee5\u6b64\u8fdb\u884c**\u91cd\u5b9a\u4f4d**\u7684\u3002 \u4e0a\u9762\u8bf4\u4e86\u91cd\u5b9a\u4f4d\uff0c\u90a3\u4e48\u5c31\u5269\u4e0b**\u7b26\u53f7\u89e3\u6790**\u4e86 \u5176\u5b9e\u5bf9\u4e8e**\u7b26\u53f7\u89e3\u6790**\u7684\u8fc7\u7a0b\u4e00\u76f4\u90fd\u4f34\u968f\u7740**\u91cd\u5b9a\u4f4d**\u7684\u8fc7\u7a0b\uff0c\u6211\u7406\u89e3\u7b26\u53f7\u89e3\u6790\u7b80\u5355\u6765\u8bf4\u901a\u8fc7**\u5168\u5c40\u7b26\u53f7\u8868**\u8981\u80fd\u5f97\u77e5\u4e00\u4e2a\u7b26\u53f7\u5b83\u7684\u5c5e\u6027\u3001\u5730\u5740\u3001\u5927\u5c0f\u3001\u4f5c\u7528\u5206\u522b\u662f\u4ec0\u4e48\uff0c\u5982\u679c\u65e0\u6cd5\u5f97\u77e5\uff0c\u90a3\u4e48\u65e0\u6cd5\u8fdb\u884c\u7b26\u53f7\u89e3\u6790\u3002 \u5176\u5b9e\u91cd\u5b9a\u4f4d\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u4e00\u4e2a**\u91cd\u5b9a\u4f4d\u5165\u53e3**\u90fd\u662f\u5bf9\u4e00\u4e2a**\u7b26\u53f7**\u7684\u5f15\u7528\uff0c\u94fe\u63a5\u5668\u8fd9\u4e2a**\u7b26\u53f7**\u7684\u5f15\u7528\u8fdb\u884c\u91cd\u5b9a\u4f4d\u65f6\uff0c\u5c31\u8981\u786e\u5b9a\u6b64\u7b26\u53f7\u7684**\u76ee\u6807\u5730\u5740**\uff0c\u5c31\u9700\u8981\u53bb\u67e5\u8be2**\u5168\u5c40\u7b26\u53f7\u8868**\u4e2d\u76f8\u5e94\u7684\u7b26\u53f7\u6765\u83b7\u5f97\u76ee\u6807\u5730\u5740\uff0c\u4ece\u800c\u91cd\u5b9a\u4f4d \u6211\u4eec\u5148\u6765\u770b\u770ba.o\u7684\u7b26\u53f7\u8868\uff1a \u6211\u4eec\u5173\u6ce8\u4e00\u4e0b\u6700\u4e0b\u9762\u7684shared\u53caswap\u7b26\u53f7\uff0c\u53ef\u4ee5\u770b\u5230\u4e24\u4e2a\u7684Ndx\u9879\u90fd\u662fUND\uff0c\u8fd9\u8868\u793aundefined\u5373\u672a\u5b9a\u4e49\u7c7b\u578b\uff0c\u8fd9\u79cd\u672a\u5b9a\u4e49\u7684\u7b26\u53f7\u662f\u56e0\u4e3a\u6b64\u76ee\u6807\u6587\u4ef6\u4e2d\u6709\u5b83\u4eec\u7684\u91cd\u5b9a\u4f4d\u9879\u3002\u6211\u4eec\u76f4\u63a5\u5bf9a.o\u6587\u4ef6\u8fdb\u884c\u94fe\u63a5\uff0c\u770b\u770b\u7ed3\u679c\uff1a \u51fa\u73b0\u9519\u8bef\uff0cshared\u548cswap\u672a\u5b9a\u4e49\uff0c\u90a3\u4e48\u53ef\u4ee5\u60f3\u8c61\u4e00\u4e0b\u62a5\u9519\u7684\u6574\u4e2a\u8fc7\u7a0b\uff1a\u94fe\u63a5\u5668\u626b\u63cf\u4e86\u6240\u6709\u7684\u8f93\u5165\u6587\u4ef6\u540e\uff0c\u8fd9\u4e9b\u672a\u5b9a\u4e49\u7684\u7b26\u53f7\u4e0d\u80fd\u518d\u5168\u5c40\u7b26\u53f7\u8868\u4e2d\u627e\u5230\uff0c\u90a3\u4e48\u5c31\u4f1a\u62a5\u672a\u5b9a\u4e49\u7684\u9519\u8bef\u3002","title":"\u7f16\u8bd1\u4ee5\u53ca\u9759\u6001\u94fe\u63a5"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/#gcc","text":"\u6211\u4eec\u5728 Linux \u4e2d\u7ecf\u5e38\u4f7f\u7528 gcc \u6e90\u6587\u4ef6\u540d.c -o \u76ee\u6807\u53ef\u6267\u884c\u6587\u4ef6\u540d \u5bf9\u4e00\u4e2a\u7f16\u5199\u597d\u7684C\u6587\u4ef6\u8fdb\u884c\u7f16\u8bd1\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u90a3\u4e48\u8fd9\u4e4b\u95f4\u7684\u7ec6\u8282\u5462\uff1f \u8fd9\u91cc\u6e90\u6587\u4ef6\u540d\u4e3a hello.c \uff0c\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\u540d\u4e3a hello \u4e3a\u4f8b\u5b50 gcc\u4e00\u4e2aC\u6e90\u6587\u4ef6\u65f6\u5bf9\u8fc7\u7a0b\u8fdb\u884c\u4e86\u9690\u85cf\uff0c\u5b9e\u9645\u4e3a\uff1a\u9884\u7f16\u8bd1 cpp\u3001\u7f16\u8bd1 cc1\u3001\u6c47\u7f16 as\u3001\u94fe\u63a5 ld\uff0c\u5176\u4e2d\u6bcf\u4e00\u6b65\u540e\u7684\u82f1\u6587\u540d\u662f\u6240\u4f7f\u7528\u7684\u5de5\u5177\u7684\u540d\u79f0\u3002 \u90a3\u4e48\u5404\u81ea\u7684\u6b65\u9aa4\u5230\u5e95\u5e72\u4e86\u4ec0\u4e48\u5462\uff1f","title":"\u4e00\u3001GCC\u505a\u4e86\u4ec0\u4e48\uff1f"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/#1c","text":"\u8fd9\u4e9b**\u9884\u7f16\u8bd1\u6307\u4ee4**\u5305\u62ec\u4e86**\u5b8f\u5b9a\u4e49**\u3001**\u6761\u4ef6\u9884\u7f16\u8bd1\u6307\u4ee4**\u7b49\u7b49\uff0c\u6b64\u6b65\u4e2d\u4e5f\u4f1a\u8fdb\u884c\u5220\u9664\u6389\u6240\u6709\u7684\u6ce8\u91ca\u7b49\u64cd\u4f5c\u3002\u5f53\u65e0\u6cd5\u5224\u65ad\u4e00\u4e2a**\u5b8f\u5b9a\u4e49**\u662f\u5426\u6b63\u786e\u6216\u8005**\u5934\u6587\u4ef6**\u662f\u5426\u6b63\u786e\u5305\u542b\u7684\u8bdd\uff0c\u53ef\u4ee5\u76f4\u63a5\u6253\u5f00\u6b64\u6b65\u751f\u6210\u7684\u6587\u4ef6\u8fdb\u884c\u68c0\u67e5\u3002 gcc -E hello.c -o hello.i","title":"1\u3001\u9884\u7f16\u8bd1\uff1a\u5904\u7406.c\u6587\u4ef6\u4e2d\u4ee5\u201c#\u201d\u5f00\u5934\u7684\u9884\u7f16\u8bd1\u6307\u4ee4\u3002"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/#2","text":"\u8fd9\u4e00\u6b65\u662f\u7531\u7f16\u8bd1\u5668cc1\u5b8c\u6210\uff08gcc\u4e2d\uff09\uff0c\u4e3b\u8981\u5206\u4e3a\u8bcd\u6cd5\u5206\u6790\u3001\u8bed\u6cd5\u5206\u6790\u3001\u8bed\u4e49\u5206\u6790\u3001\u4e2d\u95f4\u8bed\u8a00\u751f\u6210\u3001\u76ee\u6807\u4ee3\u7801\u751f\u6210\u4e0e\u4f18\u5316\u51e0\u6b65\u3002 a.\u8bcd\u6cd5\u5206\u6790\uff1a\u5c06\u6240\u6709\u7684 C\u8bed\u8a00 \u6e90\u4ee3\u7801\u5206\u5272\u4e3a\u4e00\u7cfb\u5217\u7684token\u8bb0\u53f7\uff0c\u8fd9\u4e9btoken\u8bb0\u53f7\u4e3b\u8981\u4e3a\u5173\u952e\u5b57\u3001\u6807\u8bc6\u7b26\u3001\u5e38\u91cf\u53ca\u7279\u6b8a\u7b26\u53f7\uff0c\u6bd4\u5982\u8868\u8fbe\u5f0f a+b \u5728\u8fd9\u6b65\u4e2d\u5c31\u4f1a\u88ab\u62c6\u5206\u4e3a a \u548c b \u4e24\u4e2a\u6807\u8bc6\u7b26\u53ca + \u8fd9\u4e2a\u7279\u6b8a\u7b26\u53f7\u3002 b.\u8bed\u6cd5\u5206\u6790\uff1a\u4ea7\u751f**\u8bed\u6cd5\u6811**\uff0c\u5173\u4e8e\u8fd9\u6b65\u9700\u8981\u6709\u4e00\u4e9b\u6570\u7406\u903b\u8f91\u7684\u77e5\u8bc6\uff0c\u5373\u751f\u6210\u4ee5\u8868\u8fbe\u5f0f\u4e3a\u8282\u70b9\u7684\u6811\uff0c\u5bf9\u5e94\u4e0a\u9762 a+b \u7684\u60c5\u51b5\u662f + \u4e3a\u4e00\u4e2a\u8282\u70b9\uff0c\u800c a \u548c b \u5206\u522b\u4e3a\u5de6\u53f3\u5b50\u6811\u7684\u8282\u70b9\u3002 c.\u8bed\u4e49\u5206\u6790\uff1a\u786e\u5b9a\u6bcf\u4e2a\u8282\u70b9\u7684\u7c7b\u578b\uff0c\u6bd4\u5982\u6574\u578b\u3001\u5b57\u7b26\u578b\u7b49\u3002 \u53ef\u4ee5\u7406\u89e3\u4e3a\u5728\u524d\u4e00\u6b65\u7684\u6811\u7684\u57fa\u7840\u4e0a\u5728\u6bcf\u4e2a\u8282\u70b9\u4e0a\u90fd\u6807\u793a\u597d**\u7c7b\u578b**\uff0c\u5bf9\u4e8e\u4e00\u4e9b\u9690\u5f0f\u8f6c\u6362\u53ca\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\u90fd\u4f1a\u5728\u8fd9\u6b65\u4e2d\u8fdb\u884c\u5904\u7406\u3002 d.\u4e2d\u95f4\u8bed\u8a00\u751f\u6210\uff1a\u8fdb\u884c\u4e24\u6b65\u64cd\u4f5c\uff0c\u9996\u5148\u5c06**\u8bed\u6cd5\u6811**\u8f6c\u5316\u4e3a**\u4e2d\u95f4\u4ee3\u7801**\uff0c\u7136\u540e\u5728**\u4e2d\u95f4\u4ee3\u7801**\u4e2d\u5bf9\u5df2\u7ecf\u80fd\u591f\u786e\u5b9a\u503c\u7684\u8868\u8fbe\u5f0f\u8fdb\u884c\u6c42\u503c\u3002 \u5176\u4e2d\u4e2d\u95f4\u4ee3\u7801\u4e00\u822c\u4e3a\u4e09\u5730\u5740\u7801\uff0c\u5373 x = y op z \u7684\u5f62\u5f0f\uff0c\u5176\u4e2dop\u4ee3\u8868\u7279\u6b8a\u7b26\u53f7\uff0c\u7136\u540e\u5982\u679c\u6709\u4e9b\u8868\u8fbe\u5f0f\u80fd\u591f\u786e\u5b9a\u5176\u503c\uff0c\u6bd4\u5982 t1=5+6 \u8fd9\u79cd\u4e24\u4e2a\u5e38\u91cf\u76f8\u52a0\u7684\u8bed\u53e5\u5c31\u76f4\u63a5\u8fdb\u884c\u8ba1\u7b97\u3002 e.\u76ee\u6807\u4ee3\u7801\u751f\u6210\u4e0e\u4f18\u5316\uff1a\u5982\u5b57\u9762\u610f\u601d\uff0c\u8fdb\u884c\u76ee\u6807\u4ee3\u7801\u7684\u751f\u6210\u4e0e\u4f18\u5316\u3002 \u5173\u4e8e\u76ee\u6807\u4ee3\u7801\u7684\u751f\u6210\u4e0e\u5177\u4f53\u7684\u786c\u4ef6\u5e73\u53f0\u6709\u5173\uff0c\u800c\u4f18\u5316\u90e8\u5206\u6709\u90e8\u5206\u64cd\u4f5c\uff0c\u6bd4\u5982\u5408\u9002\u7684\u5bfb\u5740\u65b9\u5f0f\u3001\u5bf9\u4e8e\u4e58\u6cd5\u8fd0\u7b97\u4f7f\u7528\u4f4d\u79fb\u8fdb\u884c\u4ee3\u66ff\uff0c\u8fd9\u4e9b\u5982\u679c\u6709\u63a5\u89e6\u6c47\u7f16\u4ee3\u7801\u4f1a\u6bd4\u8f83\u4e86\u89e3\u3002 \u7f16\u8bd1\u5668\u6d41\u7a0b\u56fe\uff1a \u6b64\u6b65\u4e2d\u751f\u6210\u7684\u6587\u4ef6\u5982\u679c\u61c2\u5f97\u6c47\u7f16\u4ee3\u7801\u7684\u8bdd\u4ecd\u7136\u662f\u53ef\u8bfb\u7684 gcc -S hello.c -o hello.s","title":"2\u3001\u7f16\u8bd1\uff1a\u8fdb\u884c\u8bcd\u6cd5\u5206\u6790\u3001\u8bed\u6cd5\u5206\u6790\u3001\u8bed\u4e49\u5206\u6790\u7b49\u5de5\u4f5c\uff0c\u6b64\u6b65\u6240\u751f\u6210\u7684\u6587\u4ef6\u662f\u4ee5\u6c47\u7f16\u4ee3\u7801\u6784\u6210\u7684\u3002"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/#3","text":"\u6b64\u6b65\u4e2d\u662f\u6839\u636e**\u6c47\u7f16\u6307\u4ee4**\u4e0e**\u673a\u5668\u6307\u4ee4**\u7684**\u5bf9\u7167\u8868**\u8fdb\u884c\u4e00\u4e00\u7ffb\u8bd1\uff0c\u57fa\u672c\u4e0a\u4e00\u4e2a\u6c47\u7f16\u8bed\u53e5\u5bf9\u5e94\u4e00\u6761\u673a\u5668\u6307\u4ee4\u3002 \u6b64\u6b65\u751f\u6210\u7684\u6587\u4ef6\u5df2\u7ecf\u6ca1\u6cd5\u8bfb\u4e86\uff0c\u6253\u5f00\u540e\u5168\u90e8\u662f\u4e71\u7801\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5168\u90e8\u673a\u5236\u6307\u4ee4\u4e86\u3002 gcc -c hello.s -o hello.o \u6216 gcc -c hello.c -o hello.o \u6216 as hello.s -o hello.o","title":"3\u3001\u6c47\u7f16\uff1a\u5c06\u6c47\u7f16\u4ee3\u7801\u8f6c\u53d8\u6210\u673a\u5668\u53ef\u4ee5\u6267\u884c\u7684\u6307\u4ee4\u3002"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/#4","text":"\u7b80\u5355\u6765\u8bf4\uff0c\u53ef\u4ee5\u770b\u4f5c\u62fc**\u62fc\u56fe**\u7684\u8fc7\u7a0b\uff0c\u6bcf\u4e2a.o\u6587\u4ef6\u90fd\u662f\u4e00\u5757\u62fc\u56fe\u788e\u7247\uff0c\u94fe\u63a5\u5c31\u662f\u5c06\u5b83\u4eec\u62fc\u63a5\u6210\u4e00\u5e45\u56fe\uff08\u53ef\u6267\u884c\u6587\u4ef6\uff09\u7684\u8fc7\u7a0b\u3002 linux \u4e2d\u53ef\u6267\u884c\u6587\u4ef6\u90fd\u79f0\u4e3aELF\u6587\u4ef6\uff0cWindows\u4e2d\u4e3aPE\u6587\u4ef6\uff0c\u4e4b\u540e\u90fd\u4f1a\u8fd9\u6837\u79f0\u547c","title":"4\u3001\u94fe\u63a5\uff1a\u5c06\u51e0\u4e2a\u8f93\u5165\u7684\u76ee\u6807\u6587\u4ef6\u52a0\u5de5\u540e\u5408\u5e76\u4e3a\u4e00\u4e2a\u8f93\u51fa\u6587\u4ef6\u3002"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/#_1","text":"\u7ecf\u8fc7\u4e0a\u9762\u7684\u51e0\u6b65\u6211\u4eec\u5927\u81f4\u4e86\u89e3\u4e86\u7f16\u8bd1\u7684\u8fc7\u7a0b\uff0c\u5c24\u5176\u662fgcc\u7684\u7f16\u8bd1\u5668cc1\u5bf9\u6e90\u6587\u4ef6\u7684\u64cd\u4f5c\u6b65\u9aa4\u3002 \u4e0b\u9762\u662f\u572832\u4f4d\u7684Ubuntu\u4e2d\u5bf9 hello.c \u6587\u4ef6\u8fdb\u884c\u52a8\u6001\u7f16\u8bd1\u663e\u793a\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u9759\u6001\u7f16\u8bd1\u4e0e\u4e4b\u7c7b\u4f3c\uff1a gcc --verbose -fno-builtin hello.c //--verbose \u8868\u793a\u663e\u793a\u7f16\u8bd1\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c-fno-builtin\u8868\u793a\u5173\u95ed\u5185\u7f6e\u51fd\u6570\u4f18\u5316\u9009\u9879\uff0c\u56e0\u4e3ahello.c\u6587\u4ef6\u4e2d\u7528printf\u53ea\u5bf9\u4e00\u4e2a\u5b57\u7b26\u4e32\u8fdb\u884c\u8f93\u51fa\uff0c\u6b64\u65f6GCC\u4f1a\u5c06\u5176\u81ea\u52a8\u66ff\u6362\u4e3aputs\u51fd\u6570\u3002 Using built-in specs. COLLECT_GCC=gcc COLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/4.8/lto-wrapper Target: i686-linux-gnu Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.4-2ubuntu1~14.04.1' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-i386/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-i386 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-i386 --with-arch-directory=i386 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-targets=all --enable-multiarch --disable-werror --with-arch-32=i686 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=i686-linux-gnu --host=i686-linux-gnu --target=i686-linux-gnu Thread model: posix gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.1) COLLECT_GCC_OPTIONS='-v' '-fno-builtin' '-mtune=generic' '-march=i686' /usr/lib/gcc/i686-linux-gnu/4.8/cc1 -quiet -v -imultiarch i386-linux-gnu hello.c -quiet -dumpbase hello.c -mtune=generic -march=i686 -auxbase hello -version -fno-builtin -fstack-protector -Wformat -Wformat-security -o /tmp/ccM5JRqF.s GNU C (Ubuntu 4.8.4-2ubuntu1~14.04.1) version 4.8.4 (i686-linux-gnu) compiled by GNU C version 4.8.4, GMP version 5.1.3, MPFR version 3.1.2-p3, MPC version 1.0.1 GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072 ignoring nonexistent directory \"/usr/local/include/i386-linux-gnu\" ignoring nonexistent directory \"/usr/lib/gcc/i686-linux-gnu/4.8/../../../../i686-linux-gnu/include\" #include \"...\" search starts here: #include <...> search starts here: /usr/lib/gcc/i686-linux-gnu/4.8/include /usr/local/include /usr/lib/gcc/i686-linux-gnu/4.8/include-fixed /usr/include/i386-linux-gnu /usr/include End of search list. GNU C (Ubuntu 4.8.4-2ubuntu1~14.04.1) version 4.8.4 (i686-linux-gnu) compiled by GNU C version 4.8.4, GMP version 5.1.3, MPFR version 3.1.2-p3, MPC version 1.0.1 GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072 Compiler executable checksum: aaaa08c6fefb26a9d107c18441ada1ef COLLECT_GCC_OPTIONS='-v' '-fno-builtin' '-mtune=generic' '-march=i686' as -v --32 -o /tmp/ccs3h630.o /tmp/ccM5JRqF.s GNU\u6c47\u7f16\u7248\u672c 2.24 (i686-linux-gnu) \u4f7f\u7528BFD\u7248\u672c (GNU Binutils for Ubuntu) 2.24 COMPILER_PATH=/usr/lib/gcc/i686-linux-gnu/4.8/:/usr/lib/gcc/i686-linux-gnu/4.8/:/usr/lib/gcc/i686-linux-gnu/:/usr/lib/gcc/i686-linux-gnu/4.8/:/usr/lib/gcc/i686-linux-gnu/ LIBRARY_PATH=/usr/lib/gcc/i686-linux-gnu/4.8/:/usr/lib/gcc/i686-linux-gnu/4.8/../../../i386-linux-gnu/:/usr/lib/gcc/i686-linux-gnu/4.8/../../../../lib/:/lib/i386-linux-gnu/:/lib/../lib/:/usr/lib/i386-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/i686-linux-gnu/4.8/../../../:/lib/:/usr/lib/ COLLECT_GCC_OPTIONS='-v' '-fno-builtin' '-mtune=generic' '-march=i686' /usr/lib/gcc/i686-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_i386 --hash-style=gnu --as-needed -dynamic-linker /lib/ld-linux.so.2 -z relro /usr/lib/gcc/i686-linux-gnu/4.8/../../../i386-linux-gnu/crt1.o /usr/lib/gcc/i686-linux-gnu/4.8/../../../i386-linux-gnu/crti.o /usr/lib/gcc/i686-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/i686-linux-gnu/4.8 -L/usr/lib/gcc/i686-linux-gnu/4.8/../../../i386-linux-gnu -L/usr/lib/gcc/i686-linux-gnu/4.8/../../../../lib -L/lib/i386-linux-gnu -L/lib/../lib -L/usr/lib/i386-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/i686-linux-gnu/4.8/../../.. /tmp/ccs3h630.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/i686-linux-gnu/4.8/crtend.o /usr/lib/gcc/i686-linux-gnu/4.8/../../../i386-linux-gnu/crtn.o \u5176\u4e2d\u6700\u91cd\u8981\u7684\u4e09\u53e5\u5df2\u7ecf\u7528\u7ea2\u5b57\u8868\u793a\u4e86\u51fa\u6765\uff0c\u53ef\u4ee5\u770b\u5230\u4e00\u4e2a\u6700\u7b80\u5355\u7684helloworld\u7a0b\u5e8f\u90fd\u9700\u8981\u94fe\u63a5\u8bb8\u591a.o\u76ee\u6807\u6587\u4ef6\u624d\u80fd\u591f\u5f97\u5230ELF\u6587\u4ef6\u3002 \u4ece\u4e0a\u770b\u51fa\uff0cgcc\u5b9e\u9645\u4e0a\u662f\u5bf9**cpp\u3001cc1\u3001as\u3001ld**\u51e0\u4e2a\u540e\u53f0\u7a0b\u5e8f\u7684\u5305\u88c5\uff0c\u6267\u884c\u5b83\u65f6\u4f1a\u6839\u636e\u5177\u4f53\u7684\u53c2\u6570\u8981\u6c42\u53bb\u8c03\u7528\u8fd9\u51e0\u4e2a\u540e\u53f0\u7a0b\u5e8f\uff0c\u4ece\u800c\u5f97\u5230\u6211\u4eec\u6240\u9700\u8981\u7f16\u8bd1\u51fa\u7684ELF\u6587\u4ef6\u3002","title":"\u603b\u7ed3\uff1a"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/#_2","text":"\u521a\u521a\u5c06gcc\u7684\u51e0\u4e2a\u6b65\u9aa4\u62c6\u5f00\u4e86\u4e86\u89e3\u5404\u6b65\u9aa4\u4f5c\u7528\uff0c\u5177\u4f53\u5206\u6790\u4e86\u5176\u4e2dcc1\u7f16\u8bd1\u7684\u90e8\u5206\uff0c\u5173\u4e8e\u9884\u7f16\u8bd1\u4e0e\u6c47\u7f16\u7684\u90e8\u5206\u4e0d\u7ec6\u7a76\uff0c\u63a5\u4e0b\u6765\u5c31\u5269\u94fe\u63a5ld\u4e86\u3002 \u4ece\u521a\u521a\u7684gcc\u8be6\u7ec6\u4fe1\u606f\u53ef\u4ee5\u770b\u51fa\uff0c\u5b9e\u9645\u8fc7\u7a0b\u4e2d\u94fe\u63a5\u7684.o\u6587\u4ef6\u6709\u5f88\u591a\uff0c\u90a3\u4e48\u4e3a\u4ec0\u4e48\u4f1a\u8fd9\u4e48\u591a\uff0c\u5b83\u4eec\u5728\u54ea\u5462\uff1f \u63a5\u7740\u521a\u521agcc\u4e2d\u7b2c\u56db\u4e2a\u90e8\u5206\u94fe\u63a5\u7684\u90e8\u5206\u8bf4\u4e0b\u53bb\uff0c\u8fd9\u91cc\u5f00\u59cb\u5206\u4e3a\u4e86\u4e24\u4e2a\u5206\u652f\uff1a \u52a8\u6001\u94fe\u63a5**\u4e0e**\u9759\u6001\u94fe\u63a5 \uff0c \u9759\u6001\u94fe\u63a5**\u4e00\u822c\u7528\u4e8e**\u4ea4\u53c9\u7f16\u8bd1**\u7b49\u60c5\u51b5\uff0c\u800c\u52a8\u6001\u94fe\u63a5\u5219\u8f83\u4e3a\u5e38\u7528\uff0c\u5f53\u6211\u4eec\u9700\u8981\u9759\u6001\u94fe\u63a5\u65f6\u9700\u8981\u6307\u5b9a -static \u53c2\u6570\uff0c\u5426\u5219\u90fd\u9ed8\u8ba4\u4e3a**\u52a8\u6001\u94fe\u63a5 \u3002 **\u52a8\u6001\u94fe\u63a5**\u4e0e**\u9759\u6001\u94fe\u63a5**\u6709\u4ec0\u4e48\u4e0d\u540c\uff1f \u52a8\u6001\u7f16\u8bd1\u7684\u6587\u4ef6\u9700\u8981\u9644\u5e26\u4e00\u4e2a**\u52a8\u6001\u94fe\u63a5\u5e93**\uff0c\u5728\u6587\u4ef6\u6267\u884c\u65f6\u9700\u8981\u8c03\u7528**\u52a8\u6001\u94fe\u63a5\u5e93**\u4e2d\u7684\u4e00\u4e9b\u547d\u4ee4\uff0c\u6240\u4ee5\u6ca1\u6709\u8fd9\u4e2a\u5e93\u5c31\u6ca1\u529e\u6cd5\u8fd0\u884c\u3002\u4f18\u70b9\uff1a\u65e2\u7f29\u5c0f\u4e86\u6267\u884c\u6587\u4ef6\u672c\u8eab\u7684\u4f53\u79ef\uff0c\u53c8\u52a0\u5feb\u4e86\u7f16\u8bd1\u7684\u901f\u5ea6\uff1b\u7f3a\u70b9\uff1a\u9996\u5148\u5373\u4fbf\u7a0b\u5e8f\u53ea\u7528\u5230\u4e86\u94fe\u63a5\u5e93\u5f88\u5c11\u7684\u547d\u4ee4\u4e5f\u9700\u8981\u643a\u5e26\u4e00\u4e2a\u5e9e\u5927\u7684\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5426\u5219\u7a0b\u5e8f\u65e0\u6cd5\u6267\u884c\uff0c\u800c\u4e14\u5f53\u5176\u4ed6\u8bbe\u5907\u4e0a\u6ca1\u6709\u6b64\u94fe\u63a5\u5e93\u65f6\u5c31\u65e0\u6cd5\u8fd0\u884c\u3002 \u9759\u6001\u7f16\u8bd1**\u4f1a\u5728\u7f16\u8bd1\u6587\u4ef6\u65f6\u5c06\u6587\u4ef6\u6240\u9700\u8981\u8c03\u7528\u7684\u5bf9\u5e94**\u94fe\u63a5\u5e93**\u4e2d\u7684\u90e8\u5206\u63d0\u53d6\u51fa\u6765\uff0c\u94fe\u63a5\u5230**\u53ef\u6267\u884c\u6587\u4ef6**\u4e2d\u53bb\uff0c\u4f7f\u7a0b\u5e8f\u5728\u6267\u884c\u65f6\u4e0d\u4f9d\u8d56**\u94fe\u63a5\u5e93 \u3002 \u53ef\u4ee5\u770b\u51fa\u52a8\u6001\u7f16\u8bd1\u4e0e\u9759\u6001\u7f16\u8bd1\u7684\u4f18\u70b9\u4e0e\u7f3a\u70b9\u57fa\u672c\u662f\u4e92\u8865\u7684\uff0c\u53ef\u79fb\u690d\u6027\u548c\u7f16\u8bd1\u901f\u5ea6\u4e24\u8005\u5bf9\u7acb\u3002 \u8fd9\u91cc\u6211\u4eec\u53ea\u8ba8\u8bba**\u9759\u6001\u94fe\u63a5**\u3002 \u524d\u9762\u8bf4\u8fc7\u94fe\u63a5\u5668\u8fdb\u884c\u4e0d\u540c\u6a21\u5757\u4e4b\u95f4\u7684\u62fc\u63a5\u5de5\u4f5c\uff0c\u4e3b\u8981\u5305\u62ec\u5730\u5740\u548c\u7a7a\u95f4\u5206\u914d\u3001\u7b26\u53f7\u51b3\u8bae\u53ca\u91cd\u5b9a\u4f4d\u6b65\u9aa4\uff0c\u4e0b\u9762\u6765\u770b\u8fd9\u4e9b\u6b65\u9aa4\u5230\u5e95\u505a\u4e86\u4ec0\u4e48\u3002","title":"\u4e8c\u3001\u9759\u6001\u94fe\u63a5"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/#1","text":"\u5bf9\u4e8e\u94fe\u63a5\u5668ld\u6765\u8bf4\uff0c\u5176\u9700\u8981\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u628a\u591a\u4e2a\u8f93\u5165\u7684\u76ee\u6807\u6587\u4ef6\uff08.o\u6587\u4ef6\uff09\u5408\u5e76\u4e3a\u4e00\u4e2a\u6587\u4ef6\uff0c\u5373**ELF\u53ef\u6267\u884c\u6587\u4ef6**\u3002 \u90a3\u4e48\u5bf9\u4e8e\u591a\u4e2a\u76ee\u6807\u6587\u4ef6\uff0c\u5982\u4f55\u5408\u5e76\uff1f\u6216\u8005\u8bf4\uff0c\u7a7a\u95f4\u5982\u4f55\u5206\u914d\uff1f \u4e0b\u9762\u63d0\u4f9b\u4e86\u4e24\u79cd\u65b9\u6cd5\uff1a a.\u6309\u5e8f\u53e0\u52a0 \u53ef\u4ee5\u770b\u5230\u56fe\u4e2d\u6709\u7740A\u3001B\u4e24\u4e2a\u76ee\u6807\u6587\u4ef6\uff0c\u5c06\u5b83\u4eec\u7ec4\u5408\u8d77\u6765\u65f6\u6309\u7167\u5404\u81ea\u7684\u4ee3\u7801\u6bb5\u3001\u6570\u636e\u6bb5\u3001bss\u6bb5\u4f9d\u6b21\u53e0\u52a0\uff0c\u4e8e\u662f\u5f62\u6210\u7684ELF\u53ef\u6267\u884c\u6587\u4ef6\u4e2d\u6709\u7740\u591a\u4e2a\u4ee3\u7801\u6bb5\u3001\u6570\u636e\u6bb5\u7b49 \u6b64\u79cd\u65b9\u6cd5\u5f88\u660e\u663e\u662f\u975e\u5e38\u6d6a\u8d39\u7a7a\u95f4\u7684\uff0c\u5728\u8fdb\u884c\u5730\u5740\u4e0e\u7a7a\u95f4\u5206\u914d\u65f6\uff0c\u90fd\u9700\u8981\u4e00\u5b9a\u7684\u5bf9\u9f50\uff0c\u90a3\u4e48\u8fd9\u6837\u5c31\u4f1a\u9020\u6210\u5185\u5b58\u4e2d\u5b58\u5728\u5927\u91cf\u7684\u5185\u90e8\u788e\u7247\uff0c\u56e0\u6b64\u63d0\u51fa\u4e86\u7b2c\u4e8c\u79cd\u65b9\u6848\u3002 b.\u76f8\u4f3c\u6bb5\u5408\u5e76 \u6b64\u79cd\u65b9\u6cd5\u5c06\u591a\u4e2a\u76ee\u6807\u6587\u4ef6\u76f8\u4f3c\u6bb5\u7ec4\u5408\u5728\u4e00\u8d77\uff0c\u5373\u4ee3\u7801\u6bb5\u3001\u6570\u636e\u6bb5\u7b49\u90fd\u5c06\u5b83\u4eec\u5408\u5e76\u7136\u540e\u8fdb\u884c\u5206\u914d\u3002 \u8fd9\u79cd\u65b9\u6cd5\u6bd4**\u6309\u5e8f\u53e0\u52a0**\u7684\u65b9\u6cd5\u8981\u51cf\u5c11\u8bb8\u591a\u6d6a\u8d39\u7684\u7a7a\u95f4\uff0c\u4e14\u4e00\u4e2aELF\u6587\u4ef6\u4e2d\u4ee3\u7801\u6bb5\u3001\u6570\u636e\u6bb5\u7b49\u90fd\u53ea\u6709\u4e00\u4e2a\uff0c\u66f4\u6613\u67e5\u770b\uff0c\u56e0\u6b64\u94fe\u63a5\u5668\u57fa\u672c\u4f7f\u7528\u7b2c\u4e8c\u79cd\u7b56\u7565\u8fdb\u884c\u94fe\u63a5\u3002 \u4f7f\u7528\u6b64\u79cd\u7b56\u7565\u7684\u94fe\u63a5\u5668\u90fd\u91c7\u7528\u4e24\u6b65\u94fe\u63a5\u6cd5\u7684\u65b9\u6cd5\u8fdb\u884c\u94fe\u63a5\uff0c\u7b2c\u4e00\u6b65\u4e3a**\u7a7a\u95f4\u4e0e\u5730\u5740\u5206\u914d**\uff0c\u7b2c\u4e8c\u6b65\u4e3a**\u7b26\u53f7\u89e3\u6790\u4e0e\u91cd\u5b9a\u4f4d**\uff0c\u8fd9\u4e5f\u662f\u4e4b\u524d\u6240\u8bf4\u7684\u94fe\u63a5\u7684\u4e3b\u8981\u6b65\u9aa4\u3002 \u4e0a\u9762\u662f\u4e24\u79cd\u5408\u5e76\u76ee\u6807\u6587\u4ef6\u7684\u7b56\u7565\uff0c\u90a3\u4e48\u73b0\u5728\u6765\u770b\u770b\u5230\u5e95\u4ec0\u4e48\u53eb\u505a**\u5730\u5740\u4e0e\u7a7a\u95f4**\u7684\u5206\u914d\uff1f \u4e8b\u5b9e\u4e0a\u8fd9\u91cc\u7684**\u5730\u5740\u4e0e\u7a7a\u95f4**\u5305\u542b\u4e86\u4e24\u5c42\u610f\u601d\uff0c\u4e00\u4e2a\u662f\u6307**ELF\u6587\u4ef6**\u4e2d\u7684\u7a7a\u95f4\uff0c\u53e6\u4e00\u4e2a\u5c31\u662f\u6307\u6587\u4ef6\u88c5\u8f7d\u540e\u5728**\u865a\u62df\u5730\u5740**\u4e2d\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff0c\u4e24\u8005\u4e4b\u95f4\u6709\u4ec0\u4e48\u533a\u522b\u5462\uff1f\u6211\u7406\u89e3\u662f\u4e00\u4e2a\u662f\u5b58\u653e\u6587\u4ef6\u6240\u9700\u8981\u7684\u7a7a\u95f4\uff0c\u800c\u53e6\u4e00\u4e2a\u662f\u6267\u884c\u65f6\u6240\u9700\u8981\u7684\u7a7a\u95f4\u3002\u770b\u4e0bbss\u6bb5\u4e0e\u4ee3\u7801\u6bb5\u7b49\u6bb5\u7684\u533a\u522b\u5c31\u77e5\u9053\u4e86\uff0c**bss\u6bb5**\u53ea\u6709\u5728\u6267\u884c\u65f6\u624d\u4f1a\u7528\u5230\uff0c\u6240\u4ee5\u5728\u5b9e\u9645\u7684\u76ee\u6807\u6587\u4ef6\u53caELF\u6587\u4ef6\u4e2d\uff0cbss\u6bb5\u662f\u4e0d\u4f1a\u5206\u914d\u7a7a\u95f4\u7684\uff0c\u4f46\u662f\u5728\u88c5\u8f7d\u540e\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2dbss\u6bb5\u5c31\u4f1a\u4e3a\u5176\u5206\u914d\u76f8\u5e94\u7684\u7a7a\u95f4\uff0c\u800c\u4ee3\u7801\u6bb5\u5219\u4e24\u79cd\u7a7a\u95f4\u90fd\u4f1a\u5206\u914d\u3002 \u6211\u4eec\u6765\u770b\u4e0b\u4e24\u4e2a\u76ee\u6807\u6587\u4ef6\u7684\u94fe\u63a5\u8fc7\u7a0b\u4ee5\u53ca\u5176\u4e2d\u7684\u6bb5\u7684\u5730\u5740\u7a7a\u95f4\u5206\u914d\uff1a /*a.c*/ extern int shared ; int main () { int a = 100 ; swap ( & a , & shared ); } /*b.c*/ int shared = 1 ; void swap ( int * a , int * b ) { * a ^= * b ^= * a ^= * b ; } \u6211\u4eec\u4e0d\u9700\u8981\u53bb\u7ec6\u7a76\u4e24\u4e2a\u6587\u4ef6\u5230\u5e95\u5e72\u4e86\u4ec0\u4e48\uff0c\u53ea\u9700\u8981\u77e5\u9053 a.c\u4e2d\u8c03\u7528\u4e86\u5b9a\u4e49\u5728b.c\u4e2d\u7684shared\u53d8\u91cf\u4ee5\u53caswap\u51fd\u6570\uff0c\u63a5\u4e0b\u6765\u5c06\u4e24\u8005\u5206\u522b\u7f16\u8bd1\uff0c\u7136\u540e\u94fe\u63a5 gcc -c a.c b.c //\u7f16\u8bd1\u6210\u76ee\u6807\u6587\u4ef6\uff0c\u4ea7\u751fa.o\u3001b.o ld a.o b.o -e main -o ab //\u94fe\u63a5a.o\u3001b.o\u5f97\u5230\u53ef\u6267\u884c\u6587\u4ef6ab\uff0c\u5176\u4e2d-e\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u7a0b\u5e8f\u5165\u53e3\uff0cld\u7684\u9ed8\u8ba4\u7a0b\u5e8f\u5165\u53e3\u4e3a_start \u4f7f\u7528objdump\u5de5\u5177\u67e5\u770b\u94fe\u63a5\u524d\u540e\u7684\u5730\u5740\u5206\u914d\u60c5\u51b5\uff1a \u8bf4\u660e\u4e00\u4e0b\u53c2\u6570\uff0c VMA**\u4ee3\u8868**\u865a\u62df\u5730\u5740 \uff0cSize\u4ee3\u8868\u5927\u5c0f\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5173\u6ce8\u8fd9\u4e24\u5904\u5373\u53ef\u3002 \u8fd9\u91cc\u4f7f\u7528\u7684\u662f32\u4f4d\u7684Linux\u7cfb\u7edf\uff0c64\u4f4d\u4e0b\u53ef\u80fd\u60c5\u51b5\u6709\u4e9b\u4e0d\u540c\uff0c\u4e0d\u8fc7\u603b\u7684\u9053\u7406\u662f\u4e00\u6837\u7684\u3002 a.o\uff1a \u5176\u4e2d\u4ee3\u7801\u6bb5\u5927\u5c0f\u4e3a0x27\u5b57\u8282\uff0c\u6570\u636e\u6bb5\u5927\u5c0f\u4e3a0\u5b57\u8282\uff0cbss\u6bb5\u4e5f\u4e3a0\u3002 VMA\u4e3a0\u662f\u56e0\u4e3a\u5176\u662f\u76ee\u6807\u6587\u4ef6\uff0c\u865a\u62df\u7a7a\u95f4\u8fd8\u6ca1\u6709\u88ab\u5206\u914d\uff0c\u9ed8\u8ba4\u4e3a0\u3002 b.o\uff1a \u5176\u4e2d\u4ee3\u7801\u6bb5\u5927\u5c0f\u4e3a0x3a\u5b57\u8282\uff0c\u6570\u636e\u6bb5\u5927\u5c0f\u4e3a0x04\u5b57\u8282\uff0c\u6570\u636e\u6bb5\u5927\u5c0f\u4e3a0x04\u5b57\u8282\uff0cbss\u6bb5\u4e3a0\u5b57\u8282\u3002 \u6700\u540e\u6765\u770b\u94fe\u63a5\u540e\u7684ELF\u6587\u4ef6ab\uff1a \u53ef\u4ee5\u770b\u5230\uff0c\u4ee3\u7801\u6bb5\u7684\u5927\u5c0f\u4e3a0x61\u5b57\u8282\uff0c\u6570\u636e\u6bb5\u4e3a0x04\u5b57\u8282\uff0c\u662fa.o\u4e0eb.o\u4e24\u4e2a\u76ee\u6807\u6587\u4ef6\u7684\u4ee3\u7801\u6bb5\u4e0e\u6570\u636e\u6bb5\u4e4b\u548c\u3002 \u5728\u6b64\u6587\u4ef6\u4e2d\u4e5f\u53ef\u4ee5\u770b\u5230**VMA**\u6709\u4e86\u5b9e\u9645\u7684\u503c\uff0c0x08048094\u662f\u5176\u5728\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u7684**\u8d77\u59cb\u5730\u5740**\uff0c\u5176\u5b9e\u572832\u4f4d\u7684Linux\u4e2dELF\u6587\u4ef6\u9ed8\u8ba4\u5e94\u4ece\u5730\u57400x08048000\u5f00\u59cb\u5206\u914d\uff0c\u4e3a\u4ec0\u4e48\u8fd9\u91cc\u662f0x08048094\u6211\u4e5f\u4e0d\u660e\u767d\u3002\u3002\u3002 \u793a\u610f\u56fe\uff1a \u7ecf\u8fc7\u4e0a\u9762\u7684\u6b65\u9aa4\u62c6\u5206\uff0c\u5bf9\u4e8e\u5730\u5740\u548c\u7a7a\u95f4\u7684\u5206\u914d\u5e94\u8be5\u6709\u4e00\u4e2a\u76f4\u89c2\u7684\u4e86\u89e3\u4e86\uff0c\u603b\u7ed3\u4e00\u4e0b\uff0c\u5176\u5b9e\u5c31\u662f\u5c06\u76ee\u6807\u6587\u4ef6\u6309\u76f8\u4f3c\u6bb5\u5408\u5e76\u7684\u7b56\u7565\u5408\u5e76\u540e\u8ba1\u7b97\u5176\u6bcf\u4e2a\u6bb5\u7684\u957f\u5ea6\u3001\u5c5e\u6027\uff0c\u8fdb\u800c\u5bf9\u5176\u8fdb\u884c\u5730\u5740\u5206\u914d\u3002","title":"1\u3001\u5730\u5740\u4e0e\u7a7a\u95f4\u5206\u914d"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/#2_1","text":"\u4e4b\u524d\u8bf4\u8fc7\u7684\u4e24\u90e8\u94fe\u63a5\u6cd5\uff0c\u524d\u9762\u8bf4\u4e86\u7a7a\u95f4\u4e0e\u5730\u5740\u5206\u914d\uff0c\u73b0\u5728\u89e3\u91ca\u4ec0\u4e48\u53eb\u505a**\u7b26\u53f7\u89e3\u6790\u4e0e\u91cd\u5b9a\u4f4d**\uff0c\u8fd9\u662f\u9759\u6001\u94fe\u63a5\u7684\u6838\u5fc3\u5185\u5bb9\u3002 \u9996\u5148\u89e3\u91ca\u4ec0\u4e48\u53eb\u505a**\u91cd\u5b9a\u4f4d** \u94fe\u63a5\u65f6\u6839\u636e\u7b26\u53f7\u627e\u5bfb\u76f8\u5e94\u6a21\u5757\u4e2d\u7684\u5730\u5740\uff0c\u7136\u540e\u5c06\u5730\u5740\u5168\u90e8\u4fee\u6b63\uff0c\u5c31\u662f**\u91cd\u5b9a\u4f4d**\u3002\u800c\u4fee\u6b63\u7684\u5730\u65b9\u5c31\u79f0\u4e3a**\u91cd\u5b9a\u4f4d\u5165\u53e3**\u3002 \u7b80\u5355\u7684\u6765\u8bf4\uff0c\u6211\u4eec\u5728\u7f16\u8bd1a.c\u6587\u4ef6\u5f97\u5230a.o\u6587\u4ef6\u65f6\uff0c\u6240\u4f7f\u7528\u7684shared\u53d8\u91cf\u4ee5\u53caswap\u51fd\u6570\uff0c\u7f16\u8bd1\u5668\u5bf9\u5b83\u4eec\u4e00\u65e0\u6240\u77e5\uff0c\u4e0d\u77e5\u9053\u4f4d\u7f6e\u4e5f\u4e0d\u77e5\u9053\u5b83\u4eec\u505a\u4e86\u4ec0\u4e48\uff0c\u7f16\u8bd1\u5668\u7f16\u8bd1\u65f6\u5047\u8bbe\u5b83\u4eec\u5728\u522b\u7684\u6587\u4ef6\u4e2d\uff0c\u5c31\u5148\u4e0d\u7ba1\u5b83\u4eec\uff0c\u5728\u76f8\u5e94\u7684\u5730\u5740\u4f4d\u7f6e\u4e0a\u586b\u5145\u9519\u8bef\u5730\u5740\u3002\u90a3\u4e48\u5728\u94fe\u63a5\u7684\u8fc7\u7a0b\u4e2d\u7531\u4e8e\u4e0b\u4e00\u6b65\u8981\u76f4\u63a5\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u5c31\u4e0d\u80fd\u518d\u653e\u4efb\u8fd9\u4e9b\u95ee\u9898\uff0c\u4e5f\u5c31\u662f\u8981\u627e\u5230\u5b83\u4eec\u5b9a\u4e49\u7684\u4f4d\u7f6e\u5bf9\u9519\u8bef\u5730\u5740\u8fdb\u884c\u4fee\u6b63\uff0c\u4ece\u800c\u6b63\u786e\u6267\u884c\u3002 \u4e3a\u4e86\u5bf9\u8fd9\u6b65\u8fdb\u884c\u7406\u89e3\uff0c\u5bf9a.o\u4e0eab\u53ef\u6267\u884c\u6587\u4ef6\u8fdb\u884c\u53cd\u6c47\u7f16\uff1a a.o\uff1a \u5176\u4e2d\u6709\u4e24\u4e2a**\u91cd\u5b9a\u4f4d\u5165\u53e3**\uff0c\u5c31\u662f\u6807\u8bb015\u4e0e21\u7684\u5730\u65b9\uff0c\u53ef\u4ee5\u770b\u5230\u4ece15\u5f00\u59cb\u5230\u4e0b\u4e00\u6b65\u6307\u4ee4\u4e4b\u95f4\u5177\u4f53\u4e3a0x00000000\uff0c\u8868\u793ashared\u53d8\u91cf\u7684\u5730\u5740\u662f0x00000000\uff0c\u5f88\u660e\u663e\u9519\u8bef\u3002\u800c21\u5f00\u59cb\u7684\u5b57\u8282\u4e3a0xfc ff ff ff\uff0c\u8fd9\u91cc\u76840xfc ff ff ff\u662f\u7528\u5c0f\u7aef\u65b9\u5f0f\u4fdd\u5b58\u7684\uff0c\u8bfb\u53d6\u51fa\u6765\u7684\u503c\u5e94\u4e3a0xff ff ff fc\uff0c\u8868\u793a\u503c\u4e3a-3\uff0c\u8fd9\u91cc\u6240\u8bb0\u5f55\u7684\u503c\u5e94\u4e3acall\u8fd9\u6761\u6307\u4ee4\u6240\u8df3\u8f6c\u7684\u76ee\u6807\u5730\u5740\u4e0e\u5176\u4e0b\u4e00\u6761\u6307\u4ee4\u5730\u5740\u7684\u504f\u79fb\u91cf\uff0c\u8fd9\u91cc\u504f\u79fb-3\u5373\u8df3\u8f6c\u5730\u5740\u4e3a21\uff0c\u90a3\u4e48\u80af\u5b9a\u9519\u8bef\u3002 ab\uff1a \u94fe\u63a5\u540e\u7684ab\u53ef\u6267\u884c\u6587\u4ef6\u4e2d\uff0c\u53ef\u4ee5\u770b\u5230\u539f\u672c\u6807\u8bb0\u7684\u91cd\u5b9a\u4f4d\u5165\u53e3\u5904\u7684\u5730\u5740\u90fd\u88ab\u4fee\u6539\uff0c0x00000000\u6539\u4e3a0x08049154\uff0c\u6839\u636e\u524d\u9762\u6211\u4eec\u5bf9ab\u8fd9\u4e2a\u6587\u4ef6\u865a\u62df\u5730\u5740\u7a7a\u95f4\u6240\u753b\u7684\u793a\u610f\u56fe\u53ef\u4ee5\u770b\u51fa\uff0c\u4f4d\u4e8e\u6570\u636e\u6bb5\u4e2d\u3002\u800c\u53e6\u4e00\u4e2a0xfc ff ff ff \u6539\u4e3a\u4e860x 02 00 00 00\uff0c\u6309\u7167\u521a\u624d\u7684\u5c0f\u7aef\u65b9\u5f0f\u6765\u8bfb\u5373\u504f\u79fb\u91cf\u4e3a2\uff0c\u5373\u6240\u8df3\u8f6c\u7684\u5730\u5740\u4e0e\u5176\u4e0b\u4e00\u6b65\u7684\u6307\u4ee4\u5730\u5740\u7684\u504f\u79fb\u91cf\u4e3a2\uff0c\u53ef\u5f97\u51faswap\u51fd\u6570\u7684\u8d77\u59cb\u5730\u5740\u4e3a0x080480b9+0x00000002=0x080480bb\uff0c\u5728\u56fe\u4e2d\u53ef\u4ee5\u770b\u5230\u6b63\u662fswap\u7684\u8d77\u59cb\u5730\u5740\u3002 \u6839\u636e\u4e0a\u9762\u7684\u8fc7\u7a0b\u5bf9\u4e8e\u91cd\u5b9a\u4f4d\u7684\u6982\u5ff5\u5e94\u8be5\u5df2\u7ecf\u4e86\u89e3\u4e86\uff0c\u5176\u5b9e\u5c31\u662f\u5728\u8f93\u5165\u7684\u76ee\u6807\u6587\u4ef6\u4e2d\u627e\u5bfb\u9700\u8981\u91cd\u5b9a\u4f4d\u5373\u5730\u5740\u9519\u8bef\u7684\u5730\u65b9\uff0c\u5c06\u5176\u5730\u5740\u8fdb\u884c\u4fee\u6b63\u3002 \u90a3\u4e48**\u94fe\u63a5\u5668**\u5982\u4f55\u77e5\u9053\u54ea\u4e9b\u5730\u65b9\u9700\u8981\u88ab\u4fee\u6b63\uff1f\u7b54\u6848\u662f**\u91cd\u5b9a\u4f4d\u8868**\uff0c\u8fd9\u662f\u5728ELF\u6587\u4ef6\u4e2d\u7684\u4e00\u4e2a\u7ed3\u6784\uff0c\u4e13\u95e8\u7528\u6765\u4fdd\u5b58\u4e0e\u91cd\u5b9a\u4f4d\u76f8\u5173\u7684\u4fe1\u606f\u3002\u6bcf\u4e00\u4e2a\u9700\u8981\u88ab\u91cd\u5b9a\u4f4d\u7684**\u6bb5**\u90fd\u6709\u7740\u5176**\u91cd\u5b9a\u4f4d\u8868**\uff0c\u4e00\u4e2a**\u91cd\u5b9a\u4f4d\u8868**\u5f80\u5f80\u5c31\u662f\u4e00\u4e2aELF\u6587\u4ef6\u4e2d\u7684\u6bb5\uff0c\u90a3\u4e48\u5c31\u53ef\u80fd\u4f1a\u6709\u591a\u4e2a\u91cd\u5b9a\u4f4d\u6bb5\uff0c\u4e3e\u4e2a\u4f8b\u5b50\uff1a\u5982\u679c.text\u6bb5\u4e0e.data\u6bb5\u90fd\u8981\u91cd\u5b9a\u4f4d\uff0c\u90a3\u4e48\u5c31\u4f1a\u5b58\u5728.rel.text\u4ee5\u53ca.rel.data\u4e24\u4e2a\u6bb5\u3002 \u6211\u4eec\u6765\u770b\u770b\u91cd\u5b9a\u4f4d\u8868\uff0c\u4ee5\u5bf9\u5176\u6709\u4e2a\u76f4\u89c2\u7684\u4e86\u89e3\uff1a \u5bf9\u4e8e.eh_frame\u8fd9\u6bb5\u6211\u4eec\u4e0d\u8ba8\u8bba\uff0c\u8fd9\u5e94\u8be5\u662f\u8f85\u52a9\u6bb5\u3002\u53ef\u4ee5\u770b\u5230.text\u6bb5\u7684\u91cd\u5b9a\u4f4d\u8868\u4e2d\u6709\u4e24\u4e2a**\u91cd\u5b9a\u4f4d\u5165\u53e3**shared\u4e0eswap\uff0c**\u94fe\u63a5\u5668**\u4e5f\u6b63\u662f\u6839\u636e\u91cd\u5b9a\u4f4d\u8868\u6765\u5bf9a.o\u6587\u4ef6\u4e2d\u7684shared\u4e0eswap\u8fdb\u884c\u6807\u8bb0\u5e76\u4ee5\u6b64\u8fdb\u884c**\u91cd\u5b9a\u4f4d**\u7684\u3002 \u4e0a\u9762\u8bf4\u4e86\u91cd\u5b9a\u4f4d\uff0c\u90a3\u4e48\u5c31\u5269\u4e0b**\u7b26\u53f7\u89e3\u6790**\u4e86 \u5176\u5b9e\u5bf9\u4e8e**\u7b26\u53f7\u89e3\u6790**\u7684\u8fc7\u7a0b\u4e00\u76f4\u90fd\u4f34\u968f\u7740**\u91cd\u5b9a\u4f4d**\u7684\u8fc7\u7a0b\uff0c\u6211\u7406\u89e3\u7b26\u53f7\u89e3\u6790\u7b80\u5355\u6765\u8bf4\u901a\u8fc7**\u5168\u5c40\u7b26\u53f7\u8868**\u8981\u80fd\u5f97\u77e5\u4e00\u4e2a\u7b26\u53f7\u5b83\u7684\u5c5e\u6027\u3001\u5730\u5740\u3001\u5927\u5c0f\u3001\u4f5c\u7528\u5206\u522b\u662f\u4ec0\u4e48\uff0c\u5982\u679c\u65e0\u6cd5\u5f97\u77e5\uff0c\u90a3\u4e48\u65e0\u6cd5\u8fdb\u884c\u7b26\u53f7\u89e3\u6790\u3002 \u5176\u5b9e\u91cd\u5b9a\u4f4d\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u4e00\u4e2a**\u91cd\u5b9a\u4f4d\u5165\u53e3**\u90fd\u662f\u5bf9\u4e00\u4e2a**\u7b26\u53f7**\u7684\u5f15\u7528\uff0c\u94fe\u63a5\u5668\u8fd9\u4e2a**\u7b26\u53f7**\u7684\u5f15\u7528\u8fdb\u884c\u91cd\u5b9a\u4f4d\u65f6\uff0c\u5c31\u8981\u786e\u5b9a\u6b64\u7b26\u53f7\u7684**\u76ee\u6807\u5730\u5740**\uff0c\u5c31\u9700\u8981\u53bb\u67e5\u8be2**\u5168\u5c40\u7b26\u53f7\u8868**\u4e2d\u76f8\u5e94\u7684\u7b26\u53f7\u6765\u83b7\u5f97\u76ee\u6807\u5730\u5740\uff0c\u4ece\u800c\u91cd\u5b9a\u4f4d \u6211\u4eec\u5148\u6765\u770b\u770ba.o\u7684\u7b26\u53f7\u8868\uff1a \u6211\u4eec\u5173\u6ce8\u4e00\u4e0b\u6700\u4e0b\u9762\u7684shared\u53caswap\u7b26\u53f7\uff0c\u53ef\u4ee5\u770b\u5230\u4e24\u4e2a\u7684Ndx\u9879\u90fd\u662fUND\uff0c\u8fd9\u8868\u793aundefined\u5373\u672a\u5b9a\u4e49\u7c7b\u578b\uff0c\u8fd9\u79cd\u672a\u5b9a\u4e49\u7684\u7b26\u53f7\u662f\u56e0\u4e3a\u6b64\u76ee\u6807\u6587\u4ef6\u4e2d\u6709\u5b83\u4eec\u7684\u91cd\u5b9a\u4f4d\u9879\u3002\u6211\u4eec\u76f4\u63a5\u5bf9a.o\u6587\u4ef6\u8fdb\u884c\u94fe\u63a5\uff0c\u770b\u770b\u7ed3\u679c\uff1a \u51fa\u73b0\u9519\u8bef\uff0cshared\u548cswap\u672a\u5b9a\u4e49\uff0c\u90a3\u4e48\u53ef\u4ee5\u60f3\u8c61\u4e00\u4e0b\u62a5\u9519\u7684\u6574\u4e2a\u8fc7\u7a0b\uff1a\u94fe\u63a5\u5668\u626b\u63cf\u4e86\u6240\u6709\u7684\u8f93\u5165\u6587\u4ef6\u540e\uff0c\u8fd9\u4e9b\u672a\u5b9a\u4e49\u7684\u7b26\u53f7\u4e0d\u80fd\u518d\u5168\u5c40\u7b26\u53f7\u8868\u4e2d\u627e\u5230\uff0c\u90a3\u4e48\u5c31\u4f1a\u62a5\u672a\u5b9a\u4e49\u7684\u9519\u8bef\u3002","title":"2\u3001\u7b26\u53f7\u89e3\u6790\u4e0e\u91cd\u5b9a\u4f4d"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/","text":"\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff08virtual memory area,VMA\uff09 \u7406\u89e3\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4 \u6211\u4eec\u77e5\u9053\u6211\u4eec\u7f16\u5199\u7684**\u5e94\u7528\u7a0b\u5e8f**\u6700\u7ec8\u8981\u4ee5**\u8fdb\u7a0b**\u7684\u5f62\u5f0f\u6765\u8fd0\u884c\uff0c\u4efb\u4f55\u4e00\u4e2a**\u8fdb\u7a0b**\u90fd\u88ab\u8d4b\u4e88\u5176\u81ea\u5df1\u7684**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\uff0c\u8be5**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u8986\u76d6\u4e86\u4e00\u4e2a\u76f8\u5f53\u5927\u7684\u8303\u56f4\uff0c\u5bf9\u4e8e32\u4f4d\u64cd\u4f5c\u7cfb\u7edf\uff0c\u5176\u8fdb\u7a0b\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u4e3a 2^{32}=4,294,967,296 2^{32}=4,294,967,296 Byte\uff0c\u8fd9\u4f7f\u5f97\u4e00\u4e2a**\u6307\u9488**\u53ef\u4ee5\u4f7f\u7528\u4ece 0x00000000 \u5230 0xFFFFFFFF \u76844GB\u8303\u56f4\u4e4b\u5185\u7684\u4efb\u4f55\u4e00\u4e2a\u503c\u3002\u867d\u7136\u6bcf\u4e00\u4e2a32\u4f4d\u8fdb\u7a0b\u53ef\u4f7f\u7528**4GB**\u7684**\u5730\u5740\u7a7a\u95f4**\uff0c\u4f46\u5e76\u4e0d\u610f\u5473\u7740\u6bcf\u4e00\u4e2a\u8fdb\u7a0b**\u5b9e\u9645**\u62e5\u6709 4GB \u7684**\u7269\u7406\u5730\u5740\u7a7a\u95f4**\uff0c\u8be5\u5730\u5740\u7a7a\u95f4\u4ec5\u4ec5\u662f\u4e00\u4e2a**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\uff0c\u5b83\u662f\u4e00\u4e2a\u903b\u8f91\u4e0a\u7684\u8bbe\u8ba1\u3002\u6b64**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u53ea\u662f\u5185\u5b58\u5730\u5740\u7684\u4e00\u4e2a\u8303\u56f4\u3002\u8fdb\u7a0b\u5b9e\u9645\u53ef\u4ee5\u5f97\u5230\u7684**\u7269\u7406\u5185\u5b58**\u8981\u8fdc\u5c0f\u4e8e\u5176**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u3002\u8fdb\u7a0b\u7684**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u662f\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u6240\u79c1\u6709\u7684\uff0c\u5728\u8fdb\u7a0b\u5185\u8fd0\u884c\u7684**\u7ebf\u7a0b**\u5bf9**\u5185\u5b58\u7a7a\u95f4**\u7684\u8bbf\u95ee\u90fd\u88ab\u9650\u5236\u5728**\u8c03\u7528\u8fdb\u7a0b**\u4e4b\u5185\uff0c\u800c\u4e0d\u80fd\u8bbf\u95ee\u5c5e\u4e8e\u5176\u4ed6\u8fdb\u7a0b\u7684\u5185\u5b58\u7a7a\u95f4\u3002\u8fd9\u6837\uff0c\u5728\u4e0d\u540c\u7684\u8fdb\u7a0b\u4e2d\u53ef\u4ee5\u4f7f\u7528\u76f8\u540c\u5730\u5740\u7684\u6307\u9488\u6765\u6307\u5411\u5c5e\u4e8e\u5404\u81ea\u8c03\u7528\u8fdb\u7a0b\u7684\u5185\u5bb9\u800c\u4e0d\u4f1a\u7531\u6b64\u5f15\u8d77\u6df7\u4e71\u3002 \u901a\u8fc7\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u63cf\u8ff0\uff0c\u53ef\u4ee5\u77e5\u9053\u8fdb\u7a0b\u4f7f\u7528\u7684\u5168\u90e8\u8d44\u6e90\u662f\u2019\u865a\u62df\u2018\u7684\uff0c\u6211\u4eec\u77e5\u9053\u6211\u4eec\u7f16\u5199\u7684**\u5e94\u7528\u7a0b\u5e8f**\u6700\u7ec8\u8981\u4ee5**\u8fdb\u7a0b**\u7684\u5f62\u5f0f\u6765\u8fd0\u884c\uff0c\u56e0\u800c\u8fdb\u7a0b\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e2a\u865a\u62df\u673a\uff08\u865a\u62df\u7684\u8ba1\u7b97\u673a\uff09\uff0c\u6240\u4ee5\u6211\u4eec\u5f88\u5bb9\u6613\u611f\u53d7\u5230\u81ea\u5df1\u7f16\u5199\u7684\u5e94\u7528\u7a0b\u5e8f\u4f3c\u4e4e\u4f7f\u7528\u7684\u662f\u6240\u6709\u7684\u8ba1\u7b97\u673a\u8d44\u6e90\uff0c32bit\u7684\u8ba1\u7b97\u673a\u6211\u4eec\u8fdb\u7a0b\u4f3c\u4e4e\u5c31\u662f\u4f7f\u7528\u5b8c\u6574\u76844G\u5185\u5b58\uff0c\u4f46\u662f\u5bf9\u7cfb\u7edf\u7a0d\u6709\u4e86\u89e3\uff0c\u6211\u4eec\u5c31\u77e5\u9053\u4e00\u4e2a\u8fdb\u7a0b\u4f7f\u7528\u7684\u7269\u7406\u5185\u5b58\u5b9e\u9645\u53ef\u80fd\u4e0d\u5230\u51e0\u767em\u751a\u81f3\u51e0m\uff01\u8fd9\u5c31\u662f\u4e00\u79cd\u865a\u62df\uff0c \u8fdb\u7a0b\u4f7f\u7528\u7684\u662f\u865a\u62df\u7684\u5168\u90e8\u8ba1\u7b97\u673a\u8d44\u6e90 \uff01\u56de\u6765\u518d\u770b\u5185\u5b58\uff0c\u5b9e\u9645\u4e0a\u4f7f\u7528\u51e0m\u7684\u5185\u5b58\uff0c\u4f46\u6bcf\u4e2a\u8fdb\u7a0b\u7684\u865a\u62df\u5185\u5b58\u5374\u662f4G\uff01\u8fd9\u5c31\u662f\u865a\u62df\u5185\u5b58\u7684\u5965\u5999\uff01 \u865a\u62df\u5185\u5b58\u7a7a\u95f4\uff08virtual memory area,VMA\uff09\uff0c\u4e5f\u79f0\u4f5c\u7ebf\u6027\u533a\u3002\u865a\u62df\u5b58\u50a8\u5668\u662f\u4e00\u4e2a\u62bd\u8c61\u6982\u5ff5\uff0c\u5b83\u4e3a\u6bcf\u4e00\u4e2a\u8fdb\u7a0b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5047\u8c61\uff0c\u597d\u50cf\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u5728\u72ec\u5360\u7684\u4f7f\u7528\u4e3b\u5b58\u3002\u6bcf\u4e2a\u8fdb\u7a0b\u770b\u5230\u7684\u5b58\u50a8\u5668\u90fd\u662f\u4e00\u81f4\u7684\uff0c\u79f0\u4e4b\u4e3a\u865a\u62df\u5730\u5740\u7a7a\u95f4\u3002 Linux\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u5e03\u5c40 \u572832 bit\u7cfb\u7edf\u4e2d\uff0c\u5185\u6838\u5206\u914d1GB\uff0c\u800c\u5404\u4e2a\u7528\u6237\u7a7a\u95f4\u8fdb\u7a0b\u53ef\u7528\u7684\u90e8\u5206\u4e3a3GB\u3002 \u4e0b\u56fe\u5c55\u793a\u4e86\u4e00\u4e2a32\u4f4d\u7cfb\u7edf\u7684\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5e03\u5c40\uff1a \u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7531\u82e5\u5e72\u4e2a\u533a\u57df\u7ec4\u6210\uff1a 1.\u5f53\u524d\u8fd0\u884c\u4ee3\u7801\u7684\u4e8c\u8fdb\u5236\u4ee3\u7801.text\u6bb5\u3002 2.\u7a0b\u5e8f\u4f7f\u7528\u7684\u52a8\u6001\u5e93\u4ee3\u7801\u3002 3.\u5b58\u50a8**\u533a\u5c40\u53d8\u91cf**\u548c**\u9759\u6001\u53d8\u91cf**\u7684\u6570\u636e\u6bb5\uff0cbss,data\u6bb5 4.\u4fdd\u5b58\u52a8\u6001\u5206\u914d\u6570\u636e\u7684\u5806 5.\u4fdd\u5b58\u5c40\u90e8\u53d8\u91cf\u548c\u5b9e\u73b0**\u51fd\u6570\u8c03\u7528**\u7684\u6808 6.\u73af\u5883\u53d8\u91cf\u548c\u547d\u4ee4\u884c\u53c2\u6570\u3002 7.\u6587\u4ef6\u5185\u5bb9\u6620\u5c04\u5230\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5185\u5b58\u6620\u5c04\u3002 \u5982\u679c\u5168\u5c40\u53d8\u91cf randomize_va_space \u8bbe\u7f6e\u4e3a 1 \uff0c\u90a3\u4e48\u542f\u7528\u5730\u5740**\u7a7a\u95f4\u968f\u673a\u5316\u673a\u5236**\uff08\u4e0a\u56fe\u7684 ramdom xxx offset \uff09\u3002\u7528\u6237\u53ef\u4ee5\u901a\u8fc7 /proc/sys/kernel/randomize_va_space \u505c\u7528\u8be5\u7279\u6027\u3002 \u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709mm_struct(linux/mm_types.h)\u7684\u5b9e\u4f8b\uff0c\u4fdd\u5b58**\u8fdb\u7a0b\u865a\u62df\u5185\u5b58\u7ba1\u7406\u4fe1\u606f**\u3002 struct mm_struct { struct vm_area_struct * mmap ; /* list of VMAs */ struct rb_root mm_rb ; #ifdef CONFIG_MMU unsigned long ( * get_unmapped_area ) ( struct file * filp , unsigned long addr , unsigned long len , unsigned long pgoff , unsigned long flags ); #endif unsigned long mmap_base ; /* base of mmap area */ \u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u7528\u4e8e\u5185\u5b58\u6620\u5c04\u7684\u8d77\u59cb\u5730\u5740\u3002 unsigned long mmap_legacy_base ; /* base of mmap area in bottom-up allocations */ unsigned long task_size ; /* size of task vm space */ \u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u7684 size . struct list_head mmlist ; /* List of maybe swapped mm's. These are globally strung unsigned long start_code, end_code, start_data, end_data;//text\u6bb5\uff0c\u6570\u636e\u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ec8\u6b62\u5730\u5740 unsigned long start_brk, brk, start_stack;//\u5806\u9996\u5730\u5740\uff0c\u5806\u5c3e\u5730\u5740\uff0c\u6808\u9996\u5730\u5740\u3002 unsigned long arg_start, arg_end, env_start, env_end;//\u547d\u4ee4\u884c\u53c2\u6570\uff0c\u73af\u5883\u53d8\u91cf\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ec8\u6b62\u5730\u5740 .... }; **\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u7531\u591a\u4e2a VMA \u7ec4\u6210\uff08 struct mm_struct \u4e2d struct vm_area_struct \\*mmap;/* list of VMAs */ \u6210\u5458\uff09\u3002\u6709\u4e24\u79cd\u7ec4\u7ec7 VMA \u7684\u65b9\u5f0f\uff0c\u94fe\u8868\uff08 mmap \uff09\u548c\u7ea2\u9ed1\u6811\uff08 mm_rb \uff09 VMA\u7ed3\u6784\u4f53\u5982\u4e0b\uff1a struct vm_area_struct { \u3000\u3000 /* The first cache line has the info for VMA tree walking. */ \u3000\u3000 unsigned long vm_start ; /* Our start address within vm_mm. */ \u3000\u3000 unsigned long vm_end ; /* The first byte after our end address within vm_mm. */ \u3000\u3000 /* linked list of VM areas per task, sorted by address */ \u3000\u3000 struct vm_area_struct * vm_next , * vm_prev ; \u3000\u3000 struct rb_node vm_rb ; \u3000\u3000 struct mm_struct * vm_mm ; /* The address space we belong to. */ \u3000\u3000 /* Function pointers to deal with this struct. */ \u3000\u3000 const struct vm_operations_struct * vm_ops ; \u3000\u3000 struct file * vm_file ; /* File we map to (can be NULL). */ \u3000\u3000 void * vm_private_data ; /* was vm_pte (shared mem) */ }; VMA\u94fe\u8868\u7ec4\u7ec7\u5f62\u5f0f\u5982\u4e0b\u56fe\uff1a VMA\u7ea2\u9ed1\u6811\u7ec4\u7ec7\u5f62\u5f0f\u5982\u4e0b\uff1a \u8f93\u51fa\u5730\u5740\u7a7a\u95f4 \u539f\u6587\u94fe\u63a5\uff1a https://blog.csdn.net/zhongjiekangping/article/details/6910211 #include <stdio.h> #include <stdlib.h> int global_init_a = 1 ; int global_uninit_a ; static int static_global_init_a = 1 ; static int static_global_uninit_a ; const int const_global_a = 1 ; int global_init_b = 1 ; int global_uninit_b ; static int static_global_init_b = 1 ; static int static_global_uninit_b ; const int const_global_b = 1 ; /*\u4e0a\u9762\u5168\u90e8\u4e3a\u5168\u5c40\u53d8\u91cf\uff0cmain\u51fd\u6570\u4e2d\u7684\u4e3a\u5c40\u90e8\u53d8\u91cf*/ int main () { int local_init_a = 1 ; int local_uninit_a ; static int static_local_init_a = 1 ; static int static_local_uninit_a ; const int const_local_a = 1 ; int local_init_b = 1 ; int local_uninit_b ; static int static_local_init_b = 1 ; static int static_local_uninit_b ; const int const_local_b = 1 ; int * malloc_p_a ; malloc_p_a = malloc ( sizeof ( int )); //\u5c06\u4e0a\u9762\u5b9a\u4e49\u7684\u53d8\u91cf\u5168\u90e8\u90fd\u6253\u5370\u51fa\u6765 printf ( \" \\n &global_init_a=%p \\t global_init_a =% d \\ n \",&global_init_a,global_init_a); printf ( \" &global_uninit_a=%p \\t global_uninit_a =% d \\ n \",&global_uninit_a,global_uninit_a); printf ( \" &static_global_init_a=%p \\t static_global_init_a =% d \\ n \",&static_global_init_a,static_global_init_a); printf ( \"&static_global_uninit_a=%p \\t static_global_uninit_a =% d \\ n \",&static_global_uninit_a,static_global_uninit_a); printf ( \" &const_global_a=%p \\t const_global_a =% d \\ n \",&const_global_a,const_global_a); printf ( \" \\n &global_init_b=%p \\t global_init_b =% d \\ n \",&global_init_b,global_init_b); printf ( \" &global_uninit_b=%p \\t global_uninit_b =% d \\ n \",&global_uninit_b,global_uninit_b); printf ( \" &static_global_init_b=%p \\t static_global_init_b =% d \\ n \",&static_global_init_b,static_global_init_b); printf ( \"&static_global_uninit_b=%p \\t static_global_uninit_b =% d \\ n \",&static_global_uninit_b,static_global_uninit_b); printf ( \" &const_global_b=%p \\t const_global_b =% d \\ n \",&const_global_b,const_global_b); printf ( \" \\n &local_init_a=%p \\t local_init_a =% d \\ n \",&local_init_a,local_init_a); printf ( \" &local_uninit_a=%p \\t local_uninit_a =% d \\ n \",&local_uninit_a,local_uninit_a); printf ( \" &static_local_init_a=%p \\t static_local_init_a =% d \\ n \",&static_local_init_a,static_local_init_a); printf ( \" &static_local_uninit_a=%p \\t static_local_uninit_a =% d \\ n \",&static_local_uninit_a,static_local_uninit_a); printf ( \" &const_local_a=%p \\t const_local_a =% d \\ n \",&const_local_a,const_local_a); printf ( \" \\n &local_init_b=%p \\t local_init_b =% d \\ n \",&local_init_b,local_init_b); printf ( \" &local_uninit_b=%p \\t local_uninit_b =% d \\ n \",&local_uninit_b,local_uninit_b); printf ( \" &static_local_init_b=%p \\t static_local_init_b =% d \\ n \",&static_local_init_b,static_local_init_b); printf ( \" &static_local_uninit_b=%p \\t static_local_uninit_b =% d \\ n \",&static_local_uninit_b,static_local_uninit_b); printf ( \" &const_local_b=%p \\t const_local_b =% d \\ n \",&const_local_b,const_local_b); printf ( \" malloc_p_a=%p \\t * malloc_p_a =% d \\ n \",malloc_p_a,*malloc_p_a); return 0 ; } \u4e0b\u9762\u662f\u8f93\u51fa\u7ed3\u679c\u3002 \u5148\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b\u4e0a\u9762\u7684\u8f93\u51fa\u7ed3\u679c\uff0c\u770b\u770b\u80fd\u5f97\u51fa\u4ec0\u4e48\u7ed3\u8bba\u3002\u8c8c\u4f3c\u5f88\u96be\u5206\u6790\u51fa\u6765\u4ec0\u4e48\u7ed3\u679c\u3002\u597d\u4e86\u6211\u4eec\u7ee7\u7eed\u5f80\u4e0b\u770b\u5427\u3002 \u63a5\u4e0b\u6765\uff0c\u901a\u8fc7\u67e5\u770b**proc\u6587\u4ef6\u7cfb\u7edf**\u4e0b\u7684\u6587\u4ef6\uff0c\u770b\u4e00\u4e0b\u8fd9\u4e2a\u8fdb\u7a0b\u7684**\u771f\u5b9e\u5185\u5b58\u5206\u914d\u60c5\u51b5**\u3002\uff08\u6211\u4eec\u9700\u8981\u5728\u7a0b\u5e8f\u7ed3\u675f\u524d\u52a0\u4e00\u4e2a\u6b7b\u5faa\u73af\uff0c\u4e0d\u8ba9\u8fdb\u7a0b\u7ed3\u675f\uff0c\u4ee5\u4fbf\u6211\u4eec\u8fdb\u4e00\u6b65\u5206\u6790\uff09\u3002 \u200b \u5728 return 0 \u524d\uff0c\u589e\u52a0 while(1); \u8bed\u53e5\u3002 \u91cd\u65b0\u7f16\u8bd1\u540e\uff0c\u8fd0\u884c\u7a0b\u5e8f\uff0c\u7a0b\u5e8f\u5c06\u8fdb\u5165\u6b7b\u5faa\u73af\u3002 \u4f7f\u7528ps\u547d\u4ee4\u67e5\u770b\u4e00\u4e0b\u8fdb\u7a0b\u7684pid\u3002 ps -aux | grep a.out \u67e5\u770b /proc/2699/maps \u6587\u4ef6\uff0c\u8fd9\u4e2a\u6587\u4ef6\u663e\u793a\u4e86\u8fdb\u7a0b\u5728\u5185\u5b58\u7a7a\u95f4\u4e2d\u5404\u4e2a\u533a\u57df\u7684\u5206\u914d\u60c5\u51b5\u3002 cat /proc/2699/maps \u4e0a\u9762\u7ea2\u989c\u8272\u6807\u51fa\u7684\u51e0\u4e2a\u533a\u95f4\u662f\u6211\u4eec\u611f\u5174\u8da3\u7684\u533a\u95f4\uff1a 08048000-08049000 r-xp \u8c8c\u4f3c\u662f\u4ee3\u7801\u6bb5 08049000-0804a000 r--p \u6682\u65f6\u4e0d\u6e05\u695a\uff0c\u770b\u4e0d\u51fa\u6765 0804a000-0804b000 rw-p \u8c8c\u4f3c\u4e3a\u6570\u636e\u6bb5 08a7e000-08a9f000 rw-p \u5806 bff73000-bff88000 rw-p \u6808 \u6211\u4eec\u628a\u8fd9\u4e9b\u6570\u636e\u4e0e\u6700\u540e\u4e00\u6b21\u7684\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u679c\u8fdb\u884c\u6bd4\u8f83\uff0c\u770b\u770b\u6709\u4ec0\u4e48\u7ed3\u8bba\u3002 \u200b &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_a=0 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_a=0 \u200b &const_global_a=0x80487c0 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u4ee3\u7801\u6bb5 const_global_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_b=0 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_b=0 \u200b &const_global_b=0x80487c4 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u4ee3\u7801\u6bb5 const_global_b=1 \u200b &local_init_a=0xbff8600c \u5c40\u90e8\u521d\u59cb\u5316\uff1a\u6808 local_init_a=1 \u200b &local_uninit_a=0xbff86008 \u5c40\u90e8\u672a\u521d\u59cb\u5316\uff1a\u6808 local_uninit_a=134514459 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_a=0 \u200b &const_local_a=0xbff86004 \u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff1a\u6808 const_local_a=1 \u200b &local_init_b=0xbff86000 \u5c40\u90e8\u521d\u59cb\u5316\uff1a\u6808 local_init_b=1 \u200b &local_uninit_b=0xbff85ffc \u5c40\u90e8\u672a\u521d\u59cb\u5316\uff1a\u6808 local_uninit_b=-1074241512 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_b=0 \u200b &const_local_b=0xbff85ff8 \u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff1a\u6808 const_local_b=1 \u200b p_chars=0x80487c8 \u5b57\u7b26\u4e32\u5e38\u91cf\uff1a\u4ee3\u7801\u6bb5 p_chars=abcdef \u200b malloc_p_a=0x8a7e008 malloc\u52a8\u6001\u5206\u914d\uff1a\u5806 *malloc_p_a=0 \u901a\u8fc7\u4ee5\u4e0a\u5206\u6790\u6211\u4eec\u6682\u65f6\u53ef\u4ee5\u5f97\u5230\u7684\u7ed3\u8bba\u5982\u4e0b\uff0c \u5728\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u4e2d \uff1a \u6570\u636e\u6bb5**\u4e2d\u5b58\u653e\uff1a**\u5168\u5c40\u53d8\u91cf \uff08\u521d\u59cb\u5316\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff09\u3001 \u9759\u6001\u53d8\u91cf \uff08\u5168\u5c40\u7684\u548c\u5c40\u90e8\u7684\u3001\u521d\u59cb\u5316\u7684\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff09 \u4ee3\u7801\u6bb5\u4e2d\u5b58\u653e\uff1a\u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff08const\uff09\u3001\u5b57\u7b26\u4e32\u5e38\u91cf \u5806\u4e2d\u5b58\u653e\uff1a\u52a8\u6001\u5206\u914d\u7684\u533a\u57df \u6808\u4e2d\u5b58\u653e\uff1a\u5c40\u90e8\u53d8\u91cf\uff08\u521d\u59cb\u5316\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff0c\u4f46\u4e0d\u5305\u542b\u9759\u6001\u53d8\u91cf\uff09\u3001\u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff08const\uff09 \u8fd9\u91cc\u6211\u4eec\u6ca1\u6709\u53d1\u73b0BSS\u6bb5\uff0c\u4f46\u662f\u6211\u4eec\u5c06\u672a\u521d\u59cb\u5316\u7684\u6570\u636e\u6309\u7167\u5730\u5740\u8fdb\u884c\u6392\u5e8f\u770b\u4e00\u4e0b\uff0c\u53ef\u4ee5\u53d1\u73b0\u4e00\u4e2a\u89c4\u5f8b\u3002 &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_a=0 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_b=0 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_a=0 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_b=0 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_b=0 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_a=0 \u200b \u8fd9\u91cc\u53ef\u4ee5\u53d1\u73b0\uff0c \u521d\u59cb\u5316\u7684\u548c\u672a\u521d\u59cb\u5316\u7684\u6570\u636e\u597d\u50cf\u662f\u5206\u5f00\u5b58\u653e\u7684 \uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u731c\u6d4bBSS\u6bb5\u662f\u5b58\u5728\u7684\uff0c\u53ea\u4e0d\u8fc7\u6570\u636e\u6bb5\u662f\u5206\u4e3a\u521d\u59cb\u5316\u548c\u672a\u521d\u59cb\u5316\uff08\u5373BSS\u6bb5\uff09\u7684\u4e24\u90e8\u5206\uff0c\u4ed6\u4eec\u5728\u52a0\u8f7d\u5230\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u65f6\u662f\u5408\u5e76\u4e3a\u6570\u636e\u6bb5\u4e86\uff0c\u5728\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u4e2d\u6ca1\u6709\u5355\u72ec\u5206\u4e3a\u4e00\u4e2a\u533a\u57df\u3002 \u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\uff0c\u9759\u6001\u6570\u636e\u4e0e\u975e\u9759\u6001\u6570\u636e\u662f\u5426\u662f\u5206\u5f00\u5b58\u653e\u7684\u5462\uff1f\u8bf7\u8bfb\u8005\u81ea\u884c\u5206\u6790\u4e00\u4e0b\u3002 \u63a5\u4e0b\u6765\u6211\u4eec\u4ece**\u7a0b\u5e8f\u7684\u89d2\u5ea6**\u770b\u4e00\u4e0b\uff0c\u8fd9\u4e9b\u5b58\u50a8\u533a\u57df\u662f\u5982\u4f55\u5206\u914d\u7684\u3002\u9996\u5148\u6211\u4eec\u5148\u4ecb\u7ecd\u4e00\u4e0bELF\u6587\u4ef6\u683c\u5f0f\u3002 ELF\uff08Executable and Linkable Format \uff09\u6587\u4ef6\u683c\u5f0f\u662f\u4e00\u4e2a\u5f00\u653e\u6807\u51c6\uff0c\u5404\u79cdUNIX\u7cfb\u7edf\u7684\u53ef\u6267\u884c\u6587\u4ef6\u90fd\u91c7\u7528ELF\u683c\u5f0f\uff0c\u5b83\u6709\u4e09\u79cd\u4e0d\u540c\u7684\u7c7b\u578b\uff1a \u2013\u53ef\u91cd\u5b9a\u4f4d\u7684\u76ee\u6807\u6587\u4ef6\uff08Relocatable\uff0c\u6216\u8005Object File\uff09 \u2013\u53ef\u6267\u884c\u6587\u4ef6\uff08Executable\uff09 \u2013\u5171\u4eab\u5e93\uff08Shared Object\uff0c\u6216\u8005Shared Library\uff09 \u4e0b\u56fe\u4e3aELF\u6587\u4ef6\u7684\u7ed3\u6784\u793a\u610f\u56fe\uff08\u6765\u6e90\uff0c\u4e0d\u8be6\uff09\uff1a \u4e00\u4e2a\u7a0b\u5e8f\u7f16\u8bd1\u751f\u6210\u76ee\u6807\u4ee3\u7801\u6587\u4ef6\uff08ELF\u6587\u4ef6\uff09\u7684\u8fc7\u7a0b\u5982\u4e0b\uff0c\u6b64\u56fe\u5f15\u81ea\u300a\u7a0b\u5e8f\u5458\u7684\u81ea\u6211\u4fee\u517b\u300b\u4e00\u4e66\u7684\u4e00\u4e2a\u56fe\uff1a \u53ef\u4ee5\u901a\u8fc7readelf\u547d\u4ee4\u67e5\u770bEFL\u6587\u4ef6\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u4f8b\u5982 readelf -a a.out \uff0c\u6211\u4eec\u53ea\u5173\u5fc3\u5404\u4e2a\u6bb5\u7684\u5206\u914d\u60c5\u51b5\uff0c\u56e0\u6b64\u6211\u4eec\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\uff1a readelf -S a.out \u5c06\u8fd9\u91cc\u7684\u5185\u5b58\u5e03\u5c40\u4e0e\u4e4b\u524d\u770b\u5230\u7684\u7a0b\u5e8f\u7684\u8fd0\u884c\u7ed3\u679c\u8fdb\u884c\u5206\u6790\uff1a \u200b &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 global_uninit_a=0 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_global_uninit_a=0 \u200b &const_global_a=0x80487c0 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u53ea\u8bfb\u6570\u636e\u6bb5 const_global_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 global_uninit_b=0 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_global_uninit_b=0 \u200b &const_global_b=0x80487c4 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u53ea\u8bfb\u6570\u636e\u6bb5 const_global_b=1 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_local_uninit_a=0 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_local_uninit_b=0 \u200b p_chars=0x80487c8 \u5b57\u7b26\u4e32\u5e38\u91cf\uff1a\u53ea\u8bfb\u6570\u636e\u6bb5 p_chars=abcdef ELF \u6587\u4ef6\u4e00\u822c\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6bb5 : .text section\uff1a\u4e3b\u8981\u662f\u7f16\u8bd1\u540e\u7684\u6e90\u7801\u6307\u4ee4\uff0c\u662f\u53ea\u8bfb\u5b57\u6bb5\u3002 .data section \uff1a\u521d\u59cb\u5316\u540e\u7684\u975econst\u7684\u5168\u5c40\u53d8\u91cf\u3001\u5c40\u90e8static\u53d8\u91cf\u3002 .bss\uff1a\u672a\u521d\u59cb\u5316\u540e\u7684\u975econst\u5168\u5c40\u53d8\u91cf\u3001\u5c40\u90e8static\u53d8\u91cf\u3002 **.rodata\u5b57\u6bb5 \u662f\u5b58\u653e\u53ea\u8bfb\u6570\u636e ** \u5206\u6790\u5230\u8fd9\u4ee5\u540e\uff0c\u6211\u4eec\u5728\u548c\u4e4b\u524d\u5206\u6790\u7684\u7ed3\u679c\u5bf9\u6bd4\u4e00\u4e0b\uff0c \u4f1a\u53d1\u73b0\u786e\u5b9e\u5b58\u5728BSS\u6bb5 \uff0c\u5730\u5740\u4e3a0804a030 \uff0c\u5927\u5c0f\u4e3a0x20\uff0c\u4e4b\u524d\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u672a\u521d\u59cb\u5316\u7684\u7684\u786e\u5b58\u653e\u5728\u8fd9\u4e2a\u5730\u5740\u533a\u95f4\u4e2d\u4e86\uff0c\u53ea\u4e0d\u8fc7\u6267\u884cexec\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u5c06\u8fd9\u90e8\u5206\u7684\u6570\u636e\u521d\u59cb\u5316\u4e3a0\u540e\uff0c\u653e\u5230\u4e86\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u7684\u6570\u636e\u6bb5\u4e2d\u4e86\uff0c\u5728\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u4e2d\u5c31\u6ca1\u6709\u5fc5\u8981\u5b58\u5728BSS\u6bb5\u4e86\uff0c\u56e0\u6b64\u90fd\u79f0\u505a\u6570\u636e\u6bb5\u3002\u540c\u7406\uff0c.rodata\u5b57\u6bb5\u4e5f\u662f\u4e0etext\u6bb5\u653e\u5728\u4e00\u8d77\u4e86\u3002 \u5728ELF\u6587\u4ef6\u4e2d\uff0c\u627e\u4e0d\u5230\u5c40\u90e8\u975e\u9759\u6001\u53d8\u91cf\u548c\u52a8\u6001\u5206\u914d\u7684\u5185\u5bb9\u3002 TODO https://blog.csdn.net/feilengcui008/article/details/44141495 https://www.cnblogs.com/dyllove98/archive/2013/07/05/3174341.html","title":"\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff08virtual memory area,VMA\uff09"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#virtual#memory#areavma","text":"","title":"\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff08virtual memory area,VMA\uff09"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_1","text":"\u6211\u4eec\u77e5\u9053\u6211\u4eec\u7f16\u5199\u7684**\u5e94\u7528\u7a0b\u5e8f**\u6700\u7ec8\u8981\u4ee5**\u8fdb\u7a0b**\u7684\u5f62\u5f0f\u6765\u8fd0\u884c\uff0c\u4efb\u4f55\u4e00\u4e2a**\u8fdb\u7a0b**\u90fd\u88ab\u8d4b\u4e88\u5176\u81ea\u5df1\u7684**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\uff0c\u8be5**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u8986\u76d6\u4e86\u4e00\u4e2a\u76f8\u5f53\u5927\u7684\u8303\u56f4\uff0c\u5bf9\u4e8e32\u4f4d\u64cd\u4f5c\u7cfb\u7edf\uff0c\u5176\u8fdb\u7a0b\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u4e3a 2^{32}=4,294,967,296 2^{32}=4,294,967,296 Byte\uff0c\u8fd9\u4f7f\u5f97\u4e00\u4e2a**\u6307\u9488**\u53ef\u4ee5\u4f7f\u7528\u4ece 0x00000000 \u5230 0xFFFFFFFF \u76844GB\u8303\u56f4\u4e4b\u5185\u7684\u4efb\u4f55\u4e00\u4e2a\u503c\u3002\u867d\u7136\u6bcf\u4e00\u4e2a32\u4f4d\u8fdb\u7a0b\u53ef\u4f7f\u7528**4GB**\u7684**\u5730\u5740\u7a7a\u95f4**\uff0c\u4f46\u5e76\u4e0d\u610f\u5473\u7740\u6bcf\u4e00\u4e2a\u8fdb\u7a0b**\u5b9e\u9645**\u62e5\u6709 4GB \u7684**\u7269\u7406\u5730\u5740\u7a7a\u95f4**\uff0c\u8be5\u5730\u5740\u7a7a\u95f4\u4ec5\u4ec5\u662f\u4e00\u4e2a**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\uff0c\u5b83\u662f\u4e00\u4e2a\u903b\u8f91\u4e0a\u7684\u8bbe\u8ba1\u3002\u6b64**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u53ea\u662f\u5185\u5b58\u5730\u5740\u7684\u4e00\u4e2a\u8303\u56f4\u3002\u8fdb\u7a0b\u5b9e\u9645\u53ef\u4ee5\u5f97\u5230\u7684**\u7269\u7406\u5185\u5b58**\u8981\u8fdc\u5c0f\u4e8e\u5176**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u3002\u8fdb\u7a0b\u7684**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u662f\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u6240\u79c1\u6709\u7684\uff0c\u5728\u8fdb\u7a0b\u5185\u8fd0\u884c\u7684**\u7ebf\u7a0b**\u5bf9**\u5185\u5b58\u7a7a\u95f4**\u7684\u8bbf\u95ee\u90fd\u88ab\u9650\u5236\u5728**\u8c03\u7528\u8fdb\u7a0b**\u4e4b\u5185\uff0c\u800c\u4e0d\u80fd\u8bbf\u95ee\u5c5e\u4e8e\u5176\u4ed6\u8fdb\u7a0b\u7684\u5185\u5b58\u7a7a\u95f4\u3002\u8fd9\u6837\uff0c\u5728\u4e0d\u540c\u7684\u8fdb\u7a0b\u4e2d\u53ef\u4ee5\u4f7f\u7528\u76f8\u540c\u5730\u5740\u7684\u6307\u9488\u6765\u6307\u5411\u5c5e\u4e8e\u5404\u81ea\u8c03\u7528\u8fdb\u7a0b\u7684\u5185\u5bb9\u800c\u4e0d\u4f1a\u7531\u6b64\u5f15\u8d77\u6df7\u4e71\u3002 \u901a\u8fc7\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u63cf\u8ff0\uff0c\u53ef\u4ee5\u77e5\u9053\u8fdb\u7a0b\u4f7f\u7528\u7684\u5168\u90e8\u8d44\u6e90\u662f\u2019\u865a\u62df\u2018\u7684\uff0c\u6211\u4eec\u77e5\u9053\u6211\u4eec\u7f16\u5199\u7684**\u5e94\u7528\u7a0b\u5e8f**\u6700\u7ec8\u8981\u4ee5**\u8fdb\u7a0b**\u7684\u5f62\u5f0f\u6765\u8fd0\u884c\uff0c\u56e0\u800c\u8fdb\u7a0b\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e2a\u865a\u62df\u673a\uff08\u865a\u62df\u7684\u8ba1\u7b97\u673a\uff09\uff0c\u6240\u4ee5\u6211\u4eec\u5f88\u5bb9\u6613\u611f\u53d7\u5230\u81ea\u5df1\u7f16\u5199\u7684\u5e94\u7528\u7a0b\u5e8f\u4f3c\u4e4e\u4f7f\u7528\u7684\u662f\u6240\u6709\u7684\u8ba1\u7b97\u673a\u8d44\u6e90\uff0c32bit\u7684\u8ba1\u7b97\u673a\u6211\u4eec\u8fdb\u7a0b\u4f3c\u4e4e\u5c31\u662f\u4f7f\u7528\u5b8c\u6574\u76844G\u5185\u5b58\uff0c\u4f46\u662f\u5bf9\u7cfb\u7edf\u7a0d\u6709\u4e86\u89e3\uff0c\u6211\u4eec\u5c31\u77e5\u9053\u4e00\u4e2a\u8fdb\u7a0b\u4f7f\u7528\u7684\u7269\u7406\u5185\u5b58\u5b9e\u9645\u53ef\u80fd\u4e0d\u5230\u51e0\u767em\u751a\u81f3\u51e0m\uff01\u8fd9\u5c31\u662f\u4e00\u79cd\u865a\u62df\uff0c \u8fdb\u7a0b\u4f7f\u7528\u7684\u662f\u865a\u62df\u7684\u5168\u90e8\u8ba1\u7b97\u673a\u8d44\u6e90 \uff01\u56de\u6765\u518d\u770b\u5185\u5b58\uff0c\u5b9e\u9645\u4e0a\u4f7f\u7528\u51e0m\u7684\u5185\u5b58\uff0c\u4f46\u6bcf\u4e2a\u8fdb\u7a0b\u7684\u865a\u62df\u5185\u5b58\u5374\u662f4G\uff01\u8fd9\u5c31\u662f\u865a\u62df\u5185\u5b58\u7684\u5965\u5999\uff01 \u865a\u62df\u5185\u5b58\u7a7a\u95f4\uff08virtual memory area,VMA\uff09\uff0c\u4e5f\u79f0\u4f5c\u7ebf\u6027\u533a\u3002\u865a\u62df\u5b58\u50a8\u5668\u662f\u4e00\u4e2a\u62bd\u8c61\u6982\u5ff5\uff0c\u5b83\u4e3a\u6bcf\u4e00\u4e2a\u8fdb\u7a0b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5047\u8c61\uff0c\u597d\u50cf\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u5728\u72ec\u5360\u7684\u4f7f\u7528\u4e3b\u5b58\u3002\u6bcf\u4e2a\u8fdb\u7a0b\u770b\u5230\u7684\u5b58\u50a8\u5668\u90fd\u662f\u4e00\u81f4\u7684\uff0c\u79f0\u4e4b\u4e3a\u865a\u62df\u5730\u5740\u7a7a\u95f4\u3002","title":"\u7406\u89e3\u8fdb\u7a0b\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#linux","text":"\u572832 bit\u7cfb\u7edf\u4e2d\uff0c\u5185\u6838\u5206\u914d1GB\uff0c\u800c\u5404\u4e2a\u7528\u6237\u7a7a\u95f4\u8fdb\u7a0b\u53ef\u7528\u7684\u90e8\u5206\u4e3a3GB\u3002 \u4e0b\u56fe\u5c55\u793a\u4e86\u4e00\u4e2a32\u4f4d\u7cfb\u7edf\u7684\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5e03\u5c40\uff1a \u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7531\u82e5\u5e72\u4e2a\u533a\u57df\u7ec4\u6210\uff1a 1.\u5f53\u524d\u8fd0\u884c\u4ee3\u7801\u7684\u4e8c\u8fdb\u5236\u4ee3\u7801.text\u6bb5\u3002 2.\u7a0b\u5e8f\u4f7f\u7528\u7684\u52a8\u6001\u5e93\u4ee3\u7801\u3002 3.\u5b58\u50a8**\u533a\u5c40\u53d8\u91cf**\u548c**\u9759\u6001\u53d8\u91cf**\u7684\u6570\u636e\u6bb5\uff0cbss,data\u6bb5 4.\u4fdd\u5b58\u52a8\u6001\u5206\u914d\u6570\u636e\u7684\u5806 5.\u4fdd\u5b58\u5c40\u90e8\u53d8\u91cf\u548c\u5b9e\u73b0**\u51fd\u6570\u8c03\u7528**\u7684\u6808 6.\u73af\u5883\u53d8\u91cf\u548c\u547d\u4ee4\u884c\u53c2\u6570\u3002 7.\u6587\u4ef6\u5185\u5bb9\u6620\u5c04\u5230\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5185\u5b58\u6620\u5c04\u3002 \u5982\u679c\u5168\u5c40\u53d8\u91cf randomize_va_space \u8bbe\u7f6e\u4e3a 1 \uff0c\u90a3\u4e48\u542f\u7528\u5730\u5740**\u7a7a\u95f4\u968f\u673a\u5316\u673a\u5236**\uff08\u4e0a\u56fe\u7684 ramdom xxx offset \uff09\u3002\u7528\u6237\u53ef\u4ee5\u901a\u8fc7 /proc/sys/kernel/randomize_va_space \u505c\u7528\u8be5\u7279\u6027\u3002 \u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709mm_struct(linux/mm_types.h)\u7684\u5b9e\u4f8b\uff0c\u4fdd\u5b58**\u8fdb\u7a0b\u865a\u62df\u5185\u5b58\u7ba1\u7406\u4fe1\u606f**\u3002 struct mm_struct { struct vm_area_struct * mmap ; /* list of VMAs */ struct rb_root mm_rb ; #ifdef CONFIG_MMU unsigned long ( * get_unmapped_area ) ( struct file * filp , unsigned long addr , unsigned long len , unsigned long pgoff , unsigned long flags ); #endif unsigned long mmap_base ; /* base of mmap area */ \u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u7528\u4e8e\u5185\u5b58\u6620\u5c04\u7684\u8d77\u59cb\u5730\u5740\u3002 unsigned long mmap_legacy_base ; /* base of mmap area in bottom-up allocations */ unsigned long task_size ; /* size of task vm space */ \u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u7684 size . struct list_head mmlist ; /* List of maybe swapped mm's. These are globally strung unsigned long start_code, end_code, start_data, end_data;//text\u6bb5\uff0c\u6570\u636e\u6bb5\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ec8\u6b62\u5730\u5740 unsigned long start_brk, brk, start_stack;//\u5806\u9996\u5730\u5740\uff0c\u5806\u5c3e\u5730\u5740\uff0c\u6808\u9996\u5730\u5740\u3002 unsigned long arg_start, arg_end, env_start, env_end;//\u547d\u4ee4\u884c\u53c2\u6570\uff0c\u73af\u5883\u53d8\u91cf\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ec8\u6b62\u5730\u5740 .... }; **\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u7531\u591a\u4e2a VMA \u7ec4\u6210\uff08 struct mm_struct \u4e2d struct vm_area_struct \\*mmap;/* list of VMAs */ \u6210\u5458\uff09\u3002\u6709\u4e24\u79cd\u7ec4\u7ec7 VMA \u7684\u65b9\u5f0f\uff0c\u94fe\u8868\uff08 mmap \uff09\u548c\u7ea2\u9ed1\u6811\uff08 mm_rb \uff09 VMA\u7ed3\u6784\u4f53\u5982\u4e0b\uff1a struct vm_area_struct { \u3000\u3000 /* The first cache line has the info for VMA tree walking. */ \u3000\u3000 unsigned long vm_start ; /* Our start address within vm_mm. */ \u3000\u3000 unsigned long vm_end ; /* The first byte after our end address within vm_mm. */ \u3000\u3000 /* linked list of VM areas per task, sorted by address */ \u3000\u3000 struct vm_area_struct * vm_next , * vm_prev ; \u3000\u3000 struct rb_node vm_rb ; \u3000\u3000 struct mm_struct * vm_mm ; /* The address space we belong to. */ \u3000\u3000 /* Function pointers to deal with this struct. */ \u3000\u3000 const struct vm_operations_struct * vm_ops ; \u3000\u3000 struct file * vm_file ; /* File we map to (can be NULL). */ \u3000\u3000 void * vm_private_data ; /* was vm_pte (shared mem) */ }; VMA\u94fe\u8868\u7ec4\u7ec7\u5f62\u5f0f\u5982\u4e0b\u56fe\uff1a VMA\u7ea2\u9ed1\u6811\u7ec4\u7ec7\u5f62\u5f0f\u5982\u4e0b\uff1a","title":"Linux\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u5e03\u5c40"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#_2","text":"\u539f\u6587\u94fe\u63a5\uff1a https://blog.csdn.net/zhongjiekangping/article/details/6910211 #include <stdio.h> #include <stdlib.h> int global_init_a = 1 ; int global_uninit_a ; static int static_global_init_a = 1 ; static int static_global_uninit_a ; const int const_global_a = 1 ; int global_init_b = 1 ; int global_uninit_b ; static int static_global_init_b = 1 ; static int static_global_uninit_b ; const int const_global_b = 1 ; /*\u4e0a\u9762\u5168\u90e8\u4e3a\u5168\u5c40\u53d8\u91cf\uff0cmain\u51fd\u6570\u4e2d\u7684\u4e3a\u5c40\u90e8\u53d8\u91cf*/ int main () { int local_init_a = 1 ; int local_uninit_a ; static int static_local_init_a = 1 ; static int static_local_uninit_a ; const int const_local_a = 1 ; int local_init_b = 1 ; int local_uninit_b ; static int static_local_init_b = 1 ; static int static_local_uninit_b ; const int const_local_b = 1 ; int * malloc_p_a ; malloc_p_a = malloc ( sizeof ( int )); //\u5c06\u4e0a\u9762\u5b9a\u4e49\u7684\u53d8\u91cf\u5168\u90e8\u90fd\u6253\u5370\u51fa\u6765 printf ( \" \\n &global_init_a=%p \\t global_init_a =% d \\ n \",&global_init_a,global_init_a); printf ( \" &global_uninit_a=%p \\t global_uninit_a =% d \\ n \",&global_uninit_a,global_uninit_a); printf ( \" &static_global_init_a=%p \\t static_global_init_a =% d \\ n \",&static_global_init_a,static_global_init_a); printf ( \"&static_global_uninit_a=%p \\t static_global_uninit_a =% d \\ n \",&static_global_uninit_a,static_global_uninit_a); printf ( \" &const_global_a=%p \\t const_global_a =% d \\ n \",&const_global_a,const_global_a); printf ( \" \\n &global_init_b=%p \\t global_init_b =% d \\ n \",&global_init_b,global_init_b); printf ( \" &global_uninit_b=%p \\t global_uninit_b =% d \\ n \",&global_uninit_b,global_uninit_b); printf ( \" &static_global_init_b=%p \\t static_global_init_b =% d \\ n \",&static_global_init_b,static_global_init_b); printf ( \"&static_global_uninit_b=%p \\t static_global_uninit_b =% d \\ n \",&static_global_uninit_b,static_global_uninit_b); printf ( \" &const_global_b=%p \\t const_global_b =% d \\ n \",&const_global_b,const_global_b); printf ( \" \\n &local_init_a=%p \\t local_init_a =% d \\ n \",&local_init_a,local_init_a); printf ( \" &local_uninit_a=%p \\t local_uninit_a =% d \\ n \",&local_uninit_a,local_uninit_a); printf ( \" &static_local_init_a=%p \\t static_local_init_a =% d \\ n \",&static_local_init_a,static_local_init_a); printf ( \" &static_local_uninit_a=%p \\t static_local_uninit_a =% d \\ n \",&static_local_uninit_a,static_local_uninit_a); printf ( \" &const_local_a=%p \\t const_local_a =% d \\ n \",&const_local_a,const_local_a); printf ( \" \\n &local_init_b=%p \\t local_init_b =% d \\ n \",&local_init_b,local_init_b); printf ( \" &local_uninit_b=%p \\t local_uninit_b =% d \\ n \",&local_uninit_b,local_uninit_b); printf ( \" &static_local_init_b=%p \\t static_local_init_b =% d \\ n \",&static_local_init_b,static_local_init_b); printf ( \" &static_local_uninit_b=%p \\t static_local_uninit_b =% d \\ n \",&static_local_uninit_b,static_local_uninit_b); printf ( \" &const_local_b=%p \\t const_local_b =% d \\ n \",&const_local_b,const_local_b); printf ( \" malloc_p_a=%p \\t * malloc_p_a =% d \\ n \",malloc_p_a,*malloc_p_a); return 0 ; } \u4e0b\u9762\u662f\u8f93\u51fa\u7ed3\u679c\u3002 \u5148\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b\u4e0a\u9762\u7684\u8f93\u51fa\u7ed3\u679c\uff0c\u770b\u770b\u80fd\u5f97\u51fa\u4ec0\u4e48\u7ed3\u8bba\u3002\u8c8c\u4f3c\u5f88\u96be\u5206\u6790\u51fa\u6765\u4ec0\u4e48\u7ed3\u679c\u3002\u597d\u4e86\u6211\u4eec\u7ee7\u7eed\u5f80\u4e0b\u770b\u5427\u3002 \u63a5\u4e0b\u6765\uff0c\u901a\u8fc7\u67e5\u770b**proc\u6587\u4ef6\u7cfb\u7edf**\u4e0b\u7684\u6587\u4ef6\uff0c\u770b\u4e00\u4e0b\u8fd9\u4e2a\u8fdb\u7a0b\u7684**\u771f\u5b9e\u5185\u5b58\u5206\u914d\u60c5\u51b5**\u3002\uff08\u6211\u4eec\u9700\u8981\u5728\u7a0b\u5e8f\u7ed3\u675f\u524d\u52a0\u4e00\u4e2a\u6b7b\u5faa\u73af\uff0c\u4e0d\u8ba9\u8fdb\u7a0b\u7ed3\u675f\uff0c\u4ee5\u4fbf\u6211\u4eec\u8fdb\u4e00\u6b65\u5206\u6790\uff09\u3002 \u200b \u5728 return 0 \u524d\uff0c\u589e\u52a0 while(1); \u8bed\u53e5\u3002 \u91cd\u65b0\u7f16\u8bd1\u540e\uff0c\u8fd0\u884c\u7a0b\u5e8f\uff0c\u7a0b\u5e8f\u5c06\u8fdb\u5165\u6b7b\u5faa\u73af\u3002 \u4f7f\u7528ps\u547d\u4ee4\u67e5\u770b\u4e00\u4e0b\u8fdb\u7a0b\u7684pid\u3002 ps -aux | grep a.out \u67e5\u770b /proc/2699/maps \u6587\u4ef6\uff0c\u8fd9\u4e2a\u6587\u4ef6\u663e\u793a\u4e86\u8fdb\u7a0b\u5728\u5185\u5b58\u7a7a\u95f4\u4e2d\u5404\u4e2a\u533a\u57df\u7684\u5206\u914d\u60c5\u51b5\u3002 cat /proc/2699/maps \u4e0a\u9762\u7ea2\u989c\u8272\u6807\u51fa\u7684\u51e0\u4e2a\u533a\u95f4\u662f\u6211\u4eec\u611f\u5174\u8da3\u7684\u533a\u95f4\uff1a 08048000-08049000 r-xp \u8c8c\u4f3c\u662f\u4ee3\u7801\u6bb5 08049000-0804a000 r--p \u6682\u65f6\u4e0d\u6e05\u695a\uff0c\u770b\u4e0d\u51fa\u6765 0804a000-0804b000 rw-p \u8c8c\u4f3c\u4e3a\u6570\u636e\u6bb5 08a7e000-08a9f000 rw-p \u5806 bff73000-bff88000 rw-p \u6808 \u6211\u4eec\u628a\u8fd9\u4e9b\u6570\u636e\u4e0e\u6700\u540e\u4e00\u6b21\u7684\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u679c\u8fdb\u884c\u6bd4\u8f83\uff0c\u770b\u770b\u6709\u4ec0\u4e48\u7ed3\u8bba\u3002 \u200b &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_a=0 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_a=0 \u200b &const_global_a=0x80487c0 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u4ee3\u7801\u6bb5 const_global_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_b=0 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_b=0 \u200b &const_global_b=0x80487c4 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u4ee3\u7801\u6bb5 const_global_b=1 \u200b &local_init_a=0xbff8600c \u5c40\u90e8\u521d\u59cb\u5316\uff1a\u6808 local_init_a=1 \u200b &local_uninit_a=0xbff86008 \u5c40\u90e8\u672a\u521d\u59cb\u5316\uff1a\u6808 local_uninit_a=134514459 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_a=0 \u200b &const_local_a=0xbff86004 \u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff1a\u6808 const_local_a=1 \u200b &local_init_b=0xbff86000 \u5c40\u90e8\u521d\u59cb\u5316\uff1a\u6808 local_init_b=1 \u200b &local_uninit_b=0xbff85ffc \u5c40\u90e8\u672a\u521d\u59cb\u5316\uff1a\u6808 local_uninit_b=-1074241512 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_b=0 \u200b &const_local_b=0xbff85ff8 \u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff1a\u6808 const_local_b=1 \u200b p_chars=0x80487c8 \u5b57\u7b26\u4e32\u5e38\u91cf\uff1a\u4ee3\u7801\u6bb5 p_chars=abcdef \u200b malloc_p_a=0x8a7e008 malloc\u52a8\u6001\u5206\u914d\uff1a\u5806 *malloc_p_a=0 \u901a\u8fc7\u4ee5\u4e0a\u5206\u6790\u6211\u4eec\u6682\u65f6\u53ef\u4ee5\u5f97\u5230\u7684\u7ed3\u8bba\u5982\u4e0b\uff0c \u5728\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u4e2d \uff1a \u6570\u636e\u6bb5**\u4e2d\u5b58\u653e\uff1a**\u5168\u5c40\u53d8\u91cf \uff08\u521d\u59cb\u5316\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff09\u3001 \u9759\u6001\u53d8\u91cf \uff08\u5168\u5c40\u7684\u548c\u5c40\u90e8\u7684\u3001\u521d\u59cb\u5316\u7684\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff09 \u4ee3\u7801\u6bb5\u4e2d\u5b58\u653e\uff1a\u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff08const\uff09\u3001\u5b57\u7b26\u4e32\u5e38\u91cf \u5806\u4e2d\u5b58\u653e\uff1a\u52a8\u6001\u5206\u914d\u7684\u533a\u57df \u6808\u4e2d\u5b58\u653e\uff1a\u5c40\u90e8\u53d8\u91cf\uff08\u521d\u59cb\u5316\u4ee5\u53ca\u672a\u521d\u59cb\u5316\u7684\uff0c\u4f46\u4e0d\u5305\u542b\u9759\u6001\u53d8\u91cf\uff09\u3001\u5c40\u90e8\u53ea\u8bfb\u53d8\u91cf\uff08const\uff09 \u8fd9\u91cc\u6211\u4eec\u6ca1\u6709\u53d1\u73b0BSS\u6bb5\uff0c\u4f46\u662f\u6211\u4eec\u5c06\u672a\u521d\u59cb\u5316\u7684\u6570\u636e\u6309\u7167\u5730\u5740\u8fdb\u884c\u6392\u5e8f\u770b\u4e00\u4e0b\uff0c\u53ef\u4ee5\u53d1\u73b0\u4e00\u4e2a\u89c4\u5f8b\u3002 &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_a=0 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_uninit_b=0 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_a=0 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_uninit_b=0 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_b=0 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_uninit_a=0 \u200b \u8fd9\u91cc\u53ef\u4ee5\u53d1\u73b0\uff0c \u521d\u59cb\u5316\u7684\u548c\u672a\u521d\u59cb\u5316\u7684\u6570\u636e\u597d\u50cf\u662f\u5206\u5f00\u5b58\u653e\u7684 \uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u731c\u6d4bBSS\u6bb5\u662f\u5b58\u5728\u7684\uff0c\u53ea\u4e0d\u8fc7\u6570\u636e\u6bb5\u662f\u5206\u4e3a\u521d\u59cb\u5316\u548c\u672a\u521d\u59cb\u5316\uff08\u5373BSS\u6bb5\uff09\u7684\u4e24\u90e8\u5206\uff0c\u4ed6\u4eec\u5728\u52a0\u8f7d\u5230\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u65f6\u662f\u5408\u5e76\u4e3a\u6570\u636e\u6bb5\u4e86\uff0c\u5728\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u4e2d\u6ca1\u6709\u5355\u72ec\u5206\u4e3a\u4e00\u4e2a\u533a\u57df\u3002 \u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\uff0c\u9759\u6001\u6570\u636e\u4e0e\u975e\u9759\u6001\u6570\u636e\u662f\u5426\u662f\u5206\u5f00\u5b58\u653e\u7684\u5462\uff1f\u8bf7\u8bfb\u8005\u81ea\u884c\u5206\u6790\u4e00\u4e0b\u3002 \u63a5\u4e0b\u6765\u6211\u4eec\u4ece**\u7a0b\u5e8f\u7684\u89d2\u5ea6**\u770b\u4e00\u4e0b\uff0c\u8fd9\u4e9b\u5b58\u50a8\u533a\u57df\u662f\u5982\u4f55\u5206\u914d\u7684\u3002\u9996\u5148\u6211\u4eec\u5148\u4ecb\u7ecd\u4e00\u4e0bELF\u6587\u4ef6\u683c\u5f0f\u3002 ELF\uff08Executable and Linkable Format \uff09\u6587\u4ef6\u683c\u5f0f\u662f\u4e00\u4e2a\u5f00\u653e\u6807\u51c6\uff0c\u5404\u79cdUNIX\u7cfb\u7edf\u7684\u53ef\u6267\u884c\u6587\u4ef6\u90fd\u91c7\u7528ELF\u683c\u5f0f\uff0c\u5b83\u6709\u4e09\u79cd\u4e0d\u540c\u7684\u7c7b\u578b\uff1a \u2013\u53ef\u91cd\u5b9a\u4f4d\u7684\u76ee\u6807\u6587\u4ef6\uff08Relocatable\uff0c\u6216\u8005Object File\uff09 \u2013\u53ef\u6267\u884c\u6587\u4ef6\uff08Executable\uff09 \u2013\u5171\u4eab\u5e93\uff08Shared Object\uff0c\u6216\u8005Shared Library\uff09 \u4e0b\u56fe\u4e3aELF\u6587\u4ef6\u7684\u7ed3\u6784\u793a\u610f\u56fe\uff08\u6765\u6e90\uff0c\u4e0d\u8be6\uff09\uff1a \u4e00\u4e2a\u7a0b\u5e8f\u7f16\u8bd1\u751f\u6210\u76ee\u6807\u4ee3\u7801\u6587\u4ef6\uff08ELF\u6587\u4ef6\uff09\u7684\u8fc7\u7a0b\u5982\u4e0b\uff0c\u6b64\u56fe\u5f15\u81ea\u300a\u7a0b\u5e8f\u5458\u7684\u81ea\u6211\u4fee\u517b\u300b\u4e00\u4e66\u7684\u4e00\u4e2a\u56fe\uff1a \u53ef\u4ee5\u901a\u8fc7readelf\u547d\u4ee4\u67e5\u770bEFL\u6587\u4ef6\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u4f8b\u5982 readelf -a a.out \uff0c\u6211\u4eec\u53ea\u5173\u5fc3\u5404\u4e2a\u6bb5\u7684\u5206\u914d\u60c5\u51b5\uff0c\u56e0\u6b64\u6211\u4eec\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\uff1a readelf -S a.out \u5c06\u8fd9\u91cc\u7684\u5185\u5b58\u5e03\u5c40\u4e0e\u4e4b\u524d\u770b\u5230\u7684\u7a0b\u5e8f\u7684\u8fd0\u884c\u7ed3\u679c\u8fdb\u884c\u5206\u6790\uff1a \u200b &global_init_a=0x804a018 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_a=1 \u200b &global_uninit_a=0x804a04c \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 global_uninit_a=0 \u200b &static_global_init_a=0x804a01c \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_a=1 &static_global_uninit_a=0x804a038 \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_global_uninit_a=0 \u200b &const_global_a=0x80487c0 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u53ea\u8bfb\u6570\u636e\u6bb5 const_global_a=1 \u200b &global_init_b=0x804a020 \u5168\u5c40\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 global_init_b=1 \u200b &global_uninit_b=0x804a048 \u5168\u5c40\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 global_uninit_b=0 \u200b &static_global_init_b=0x804a024 \u5168\u5c40\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_global_init_b=1 &static_global_uninit_b=0x804a03c \u5168\u5c40\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_global_uninit_b=0 \u200b &const_global_b=0x80487c4 \u5168\u5c40\u53ea\u8bfb\u53d8\u91cf\uff1a \u53ea\u8bfb\u6570\u636e\u6bb5 const_global_b=1 \u200b &static_local_init_a=0x804a028 \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_a=1 &static_local_uninit_a=0x804a040 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_local_uninit_a=0 \u200b &static_local_init_b=0x804a02c \u5c40\u90e8\u9759\u6001\u521d\u59cb\u5316\uff1a\u6570\u636e\u6bb5 static_local_init_b=1 &static_local_uninit_b=0x804a044 \u5c40\u90e8\u9759\u6001\u672a\u521d\u59cb\u5316\uff1aBSS\u6bb5 static_local_uninit_b=0 \u200b p_chars=0x80487c8 \u5b57\u7b26\u4e32\u5e38\u91cf\uff1a\u53ea\u8bfb\u6570\u636e\u6bb5 p_chars=abcdef ELF \u6587\u4ef6\u4e00\u822c\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6bb5 : .text section\uff1a\u4e3b\u8981\u662f\u7f16\u8bd1\u540e\u7684\u6e90\u7801\u6307\u4ee4\uff0c\u662f\u53ea\u8bfb\u5b57\u6bb5\u3002 .data section \uff1a\u521d\u59cb\u5316\u540e\u7684\u975econst\u7684\u5168\u5c40\u53d8\u91cf\u3001\u5c40\u90e8static\u53d8\u91cf\u3002 .bss\uff1a\u672a\u521d\u59cb\u5316\u540e\u7684\u975econst\u5168\u5c40\u53d8\u91cf\u3001\u5c40\u90e8static\u53d8\u91cf\u3002 **.rodata\u5b57\u6bb5 \u662f\u5b58\u653e\u53ea\u8bfb\u6570\u636e ** \u5206\u6790\u5230\u8fd9\u4ee5\u540e\uff0c\u6211\u4eec\u5728\u548c\u4e4b\u524d\u5206\u6790\u7684\u7ed3\u679c\u5bf9\u6bd4\u4e00\u4e0b\uff0c \u4f1a\u53d1\u73b0\u786e\u5b9e\u5b58\u5728BSS\u6bb5 \uff0c\u5730\u5740\u4e3a0804a030 \uff0c\u5927\u5c0f\u4e3a0x20\uff0c\u4e4b\u524d\u6211\u4eec\u7684\u7a0b\u5e8f\u4e2d\u672a\u521d\u59cb\u5316\u7684\u7684\u786e\u5b58\u653e\u5728\u8fd9\u4e2a\u5730\u5740\u533a\u95f4\u4e2d\u4e86\uff0c\u53ea\u4e0d\u8fc7\u6267\u884cexec\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u5c06\u8fd9\u90e8\u5206\u7684\u6570\u636e\u521d\u59cb\u5316\u4e3a0\u540e\uff0c\u653e\u5230\u4e86\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u7684\u6570\u636e\u6bb5\u4e2d\u4e86\uff0c\u5728\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u4e2d\u5c31\u6ca1\u6709\u5fc5\u8981\u5b58\u5728BSS\u6bb5\u4e86\uff0c\u56e0\u6b64\u90fd\u79f0\u505a\u6570\u636e\u6bb5\u3002\u540c\u7406\uff0c.rodata\u5b57\u6bb5\u4e5f\u662f\u4e0etext\u6bb5\u653e\u5728\u4e00\u8d77\u4e86\u3002 \u5728ELF\u6587\u4ef6\u4e2d\uff0c\u627e\u4e0d\u5230\u5c40\u90e8\u975e\u9759\u6001\u53d8\u91cf\u548c\u52a8\u6001\u5206\u914d\u7684\u5185\u5bb9\u3002","title":"\u8f93\u51fa\u5730\u5740\u7a7a\u95f4"},{"location":"Programming/Object-file/ELF/draft/ELF-from-local-diary/diary/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/#todo","text":"https://blog.csdn.net/feilengcui008/article/details/44141495 https://www.cnblogs.com/dyllove98/archive/2013/07/05/3174341.html","title":"TODO"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Check-symbol/","text":"nm (Unix)","title":"[nm (Unix)](https://en.wikipedia.org/wiki/Nm_(Unix))"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Check-symbol/#nm#unix","text":"","title":"nm (Unix)"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/ELF/","text":"ELF Google\uff1a shard library visible symbol \u7ef4\u57fa\u767e\u79d1 Executable and Linkable Format elinux Executable and Linkable Format (ELF) elf(1) ELF(5)","title":"ELF"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/ELF/#elf","text":"Google\uff1a shard library visible symbol","title":"ELF"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/ELF/#executable#and#linkable#format","text":"","title":"\u7ef4\u57fa\u767e\u79d1Executable and Linkable Format"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/ELF/#elinux#executable#and#linkable#format#elf","text":"","title":"elinux Executable and Linkable Format (ELF)"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/ELF/#elf1","text":"","title":"elf(1)"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/ELF/#elf5","text":"","title":"ELF(5)"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Weak-symbol/","text":"Weak symbol","title":"[Weak symbol](https://en.wikipedia.org/wiki/Weak_symbol)"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Weak-symbol/#weak#symbol","text":"","title":"Weak symbol"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/TO-read/","text":"TO read Google symbol visibility Visibility Part 1 \u2013 Introduction to symbol visibility fvisibility hidden Google fvisibility hidden C++ -fvisibility=hidden -fvisibility-inlines-hidden Symbol visibility and namespace shared-library-testcase Controlling symbol visibility for shared libraries: Part 2 - Advanced knowledge with IBM XL C/C++ V13 compiler Part 1 \u2013 Introduction to symbol visibility Limiting visibility of symbols when linking shared libraries","title":"TO read"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/TO-read/#to#read","text":"Google symbol visibility","title":"TO read"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/TO-read/#visibility","text":"","title":"Visibility"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/TO-read/#part#1#introduction#to#symbol#visibility","text":"","title":"Part 1 \u2013 Introduction to symbol visibility"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/TO-read/#fvisibility#hidden","text":"Google fvisibility hidden C++ -fvisibility=hidden -fvisibility-inlines-hidden","title":"fvisibility hidden"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/TO-read/#symbol#visibility#and#namespace","text":"","title":"Symbol visibility and namespace"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/TO-read/#shared-library-testcase","text":"","title":"shared-library-testcase"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/TO-read/#controlling#symbol#visibility#for#shared#libraries#part#2#-#advanced#knowledge#with#ibm#xl#cc#v13#compiler","text":"","title":"Controlling symbol visibility for shared libraries: Part 2 - Advanced knowledge with IBM XL C/C++ V13 compiler"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/TO-read/#part#1#introduction#to#symbol#visibility_1","text":"","title":"Part 1 \u2013 Introduction to symbol visibility"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/TO-read/#limiting#visibility#of#symbols#when#linking#shared#libraries","text":"","title":"Limiting visibility of symbols when linking shared libraries"},{"location":"Programming/Object-file/ELF/draft/ELF-from-programming-language/Visibility/Visibility/","text":"https://stackoverflow.com/questions/52719364/how-to-use-the-attribute-visibilitydefault","title":"Visibility"},{"location":"Programming/Object-file/ELF/man-5-elf/","text":"ELF(5)","title":"Introduction"},{"location":"Programming/Object-file/ELF/man-5-elf/#elf5","text":"","title":"ELF(5)"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/","text":"Linux Dynamic Shared Library && LD Linker \u52a8\u6001\u94fe\u63a5\u7684\u610f\u4e49 **\u9759\u6001\u94fe\u63a5**\u5bf9**\u5185\u5b58**\u548c**\u78c1\u76d8**\u7684\u6d6a\u8d39\u5f88\u4e25\u91cd\uff0c\u5728\u9759\u6001\u94fe\u63a5\u4e2d\uff0cC\u8bed\u8a00\u9759\u6001\u5e93\u662f\u5f88\u5178\u578b\u7684\u5360\u7528\u7a7a\u95f4\u7684\u4f8b\u5b50 \u9759\u6001\u94fe\u63a5\u5bf9\u7a0b\u5e8f\u7684\u66f4\u65b0\u3001\u90e8\u7f72\u3001\u53d1\u5e03\u4f1a\u9020\u6210\u4e25\u91cd\u7684\u9ebb\u70e6 \u7b2c\u4e00\u70b9\u6240\u8bf4\u7684\u5305\u62ec\u5185\u5b58\u548c\u78c1\u76d8\uff0c\u5176\u5b9e\u8fd9\u5c31\u662f\u7a0b\u5e8f\u548c\u8fdb\u7a0b\u7684\u5173\u7cfb\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\uff0c\u6700\u597d\u7684\u601d\u8def\u5c31\u662f\u628a\u7a0b\u5e8f\u7684\u6a21\u5757\u76f8\u4e92**\u5206\u5272**\u5f00\u6765\uff0c\u5f62\u6210\u72ec\u7acb\u7684\u6587\u4ef6\uff0c\u800c\u4e0d\u518d\u5c06\u5b83\u4eec\u9759\u6001\u5730\u94fe\u63a5\u5728\u4e00\u8d77\u3002\u7b80\u5355\u6765\u8bf4\uff0c\u5c31\u662f\u4e0d\u5bf9\u90a3\u4e9b\u7ec4\u6210\u7a0b\u5e8f\u7684\u76ee\u6807\u6587\u4ef6\u8fdb\u884c\u94fe\u63a5\uff0c\u7b49\u5230\u7a0b\u5e8f\u8981**\u8fd0\u884c\u65f6**\u624d\u8fdb\u884c**\u94fe\u63a5**\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u628a**\u94fe\u63a5**\u8fd9\u4e2a\u8fc7\u7a0b\u63a8\u8fdf\u5230\u4e86**\u8fd0\u884c\u65f6**\u518d\u8fdb\u884c\uff0c\u8fd9\u5c31\u662f**\"\u52a8\u6001\u94fe\u63a5(dynamic linking)\"**\u7684\u57fa\u672c\u601d\u60f3 \u52a8\u6001\u94fe\u63a5\u7684\u4f18\u70b9 \u591a\u4e2a\u8fdb\u7a0b\u4f7f\u7528\u5230\u540c\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u6587\u4ef6\uff0c\u53ea\u8981\u5728\u5185\u5b58\u4e2d\u6620\u5c04\u4e00\u4efdELF .SO\u6587\u4ef6\u5373\u53ef\uff0c\u6709\u6548\u5730\u51cf\u5c11\u4e86\u8fdb\u7a0b\u7684\u5185\u5b58\u6d88\u8017 \u51cf\u5c11\u7269\u7406\u9875\u9762\u7684\u6362\u5165\u6362\u51fa(\u51cf\u5c11page out\u3001page in\u64cd\u4f5c) \u589e\u52a0CPU\u7f13\u5b58\u7684\u547d\u4e2d\u7387\uff0c\u56e0\u4e3a\u4e0d\u540c\u8fdb\u7a0b\u95f4\u7684\u6570\u636e\u548c\u6307\u4ee4\u8bbf\u95ee\u90fd\u96c6\u4e2d\u5728\u4e86\u540c\u4e00\u4e2a\u5171\u4eab\u6a21\u5757\u4e0a \u4f7f\u7a0b\u5e8f\u7684\u5347\u7ea7\u66f4\u52a0\u5bb9\u6613\uff0c\u5728\u5347\u7ea7\u7a0b\u5e8f\u5e93\u6216\u5171\u4eab\u67d0\u4e2a\u6a21\u5757\u65f6\uff0c\u53ea\u8981\u7b80\u5355\u5730\u5c06\u65e7\u7684\u76ee\u6807\u6587\u4ef6\u8986\u76d6\u6389\uff0c\u800c\u65e0\u987b\u5c06\u6240\u6709\u7684\u7a0b\u5e8f\u518d\u91cd\u65b0\u94fe\u63a5\u4e00\u904d\u3002\u5f53\u7a0b\u5e8f\u4e0b\u4e00\u6b21\u8fd0\u884c\u7684\u65f6\u5019\uff0c\u65b0\u7248\u672c\u7684\u76ee\u6807\u6587\u4ef6\u4f1a\u88ab\u81ea\u52a8\u88c5\u8f7d\u5230\u5185\u5b58\u5e76\u94fe\u63a5\u8d77\u6765\uff0c\u7a0b\u5e8f\u5c31\u5b8c\u6210\u4e86\u5347\u7ea7\u7684\u64cd\u4f5c \u8fd9\u8ba9\u6211\u60f3\u5230\u4e86\u4e4b\u524d\u78b0\u5230\u7684undefined symbol\u9519\u8bef\uff0c\u5982\u679c\u6211\u4eec\u4f7f\u7528\u7684\u51fd\u6570\u5728\u7b2c\u4e09\u65b9\u63d0\u4f9b\u7684\u52a8\u6001\u94fe\u63a5\u5e93\u4e2d\uff0c\u6211\u4eec\u5f80\u5f80\u4f1a\u5728\u7f16\u8bd1\u7684\u65f6\u5019\u52a0\u4e0a -llib \u7684\u65b9\u5f0f\u6765\u6307\u5b9a\u8fd9\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u3002\u6240\u4ee5\u5373\u4f7f\u662f\u52a8\u6001\u94fe\u63a5\uff0c\u5728\u7f16\u8bd1\u7684\u65f6\u5019\uff0c\u8fd8\u662f\u9700\u8981\u63d0\u4f9b\u9700\u8981\u4f7f\u7528\u7684\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4fe1\u606f\u7684\uff0c\u5e76\u4e14\u4fdd\u8bc1\u7a0b\u5e8f\u5728\u8fd0\u884c\u7684\u65f6\u5019\u662f\u80fd\u591f\u94fe\u63a5\u5230\u7684\uff0c\u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5728\u7f16\u8bd1so\u7684\u65f6\u5019\uff0c\u5982\u679c\u7f16\u8bd1\u5668\u53d1\u73b0\u4e86\u67d0\u4e2a\u7b26\u53f7\u662fundefined\u7684\uff0c\u4f46\u662f\u7f16\u8bd1\u5668\u662f\u4e0d\u4f1a\u62a5\u9519\u7684\u3002\u8fd9\u79cdundefined symbol\u9519\u8bef\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u7a0b\u5e8f\u5f02\u5e38\u3002\u4e5f\u6709\u53ef\u80fd\u7a0b\u5e8f\u8fd8\u662f\u6b63\u5e38\u8fd0\u884c\u3002 \u7a0b\u5e8f\u53ef\u6269\u5c55\u6027\u548c\u517c\u5bb9\u6027 \u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u6280\u672f\uff0c\u7a0b\u5e8f\u5728\u8fd0\u884c\u65f6\u53ef\u4ee5\u52a8\u6001\u5730\u9009\u62e9\u52a0\u8f7d\u5404\u79cd\u7a0b\u5e8f\u6a21\u5757\uff0c\u5373**\u63d2\u4ef6\u6280\u672f(Plug-in)** 1) \u7a0b\u5e8f\u6309\u7167\u4e00\u5b9a\u7684\u89c4\u5219\u5236\u5b9a\u597d\u7a0b\u5e8f\u7684**\u63a5\u53e3**\uff0c\u7b2c\u4e09\u65b9\u5f00\u53d1\u8005\u53ef\u4ee5\u6309\u7167\u8fd9\u79cd**\u63a5\u53e3**\u6765\u7f16\u5199\u7b26\u5408\u8981\u6c42\u7684**\u52a8\u6001\u94fe\u63a5\u6587\u4ef6**\uff0c\u8be5\u7a0b\u5e8f\u53ef\u4ee5**\u52a8\u6001\u5730\u8f7d\u5165**\u5404\u79cd\u7531\u7b2c\u4e09\u65b9\u5f00\u53d1\u7684\u6a21\u5757\uff0c\u5728\u7a0b\u5e8f\u8fd0\u884c\u65f6\u52a8\u6001\u5730\u94fe\u63a5\uff0c\u5b9e\u73b0\u7a0b\u5e8f\u529f\u80fd\u7684\u6269\u5c55\u3002\u5178\u578b\u5730\u5982php\u7684**zend\u6269\u5c55**\u3001iis\u7684filter/extension\u3001apache\u7684**mod\u6a21\u5757** 2) \u52a8\u6001\u94fe\u63a5\u8fd8\u53ef\u4ee5\u52a0\u5f3a\u7a0b\u5e8f\u7684\u517c\u5bb9\u6027\u3002\u4e00\u4e2a\u7a0b\u5e8f\u5728\u4e0d\u540c\u7684\u5e73\u53f0\u8fd0\u884c\u65f6\u53ef\u4ee5\u52a8\u6001\u5730\u94fe\u63a5\u5230\u7531\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684**\u52a8\u6001\u94fe\u63a5\u5e93**\uff0c\u8fd9\u4e9b\u52a8\u6001\u94fe\u63a5\u5e93\u5728**\u7a0b\u5e8f**\u548c**\u64cd\u4f5c\u7cfb\u7edf**\u4e4b\u95f4\u589e\u52a0\u4e86\u4e00\u4e2a**\u4e2d\u95f4\u5c42**\uff0c\u4ece\u800c\u6d88\u9664\u4e86\u7a0b\u5e8f\u5bf9\u4e0d\u540c\u5e73\u53f0\u4e4b\u95f4\u4f9d\u8d56\u7684\u5dee\u5f02\u6027 \u52a8\u6001\u94fe\u63a5\u6587\u4ef6\u7684\u7c7b\u522b \u52a8\u6001\u94fe\u63a5\u6d89\u53ca\u8fd0\u884c\u65f6\u7684\u94fe\u63a5\u53ca\u591a\u4e2a\u6587\u4ef6\u7684\u88c5\u8f7d\uff0c\u5fc5\u987b\u8981\u6709\u64cd\u4f5c\u7cfb\u7edf\u7684\u652f\u6301\uff0c\u56e0\u4e3a\u52a8\u6001\u94fe\u63a5\u7684\u60c5\u51b5\u4e0b\uff0c\u8fdb\u7a0b\u7684**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u7684\u5206\u5e03\u4f1a\u6bd4\u9759\u6001\u94fe\u63a5\u7684\u60c5\u51b5\u4e0b\u66f4\u4e3a\u590d\u6742\uff0c\u8fd8\u9700\u8981\u8003\u8651\u5230\u4e00\u4e9b\u5b58\u50a8\u7ba1\u7406\u3001\u5185\u5b58\u5171\u4eab\u3001\u8fdb\u7a0b\u7ebf\u7a0b\u7b49\u673a\u5236\u7684\u8003\u8651 Linux \u5728Linux\u7cfb\u7edf\u4e2d\uff0cELF\u52a8\u6001\u94fe\u63a5\u6587\u4ef6\u88ab\u79f0\u4e3a\u52a8\u6001\u5171\u4eab\u5bf9\u8c61(DSO Dynamic Shared Objects)\uff0c\u4e00\u822c\u4ee5\".so\"\u4e3a\u6269\u5c55\u540d \u5e38\u7528\u7684C\u8bed\u8a00\u5e93\u7684**\u8fd0\u884c\u5e93glibc**\uff0c\u5b83\u7684**\u52a8\u6001\u94fe\u63a5\u5f62\u5f0f\u7684\u7248\u672c**\u4fdd\u5b58\u5728\"/lib/libc.so\"\u3001\"/lib64/libc.so\"\u3002\u6574\u4e2a\u7cfb\u7edf\u53ea\u4fdd\u7559\u4e00\u4efdC\u8bed\u8a00\u5e93\u7684\u52a8\u6001\u94fe\u63a5\u6587\u4ef6\uff0c\u800c\u6240\u6709\u7684\u7531C\u8bed\u8a00\u7f16\u5199\u7684\u3001\u52a8\u6001\u94fe\u63a5\u7684\u7a0b\u5e8f\u90fd\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u4f7f\u7528\u5b83\uff0c\u5f53\u7a0b\u5e8f\u88ab\u88c5\u8f7d\u65f6\uff0c\u7cfb\u7edf\u7684**\u52a8\u6001\u94fe\u63a5\u5668**\u4f1a\u5c06\u7a0b\u5e8f\u6240\u9700\u7684**\u6240\u6709\u52a8\u6001\u94fe\u63a5\u5e93**(\u6700\u57fa\u672c\u7684\u5c31\u662flibc.so)\u88c5\u8f7d\u5230**\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4**\uff0c\u5e76\u4e14\u5c06\u7a0b\u5e8f\u4e2d\u6240\u6709**\u672a\u51b3\u8bae\u7684\u7b26\u53f7**\u7ed1\u5b9a\u5230\u76f8\u5e94\u7684**\u52a8\u6001\u94fe\u63a5\u5e93**\u4e2d\uff0c\u5e76\u8fdb\u884c**\u91cd\u5b9a\u4f4d**\u5de5\u4f5c Windows \u5728Windows\u7cfb\u7edf\u4e2d\uff0c\u52a8\u6001\u94fe\u63a5\u6587\u4ef6\u88ab\u79f0\u4e3a\u52a8\u6001\u94fe\u63a5\u5e93(Dynamic Linking Library)\uff0c\u4e00\u822c\u4ee5\".dll\"\u4e3a\u6269\u5c55\u540d \u5730\u5740\u65e0\u5173\u4ee3\u7801: PIC **\u53ef\u6267\u884c\u6587\u4ef6**\u5728**\u7f16\u8bd1**\u65f6\u53ef\u4ee5\u786e\u5b9a\u81ea\u5df1\u5728**\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u4e2d\u7684\u4f4d\u7f6e\uff0c\u56e0\u4e3a\u53ef\u6267\u884c\u6587\u4ef6\u5f80\u5f80\u90fd\u662f\u7b2c\u4e00\u4e2a\u88ab\u52a0\u8f7d\u7684\u6587\u4ef6\uff0c\u5b83\u53ef\u4ee5\u9009\u62e9\u4e00\u4e2a\u56fa\u5b9a\u7684\u4f4d\u7f6e 1) Linux: 0x08040000 2) Windows: 0x0040000 **\u5171\u4eab\u5bf9\u8c61**\u5728**\u7f16\u8bd1\u65f6**\u4e0d\u80fd\u5047\u8bbe\u81ea\u5df1\u5728\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u4f4d\u7f6e \u9700\u8981\u6ce8\u610f\u201c\u5171\u4eab\u201d\u8fd9\u4e2a\u8bcd\u7684\u542b\u4e49 \u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d Linux\u548cGCC\u652f\u63012\u79cd\u91cd\u5b9a\u4f4d\u7684\u65b9\u6cd5\uff1a 1. \u94fe\u63a5\u65f6**\u91cd\u5b9a\u4f4d(Link Time Relocation) -shared -fPIC \u5728\u7a0b\u5e8f**\u94fe\u63a5**\u7684\u65f6\u5019\u5c31\u5c06\u4ee3\u7801\u4e2d**\u7edd\u5bf9\u5730\u5740\u7684\u5f15\u7528**\u91cd\u5b9a\u4f4d\u4e3a**\u5b9e\u9645\u7684\u5730\u5740 \u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d(Load Time Relocation) -shared \u7a0b\u5e8f\u6a21\u5757\u5728\u7f16\u8bd1\u65f6\u76ee\u6807\u5730\u5740\u4e0d\u786e\u5b9a\u800c\u9700\u8981\u5728\u88c5\u8f7d\u65f6\u5c06\u6a21\u5757\u91cd\u5b9a\u4f4d \u5730\u5740\u65e0\u5173\u4ee3\u7801 \u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u662f\u89e3\u51b3\u52a8\u6001\u6a21\u5757\u4e2d\u6709**\u7edd\u5bf9\u5730\u5740\u5f15\u7528**\u7684\u65b9\u6cd5\u4e4b\u4e00\uff0c\u4f46\u662f\u8fd8\u5b58\u5728\u4e00\u4e2a\u95ee\u9898\uff0c**\u6307\u4ee4\u90e8\u5206**\u65e0\u6cd5\u5728\u591a\u4e2a\u8fdb\u7a0b\u95f4**\u5171\u4eab \uff0c\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u4e00\u4e2a\u57fa\u672c\u601d\u60f3\u5c31\u662f\u628a\u6307\u4ee4\u4e2d\u90a3\u4e9b\u9700\u8981\u88ab\u4fee\u6539\u7684\u90e8\u5206\u5206\u79bb\u51fa\u6765\uff0c\u8ddf**\u6570\u636e\u90e8\u5206**\u653e\u5728\u4e00\u8d77\uff0c\u8fd9\u6837\u6307\u4ee4\u5c31\u53ef\u4ee5\u4fdd\u6301\u4e0d\u53d8\uff0c\u800c**\u6570\u636e\u90e8\u5206**\u53ef\u4ee5\u5728\u6bcf\u4e2a\u8fdb\u7a0b\u4e2d\u62e5\u6709\u4e00\u4e2a\u526f\u672c\uff0c\u8fd9\u79cd\u65b9\u6848\u5c31\u662f**\u5730\u5740\u65e0\u5173\u4ee3\u7801(PIC Position-Independent Code)** \u5173\u4e8e\u5730\u5740\u65e0\u5173\u4ee3\u7801\u7684\u8865\u51fa\u5185\u5bb9\u5728 \u8fd9\u7bc7\u6587\u7ae0 \u4e2d\u4ecb\u7ecd\u4e86\u3002 \u6211\u4eec\u628a\u5171\u4eab\u5bf9\u8c61\u6a21\u5757\u4e2d\u7684\u5730\u5740\u5f15\u7528\u6309\u7167\u6a21\u5757\u5185\u90e8\u5f15\u7528/\u6a21\u5757\u5916\u90e8\u5f15\u7528\u3001\u6307\u4ee4\u5f15\u7528/\u6570\u636e\u8bbf\u95ee\u5206\u4e3a4\u7c7b /* pic.c */ static int a; extern int b; extern void ext(); void bar() { //Type2: Inner-module data access(\u6a21\u5757\u5185\u6570\u636e\u8bbf\u95ee) a = 1; //Tyep4: Inter-module data access(\u6a21\u5757\u95f4\u6570\u636e\u8bbf\u95ee) b = 2; } void foo() { //Type1: Inner-module call(\u6a21\u5757\u5185\u6307\u4ee4\u5f15\u7528) bar(); //Type3: Inter-module call() ext(); } \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5f53\u7f16\u8bd1\u5668\u5728\u7f16\u8bd1pic.c\u65f6\uff0c\u5b83\u5e76\u4e0d\u80fd\u786e\u5b9a\u53d8\u91cfb\u3001\u51fd\u6570ext()\u662f**\u6a21\u5757\u5916\u90e8**\u8fd8\u662f**\u6a21\u5757\u5185\u90e8**\u7684\uff0c\u56e0\u4e3a\u5b83\u4eec\u6709\u53ef\u80fd\u88ab\u5b9a\u4e49\u5728\u540c\u4e00\u4e2a\u5171\u4eab\u5bf9\u8c61\u7684\u5176\u4ed6**\u76ee\u6807\u6587\u4ef6**\u4e2d\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\u53ea\u80fd\u628a\u5b83\u4eec\u90fd\u5f53\u4f5c\u6a21\u5757\u5916\u90e8\u7684\u51fd\u6570\u548c\u53d8\u91cf\u6765\u5904\u7406\u3002 Type1: Inner-module call(\u6a21\u5757\u5185\u6307\u4ee4\u5f15\u7528) \u8fd9\u662f\u6700\u7b80\u5355\u7684\u4e00\u79cd\u60c5\u51b5\uff0c\u88ab\u8c03\u7528\u7684\u51fd\u6570\u4e0e\u8c03\u7528\u8005\u90fd\u5904\u4e8e**\u540c\u4e00\u4e2a\u6a21\u5757**\uff0c\u5b83\u4eec\u4e4b\u95f4\u7684\u76f8\u5bf9\u4f4d\u7f6e\u662f\u56fa\u5b9a\u7684\uff0c\u5bf9\u4e8e\u73b0\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u6765\u8bf4\uff0c\u6a21\u5757\u5185\u90e8\u8df3\u8f6c\u3001\u51fd\u6570\u8c03\u7528\u90fd\u53ef\u4ee5\u662f\"\u76f8\u5bf9\u5730\u5740\u8c03\u7528\"\u3001\u6216\u8005\u662f\"\u57fa\u4e8e\u5bc4\u5b58\u5668\u7684\u76f8\u5bf9\u8c03\u7528\"\uff0c\u6240\u4ee5\u5bf9\u4e8e\u8fd9\u79cd\u6307\u4ee4\u662f*\u4e0d\u9700\u8981\u91cd\u5b9a\u4f4d*\u7684\uff0c\u53ea\u8981\u6a21\u5757\u5185\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4e0d\u53d8\uff0c\u5219\u6a21\u5757\u5185\u7684\u6307\u4ee4\u8c03\u7528\u5c31\u662f**\u5730\u5740\u65e0\u5173**\u7684 Type2: Inner-module data access(\u6a21\u5757\u5185\u6570\u636e\u8bbf\u95ee) \u6211\u4eec\u77e5\u9053\uff0c\u4e00\u4e2a\u6a21\u5757\u524d\u9762\u4e00\u822c\u662f\u82e5\u5e72\u4e2a\u9875\u7684\u4ee3\u7801\uff0c\u540e\u9762\u7d27\u8ddf\u7740\u82e5\u5e72\u4e2a\u9875\u7684\u6570\u636e\uff0c\u8fd9\u4e9b\u9875\u4e4b\u95f4\u7684\u76f8\u5bf9\u4f4d\u7f6e\u662f\u56fa\u5b9a\u7684\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u76f8\u5bf9\u4e8e\u5f53\u524d\u6307\u4ee4\u52a0\u4e0a\"\u56fa\u5b9a\u7684\u504f\u79fb\u91cf\"\u5c31\u53ef\u4ee5\u8bbf\u95ee\u5230*\u6a21\u5757\u5185\u90e8\u6570\u636e*\u4e86 Type3: Inter-module call() GOT\u5b9e\u73b0\u6307\u4ee4\u5730\u5740\u65e0\u5173\u7684\u65b9\u5f0f\u548cGOT\u5b9e\u73b0\u6a21\u5757\u95f4\u6570\u636e\u8bbf\u95ee\u7684\u65b9\u5f0f\u7c7b\u4f3c\uff0c\u552f\u4e00\u4e0d\u540c\u7684\u662f\uff0cGOT\u4e2d\u7684\u9879\u4fdd\u5b58\u7684\u662f**\u76ee\u6807\u51fd\u6570**\u7684\u5730\u5740\uff0c\u5f53\u6a21\u5757\u8981\u8c03\u7528\u76ee\u6807\u51fd\u6570\u65f6\uff0c\u53ef\u4ee5\u901a\u8fc7GOT\u4e2d\u7684\u9879\u8fdb\u884c\u95f4\u63a5\u8df3\u8f6c Tyep4: Inter-module data access(\u6a21\u5757\u95f4\u6570\u636e\u8bbf\u95ee) \u6a21\u5757\u95f4\u7684\u6570\u636e\u8bbf\u95ee\u6bd4\u6a21\u5757\u5185\u90e8\u7a0d\u5fae\u9ebb\u70e6\u4e00\u70b9\uff0c\u56e0\u4e3a\u6a21\u5757\u95f4\u7684\u6570\u636e\u8bbf\u95ee*\u76ee\u6807\u5730\u5740*\u8981\u7b49\u5230*\u88c5\u8f7d*\u65f6\u624d\u80fd\u786e\u5b9a\u3002\u800c\u6211\u4eec\u8981\u8fbe\u5230**\u4ee3\u7801**\u548c**\u5730\u5740**\u65e0\u5173\u7684\u76ee\u7684\uff0c\u6700\u57fa\u672c\u7684\u601d\u60f3\u5c31\u662f\u628a\u548c**\u5730\u5740**\u76f8\u5173\u7684\u90e8\u5206\u653e\u5230**\u6570\u636e\u6bb5**\u4e2d\uff0cELF\u7684\u505a\u6cd5\u662f\u5728**\u6570\u636e\u6bb5**\u91cc\u5efa\u7acb\u4e00\u4e2a\u6307\u5411\u8fd9\u4e9b\u53d8\u91cf\u7684**\u6307\u9488\u6570\u7ec4**\uff0c\u4e5f\u88ab\u79f0\u4e3a**\u5168\u5c40\u504f\u79fb\u8868**(global offset table GOT)\uff0c\u5f53\u4ee3\u7801\u9700\u8981\u5f15\u7528\u5230\u8be5\u5168\u5c40\u53d8\u91cf\u65f6\uff0c\u53ef\u4ee5\u901a\u8fc7GOT\u4e2d\u76f8\u5bf9\u5e94\u7684\u9879\u8fdb\u884c\u95f4\u63a5\u5f15\u7528\u3002 \u94fe\u63a5\u5668\u5728\u88c5\u8f7d\u52a8\u6001\u6a21\u5757\u7684\u65f6\u5019\u4f1a\u67e5\u627e\u6bcf\u4e2a\u53d8\u91cf\u6240\u5728\u7684\u5730\u5740\uff0c\u7136\u540e\u586b\u5145GOT\u4e2d\u7684\u5404\u4e2a\u9879\uff0c\u4ee5\u786e\u4fdd\u6bcf\u4e2a\u6307\u9488\u6240\u6307\u5411\u7684\u5730\u5740\u6b63\u786e\uff0c\u7531\u4e8eGOT\u672c\u8eab\u662f\u653e\u5728\u6570\u636e\u6bb5\u7684\uff0c\u6240\u4ee5\u5b83\u53ef\u4ee5\u5728\u6a21\u5757\u88c5\u8f7d\u65f6\u88ab\u4fee\u6539\uff0c\u5e76\u4e14\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u6709\u72ec\u7acb\u7684\u526f\u672c\uff0c\u76f8\u4e92\u4e0d\u53d7\u5f71\u54cd\u3002 \u7efc\u4e0a\u6240\u8ff0\uff0c\u5730\u5740\u65e0\u5173\u4ee3\u7801\u7684\u5b9e\u73b0\u65b9\u5f0f\u5982\u4e0b: 1. \u6a21\u5757\u5185\u90e8 1) \u6307\u4ee4\u8df3\u8f6c\u3001\u8c03\u7528: \u76f8\u5bf9\u8df3\u8f6c\u548c\u8c03\u7528 2) \u6570\u636e\u8bbf\u95ee: \u76f8\u5bf9\u5730\u5740\u8bbf\u95ee 2. \u6a21\u5757\u5916\u90e8 1) \u6307\u4ee4\u8df3\u8f6c\u3001\u8c03\u7528: \u95f4\u63a5\u8df3\u8f6c\u548c\u8c03\u7528(GOT) 2) \u6570\u636e\u8bbf\u95ee: \u95f4\u63a5\u8bbf\u95ee(GOT) \u4f7f\u7528GCC\u4ea7\u751f**\u5730\u5740\u65e0\u5173\u4ee3\u7801**\u5f88\u7b80\u5355\uff0c\u53ea\u9700\u8981\u4f7f\u7528 -fPIC \u53c2\u6570\u5373\u53ef \u533a\u5206\u4e00\u4e2a**DSO**(\u52a8\u6001\u5171\u4eab\u5bf9\u8c61)\u662f\u5426\u4e3a**PIC**\u7684\u65b9\u6cd5\u5f88\u7b80\u5355\uff0c\u8f93\u5165\u4ee5\u4e0b\u6307\u4ee4 readelf -d hook.so | grep TEXTREL /* 1. PIC PIC\u7684DSO\u662f\u4e0d\u4f1a\u5305\u542b\u4efb\u4f55\u4ee3\u7801\u6bb5\u91cd\u5b9a\u4f4d\u8868\u7684\uff0cTEXTREL\u8868\u793a\u4ee3\u7801\u6bb5\u91cd\u5b9a\u4f4d\u8868\u5730\u5740 2. \u975ePIC \u672c\u6761\u6307\u4ee4\u6709\u4efb\u4f55\u8f93\u51fa\uff0c\u5219hook.so\u5c31\u4e0d\u662fPIC */ \u5730\u5740\u65e0\u5173\u4ee3\u7801**\u6280\u672f\u9664\u4e86\u53ef\u4ee5\u7528\u5728**\u5171\u4eab\u5bf9\u8c61**\u4e0a\u9762\uff0c\u5b83\u4e5f\u53ef\u4ee5\u7528\u4e8e**\u53ef\u6267\u884c\u6587\u4ef6 \uff0c\u4e00\u4e2a\u4ee5\u5730\u5740\u65e0\u5173\u65b9\u5f0f\u7f16\u8bd1\u7684\u53ef\u6267\u884c\u6587\u4ef6\u88ab\u79f0\u4f5c**\u5730\u5740\u65e0\u5173\u53ef\u6267\u884c\u6587\u4ef6**(PIE Position-Independent Executable)\uff0c\u4e0eGCC\u7684\"-fPIC\"\u7c7b\u4f3c\uff0c\u4ea7\u751fPIE\u7684\u53c2\u6570\u4e3a\"-fPIE\"\u3002 \u5168\u5c40\u504f\u79fb\u8868(GOT) \u5bf9\u4e8e**\u6a21\u5757\u5916\u90e8**\u5f15\u7528\u7684**\u5168\u5c40\u53d8\u91cf**\u548c**\u5168\u5c40\u51fd\u6570**\uff0c\u7528GOT\u8868\u7684\u8868\u9879\u5185\u5bb9\u4f5c\u4e3a\u5730\u5740\u6765**\u95f4\u63a5\u5bfb\u5740** \u5bf9\u4e8e\u672c\u6a21\u5757\u5185\u7684**\u9759\u6001\u53d8\u91cf**\u548c**\u9759\u6001\u51fd\u6570**\uff0c\u7528GOT\u8868\u7684\u9996\u5730\u5740\u4f5c\u4e3a\u4e00\u4e2a\u57fa\u51c6\uff0c\u7528\u76f8\u5bf9\u4e8e\u8be5\u57fa\u51c6\u7684\u504f\u79fb\u91cf\u6765\u5f15\u7528\uff0c\u56e0\u4e3a\u4e0d\u8bba\u7a0b\u5e8f\u88ab\u52a0\u8f7d\u5230\u4f55\u79cd\u5730\u5740\u7a7a\u95f4\uff0c\u6a21\u5757\u5185\u7684\u9759\u6001\u53d8\u91cf\u548c\u9759\u6001\u51fd\u6570\u4e0eGOT\u7684\u8ddd\u79bb\u662f\u56fa\u5b9a\u7684\uff0c\u5e76\u4e14\u5728\u94fe\u63a5\u9636\u6bb5\u5c31\u53ef\u77e5\u6653\u5176\u8ddd\u79bb\u7684\u5927\u5c0f \uff1f\uff1f\u5b83\u8fd9\u662f\u57fa\u4e8e\u600e\u6837\u7684\u4e00\u79cd\u8fd0\u7b97\u624d\u80fd\u591f\u4fdd\u8bc1\u51c6\u786e\u65e0\u8bef","title":"Dynamic Shared Library And LD Linker"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#_1","text":"**\u9759\u6001\u94fe\u63a5**\u5bf9**\u5185\u5b58**\u548c**\u78c1\u76d8**\u7684\u6d6a\u8d39\u5f88\u4e25\u91cd\uff0c\u5728\u9759\u6001\u94fe\u63a5\u4e2d\uff0cC\u8bed\u8a00\u9759\u6001\u5e93\u662f\u5f88\u5178\u578b\u7684\u5360\u7528\u7a7a\u95f4\u7684\u4f8b\u5b50 \u9759\u6001\u94fe\u63a5\u5bf9\u7a0b\u5e8f\u7684\u66f4\u65b0\u3001\u90e8\u7f72\u3001\u53d1\u5e03\u4f1a\u9020\u6210\u4e25\u91cd\u7684\u9ebb\u70e6 \u7b2c\u4e00\u70b9\u6240\u8bf4\u7684\u5305\u62ec\u5185\u5b58\u548c\u78c1\u76d8\uff0c\u5176\u5b9e\u8fd9\u5c31\u662f\u7a0b\u5e8f\u548c\u8fdb\u7a0b\u7684\u5173\u7cfb\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\uff0c\u6700\u597d\u7684\u601d\u8def\u5c31\u662f\u628a\u7a0b\u5e8f\u7684\u6a21\u5757\u76f8\u4e92**\u5206\u5272**\u5f00\u6765\uff0c\u5f62\u6210\u72ec\u7acb\u7684\u6587\u4ef6\uff0c\u800c\u4e0d\u518d\u5c06\u5b83\u4eec\u9759\u6001\u5730\u94fe\u63a5\u5728\u4e00\u8d77\u3002\u7b80\u5355\u6765\u8bf4\uff0c\u5c31\u662f\u4e0d\u5bf9\u90a3\u4e9b\u7ec4\u6210\u7a0b\u5e8f\u7684\u76ee\u6807\u6587\u4ef6\u8fdb\u884c\u94fe\u63a5\uff0c\u7b49\u5230\u7a0b\u5e8f\u8981**\u8fd0\u884c\u65f6**\u624d\u8fdb\u884c**\u94fe\u63a5**\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u628a**\u94fe\u63a5**\u8fd9\u4e2a\u8fc7\u7a0b\u63a8\u8fdf\u5230\u4e86**\u8fd0\u884c\u65f6**\u518d\u8fdb\u884c\uff0c\u8fd9\u5c31\u662f**\"\u52a8\u6001\u94fe\u63a5(dynamic linking)\"**\u7684\u57fa\u672c\u601d\u60f3","title":"\u52a8\u6001\u94fe\u63a5\u7684\u610f\u4e49"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#_2","text":"\u591a\u4e2a\u8fdb\u7a0b\u4f7f\u7528\u5230\u540c\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u6587\u4ef6\uff0c\u53ea\u8981\u5728\u5185\u5b58\u4e2d\u6620\u5c04\u4e00\u4efdELF .SO\u6587\u4ef6\u5373\u53ef\uff0c\u6709\u6548\u5730\u51cf\u5c11\u4e86\u8fdb\u7a0b\u7684\u5185\u5b58\u6d88\u8017 \u51cf\u5c11\u7269\u7406\u9875\u9762\u7684\u6362\u5165\u6362\u51fa(\u51cf\u5c11page out\u3001page in\u64cd\u4f5c) \u589e\u52a0CPU\u7f13\u5b58\u7684\u547d\u4e2d\u7387\uff0c\u56e0\u4e3a\u4e0d\u540c\u8fdb\u7a0b\u95f4\u7684\u6570\u636e\u548c\u6307\u4ee4\u8bbf\u95ee\u90fd\u96c6\u4e2d\u5728\u4e86\u540c\u4e00\u4e2a\u5171\u4eab\u6a21\u5757\u4e0a \u4f7f\u7a0b\u5e8f\u7684\u5347\u7ea7\u66f4\u52a0\u5bb9\u6613\uff0c\u5728\u5347\u7ea7\u7a0b\u5e8f\u5e93\u6216\u5171\u4eab\u67d0\u4e2a\u6a21\u5757\u65f6\uff0c\u53ea\u8981\u7b80\u5355\u5730\u5c06\u65e7\u7684\u76ee\u6807\u6587\u4ef6\u8986\u76d6\u6389\uff0c\u800c\u65e0\u987b\u5c06\u6240\u6709\u7684\u7a0b\u5e8f\u518d\u91cd\u65b0\u94fe\u63a5\u4e00\u904d\u3002\u5f53\u7a0b\u5e8f\u4e0b\u4e00\u6b21\u8fd0\u884c\u7684\u65f6\u5019\uff0c\u65b0\u7248\u672c\u7684\u76ee\u6807\u6587\u4ef6\u4f1a\u88ab\u81ea\u52a8\u88c5\u8f7d\u5230\u5185\u5b58\u5e76\u94fe\u63a5\u8d77\u6765\uff0c\u7a0b\u5e8f\u5c31\u5b8c\u6210\u4e86\u5347\u7ea7\u7684\u64cd\u4f5c \u8fd9\u8ba9\u6211\u60f3\u5230\u4e86\u4e4b\u524d\u78b0\u5230\u7684undefined symbol\u9519\u8bef\uff0c\u5982\u679c\u6211\u4eec\u4f7f\u7528\u7684\u51fd\u6570\u5728\u7b2c\u4e09\u65b9\u63d0\u4f9b\u7684\u52a8\u6001\u94fe\u63a5\u5e93\u4e2d\uff0c\u6211\u4eec\u5f80\u5f80\u4f1a\u5728\u7f16\u8bd1\u7684\u65f6\u5019\u52a0\u4e0a -llib \u7684\u65b9\u5f0f\u6765\u6307\u5b9a\u8fd9\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u3002\u6240\u4ee5\u5373\u4f7f\u662f\u52a8\u6001\u94fe\u63a5\uff0c\u5728\u7f16\u8bd1\u7684\u65f6\u5019\uff0c\u8fd8\u662f\u9700\u8981\u63d0\u4f9b\u9700\u8981\u4f7f\u7528\u7684\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4fe1\u606f\u7684\uff0c\u5e76\u4e14\u4fdd\u8bc1\u7a0b\u5e8f\u5728\u8fd0\u884c\u7684\u65f6\u5019\u662f\u80fd\u591f\u94fe\u63a5\u5230\u7684\uff0c\u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5728\u7f16\u8bd1so\u7684\u65f6\u5019\uff0c\u5982\u679c\u7f16\u8bd1\u5668\u53d1\u73b0\u4e86\u67d0\u4e2a\u7b26\u53f7\u662fundefined\u7684\uff0c\u4f46\u662f\u7f16\u8bd1\u5668\u662f\u4e0d\u4f1a\u62a5\u9519\u7684\u3002\u8fd9\u79cdundefined symbol\u9519\u8bef\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u7a0b\u5e8f\u5f02\u5e38\u3002\u4e5f\u6709\u53ef\u80fd\u7a0b\u5e8f\u8fd8\u662f\u6b63\u5e38\u8fd0\u884c\u3002 \u7a0b\u5e8f\u53ef\u6269\u5c55\u6027\u548c\u517c\u5bb9\u6027 \u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u6280\u672f\uff0c\u7a0b\u5e8f\u5728\u8fd0\u884c\u65f6\u53ef\u4ee5\u52a8\u6001\u5730\u9009\u62e9\u52a0\u8f7d\u5404\u79cd\u7a0b\u5e8f\u6a21\u5757\uff0c\u5373**\u63d2\u4ef6\u6280\u672f(Plug-in)** 1) \u7a0b\u5e8f\u6309\u7167\u4e00\u5b9a\u7684\u89c4\u5219\u5236\u5b9a\u597d\u7a0b\u5e8f\u7684**\u63a5\u53e3**\uff0c\u7b2c\u4e09\u65b9\u5f00\u53d1\u8005\u53ef\u4ee5\u6309\u7167\u8fd9\u79cd**\u63a5\u53e3**\u6765\u7f16\u5199\u7b26\u5408\u8981\u6c42\u7684**\u52a8\u6001\u94fe\u63a5\u6587\u4ef6**\uff0c\u8be5\u7a0b\u5e8f\u53ef\u4ee5**\u52a8\u6001\u5730\u8f7d\u5165**\u5404\u79cd\u7531\u7b2c\u4e09\u65b9\u5f00\u53d1\u7684\u6a21\u5757\uff0c\u5728\u7a0b\u5e8f\u8fd0\u884c\u65f6\u52a8\u6001\u5730\u94fe\u63a5\uff0c\u5b9e\u73b0\u7a0b\u5e8f\u529f\u80fd\u7684\u6269\u5c55\u3002\u5178\u578b\u5730\u5982php\u7684**zend\u6269\u5c55**\u3001iis\u7684filter/extension\u3001apache\u7684**mod\u6a21\u5757** 2) \u52a8\u6001\u94fe\u63a5\u8fd8\u53ef\u4ee5\u52a0\u5f3a\u7a0b\u5e8f\u7684\u517c\u5bb9\u6027\u3002\u4e00\u4e2a\u7a0b\u5e8f\u5728\u4e0d\u540c\u7684\u5e73\u53f0\u8fd0\u884c\u65f6\u53ef\u4ee5\u52a8\u6001\u5730\u94fe\u63a5\u5230\u7531\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684**\u52a8\u6001\u94fe\u63a5\u5e93**\uff0c\u8fd9\u4e9b\u52a8\u6001\u94fe\u63a5\u5e93\u5728**\u7a0b\u5e8f**\u548c**\u64cd\u4f5c\u7cfb\u7edf**\u4e4b\u95f4\u589e\u52a0\u4e86\u4e00\u4e2a**\u4e2d\u95f4\u5c42**\uff0c\u4ece\u800c\u6d88\u9664\u4e86\u7a0b\u5e8f\u5bf9\u4e0d\u540c\u5e73\u53f0\u4e4b\u95f4\u4f9d\u8d56\u7684\u5dee\u5f02\u6027","title":"\u52a8\u6001\u94fe\u63a5\u7684\u4f18\u70b9"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#_3","text":"\u52a8\u6001\u94fe\u63a5\u6d89\u53ca\u8fd0\u884c\u65f6\u7684\u94fe\u63a5\u53ca\u591a\u4e2a\u6587\u4ef6\u7684\u88c5\u8f7d\uff0c\u5fc5\u987b\u8981\u6709\u64cd\u4f5c\u7cfb\u7edf\u7684\u652f\u6301\uff0c\u56e0\u4e3a\u52a8\u6001\u94fe\u63a5\u7684\u60c5\u51b5\u4e0b\uff0c\u8fdb\u7a0b\u7684**\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u7684\u5206\u5e03\u4f1a\u6bd4\u9759\u6001\u94fe\u63a5\u7684\u60c5\u51b5\u4e0b\u66f4\u4e3a\u590d\u6742\uff0c\u8fd8\u9700\u8981\u8003\u8651\u5230\u4e00\u4e9b\u5b58\u50a8\u7ba1\u7406\u3001\u5185\u5b58\u5171\u4eab\u3001\u8fdb\u7a0b\u7ebf\u7a0b\u7b49\u673a\u5236\u7684\u8003\u8651 Linux \u5728Linux\u7cfb\u7edf\u4e2d\uff0cELF\u52a8\u6001\u94fe\u63a5\u6587\u4ef6\u88ab\u79f0\u4e3a\u52a8\u6001\u5171\u4eab\u5bf9\u8c61(DSO Dynamic Shared Objects)\uff0c\u4e00\u822c\u4ee5\".so\"\u4e3a\u6269\u5c55\u540d \u5e38\u7528\u7684C\u8bed\u8a00\u5e93\u7684**\u8fd0\u884c\u5e93glibc**\uff0c\u5b83\u7684**\u52a8\u6001\u94fe\u63a5\u5f62\u5f0f\u7684\u7248\u672c**\u4fdd\u5b58\u5728\"/lib/libc.so\"\u3001\"/lib64/libc.so\"\u3002\u6574\u4e2a\u7cfb\u7edf\u53ea\u4fdd\u7559\u4e00\u4efdC\u8bed\u8a00\u5e93\u7684\u52a8\u6001\u94fe\u63a5\u6587\u4ef6\uff0c\u800c\u6240\u6709\u7684\u7531C\u8bed\u8a00\u7f16\u5199\u7684\u3001\u52a8\u6001\u94fe\u63a5\u7684\u7a0b\u5e8f\u90fd\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u4f7f\u7528\u5b83\uff0c\u5f53\u7a0b\u5e8f\u88ab\u88c5\u8f7d\u65f6\uff0c\u7cfb\u7edf\u7684**\u52a8\u6001\u94fe\u63a5\u5668**\u4f1a\u5c06\u7a0b\u5e8f\u6240\u9700\u7684**\u6240\u6709\u52a8\u6001\u94fe\u63a5\u5e93**(\u6700\u57fa\u672c\u7684\u5c31\u662flibc.so)\u88c5\u8f7d\u5230**\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4**\uff0c\u5e76\u4e14\u5c06\u7a0b\u5e8f\u4e2d\u6240\u6709**\u672a\u51b3\u8bae\u7684\u7b26\u53f7**\u7ed1\u5b9a\u5230\u76f8\u5e94\u7684**\u52a8\u6001\u94fe\u63a5\u5e93**\u4e2d\uff0c\u5e76\u8fdb\u884c**\u91cd\u5b9a\u4f4d**\u5de5\u4f5c Windows \u5728Windows\u7cfb\u7edf\u4e2d\uff0c\u52a8\u6001\u94fe\u63a5\u6587\u4ef6\u88ab\u79f0\u4e3a\u52a8\u6001\u94fe\u63a5\u5e93(Dynamic Linking Library)\uff0c\u4e00\u822c\u4ee5\".dll\"\u4e3a\u6269\u5c55\u540d","title":"\u52a8\u6001\u94fe\u63a5\u6587\u4ef6\u7684\u7c7b\u522b"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#pic","text":"**\u53ef\u6267\u884c\u6587\u4ef6**\u5728**\u7f16\u8bd1**\u65f6\u53ef\u4ee5\u786e\u5b9a\u81ea\u5df1\u5728**\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4**\u4e2d\u7684\u4f4d\u7f6e\uff0c\u56e0\u4e3a\u53ef\u6267\u884c\u6587\u4ef6\u5f80\u5f80\u90fd\u662f\u7b2c\u4e00\u4e2a\u88ab\u52a0\u8f7d\u7684\u6587\u4ef6\uff0c\u5b83\u53ef\u4ee5\u9009\u62e9\u4e00\u4e2a\u56fa\u5b9a\u7684\u4f4d\u7f6e 1) Linux: 0x08040000 2) Windows: 0x0040000 **\u5171\u4eab\u5bf9\u8c61**\u5728**\u7f16\u8bd1\u65f6**\u4e0d\u80fd\u5047\u8bbe\u81ea\u5df1\u5728\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u4f4d\u7f6e \u9700\u8981\u6ce8\u610f\u201c\u5171\u4eab\u201d\u8fd9\u4e2a\u8bcd\u7684\u542b\u4e49","title":"\u5730\u5740\u65e0\u5173\u4ee3\u7801: PIC"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#_4","text":"Linux\u548cGCC\u652f\u63012\u79cd\u91cd\u5b9a\u4f4d\u7684\u65b9\u6cd5\uff1a 1. \u94fe\u63a5\u65f6**\u91cd\u5b9a\u4f4d(Link Time Relocation) -shared -fPIC \u5728\u7a0b\u5e8f**\u94fe\u63a5**\u7684\u65f6\u5019\u5c31\u5c06\u4ee3\u7801\u4e2d**\u7edd\u5bf9\u5730\u5740\u7684\u5f15\u7528**\u91cd\u5b9a\u4f4d\u4e3a**\u5b9e\u9645\u7684\u5730\u5740 \u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d(Load Time Relocation) -shared \u7a0b\u5e8f\u6a21\u5757\u5728\u7f16\u8bd1\u65f6\u76ee\u6807\u5730\u5740\u4e0d\u786e\u5b9a\u800c\u9700\u8981\u5728\u88c5\u8f7d\u65f6\u5c06\u6a21\u5757\u91cd\u5b9a\u4f4d","title":"\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#_5","text":"\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u662f\u89e3\u51b3\u52a8\u6001\u6a21\u5757\u4e2d\u6709**\u7edd\u5bf9\u5730\u5740\u5f15\u7528**\u7684\u65b9\u6cd5\u4e4b\u4e00\uff0c\u4f46\u662f\u8fd8\u5b58\u5728\u4e00\u4e2a\u95ee\u9898\uff0c**\u6307\u4ee4\u90e8\u5206**\u65e0\u6cd5\u5728\u591a\u4e2a\u8fdb\u7a0b\u95f4**\u5171\u4eab \uff0c\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u4e00\u4e2a\u57fa\u672c\u601d\u60f3\u5c31\u662f\u628a\u6307\u4ee4\u4e2d\u90a3\u4e9b\u9700\u8981\u88ab\u4fee\u6539\u7684\u90e8\u5206\u5206\u79bb\u51fa\u6765\uff0c\u8ddf**\u6570\u636e\u90e8\u5206**\u653e\u5728\u4e00\u8d77\uff0c\u8fd9\u6837\u6307\u4ee4\u5c31\u53ef\u4ee5\u4fdd\u6301\u4e0d\u53d8\uff0c\u800c**\u6570\u636e\u90e8\u5206**\u53ef\u4ee5\u5728\u6bcf\u4e2a\u8fdb\u7a0b\u4e2d\u62e5\u6709\u4e00\u4e2a\u526f\u672c\uff0c\u8fd9\u79cd\u65b9\u6848\u5c31\u662f**\u5730\u5740\u65e0\u5173\u4ee3\u7801(PIC Position-Independent Code)** \u5173\u4e8e\u5730\u5740\u65e0\u5173\u4ee3\u7801\u7684\u8865\u51fa\u5185\u5bb9\u5728 \u8fd9\u7bc7\u6587\u7ae0 \u4e2d\u4ecb\u7ecd\u4e86\u3002 \u6211\u4eec\u628a\u5171\u4eab\u5bf9\u8c61\u6a21\u5757\u4e2d\u7684\u5730\u5740\u5f15\u7528\u6309\u7167\u6a21\u5757\u5185\u90e8\u5f15\u7528/\u6a21\u5757\u5916\u90e8\u5f15\u7528\u3001\u6307\u4ee4\u5f15\u7528/\u6570\u636e\u8bbf\u95ee\u5206\u4e3a4\u7c7b /* pic.c */ static int a; extern int b; extern void ext(); void bar() { //Type2: Inner-module data access(\u6a21\u5757\u5185\u6570\u636e\u8bbf\u95ee) a = 1; //Tyep4: Inter-module data access(\u6a21\u5757\u95f4\u6570\u636e\u8bbf\u95ee) b = 2; } void foo() { //Type1: Inner-module call(\u6a21\u5757\u5185\u6307\u4ee4\u5f15\u7528) bar(); //Type3: Inter-module call() ext(); } \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5f53\u7f16\u8bd1\u5668\u5728\u7f16\u8bd1pic.c\u65f6\uff0c\u5b83\u5e76\u4e0d\u80fd\u786e\u5b9a\u53d8\u91cfb\u3001\u51fd\u6570ext()\u662f**\u6a21\u5757\u5916\u90e8**\u8fd8\u662f**\u6a21\u5757\u5185\u90e8**\u7684\uff0c\u56e0\u4e3a\u5b83\u4eec\u6709\u53ef\u80fd\u88ab\u5b9a\u4e49\u5728\u540c\u4e00\u4e2a\u5171\u4eab\u5bf9\u8c61\u7684\u5176\u4ed6**\u76ee\u6807\u6587\u4ef6**\u4e2d\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\u53ea\u80fd\u628a\u5b83\u4eec\u90fd\u5f53\u4f5c\u6a21\u5757\u5916\u90e8\u7684\u51fd\u6570\u548c\u53d8\u91cf\u6765\u5904\u7406\u3002","title":"\u5730\u5740\u65e0\u5173\u4ee3\u7801"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#type1#inner-module#call","text":"\u8fd9\u662f\u6700\u7b80\u5355\u7684\u4e00\u79cd\u60c5\u51b5\uff0c\u88ab\u8c03\u7528\u7684\u51fd\u6570\u4e0e\u8c03\u7528\u8005\u90fd\u5904\u4e8e**\u540c\u4e00\u4e2a\u6a21\u5757**\uff0c\u5b83\u4eec\u4e4b\u95f4\u7684\u76f8\u5bf9\u4f4d\u7f6e\u662f\u56fa\u5b9a\u7684\uff0c\u5bf9\u4e8e\u73b0\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u6765\u8bf4\uff0c\u6a21\u5757\u5185\u90e8\u8df3\u8f6c\u3001\u51fd\u6570\u8c03\u7528\u90fd\u53ef\u4ee5\u662f\"\u76f8\u5bf9\u5730\u5740\u8c03\u7528\"\u3001\u6216\u8005\u662f\"\u57fa\u4e8e\u5bc4\u5b58\u5668\u7684\u76f8\u5bf9\u8c03\u7528\"\uff0c\u6240\u4ee5\u5bf9\u4e8e\u8fd9\u79cd\u6307\u4ee4\u662f*\u4e0d\u9700\u8981\u91cd\u5b9a\u4f4d*\u7684\uff0c\u53ea\u8981\u6a21\u5757\u5185\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4e0d\u53d8\uff0c\u5219\u6a21\u5757\u5185\u7684\u6307\u4ee4\u8c03\u7528\u5c31\u662f**\u5730\u5740\u65e0\u5173**\u7684","title":"Type1: Inner-module call(\u6a21\u5757\u5185\u6307\u4ee4\u5f15\u7528)"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#type2#inner-module#data#access","text":"\u6211\u4eec\u77e5\u9053\uff0c\u4e00\u4e2a\u6a21\u5757\u524d\u9762\u4e00\u822c\u662f\u82e5\u5e72\u4e2a\u9875\u7684\u4ee3\u7801\uff0c\u540e\u9762\u7d27\u8ddf\u7740\u82e5\u5e72\u4e2a\u9875\u7684\u6570\u636e\uff0c\u8fd9\u4e9b\u9875\u4e4b\u95f4\u7684\u76f8\u5bf9\u4f4d\u7f6e\u662f\u56fa\u5b9a\u7684\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u76f8\u5bf9\u4e8e\u5f53\u524d\u6307\u4ee4\u52a0\u4e0a\"\u56fa\u5b9a\u7684\u504f\u79fb\u91cf\"\u5c31\u53ef\u4ee5\u8bbf\u95ee\u5230*\u6a21\u5757\u5185\u90e8\u6570\u636e*\u4e86","title":"Type2: Inner-module data access(\u6a21\u5757\u5185\u6570\u636e\u8bbf\u95ee)"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#type3#inter-module#call","text":"GOT\u5b9e\u73b0\u6307\u4ee4\u5730\u5740\u65e0\u5173\u7684\u65b9\u5f0f\u548cGOT\u5b9e\u73b0\u6a21\u5757\u95f4\u6570\u636e\u8bbf\u95ee\u7684\u65b9\u5f0f\u7c7b\u4f3c\uff0c\u552f\u4e00\u4e0d\u540c\u7684\u662f\uff0cGOT\u4e2d\u7684\u9879\u4fdd\u5b58\u7684\u662f**\u76ee\u6807\u51fd\u6570**\u7684\u5730\u5740\uff0c\u5f53\u6a21\u5757\u8981\u8c03\u7528\u76ee\u6807\u51fd\u6570\u65f6\uff0c\u53ef\u4ee5\u901a\u8fc7GOT\u4e2d\u7684\u9879\u8fdb\u884c\u95f4\u63a5\u8df3\u8f6c","title":"Type3: Inter-module call()"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#tyep4#inter-module#data#access","text":"\u6a21\u5757\u95f4\u7684\u6570\u636e\u8bbf\u95ee\u6bd4\u6a21\u5757\u5185\u90e8\u7a0d\u5fae\u9ebb\u70e6\u4e00\u70b9\uff0c\u56e0\u4e3a\u6a21\u5757\u95f4\u7684\u6570\u636e\u8bbf\u95ee*\u76ee\u6807\u5730\u5740*\u8981\u7b49\u5230*\u88c5\u8f7d*\u65f6\u624d\u80fd\u786e\u5b9a\u3002\u800c\u6211\u4eec\u8981\u8fbe\u5230**\u4ee3\u7801**\u548c**\u5730\u5740**\u65e0\u5173\u7684\u76ee\u7684\uff0c\u6700\u57fa\u672c\u7684\u601d\u60f3\u5c31\u662f\u628a\u548c**\u5730\u5740**\u76f8\u5173\u7684\u90e8\u5206\u653e\u5230**\u6570\u636e\u6bb5**\u4e2d\uff0cELF\u7684\u505a\u6cd5\u662f\u5728**\u6570\u636e\u6bb5**\u91cc\u5efa\u7acb\u4e00\u4e2a\u6307\u5411\u8fd9\u4e9b\u53d8\u91cf\u7684**\u6307\u9488\u6570\u7ec4**\uff0c\u4e5f\u88ab\u79f0\u4e3a**\u5168\u5c40\u504f\u79fb\u8868**(global offset table GOT)\uff0c\u5f53\u4ee3\u7801\u9700\u8981\u5f15\u7528\u5230\u8be5\u5168\u5c40\u53d8\u91cf\u65f6\uff0c\u53ef\u4ee5\u901a\u8fc7GOT\u4e2d\u76f8\u5bf9\u5e94\u7684\u9879\u8fdb\u884c\u95f4\u63a5\u5f15\u7528\u3002 \u94fe\u63a5\u5668\u5728\u88c5\u8f7d\u52a8\u6001\u6a21\u5757\u7684\u65f6\u5019\u4f1a\u67e5\u627e\u6bcf\u4e2a\u53d8\u91cf\u6240\u5728\u7684\u5730\u5740\uff0c\u7136\u540e\u586b\u5145GOT\u4e2d\u7684\u5404\u4e2a\u9879\uff0c\u4ee5\u786e\u4fdd\u6bcf\u4e2a\u6307\u9488\u6240\u6307\u5411\u7684\u5730\u5740\u6b63\u786e\uff0c\u7531\u4e8eGOT\u672c\u8eab\u662f\u653e\u5728\u6570\u636e\u6bb5\u7684\uff0c\u6240\u4ee5\u5b83\u53ef\u4ee5\u5728\u6a21\u5757\u88c5\u8f7d\u65f6\u88ab\u4fee\u6539\uff0c\u5e76\u4e14\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u6709\u72ec\u7acb\u7684\u526f\u672c\uff0c\u76f8\u4e92\u4e0d\u53d7\u5f71\u54cd\u3002 \u7efc\u4e0a\u6240\u8ff0\uff0c\u5730\u5740\u65e0\u5173\u4ee3\u7801\u7684\u5b9e\u73b0\u65b9\u5f0f\u5982\u4e0b: 1. \u6a21\u5757\u5185\u90e8 1) \u6307\u4ee4\u8df3\u8f6c\u3001\u8c03\u7528: \u76f8\u5bf9\u8df3\u8f6c\u548c\u8c03\u7528 2) \u6570\u636e\u8bbf\u95ee: \u76f8\u5bf9\u5730\u5740\u8bbf\u95ee 2. \u6a21\u5757\u5916\u90e8 1) \u6307\u4ee4\u8df3\u8f6c\u3001\u8c03\u7528: \u95f4\u63a5\u8df3\u8f6c\u548c\u8c03\u7528(GOT) 2) \u6570\u636e\u8bbf\u95ee: \u95f4\u63a5\u8bbf\u95ee(GOT) \u4f7f\u7528GCC\u4ea7\u751f**\u5730\u5740\u65e0\u5173\u4ee3\u7801**\u5f88\u7b80\u5355\uff0c\u53ea\u9700\u8981\u4f7f\u7528 -fPIC \u53c2\u6570\u5373\u53ef \u533a\u5206\u4e00\u4e2a**DSO**(\u52a8\u6001\u5171\u4eab\u5bf9\u8c61)\u662f\u5426\u4e3a**PIC**\u7684\u65b9\u6cd5\u5f88\u7b80\u5355\uff0c\u8f93\u5165\u4ee5\u4e0b\u6307\u4ee4 readelf -d hook.so | grep TEXTREL /* 1. PIC PIC\u7684DSO\u662f\u4e0d\u4f1a\u5305\u542b\u4efb\u4f55\u4ee3\u7801\u6bb5\u91cd\u5b9a\u4f4d\u8868\u7684\uff0cTEXTREL\u8868\u793a\u4ee3\u7801\u6bb5\u91cd\u5b9a\u4f4d\u8868\u5730\u5740 2. \u975ePIC \u672c\u6761\u6307\u4ee4\u6709\u4efb\u4f55\u8f93\u51fa\uff0c\u5219hook.so\u5c31\u4e0d\u662fPIC */ \u5730\u5740\u65e0\u5173\u4ee3\u7801**\u6280\u672f\u9664\u4e86\u53ef\u4ee5\u7528\u5728**\u5171\u4eab\u5bf9\u8c61**\u4e0a\u9762\uff0c\u5b83\u4e5f\u53ef\u4ee5\u7528\u4e8e**\u53ef\u6267\u884c\u6587\u4ef6 \uff0c\u4e00\u4e2a\u4ee5\u5730\u5740\u65e0\u5173\u65b9\u5f0f\u7f16\u8bd1\u7684\u53ef\u6267\u884c\u6587\u4ef6\u88ab\u79f0\u4f5c**\u5730\u5740\u65e0\u5173\u53ef\u6267\u884c\u6587\u4ef6**(PIE Position-Independent Executable)\uff0c\u4e0eGCC\u7684\"-fPIC\"\u7c7b\u4f3c\uff0c\u4ea7\u751fPIE\u7684\u53c2\u6570\u4e3a\"-fPIE\"\u3002","title":"Tyep4: Inter-module data access(\u6a21\u5757\u95f4\u6570\u636e\u8bbf\u95ee)"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-Shared-Library-And-LD-Linker/#got","text":"\u5bf9\u4e8e**\u6a21\u5757\u5916\u90e8**\u5f15\u7528\u7684**\u5168\u5c40\u53d8\u91cf**\u548c**\u5168\u5c40\u51fd\u6570**\uff0c\u7528GOT\u8868\u7684\u8868\u9879\u5185\u5bb9\u4f5c\u4e3a\u5730\u5740\u6765**\u95f4\u63a5\u5bfb\u5740** \u5bf9\u4e8e\u672c\u6a21\u5757\u5185\u7684**\u9759\u6001\u53d8\u91cf**\u548c**\u9759\u6001\u51fd\u6570**\uff0c\u7528GOT\u8868\u7684\u9996\u5730\u5740\u4f5c\u4e3a\u4e00\u4e2a\u57fa\u51c6\uff0c\u7528\u76f8\u5bf9\u4e8e\u8be5\u57fa\u51c6\u7684\u504f\u79fb\u91cf\u6765\u5f15\u7528\uff0c\u56e0\u4e3a\u4e0d\u8bba\u7a0b\u5e8f\u88ab\u52a0\u8f7d\u5230\u4f55\u79cd\u5730\u5740\u7a7a\u95f4\uff0c\u6a21\u5757\u5185\u7684\u9759\u6001\u53d8\u91cf\u548c\u9759\u6001\u51fd\u6570\u4e0eGOT\u7684\u8ddd\u79bb\u662f\u56fa\u5b9a\u7684\uff0c\u5e76\u4e14\u5728\u94fe\u63a5\u9636\u6bb5\u5c31\u53ef\u77e5\u6653\u5176\u8ddd\u79bb\u7684\u5927\u5c0f \uff1f\uff1f\u5b83\u8fd9\u662f\u57fa\u4e8e\u600e\u6837\u7684\u4e00\u79cd\u8fd0\u7b97\u624d\u80fd\u591f\u4fdd\u8bc1\u51c6\u786e\u65e0\u8bef","title":"\u5168\u5c40\u504f\u79fb\u8868(GOT)"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/PIC-%26-PIE/","text":"\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d\u662f\u89e3\u51b3\u52a8\u6001\u6a21\u5757\u4e2d\u6709\u7edd\u5bf9\u5730\u5740\u5f15\u7528\u7684\u65b9\u6cd5\u4e4b\u4e00\uff0c\u4f46\u662f\u8fd8\u5b58\u5728\u4e00\u4e2a\u95ee\u9898\uff0c\u6307\u4ee4\u90e8\u5206\u65e0\u6cd5\u5728\u591a\u4e2a\u8fdb\u7a0b\u95f4\u5171\u4eab\uff0c\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u4e00\u4e2a\u57fa\u672c\u601d\u60f3\u5c31\u662f\u628a\u6307\u4ee4\u4e2d\u90a3\u4e9b\u9700\u8981\u88ab\u4fee\u6539\u7684\u90e8\u5206\u5206\u79bb\u51fa\u6765\uff0c\u8ddf\u6570\u636e\u90e8\u5206\u653e\u5728\u4e00\u8d77\uff0c\u8fd9\u6837\u6307\u4ee4\u5c31\u53ef\u4ee5\u4fdd\u6301\u4e0d\u53d8\uff0c\u800c\u6570\u636e\u90e8\u5206\u53ef\u4ee5\u5728\u6bcf\u4e2a\u8fdb\u7a0b\u4e2d\u62e5\u6709\u4e00\u4e2a\u526f\u672c\uff0c\u8fd9\u79cd\u65b9\u6848\u5c31\u662f\u5730\u5740\u65e0\u5173\u4ee3\u7801(PIC Position-Independent Code) \u5730\u5740\u65e0\u5173\u4ee3\u7801\u6280\u672f\u9664\u4e86\u53ef\u4ee5\u7528\u5728\u5171\u4eab\u5bf9\u8c61\u4e0a\u9762\uff0c\u5b83\u4e5f\u53ef\u4ee5\u7528\u4e8e\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u4e00\u4e2a\u4ee5\u5730\u5740\u65e0\u5173\u65b9\u5f0f\u7f16\u8bd1\u7684\u53ef\u6267\u884c\u6587\u4ef6\u88ab\u79f0\u4f5c\u5730\u5740\u65e0\u5173\u53ef\u6267\u884c\u6587\u4ef6(PIE Position-Independent Executable)\uff0c\u4e0eGCC\u7684\"-fPIC\"\u7c7b\u4f3c\uff0c\u4ea7\u751fPIE\u7684\u53c2\u6570\u4e3a\"-fPIE\"","title":"PIC & PIE"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/how-to-determine-the-address-of-a-program/","text":"\u4eca\u5929\u5728\u9605\u8bfb \u8fd9\u7bc7\u6587\u7ae0 \u7684\u65f6\u5019\uff0c\u5176\u4e2d\u63d0\u5230\u4e86\u5982\u4e0b\u5185\u5bb9\uff1a \u94fe\u63a5\u5668\u5c06\u6240\u6709\u76f8\u540c\u7c7b\u578b\u7684\u8282\u5408\u5e76\u4e3a\u540c\u4e00\u7c7b\u578b\u7684\u65b0\u7684\u805a\u5408\u8282\u3002\u4f8b\u5982\u6765\u81ea\u8f93\u5165\u6a21\u5757\u7684.data\u8282\u5168\u90e8\u5408\u5e76\u6210\u4e00\u4e2a\u8282\uff0c\u8fd9\u4e2a\u8282\u6210\u4e3a\u8f93\u51fa\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684.data\u8282\u3002\u7136\u540e**\u94fe\u63a5\u5668**\u5c06**\u8fd0\u884c\u65f6\u5b58\u50a8\u5668\u5730\u5740**\u8d4b\u7ed9\u65b0\u7684\u805a\u5408\u8282\uff0c\u8d4b\u7ed9\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6bcf\u4e2a\u8282\uff0c\u4ee5\u53ca\u8d4b\u7ed9\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6bcf\u4e2a\u7b26\u53f7\u3002\u5f53\u8fd9\u4e00\u6b65\u5b8c\u6210\u65f6\uff0c\u7a0b\u5e8f\u4e2d\u7684\u6bcf\u4e2a\u6307\u4ee4\u548c\u5168\u5c40\u53d8\u91cf\u90fd\u6709\u552f\u4e00\u7684\u8fd0\u884c\u65f6\u5b58\u50a8\u5668\u5730\u5740\u4e86\u3002 \u901a\u8fc7\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u6211\u7684\u611f\u89c9\u662f\u7a0b\u5e8f\u7684\u8fd0\u884c\u5730\u5740\u662f\u7531\u7f16\u8bd1\u5668\u51b3\u5b9a\u7684\u3002\u4f46\u662f\u4ed4\u7ec6\u4e00\u60f3\uff0c\u89c9\u5f97\u8fd9\u6837\u7684\u63cf\u8ff0\u662f\u975e\u5e38\u4e0d\u6b63\u786e\u7684\uff1b\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u540c\u65f6\u662f\u8fd0\u884c\u591a\u4e2a\u8fdb\u7a0b\u7684\uff0c\u5e76\u4e14\u5c06\u6765\u8981\u8fd0\u884c\u591a\u4e2a\u4e2a\u8fdb\u7a0b\u662f\u65e0\u6cd5\u63d0\u524d\u9884\u77e5\u7684\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\u5728\u521b\u5efa\u4e00\u4e2a\u7a0b\u5e8f\u7684\u65f6\u5019\uff0c\u5b83\u662f\u4e0d\u77e5\u9053\u6b64\u4e8b\u64cd\u4f5c\u7cfb\u7edf\u7684\u5185\u5b58\u7a7a\u95f4\u7684\u4f7f\u7528\u60c5\u51b5\u7684\uff0c\u6240\u4ee5\u5b83\u662f\u65e0\u6cd5\u51b3\u5b9a\u7a0b\u5e8f\u8fd0\u884c\u65f6\u7684\u5185\u5b58\u5730\u5740\u7684\u3002\u770b\u6765\u662f\u9700\u8981\u4e86\u89e3\u4e00\u4e0b\uff0c\u7a0b\u5e8f\u7684\u88c5\u8f7d\u7684\u76f8\u5173\u77e5\u8bc6\u4e86\u3002 \u663e\u7136\uff0c\u6b64\u65f6\u6307\u5b9a\u7684\u5730\u5740\u662f\u5728\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u5730\u5740\u3002","title":"How to determine the address of a program"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/load-time-relocation/","text":"\u52a8\u6001\u5171\u4eab\u5bf9\u8c61\u7684\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d \u6700\u8fd1\u8bfb\u7a0b\u5e8f\u5458\u7684\u81ea\u6211\u4fee\u517b--\u94fe\u63a5 \u88c5\u8f7d\u4e0e\u5e93\uff0c\u5176\u4e2d\u6709\u53e5\u8bdd\uff1a**\u52a8\u6001\u94fe\u63a5\u6a21\u5757**\u88ab\u88c5\u8f7d\u6620\u5c04\u5230**\u865a\u62df\u7a7a\u95f4**\u540e\uff0c**\u6307\u4ee4\u90e8\u5206**\u662f\u5728\u591a\u4e2a**\u8fdb\u7a0b**\u4e4b\u95f4**\u5171\u4eab**\u7684\uff0c\u7531\u4e8e**\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u7684\u65b9\u6cd5\u9700\u8981**\u4fee\u6539**\u6307\u4ee4\uff0c\u6240\u4ee5\u6ca1\u6709\u529e\u6cd5\u505a\u5230\u540c\u4e00\u4efd\u6307\u4ee4\u88ab\u591a\u4e2a\u8fdb\u7a0b\u5171\u4eab\uff0c\u56e0\u4e3a\u6307\u4ee4\u88ab**\u91cd\u5b9a\u4f4d**\u540e\u5bf9\u4e8e\u6bcf\u4e2a\u8fdb\u7a0b\u6765\u8bb2\u662f\u4e0d\u540c\u7684\u3002\u4e00\u76f4\u6ca1\u641e\u61c2\uff0c\u82b1\u4e86\u4e0d\u5c11\u65f6\u95f4\u67e5\u9605\u8d44\u6599\uff0c\u4e86\u89e3\u539f\u7406\u3002\u89c9\u5f97\u81ea\u5df1\u4e00\u76f4\u7406\u89e3\u7684\u4e1c\u897f\u90fd\u592a\u6d45\u4e86\u3002 \u4ee5\u4e0b\u662f\u5bf9\u8fd9\u5757\u5185\u5bb9\u7684\u603b\u7ed3\uff0c\u4f5c\u4e3a\u8bb0\u5f55\u3002 \u5176\u4e2d\u7684\u5173\u952e\u70b9\u5728\u4e8e\u638c\u63e1**\u5185\u5b58\u6620\u5c04**\uff0c\u91cd\u5b9a\u4f4d\u7684\u5b9e\u73b0\u4ee5\u53ca\u5171\u4eab\u5bf9\u8c61\u7684\u88c5\u8f7d\u3002\u641e\u6e05\u695a**\u865a\u62df\u5185\u5b58\u7a7a\u95f4**\u548c**\u7269\u7406\u5185\u5b58\u7a7a\u95f4**\u3002 \u5171\u4eab\u5bf9\u8c61\u5728\u88ab\u88c5\u8f7d\u65f6\uff0c\u662f\u5982\u4f55\u786e\u5b9a\u5b83\u5728\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u4f4d\u7f6e\uff1f \u4e00\u79cd\u65b9\u6cd5\u662f\u56fa\u5b9a\u88c5\u8f7d\uff0c\u8fd9\u79cd\u65b9\u6cd5\u5f0a\u7aef\u660e\u663e\uff1a\u5730\u5740\u51b2\u7a81\uff1b\u5171\u4eab\u5e93\u5347\u7ea7\u56f0\u96be\uff1b\u7a7a\u95f4\u53d7\u9650\u7b49\u7b49\u3002\uff08\u57fa\u672c\u4e0d\u7528\uff09 \u90a3\u4e48\u53ea\u80fd\u91c7\u7528\u53e6\u4e00\u79cd\u601d\u8def\uff0c\u5373**\u5171\u4eab\u5bf9\u8c61**\u80fd\u5728\u4efb\u610f\u5730\u5740\u88c5\u8f7d\u3002\u8fd9\u79cd\u60c5\u51b5\u53eb\u505a**\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u3002\u5f53\u7a0b\u5e8f\u88ab\u88c5\u8f7d\u65f6\uff0c\u7cfb\u7edf\u7684**\u52a8\u6001\u94fe\u63a5\u5668**\u4f1a\u5c06\u7a0b\u5e8f\u6240\u9700\u7684\u6240\u6709**\u52a8\u6001\u94fe\u63a5\u5e93**\uff08\u4f8b\u5982\u6700\u57fa\u672c\u7684libc.so\uff09\u88c5\u8f7d\u5230\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u4e14\u5c06\u7a0b\u5e8f\u4e2d\u6240\u6709**\u672a\u51b3\u8bae\u7684\u7b26\u53f7**\u7ed1\u5b9a\u5230\u76f8\u5e94\u7684**\u52a8\u6001\u94fe\u63a5\u5e93**\u4e2d\uff0c\u5e76\u8fdb\u884c**\u91cd\u5b9a\u4f4d\u5de5\u4f5c**\uff08\u672f\u8bed\u53eb**\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**-load time relocation\uff0c\u5728windows\u4e2d\uff0c\u53c8\u53eb\u57fa\u5740\u91cd\u7f6e-rebasing\uff0c\u533a\u522b\u4e8e\u9759\u6001\u94fe\u63a5\u7684**\u94fe\u63a5\u65f6\u91cd\u5b9a\u4f4d**-link time relocation\uff09\u3002\u4e5f\u5373\uff0c\u52a8\u6001\u94fe\u63a5\u662f\u628a**\u53ef\u6267\u884celf**\u7684\u5f62\u6210\u8fc7\u7a0b\u4ece\u672c\u6765\u7684\u7a0b\u5e8f\u94fe\u63a5\u524d**\u63a8\u8fdf**\u5230\u88c5\u8f7d\u65f6\u3002\u5171\u4eab\u5bf9\u8c61\u7684\u6700\u7ec8\u88c5\u8f7d\u5730\u5740\u5728**\u7f16\u8bd1\u65f6**\u662f\u4e0d\u786e\u5b9a\u7684\uff0c\u800c\u662f\u5728**\u88c5\u8f7d\u65f6**\uff0c**\u88c5\u8f7d\u5668**\u6839\u636e\u5f53\u524d\u5730\u5740\u7a7a\u95f4\u7684\u7a7a\u95f2\u60c5\u51b5\uff0c\u52a8\u6001\u5206\u914d\u4e00\u5757\u8db3\u591f\u5927\u5c0f\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7ed9\u76f8\u5e94\u7684\u5171\u4eab\u5bf9\u8c61\u3002 \u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u7684\u539f\u7406\u6765\u81ea**\u94fe\u63a5\u65f6\u91cd\u5b9a\u4f4d \uff0c\u4f46\u662f\u5bf9\u4e8e\u5171\u4eab\u5bf9\u8c61\uff0c\u5355\u7eaf\u7684\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d\u663e\u7136\u4f1a\u5f15\u53d1\u95ee\u9898\uff0c\u4e5f\u5c31\u662f\u6587\u7ae0\u5f00\u5934\u8bf4\u5230\u7684\u90a3\u53e5\u8bdd\u3002\u52a8\u6001\u94fe\u63a5\u6a21\u5757\u88ab\u88c5\u8f7d\u6620\u5c04\u5230\u865a\u62df\u7a7a\u95f4\u540e\uff0c\u6307\u4ee4\u90e8\u5206\u662f\u5728\u591a\u4e2a\u8fdb\u7a0b\u4e4b\u95f4\u5171\u4eab\u7684\uff0c\u7531\u4e8e**\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u7684\u65b9\u6cd5\u9700\u8981\u4fee\u6539\u6307\u4ee4\uff0c\u6240\u4ee5\u6ca1\u6709\u529e\u6cd5\u505a\u5230\u540c\u4e00\u4efd\u6307\u4ee4\u88ab\u591a\u4e2a\u8fdb\u7a0b\u5171\u4eab\uff0c\u56e0\u4e3a\u6307\u4ee4\u88ab\u91cd\u5b9a\u4f4d\u540e\u5bf9\u4e8e\u6bcf\u4e2a\u8fdb\u7a0b\u6765\u8bb2\u662f\u4e0d\u540c\u7684\u3002 \u5728\u7f51\u4e0a\u770b\u5230\u6709\u4e0d\u5c11\u4eba\u95ee\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u7b54\u6848\u770b\u5f97\u6211\u4e5f\u662f\u8ff7\u8ff7\u7cca\u7cca\u3002\u6298\u817e\u4e86\u4e00\u4e0b\u5348\uff0c\u53d1\u73b0\u5176\u5b9e\u662f\u81ea\u5df1\u5bf9\u57fa\u672c\u7684\u539f\u7406\u90fd\u6ca1\u641e\u6e05\u695a\u624d\u4f1a\u770b\u4e0d\u61c2\u8fd9\u53e5\u8bdd\u3002\u5173\u952e\u5728\u4e8e\u5171\u4eab\u5bf9\u8c61\u4e5f\u5c31\u662f\u52a8\u6001\u94fe\u63a5\u5e93\u5728\u88ab\u88c5\u8f7d\u5230\u7269\u7406\u5185\u5b58\u540e\uff0c\u59cb\u7ec8\u662f\u53ea\u6709\u4e00\u4efd\u7684\uff0c\u4e0d\u7ba1\u6709\u591a\u5c11\u4e2a\u8fdb\u7a0b\u4f7f\u7528\u5b83\u3002\u4f46\u662f\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8fdb\u7a0b\uff0c \u5171\u4eab\u5bf9\u8c61**\u4f1a\u6620\u5c04\u4e00\u6b21\u5230**\u865a\u62df\u5730\u5740\u7a7a\u95f4 \uff0c\u4e5f\u5c31\u662f\u6bcf\u4e2a\u8fdb\u7a0b\u7a7a\u95f4\u90fd\u6709\u4e00\u4efd\u5171\u4eab\u5bf9\u8c61\u7684**\u6620\u5c04**\uff0c\u6b64\u65f6\uff0c\u5bf9\u4e8e\u4e0d\u540c\u7684\u8fdb\u7a0b\uff0c\u6620\u5c04\u7684\u5730\u5740\uff08 \u57fa\u5740 \uff09\u662f\u4e0d\u4e00\u6837\u7684\uff08\u5927\u90e8\u5206\u60c5\u51b5\u4e0b\uff09\u3002\u7d27\u63a5\u7740\uff0c\u8fdb\u884c**\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u3002 \u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u7531**\u52a8\u6001\u94fe\u63a5\u5668**\u5b8c\u6210\uff0c**\u52a8\u6001\u94fe\u63a5\u5668**\u4f1a\u88ab\u4e00\u8d77\u6620\u5c04\u5230**\u8fdb\u7a0b\u7a7a\u95f4**\u4e2d\u3002\u5b83\u6839\u636e**\u5171\u4eab\u5bf9\u8c61**\u5728**\u865a\u62df\u5185\u5b58\u7a7a\u95f4\u4e2d**\u7684\u5730\u5740\u4fee\u6539\u5728**\u7269\u7406\u5185\u5b58**\u4e2d\u7684**\u5171\u4eab\u5bf9\u8c61**\u4e2d\u7684\u6307\u4ee4\uff0c\u4e3a\u4ec0\u4e48\u4f1a\u4fee\u6539\u6307\u4ee4\uff0c\u539f\u56e0\u5728\u4e8e**\u7edd\u5bf9\u5730\u5740\u8bbf\u95ee \uff08\u5982\u6a21\u5757\u5185\u7684\u53d8\u91cf\u8bbf\u95ee\uff09\u662f\u76f4\u63a5\u7528 mov \u6307\u4ee4\u5b8c\u6210\u7684\uff0c\u4e5f\u5c31\u662f\u76f4\u63a5\u5c06\u5730\u5740\u6253\u5165\u5bc4\u5b58\u5668\uff0c\u6240\u4ee5\uff0c\u6b64\u65f6\u7684\u91cd\u5b9a\u4f4d\u4f1a\u76f4\u63a5\u4fee\u6539\u6307\u4ee4\u3002\u8fdb\u4e00\u6b65\uff0c\u5171\u4eab\u5bf9\u8c61\u4e2d\u4fee\u6539\u7684\u6307\u4ee4\u662f**\u6839\u636e\u5171\u4eab\u5bf9\u8c61\u88ab\u6620\u5c04\u5230\u865a\u62df\u7a7a\u95f4\u4e2d\u7684\u5730\u5740\uff08\u57fa\u5740\uff09\u51b3\u5b9a\u7684**\uff0c\u800c\u6bcf\u4e2a\u8fdb\u7a0b\u5bf9\u5171\u4eab\u5bf9\u8c61\u7684\u6620\u5c04\u4e0d\u53ef\u80fd\u90fd\u662f\u5728\u76f8\u540c\u5730\u5740\u3002\u6240\u4ee5\u4e5f\u5c31\u65e0\u6cd5\u5b8c\u6210\u8fd9\u4e00\u90e8\u5206\u4ee3\u7801\u7684\u5171\u4eab\u3002 \u90a3\u4e48\u5982\u4f55\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u5c31\u8981\u7528\u5230**\u4f4d\u7f6e\u65e0\u5173\u4ee3\u7801\uff08PIC\uff09**\uff0c\u4e5f\u6709\u53eb**\u5730\u5740\u65e0\u5173\u4ee3\u7801**\u7684\u3002\u57fa\u672c\u601d\u8def\u662f\u628a**\u6307\u4ee4**\u4e2d\u90a3\u4e9b\u9700\u8981\u88ab\u4fee\u6539\u7684\u90e8\u5206\u5206\u79bb\u51fa\u6765\uff0c\u8ddf**\u6570\u636e\u90e8\u5206**\u653e\u5230\u4e00\u8d77\uff0c\u8fd9\u6837\uff0c\u5269\u4e0b\u7684\u6307\u4ee4\u5c31\u53ef\u4ee5\u4fdd\u6301\u4e0d\u53d8\uff0c\u800c\u6570\u636e\u90e8\u5206\u5728\u6bcf\u4e2a\u8fdb\u7a0b\u4e2d\u62e5\u6709\u4e00\u4e2a\u526f\u672c\u3002ELF\u9488\u5bf9\u5404\u79cd\u53ef\u80fd\u7684\u8bbf\u95ee\u7c7b\u578b\uff08\u6a21\u5757\u5185\u90e8\u6307\u4ee4\u8c03\u7528\u3001\u6a21\u5757\u5185\u90e8\u6570\u636e\u8bbf\u95ee\u3001\u6a21\u5757\u95f4\u6307\u4ee4\u8c03\u7528\u3001\u6a21\u5757\u95f4\u6570\u636e\u8bbf\u95ee\uff09\uff0c\u5b9e\u73b0\u4e86\u5bf9\u5e94\u5730\u5740\u5f15\u7528\u65b9\u5f0f\uff0c\u4ece\u800c\u5b9e\u73b0\u4e86PIC\u3002\u5177\u4f53\u7684\u7ec6\u8282\u4e0d\u5728\u8fd9\u91cc\u8d58\u8ff0\u3002 Q&A \u6bcf\u4e2a\u8fdb\u7a0b\u4f1a\u6709\u4e00\u4efd\u5171\u4eab\u5bf9\u8c61\u7684\u6620\u5c04 \u8fd9\u6bb5\u8bdd\u4e2d\u7684\u6620\u5c04\u662f\u4ec0\u4e48\u610f\u601d\uff1f \u53c2\u8003\u8d44\u6599\uff1a http://www.360doc.com/content/14/0902/09/19184777_406438267.shtml http://blog.chinaunix.net/uid-26983585-id-3364514.html http://blog.163.com/shi_shun/blog/static/2370784920122875910467/","title":"[\u52a8\u6001\u5171\u4eab\u5bf9\u8c61\u7684\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d](https://blog.csdn.net/parallelyk/article/details/42747239)"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/load-time-relocation/#_1","text":"\u6700\u8fd1\u8bfb\u7a0b\u5e8f\u5458\u7684\u81ea\u6211\u4fee\u517b--\u94fe\u63a5 \u88c5\u8f7d\u4e0e\u5e93\uff0c\u5176\u4e2d\u6709\u53e5\u8bdd\uff1a**\u52a8\u6001\u94fe\u63a5\u6a21\u5757**\u88ab\u88c5\u8f7d\u6620\u5c04\u5230**\u865a\u62df\u7a7a\u95f4**\u540e\uff0c**\u6307\u4ee4\u90e8\u5206**\u662f\u5728\u591a\u4e2a**\u8fdb\u7a0b**\u4e4b\u95f4**\u5171\u4eab**\u7684\uff0c\u7531\u4e8e**\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u7684\u65b9\u6cd5\u9700\u8981**\u4fee\u6539**\u6307\u4ee4\uff0c\u6240\u4ee5\u6ca1\u6709\u529e\u6cd5\u505a\u5230\u540c\u4e00\u4efd\u6307\u4ee4\u88ab\u591a\u4e2a\u8fdb\u7a0b\u5171\u4eab\uff0c\u56e0\u4e3a\u6307\u4ee4\u88ab**\u91cd\u5b9a\u4f4d**\u540e\u5bf9\u4e8e\u6bcf\u4e2a\u8fdb\u7a0b\u6765\u8bb2\u662f\u4e0d\u540c\u7684\u3002\u4e00\u76f4\u6ca1\u641e\u61c2\uff0c\u82b1\u4e86\u4e0d\u5c11\u65f6\u95f4\u67e5\u9605\u8d44\u6599\uff0c\u4e86\u89e3\u539f\u7406\u3002\u89c9\u5f97\u81ea\u5df1\u4e00\u76f4\u7406\u89e3\u7684\u4e1c\u897f\u90fd\u592a\u6d45\u4e86\u3002 \u4ee5\u4e0b\u662f\u5bf9\u8fd9\u5757\u5185\u5bb9\u7684\u603b\u7ed3\uff0c\u4f5c\u4e3a\u8bb0\u5f55\u3002 \u5176\u4e2d\u7684\u5173\u952e\u70b9\u5728\u4e8e\u638c\u63e1**\u5185\u5b58\u6620\u5c04**\uff0c\u91cd\u5b9a\u4f4d\u7684\u5b9e\u73b0\u4ee5\u53ca\u5171\u4eab\u5bf9\u8c61\u7684\u88c5\u8f7d\u3002\u641e\u6e05\u695a**\u865a\u62df\u5185\u5b58\u7a7a\u95f4**\u548c**\u7269\u7406\u5185\u5b58\u7a7a\u95f4**\u3002 \u5171\u4eab\u5bf9\u8c61\u5728\u88ab\u88c5\u8f7d\u65f6\uff0c\u662f\u5982\u4f55\u786e\u5b9a\u5b83\u5728\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u4f4d\u7f6e\uff1f \u4e00\u79cd\u65b9\u6cd5\u662f\u56fa\u5b9a\u88c5\u8f7d\uff0c\u8fd9\u79cd\u65b9\u6cd5\u5f0a\u7aef\u660e\u663e\uff1a\u5730\u5740\u51b2\u7a81\uff1b\u5171\u4eab\u5e93\u5347\u7ea7\u56f0\u96be\uff1b\u7a7a\u95f4\u53d7\u9650\u7b49\u7b49\u3002\uff08\u57fa\u672c\u4e0d\u7528\uff09 \u90a3\u4e48\u53ea\u80fd\u91c7\u7528\u53e6\u4e00\u79cd\u601d\u8def\uff0c\u5373**\u5171\u4eab\u5bf9\u8c61**\u80fd\u5728\u4efb\u610f\u5730\u5740\u88c5\u8f7d\u3002\u8fd9\u79cd\u60c5\u51b5\u53eb\u505a**\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u3002\u5f53\u7a0b\u5e8f\u88ab\u88c5\u8f7d\u65f6\uff0c\u7cfb\u7edf\u7684**\u52a8\u6001\u94fe\u63a5\u5668**\u4f1a\u5c06\u7a0b\u5e8f\u6240\u9700\u7684\u6240\u6709**\u52a8\u6001\u94fe\u63a5\u5e93**\uff08\u4f8b\u5982\u6700\u57fa\u672c\u7684libc.so\uff09\u88c5\u8f7d\u5230\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u4e14\u5c06\u7a0b\u5e8f\u4e2d\u6240\u6709**\u672a\u51b3\u8bae\u7684\u7b26\u53f7**\u7ed1\u5b9a\u5230\u76f8\u5e94\u7684**\u52a8\u6001\u94fe\u63a5\u5e93**\u4e2d\uff0c\u5e76\u8fdb\u884c**\u91cd\u5b9a\u4f4d\u5de5\u4f5c**\uff08\u672f\u8bed\u53eb**\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**-load time relocation\uff0c\u5728windows\u4e2d\uff0c\u53c8\u53eb\u57fa\u5740\u91cd\u7f6e-rebasing\uff0c\u533a\u522b\u4e8e\u9759\u6001\u94fe\u63a5\u7684**\u94fe\u63a5\u65f6\u91cd\u5b9a\u4f4d**-link time relocation\uff09\u3002\u4e5f\u5373\uff0c\u52a8\u6001\u94fe\u63a5\u662f\u628a**\u53ef\u6267\u884celf**\u7684\u5f62\u6210\u8fc7\u7a0b\u4ece\u672c\u6765\u7684\u7a0b\u5e8f\u94fe\u63a5\u524d**\u63a8\u8fdf**\u5230\u88c5\u8f7d\u65f6\u3002\u5171\u4eab\u5bf9\u8c61\u7684\u6700\u7ec8\u88c5\u8f7d\u5730\u5740\u5728**\u7f16\u8bd1\u65f6**\u662f\u4e0d\u786e\u5b9a\u7684\uff0c\u800c\u662f\u5728**\u88c5\u8f7d\u65f6**\uff0c**\u88c5\u8f7d\u5668**\u6839\u636e\u5f53\u524d\u5730\u5740\u7a7a\u95f4\u7684\u7a7a\u95f2\u60c5\u51b5\uff0c\u52a8\u6001\u5206\u914d\u4e00\u5757\u8db3\u591f\u5927\u5c0f\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7ed9\u76f8\u5e94\u7684\u5171\u4eab\u5bf9\u8c61\u3002 \u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u7684\u539f\u7406\u6765\u81ea**\u94fe\u63a5\u65f6\u91cd\u5b9a\u4f4d \uff0c\u4f46\u662f\u5bf9\u4e8e\u5171\u4eab\u5bf9\u8c61\uff0c\u5355\u7eaf\u7684\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d\u663e\u7136\u4f1a\u5f15\u53d1\u95ee\u9898\uff0c\u4e5f\u5c31\u662f\u6587\u7ae0\u5f00\u5934\u8bf4\u5230\u7684\u90a3\u53e5\u8bdd\u3002\u52a8\u6001\u94fe\u63a5\u6a21\u5757\u88ab\u88c5\u8f7d\u6620\u5c04\u5230\u865a\u62df\u7a7a\u95f4\u540e\uff0c\u6307\u4ee4\u90e8\u5206\u662f\u5728\u591a\u4e2a\u8fdb\u7a0b\u4e4b\u95f4\u5171\u4eab\u7684\uff0c\u7531\u4e8e**\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u7684\u65b9\u6cd5\u9700\u8981\u4fee\u6539\u6307\u4ee4\uff0c\u6240\u4ee5\u6ca1\u6709\u529e\u6cd5\u505a\u5230\u540c\u4e00\u4efd\u6307\u4ee4\u88ab\u591a\u4e2a\u8fdb\u7a0b\u5171\u4eab\uff0c\u56e0\u4e3a\u6307\u4ee4\u88ab\u91cd\u5b9a\u4f4d\u540e\u5bf9\u4e8e\u6bcf\u4e2a\u8fdb\u7a0b\u6765\u8bb2\u662f\u4e0d\u540c\u7684\u3002 \u5728\u7f51\u4e0a\u770b\u5230\u6709\u4e0d\u5c11\u4eba\u95ee\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u7b54\u6848\u770b\u5f97\u6211\u4e5f\u662f\u8ff7\u8ff7\u7cca\u7cca\u3002\u6298\u817e\u4e86\u4e00\u4e0b\u5348\uff0c\u53d1\u73b0\u5176\u5b9e\u662f\u81ea\u5df1\u5bf9\u57fa\u672c\u7684\u539f\u7406\u90fd\u6ca1\u641e\u6e05\u695a\u624d\u4f1a\u770b\u4e0d\u61c2\u8fd9\u53e5\u8bdd\u3002\u5173\u952e\u5728\u4e8e\u5171\u4eab\u5bf9\u8c61\u4e5f\u5c31\u662f\u52a8\u6001\u94fe\u63a5\u5e93\u5728\u88ab\u88c5\u8f7d\u5230\u7269\u7406\u5185\u5b58\u540e\uff0c\u59cb\u7ec8\u662f\u53ea\u6709\u4e00\u4efd\u7684\uff0c\u4e0d\u7ba1\u6709\u591a\u5c11\u4e2a\u8fdb\u7a0b\u4f7f\u7528\u5b83\u3002\u4f46\u662f\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8fdb\u7a0b\uff0c \u5171\u4eab\u5bf9\u8c61**\u4f1a\u6620\u5c04\u4e00\u6b21\u5230**\u865a\u62df\u5730\u5740\u7a7a\u95f4 \uff0c\u4e5f\u5c31\u662f\u6bcf\u4e2a\u8fdb\u7a0b\u7a7a\u95f4\u90fd\u6709\u4e00\u4efd\u5171\u4eab\u5bf9\u8c61\u7684**\u6620\u5c04**\uff0c\u6b64\u65f6\uff0c\u5bf9\u4e8e\u4e0d\u540c\u7684\u8fdb\u7a0b\uff0c\u6620\u5c04\u7684\u5730\u5740\uff08 \u57fa\u5740 \uff09\u662f\u4e0d\u4e00\u6837\u7684\uff08\u5927\u90e8\u5206\u60c5\u51b5\u4e0b\uff09\u3002\u7d27\u63a5\u7740\uff0c\u8fdb\u884c**\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u3002 \u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d**\u7531**\u52a8\u6001\u94fe\u63a5\u5668**\u5b8c\u6210\uff0c**\u52a8\u6001\u94fe\u63a5\u5668**\u4f1a\u88ab\u4e00\u8d77\u6620\u5c04\u5230**\u8fdb\u7a0b\u7a7a\u95f4**\u4e2d\u3002\u5b83\u6839\u636e**\u5171\u4eab\u5bf9\u8c61**\u5728**\u865a\u62df\u5185\u5b58\u7a7a\u95f4\u4e2d**\u7684\u5730\u5740\u4fee\u6539\u5728**\u7269\u7406\u5185\u5b58**\u4e2d\u7684**\u5171\u4eab\u5bf9\u8c61**\u4e2d\u7684\u6307\u4ee4\uff0c\u4e3a\u4ec0\u4e48\u4f1a\u4fee\u6539\u6307\u4ee4\uff0c\u539f\u56e0\u5728\u4e8e**\u7edd\u5bf9\u5730\u5740\u8bbf\u95ee \uff08\u5982\u6a21\u5757\u5185\u7684\u53d8\u91cf\u8bbf\u95ee\uff09\u662f\u76f4\u63a5\u7528 mov \u6307\u4ee4\u5b8c\u6210\u7684\uff0c\u4e5f\u5c31\u662f\u76f4\u63a5\u5c06\u5730\u5740\u6253\u5165\u5bc4\u5b58\u5668\uff0c\u6240\u4ee5\uff0c\u6b64\u65f6\u7684\u91cd\u5b9a\u4f4d\u4f1a\u76f4\u63a5\u4fee\u6539\u6307\u4ee4\u3002\u8fdb\u4e00\u6b65\uff0c\u5171\u4eab\u5bf9\u8c61\u4e2d\u4fee\u6539\u7684\u6307\u4ee4\u662f**\u6839\u636e\u5171\u4eab\u5bf9\u8c61\u88ab\u6620\u5c04\u5230\u865a\u62df\u7a7a\u95f4\u4e2d\u7684\u5730\u5740\uff08\u57fa\u5740\uff09\u51b3\u5b9a\u7684**\uff0c\u800c\u6bcf\u4e2a\u8fdb\u7a0b\u5bf9\u5171\u4eab\u5bf9\u8c61\u7684\u6620\u5c04\u4e0d\u53ef\u80fd\u90fd\u662f\u5728\u76f8\u540c\u5730\u5740\u3002\u6240\u4ee5\u4e5f\u5c31\u65e0\u6cd5\u5b8c\u6210\u8fd9\u4e00\u90e8\u5206\u4ee3\u7801\u7684\u5171\u4eab\u3002 \u90a3\u4e48\u5982\u4f55\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u5c31\u8981\u7528\u5230**\u4f4d\u7f6e\u65e0\u5173\u4ee3\u7801\uff08PIC\uff09**\uff0c\u4e5f\u6709\u53eb**\u5730\u5740\u65e0\u5173\u4ee3\u7801**\u7684\u3002\u57fa\u672c\u601d\u8def\u662f\u628a**\u6307\u4ee4**\u4e2d\u90a3\u4e9b\u9700\u8981\u88ab\u4fee\u6539\u7684\u90e8\u5206\u5206\u79bb\u51fa\u6765\uff0c\u8ddf**\u6570\u636e\u90e8\u5206**\u653e\u5230\u4e00\u8d77\uff0c\u8fd9\u6837\uff0c\u5269\u4e0b\u7684\u6307\u4ee4\u5c31\u53ef\u4ee5\u4fdd\u6301\u4e0d\u53d8\uff0c\u800c\u6570\u636e\u90e8\u5206\u5728\u6bcf\u4e2a\u8fdb\u7a0b\u4e2d\u62e5\u6709\u4e00\u4e2a\u526f\u672c\u3002ELF\u9488\u5bf9\u5404\u79cd\u53ef\u80fd\u7684\u8bbf\u95ee\u7c7b\u578b\uff08\u6a21\u5757\u5185\u90e8\u6307\u4ee4\u8c03\u7528\u3001\u6a21\u5757\u5185\u90e8\u6570\u636e\u8bbf\u95ee\u3001\u6a21\u5757\u95f4\u6307\u4ee4\u8c03\u7528\u3001\u6a21\u5757\u95f4\u6570\u636e\u8bbf\u95ee\uff09\uff0c\u5b9e\u73b0\u4e86\u5bf9\u5e94\u5730\u5740\u5f15\u7528\u65b9\u5f0f\uff0c\u4ece\u800c\u5b9e\u73b0\u4e86PIC\u3002\u5177\u4f53\u7684\u7ec6\u8282\u4e0d\u5728\u8fd9\u91cc\u8d58\u8ff0\u3002","title":"\u52a8\u6001\u5171\u4eab\u5bf9\u8c61\u7684\u88c5\u8f7d\u65f6\u91cd\u5b9a\u4f4d"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/load-time-relocation/#qa","text":"","title":"Q&amp;A"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/load-time-relocation/#_2","text":"\u8fd9\u6bb5\u8bdd\u4e2d\u7684\u6620\u5c04\u662f\u4ec0\u4e48\u610f\u601d\uff1f \u53c2\u8003\u8d44\u6599\uff1a http://www.360doc.com/content/14/0902/09/19184777_406438267.shtml http://blog.chinaunix.net/uid-26983585-id-3364514.html http://blog.163.com/shi_shun/blog/static/2370784920122875910467/","title":"\u6bcf\u4e2a\u8fdb\u7a0b\u4f1a\u6709\u4e00\u4efd\u5171\u4eab\u5bf9\u8c61\u7684\u6620\u5c04"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/","text":"\u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u53caLinux\u4e0b\u52a8\u6001\u94fe\u63a5\u7684\u5b9e\u73b0 \u7a0b\u5e8f\u7684**\u94fe\u63a5**\u548c**\u88c5\u5165**\u5b58\u5728\u7740\u591a\u79cd\u65b9\u6cd5\uff0c\u800c\u5982\u4eca\u6700\u4e3a\u6d41\u884c\u7684\u5f53\u5c5e**\u52a8\u6001\u94fe\u63a5**\u3001**\u52a8\u6001\u88c5\u5165**\u65b9\u6cd5\u3002\u672c\u6587\u9996\u5148\u56de\u987e\u4e86**\u94fe\u63a5\u5668**\u548c**\u88c5\u5165\u5668**\u7684\u57fa\u672c\u5de5\u4f5c\u539f\u7406\u53ca\u8fd9\u4e00\u6280\u672f\u7684\u53d1\u5c55\u5386\u53f2\uff0c\u7136\u540e\u901a\u8fc7\u5b9e\u9645\u7684\u4f8b\u5b50\u5256\u6790\u4e86Linux\u7cfb\u7edf\u4e0b**\u52a8\u6001\u94fe\u63a5**\u7684\u5b9e\u73b0\u3002\u4e86\u89e3\u5e95\u5c42\u5173\u952e\u6280\u672f\u7684\u5b9e\u73b0\u7ec6\u8282\u5bf9\u7cfb\u7edf\u5206\u6790\u548c\u8bbe\u8ba1\u4eba\u5458\u65e0\u7591\u662f\u5fc5\u987b\u7684\uff0c\u5c24\u5176\u5f53\u6211\u4eec\u5728\u9762\u5bf9\u5b9e\u65f6\u7cfb\u7edf\uff0c\u9700\u8981\u5bf9\u7a0b\u5e8f\u6267\u884c\u65f6\u7684\u65f6\u7a7a\u6548\u7387\u6709\u7740\u7cbe\u786e\u7684\u5ea6\u91cf\u548c\u628a\u63e1\u65f6\uff0c\u8fd9\u79cd\u77e5\u8bc6\u66f4\u663e\u91cd\u8981 \u94fe\u63a5\u5668\u548c\u88c5\u5165\u5668\u7684\u57fa\u672c\u5de5\u4f5c\u539f\u7406 \u4e00\u4e2a\u7a0b\u5e8f\u8981\u60f3\u5728\u5185\u5b58\u4e2d\u8fd0\u884c\uff0c\u9664\u4e86\u7f16\u8bd1\u4e4b\u5916\u8fd8\u8981\u7ecf\u8fc7**\u94fe\u63a5**\u548c**\u88c5\u5165**\u8fd9\u4e24\u4e2a\u6b65\u9aa4\u3002\u4ece\u7a0b\u5e8f\u5458\u7684\u89d2\u5ea6\u6765\u770b\uff0c\u5f15\u5165\u8fd9\u4e24\u4e2a\u6b65\u9aa4\u5e26\u6765\u7684\u597d\u5904\u5c31\u662f\u53ef\u4ee5\u76f4\u63a5\u5728\u7a0b\u5e8f\u4e2d\u4f7f\u7528 printf \u548c errno \u8fd9\u79cd**\u6709\u610f\u4e49**\u7684**\u51fd\u6570\u540d**\u548c**\u53d8\u91cf\u540d**\uff0c\u800c\u4e0d\u7528\u660e\u786e\u6307\u660e printf \u548c errno \u5728\u6807\u51c6C\u5e93\u4e2d\u7684**\u5730\u5740**\u3002\u5f53\u7136\uff0c\u4e3a\u4e86\u5c06\u7a0b\u5e8f\u5458\u4ece\u65e9\u671f\u76f4\u63a5\u4f7f\u7528**\u5730\u5740\u7f16\u7a0b**\u7684\u68a6\u9b47\u4e2d\u89e3\u6551\u51fa\u6765\uff0c \u7f16\u8bd1\u5668**\u548c**\u6c47\u7f16\u5668**\u5728\u8fd9\u5f53\u4e2d\u505a\u51fa\u4e86\u9769\u547d\u6027\u7684\u8d21\u732e\u3002**\u7f16\u8bd1\u5668**\u548c**\u6c47\u7f16\u5668**\u7684\u51fa\u73b0\u4f7f\u5f97\u7a0b\u5e8f\u5458\u53ef\u4ee5\u5728\u7a0b\u5e8f\u4e2d\u4f7f\u7528**\u66f4\u5177\u610f\u4e49\u7684\u7b26\u53f7**\u6765\u4e3a*\u51fd\u6570*\u548c*\u53d8\u91cf***\u547d\u540d \uff0c\u8fd9\u6837\u4f7f\u5f97\u7a0b\u5e8f\u5728**\u6b63\u786e\u6027**\u548c**\u53ef\u8bfb\u6027**\u7b49\u65b9\u9762\u90fd\u5f97\u5230\u4e86\u6781\u5927\u7684\u63d0\u9ad8\u3002\u4f46\u662f\u968f\u7740C\u8bed\u8a00\u8fd9\u79cd\u652f\u6301\u5206\u522b\u7f16\u8bd1\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u8bed\u8a00\u7684\u6d41\u884c\uff0c\u4e00\u4e2a\u5b8c\u6574\u7684\u7a0b\u5e8f\u5f80\u5f80\u88ab\u5206\u5272\u4e3a\u82e5\u5e72\u4e2a\u72ec\u7acb\u7684\u90e8\u5206\u5e76\u884c\u5f00\u53d1\uff0c\u800c\u5404\u4e2a\u6a21\u5757\u95f4\u901a\u8fc7**\u51fd\u6570\u63a5\u53e3**\u6216**\u5168\u5c40\u53d8\u91cf**\u8fdb\u884c\u901a\u8baf\u3002\u8fd9\u5c31\u5e26\u6765\u4e86\u4e00\u4e2a\u95ee\u9898\uff0c\u7f16\u8bd1\u5668\u53ea\u80fd\u5728*\u4e00\u4e2a\u6a21\u5757*\u5185\u90e8\u5b8c\u6210**\u7b26\u53f7\u540d**\u5230**\u5730\u5740**\u7684\u8f6c\u6362\u5de5\u4f5c\uff0c\u4e0d\u540c\u6a21\u5757\u95f4\u7684**\u7b26\u53f7\u89e3\u6790**\u7531\u8c01\u6765\u505a\u5462\uff1f\u6bd4\u5982\u524d\u9762\u6240\u4e3e\u7684\u4f8b\u5b50\uff0c\u8c03\u7528 printf \u7684\u7528\u6237\u7a0b\u5e8f\u548c\u5b9e\u73b0\u4e86 printf \u7684\u6807\u51c6C\u5e93\u663e\u7136\u5c31\u662f\u4e24\u4e2a\u4e0d\u540c\u7684\u6a21\u5757\u3002\u5b9e\u9645\u4e0a\uff0c\u8fd9\u4e2a\u5de5\u4f5c\u662f\u7531**\u94fe\u63a5\u5668**\u6765\u5b8c\u6210\u7684\u3002 \u94fe\u63a5\u5668\u7684\u4e3b\u8981\u529f\u80fd \u4e3a\u4e86\u89e3\u51b3\u4e0d\u540c\u6a21\u5757\u95f4\u7684**\u94fe\u63a5**\u95ee\u9898\uff0c \u94fe\u63a5\u5668**\u4e3b\u8981\u6709\u4e24\u4e2a\u5de5\u4f5c\u8981\u505a\u2015\u2015**\u7b26\u53f7\u89e3\u6790**\u548c**\u91cd\u5b9a\u4f4d \uff1a \u7b26\u53f7\u89e3\u6790 \u7b26\u53f7\u89e3\u6790\uff1a\u5f53\u4e00\u4e2a\u6a21\u5757\u4f7f\u7528\u4e86\u5728\u8be5\u6a21\u5757\u4e2d\u6ca1\u6709\u5b9a\u4e49\u8fc7\u7684**\u51fd\u6570**\u6216**\u5168\u5c40\u53d8\u91cf**\u65f6\uff0c\u7f16\u8bd1\u5668\u751f\u6210\u7684**\u7b26\u53f7\u8868**\u4f1a\u6807\u8bb0\u51fa\u6240\u6709\u8fd9\u6837\u7684\u51fd\u6570\u6216\u5168\u5c40\u53d8\u91cf\uff0c\u800c\u94fe\u63a5\u5668\u7684\u8d23\u4efb\u5c31\u662f\u8981\u5230\u522b\u7684\u6a21\u5757\u4e2d\u53bb\u67e5\u627e\u5b83\u4eec\u7684**\u5b9a\u4e49**\uff0c\u5982\u679c\u6ca1\u6709\u627e\u5230\u5408\u9002\u7684\u5b9a\u4e49\u6216\u8005\u627e\u5230\u7684\u5408\u9002\u7684\u5b9a\u4e49\u4e0d\u552f\u4e00\uff0c\u7b26\u53f7\u89e3\u6790\u90fd\u65e0\u6cd5\u6b63\u5e38\u5b8c\u6210\u3002 \u51fd\u6570\u7684\u58f0\u660e\uff0c\u51fd\u6570\u7684\u5b9a\u4e49\uff0c\u51fd\u6570\u7684\u8c03\u7528\uff1b\u8fd9\u51e0\u70b9\u4e4b\u95f4\u7684\u5173\u8054 \u91cd\u5b9a\u4f4d \u91cd\u5b9a\u4f4d\uff1a \u7f16\u8bd1\u5668**\u5728\u7f16\u8bd1\u751f\u6210\u76ee\u6807\u6587\u4ef6\u65f6\uff0c\u901a\u5e38\u90fd\u4f7f\u7528\u4ece**\u96f6**\u5f00\u59cb\u7684**\u76f8\u5bf9\u5730\u5740 \u3002\u7136\u800c\uff0c\u5728**\u94fe\u63a5**\u8fc7\u7a0b\u4e2d\uff0c**\u94fe\u63a5\u5668**\u5c06\u4ece\u4e00\u4e2a**\u6307\u5b9a\u7684\u5730\u5740**\u5f00\u59cb\uff0c\u6839\u636e\u8f93\u5165\u7684\u76ee\u6807\u6587\u4ef6\u7684\u987a\u5e8f\u4ee5\u6bb5\u4e3a\u5355\u4f4d\u5c06\u5b83\u4eec\u4e00\u4e2a\u63a5\u4e00\u4e2a\u7684\u62fc\u88c5\u8d77\u6765\u3002\u9664\u4e86\u76ee\u6807\u6587\u4ef6\u7684\u62fc\u88c5\u4e4b\u5916\uff0c\u5728\u91cd\u5b9a\u4f4d\u7684\u8fc7\u7a0b\u4e2d\u8fd8\u5b8c\u6210\u4e86\u4e24\u4e2a\u4efb\u52a1\uff1a\u4e00\u662f\u751f\u6210\u6700\u7ec8\u7684\u7b26\u53f7\u8868\uff1b\u4e8c\u662f\u5bf9\u4ee3\u7801\u6bb5\u4e2d\u7684\u67d0\u4e9b\u4f4d\u7f6e\u8fdb\u884c\u4fee\u6539\uff0c\u6240\u6709\u9700\u8981\u4fee\u6539\u7684\u4f4d\u7f6e\u90fd\u7531\u7f16\u8bd1\u5668\u751f\u6210\u7684**\u91cd\u5b9a\u4f4d\u8868**\u6307\u51fa\u3002 \u4e3e\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u4e0a\u9762\u7684\u6982\u5ff5\u5bf9\u8bfb\u8005\u6765\u8bf4\u5c31\u4e00\u76ee\u4e86\u7136\u4e86\u3002\u5047\u5982\u6211\u4eec\u6709\u4e00\u4e2a\u7a0b\u5e8f\u7531\u4e24\u90e8\u5206\u6784\u6210\uff0cm.c\u4e2d\u7684main\u51fd\u6570\u8c03\u7528f.c\u4e2d\u5b9e\u73b0\u7684\u51fd\u6570sum\uff1a /* m.c */ int i = 1 ; int j = 2 ; extern int sum (); void main () { int s ; s = sum ( i , j ); } /* f.c */ int sum ( int i , int j ) { return i + j ; } \u5728Linux\u7528gcc\u5206\u522b\u5c06\u4e24\u6bb5\u6e90\u7a0b\u5e8f\u7f16\u8bd1\u6210\u76ee\u6807\u6587\u4ef6\uff1a $ gcc -c m.c $ gcc -c f.c \u6211\u4eec\u901a\u8fc7objdump\u6765\u770b\u770b\u5728\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u751f\u6210\u7684\u7b26\u53f7\u8868\u548c\u91cd\u5b9a\u4f4d\u8868\uff1a $ objdump -x m.o \u2026\u2026 SYMBOL TABLE: \u2026\u2026 00000000 g O .data 00000004 i 00000004 g O .data 00000004 j 00000000 g F .text 00000021 main 00000000 *UND* 00000000 sum RELOCATION RECORDS FOR [ .text ] : OFFSET TYPE VALUE 00000007 R_386_32 j 0000000d R_386_32 i 00000013 R_386_PC32 sum \u9996\u5148\uff0c\u6211\u4eec\u6ce8\u610f\u5230\u7b26\u53f7\u8868\u91cc\u9762\u7684 sum \u88ab\u6807\u8bb0\u4e3a UND\uff08undefined\uff09 \uff0c\u4e5f\u5c31\u662f\u5728 m.o \u4e2d\u6ca1\u6709\u5b9a\u4e49\uff0c\u6240\u4ee5\u5c06\u6765\u8981\u901a\u8fc7 ld \uff08Linux\u4e0b\u7684\u94fe\u63a5\u5668\uff09\u7684\u7b26\u53f7\u89e3\u6790\u529f\u80fd\u5230\u522b\u7684\u6a21\u5757\u4e2d\u53bb\u67e5\u627e\u662f\u5426\u5b58\u5728\u51fd\u6570 sum \u7684\u5b9a\u4e49\u3002\u53e6\u5916\uff0c\u5728\u91cd\u5b9a\u4f4d\u8868\u4e2d\u6709\u4e09\u6761\u8bb0\u5f55\uff0c\u6307\u51fa\u4e86\u5728\u91cd\u5b9a\u4f4d\u8fc7\u7a0b\u4e2d**\u4ee3\u7801\u6bb5**\u4e2d\u4e09\u5904\u9700\u8981\u4fee\u6539\u7684\u4f4d\u7f6e\uff0c\u5206\u522b\u4f4d\u4e8e7\u3001d\u548c13\u3002\u4e0b\u9762\u4ee5\u4e00\u79cd\u66f4\u52a0\u76f4\u89c2\u7684\u65b9\u5f0f\u6765\u770b\u4e00\u4e0b\u8fd9\u4e09\u4e2a\u4f4d\u7f6e\uff1a $ objdump -dx m.o Disassembly of section .text: 00000000 <main>: 0: 55 push %ebp 1: 89 e5 mov %esp,%ebp 3: 83 ec 04 sub $0x4,%esp 6: a1 00 00 00 00 mov 0x0,%eax 7: R_386_32 j b: 50 push %eax c: a1 00 00 00 00 mov 0x0,%eax d: R_386_32 i 11: 50 push %eax 12: e8 fc ff ff ff call 13 <main+0x13> 13: R_386_PC32 sum 17: 83 c4 08 add $0x8,%esp 1a: 89 c0 mov %eax,%eax 1c: 89 45 fc mov %eax,0xfffffffc(%ebp) 1f: c9 leave 20: c3 ret \u4ee5 sum \u4e3a\u4f8b\uff0c\u5bf9\u51fd\u6570 sum \u7684\u8c03\u7528\u662f\u901a\u8fc7 call \u6307\u4ee4\u5b9e\u73b0\u7684\uff0c\u4f7f\u7528**IP\u76f8\u5bf9\u5bfb\u5740\u65b9\u5f0f**\u3002\u53ef\u4ee5\u770b\u5230\uff0c\u5728\u76ee\u6807\u6587\u4ef6 m.o \u4e2d\uff0c call \u6307\u4ee4\u4f4d\u4e8e\u4ece\u96f6\u5f00\u59cb\u7684\u76f8\u5bf9\u5730\u5740 0X12 \u7684\u4f4d\u7f6e\uff0c\u8fd9\u91cc\u5b58\u653e\u7684 e8 \u662f call \u7684**\u64cd\u4f5c\u7801**\uff0c\u800c\u4ece 0x13 \u5f00\u59cb\u76844\u4e2a\u5b57\u8282\u5b58\u653e\u7740 sum \u76f8\u5bf9 call \u7684\u4e0b\u4e00\u6761\u6307\u4ee4 add \u7684\u504f\u79fb\u3002\u663e\u7136\uff0c\u5728\u94fe\u63a5\u4e4b\u524d\u8fd9\u4e2a**\u504f\u79fb\u91cf**\u662f\u4e0d\u77e5\u9053\u7684\uff0c\u6240\u4ee5\u5c06\u6765\u8981\u6765\u4fee\u653913\u8fd9\u91cc\u7684\u4ee3\u7801\u3002\u90a3\u73b0\u5728\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u5b58\u653e\u7740 0xfffffffc \uff08\u6ce8\u610fIntel\u7684CPU\u4f7f\u7528little endian\u7684\u7f16\u5740\u65b9\u5f0f\uff09\u5462\uff1f\u8fd9\u5927\u6982\u662f\u51fa\u4e8e\u5b89\u5168\u7684\u8003\u8651\uff0c\u56e0\u4e3a 0xfffffffc \u6b63\u662f\uff0d4\u7684\u8865\u7801\u8868\u793a\uff08\u8bfb\u8005\u53ef\u4ee5\u5728gdb\u4e2d\u4f7f\u7528p /x -4\u67e5\u770b\uff09\uff0c\u800c call \u6307\u4ee4\u672c\u8eab\u5360\u7528\u4e865\u4e2a\u5b57\u8282\uff0c\u56e0\u6b64\u65e0\u8bba\u5982\u4f55 call \u6307\u4ee4\u4e2d\u7684\u504f\u79fb\u91cf\u4e0d\u53ef\u80fd\u662f\uff0d4\u3002\u6211\u4eec\u518d\u770b\u770b\u91cd\u5b9a\u4f4d\u4e4b\u540ecall\u6307\u4ee4\u4e2d\u7684\u8fd9\u4e2a\u504f\u79fb\u91cf\u88ab\u4fee\u6539\u6210\u4e86\u4ec0\u4e48\uff1a $ gcc m.o f.o $ objdump -dj .text a.out | less Disassembly of section .text: \u2026\u2026 080482c4 <main>: \u2026\u2026 80482d6: e8 0d 00 00 00 call 80482e8 <sum> 80482db: 83 c4 08 add $0x8,%esp \u2026\u2026 080482e8 <sum>: \u2026\u2026 \u53ef\u4ee5\u770b\u5230\u7ecf\u8fc7\u91cd\u5b9a\u4f4d\u4e4b\u540e\uff0ccall\u6307\u4ee4\u4e2d\u7684**\u504f\u79fb\u91cf**\u4fee\u6539\u6210 0x0000000d \u4e86\uff0c\u7b80\u5355\u7684\u8ba1\u7b97\u544a\u8bc9\u6211\u4eec\uff1a0x080482e8\uff0d0x80482db=0xd\u3002\u8fd9\u6837\uff0c\u7ecf\u8fc7\u91cd\u5b9a\u4f4d\u4e4b\u540e\u6700\u7ec8\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u5c31\u751f\u6210\u4e86\u3002 \u53ef\u6267\u884c\u7a0b\u5e8f\u751f\u6210\u540e\uff0c\u4e0b\u4e00\u6b65\u5c31\u662f\u5c06\u5176\u88c5\u5165\u5185\u5b58\u8fd0\u884c\u3002Linux\u4e0b\u7684\u7f16\u8bd1\u5668\uff08C\u8bed\u8a00\uff09\u662f cc1 \uff0c\u6c47\u7f16\u5668\u662f as \uff0c\u94fe\u63a5\u5668\u662f ld \uff0c\u4f46\u662f\u5e76\u6ca1\u6709\u4e00\u4e2a\u5b9e\u9645\u7684\u7a0b\u5e8f\u5bf9\u5e94**\u88c5\u5165\u5668**\u8fd9\u4e2a\u6982\u5ff5\u3002\u5b9e\u9645\u4e0a\uff0c\u5c06\u53ef\u6267\u884c\u7a0b\u5e8f\u88c5\u5165\u5185\u5b58\u8fd0\u884c\u7684\u529f\u80fd\u662f\u7531 execve(2) \u8fd9\u4e00**\u7cfb\u7edf\u8c03\u7528**\u5b9e\u73b0\u7684\u3002\u7b80\u5355\u6765\u8bb2\uff0c\u7a0b\u5e8f\u7684\u88c5\u5165\u4e3b\u8981\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6b65\u9aa4\uff1a \u8bfb\u5165\u53ef\u6267\u884c\u6587\u4ef6\u7684\u5934\u90e8\u4fe1\u606f\u4ee5\u786e\u5b9a\u5176\u6587\u4ef6\u683c\u5f0f\u53ca**\u5730\u5740\u7a7a\u95f4**\u7684\u5927\u5c0f\uff1b \u4ee5\u6bb5\u7684\u5f62\u5f0f\u5212\u5206**\u5730\u5740\u7a7a\u95f4**\uff1b \u5c06**\u53ef\u6267\u884c\u7a0b\u5e8f**\u8bfb\u5165\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u5404\u4e2a\u6bb5\uff0c\u5efa\u7acb\u865a\u5b9e\u5730\u5740\u95f4\u7684\u6620\u5c04\u5173\u7cfb\uff1b \u5c06bbs\u6bb5\u6e05\u96f6\uff1b \u521b\u5efa\u5806\u6808\u6bb5\uff1b \u5efa\u7acb\u7a0b\u5e8f\u53c2\u6570\u3001\u73af\u5883\u53d8\u91cf\u7b49\u7a0b\u5e8f\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6240\u9700\u7684\u4fe1\u606f\uff1b \u542f\u52a8\u8fd0\u884c\u3002 \u56de\u9875\u9996 \u94fe\u63a5\u548c\u88c5\u5165\u6280\u672f\u7684\u53d1\u5c55\u53f2 \u4e00\u4e2a\u7a0b\u5e8f\u8981\u60f3\u88c5\u5165\u5185\u5b58\u8fd0\u884c\u5fc5\u7136\u8981\u5148\u7ecf\u8fc7\u7f16\u8bd1\u3001\u94fe\u63a5\u548c\u88c5\u5165\u8fd9\u4e09\u4e2a\u9636\u6bb5\uff0c\u867d\u7136\u662f\u8fd9\u6837\u4e00\u4e2a\u5927\u5bb6\u542c\u8d77\u6765\u8033\u719f\u80fd\u8be6\u7684\u6982\u5ff5\uff0c\u5728\u64cd\u4f5c\u7cfb\u7edf\u53d1\u5c55\u7684\u8fc7\u7a0b\u4e2d\u5374\u5df2\u7ecf\u7ecf\u5386\u4e86\u591a\u6b21\u91cd\u5927\u53d8\u9769\u3002\u7b80\u5355\u6765\u8bb2\uff0c\u53ef\u4ee5\u5c06\u5176\u5212\u5206\u4e3a\u4ee5\u4e0b\u4e09\u4e2a\u9636\u6bb5\uff1a 1\uff0e \u9759\u6001\u94fe\u63a5\u3001\u9759\u6001\u88c5\u5165 \u8fd9\u79cd\u65b9\u6cd5\u6700\u65e9\u88ab\u91c7\u7528\uff0c\u5176\u7279\u70b9\u662f\u7b80\u5355\uff0c\u4e0d\u9700\u8981\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4efb\u4f55\u989d\u5916\u7684\u652f\u6301\u3002\u50cfC\u8fd9\u6837\u7684\u7f16\u7a0b\u8bed\u8a00\u4ece\u5f88\u65e9\u5f00\u59cb\u5c31\u5df2\u7ecf\u652f\u6301\u5206\u522b\u7f16\u8bd1\u4e86\uff0c\u7a0b\u5e8f\u7684\u4e0d\u540c\u6a21\u5757\u53ef\u4ee5\u5e76\u884c\u5f00\u53d1\uff0c\u7136\u540e\u72ec\u7acb\u7f16\u8bd1\u4e3a\u76f8\u5e94\u7684\u76ee\u6807\u6587\u4ef6\u3002\u5728\u5f97\u5230\u4e86\u6240\u6709\u7684\u76ee\u6807\u6587\u4ef6\u540e\uff0c\u9759\u6001\u94fe\u63a5\u3001\u9759\u6001\u88c5\u5165\u7684\u505a\u6cd5\u662f\u5c06\u6240\u6709\u76ee\u6807\u6587\u4ef6\u94fe\u63a5\u6210\u4e00\u4e2a**\u53ef\u6267\u884c\u6620\u8c61**\uff0c\u968f\u540e\u5728\u521b\u5efa\u8fdb\u7a0b\u65f6\u5c06\u8be5**\u53ef\u6267\u884c\u6620\u8c61**\u4e00\u6b21\u5168\u90e8\u88c5\u5165\u5185\u5b58\u3002\u4e3e\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u5047\u8bbe\u6211\u4eec\u5f00\u53d1\u4e86\u4e24\u4e2a\u7a0b\u5e8f Prog1 \u548c Prog2 \uff0c Prog1 \u7531 main1.c \u3001 utilities.c \u4ee5\u53ca errhdl1.c \u4e09\u90e8\u5206\u7ec4\u6210\uff0c\u5206\u522b\u5bf9\u5e94\u7a0b\u5e8f\u7684\u4e3b\u6846\u67b6\u3001\u4e00\u4e9b\u516c\u7528\u7684\u8f85\u52a9\u51fd\u6570\uff08\u5176\u4f5c\u7528\u76f8\u5f53\u4e8e\u5e93\uff09\u4ee5\u53ca\u9519\u8bef\u5904\u7406\u90e8\u5206\uff0c\u8fd9\u4e09\u90e8\u5206\u4ee3\u7801\u7f16\u8bd1\u540e\u5206\u522b\u5f97\u5230\u5404\u81ea\u5bf9\u5e94\u7684\u76ee\u6807\u6587\u4ef6main1.o\u3001utilities.o\u4ee5\u53caerrhdl1.o\u3002\u540c\u6837\uff0cProg2\u7531main2.c\u3001utilities.c\u4ee5\u53caerrhdl2.c\u4e09\u90e8\u5206\u7ec4\u6210\uff0c\u4e09\u90e8\u5206\u4ee3\u7801\u7f16\u8bd1\u540e\u5206\u522b\u5f97\u5230\u5404\u81ea\u5bf9\u5e94\u7684\u76ee\u6807\u6587\u4ef6main2.o\u3001utilities.o\u4ee5\u53caerrhdl2.o\u3002\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u91ccProg1\u548cProg2\u4f7f\u7528\u4e86\u76f8\u540c\u7684\u516c\u7528\u8f85\u52a9\u51fd\u6570utilities.o\u3002\u5f53\u6211\u4eec\u91c7\u7528\u9759\u6001\u94fe\u63a5\u3001\u9759\u6001\u88c5\u5165\u7684\u65b9\u6cd5\uff0c\u540c\u65f6\u8fd0\u884c\u8fd9\u4e24\u4e2a\u7a0b\u5e8f\u65f6\u5185\u5b58\u548c\u786c\u76d8\u7684\u4f7f\u7528\u60c5\u51b5\u5982\u56fe1\u6240\u793a\uff1a \u53ef\u4ee5\u770b\u5230\uff0c\u9996\u5148\u5c31\u786c\u76d8\u7684\u4f7f\u7528\u6765\u8bb2\uff0c\u867d\u7136\u4e24\u4e2a\u7a0b\u5e8f**\u5171\u4eab**\u4f7f\u7528\u4e86utilities\uff0c\u4f46\u8fd9\u5e76\u6ca1\u6709\u5728\u786c\u76d8\u4fdd\u5b58\u7684**\u53ef\u6267\u884c\u7a0b\u5e8f\u6620\u8c61**\u4e0a\u4f53\u73b0\u51fa\u6765\u3002\u76f8\u53cd\uff0c utilities.o \u88ab\u94fe\u63a5\u8fdb\u4e86\u6bcf\u4e00\u4e2a\u7528\u5230\u5b83\u7684\u7a0b\u5e8f\u7684\u53ef\u6267\u884c\u6620\u8c61\u3002\u5185\u5b58\u7684\u4f7f\u7528\u4e5f\u662f\u5982\u6b64\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5728\u521b\u5efa\u8fdb\u7a0b\u65f6\u5c06\u7a0b\u5e8f\u7684\u53ef\u6267\u884c\u6620\u8c61**\u4e00\u6b21\u5168\u90e8**\u88c5\u5165\u5185\u5b58\uff0c\u4e4b\u540e\u8fdb\u7a0b\u624d\u80fd\u5f00\u59cb\u8fd0\u884c\u3002\u5982\u524d\u6240\u8ff0\uff0c\u91c7\u7528\u8fd9\u79cd\u65b9\u6cd5\u4f7f\u5f97\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\u53d8\u5f97\u975e\u5e38\u7b80\u5355\uff0c\u4f46\u5176\u7f3a\u70b9\u4e5f\u662f\u663e\u800c\u6613\u89c1\u7684\u3002\u9996\u5148\uff0c\u65e2\u7136\u4e24\u4e2a\u7a0b\u5e8f\u4f7f\u7528\u7684\u662f\u76f8\u540c\u7684 utilities.o \uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u8981\u5728\u786c\u76d8\u4e0a\u4fdd\u5b58 utilities.o \u7684\u4e00\u4efd\u62f7\u8d1d\u5e94\u8be5\u5c31\u8db3\u591f\u4e86\uff1b\u53e6\u5916\uff0c\u5047\u5982\u7a0b\u5e8f\u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6ca1\u6709\u51fa\u73b0\u4efb\u4f55\u9519\u8bef\uff0c\u90a3\u4e48\u9519\u8bef\u5904\u7406\u90e8\u5206\u7684\u4ee3\u7801\u5c31\u4e0d\u5e94\u8be5\u88ab\u88c5\u5165\u5185\u5b58\u3002\u56e0\u6b64\u9759\u6001\u94fe\u63a5\u3001\u9759\u6001\u88c5\u5165\u7684\u65b9\u6cd5\u4e0d\u4f46\u6d6a\u8d39\u4e86\u786c\u76d8\u7a7a\u95f4\uff0c\u540c\u65f6\u4e5f\u6d6a\u8d39\u4e86\u5185\u5b58\u7a7a\u95f4\u3002\u7531\u4e8e\u65e9\u671f\u7cfb\u7edf\u7684\u5185\u5b58\u8d44\u6e90\u5341\u5206\u5b9d\u8d35\uff0c\u6240\u4ee5\u540e\u8005\u5bf9\u65e9\u671f\u7684\u7cfb\u7edf\u6765\u8bb2\u66f4\u52a0\u81f4\u547d\u3002 2\uff0e \u9759\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165 \u65e2\u7136\u91c7\u7528**\u9759\u6001\u94fe\u63a5**\u3001**\u9759\u6001\u88c5\u5165**\u7684\u65b9\u6cd5\u5f0a\u5927\u4e8e\u5229\uff0c\u6211\u4eec\u6765\u770b\u770b\u4eba\u4eec\u662f\u5982\u4f55\u89e3\u51b3\u8fd9\u4e00\u95ee\u9898\u7684\u3002\u7531\u4e8e\u5185\u5b58\u7d27\u5f20\u7684\u95ee\u9898\u5728\u65e9\u671f\u7684\u7cfb\u7edf\u4e2d\u663e\u5f97\u66f4\u52a0\u7a81\u51fa\uff0c\u56e0\u6b64\u4eba\u4eec\u9996\u5148\u60f3\u5230\u7684\u662f\u8981\u89e3\u51b3\u5185\u5b58\u4f7f\u7528\u6548\u7387\u4e0d\u9ad8\u8fd9\u4e00\u95ee\u9898\uff0c\u4e8e\u662f\u4fbf\u63d0\u51fa\u4e86**\u52a8\u6001\u88c5\u5165**\u7684\u601d\u60f3\u3002\u5176\u60f3\u6cd5\u662f\u975e\u5e38\u7b80\u5355\u7684\uff0c\u5373\u4e00\u4e2a\u51fd\u6570\u53ea\u6709\u5f53\u5b83\u88ab\u8c03\u7528\u65f6\uff0c\u5176\u6240\u5728\u7684\u6a21\u5757\u624d\u4f1a\u88ab\u88c5\u5165\u5185\u5b58\u3002\u6240\u6709\u7684\u6a21\u5757\u90fd\u4ee5\u4e00\u79cd**\u53ef\u91cd\u5b9a\u4f4d\u7684\u88c5\u5165\u683c\u5f0f**\u5b58\u653e\u5728\u78c1\u76d8\u4e0a\u3002\u9996\u5148\uff0c\u4e3b\u7a0b\u5e8f\u88ab\u88c5\u5165\u5185\u5b58\u5e76\u5f00\u59cb\u8fd0\u884c\u3002\u5f53\u4e00\u4e2a\u6a21\u5757\u9700\u8981\u8c03\u7528\u53e6\u4e00\u4e2a\u6a21\u5757\u4e2d\u7684\u51fd\u6570\u65f6\uff0c\u9996\u5148\u8981\u68c0\u67e5\u542b\u6709\u88ab\u8c03\u7528\u51fd\u6570\u7684\u6a21\u5757\u662f\u5426\u5df2\u88c5\u5165\u5185\u5b58\u3002\u5982\u679c\u8be5\u6a21\u5757\u5c1a\u672a\u88ab\u88c5\u5165\u5185\u5b58\uff0c\u90a3\u4e48\u5c06\u7531\u8d1f\u8d23\u91cd\u5b9a\u4f4d\u7684\u94fe\u63a5\u88c5\u5165\u5668\u5c06\u8be5\u6a21\u5757\u88c5\u5165\u5185\u5b58\uff0c\u540c\u65f6\u66f4\u65b0\u6b64\u7a0b\u5e8f\u7684**\u5730\u5740\u8868**\u4ee5\u53cd\u5e94\u8fd9\u4e00\u53d8\u5316\u3002\u4e4b\u540e\uff0c\u63a7\u5236\u4fbf\u8f6c\u79fb\u5230\u4e86\u65b0\u88c5\u5165\u7684\u6a21\u5757\u4e2d\u88ab\u8c03\u7528\u7684\u51fd\u6570\u90a3\u91cc\u3002 \u52a8\u6001\u88c5\u5165\u7684\u4f18\u70b9\u5728\u4e8e\u6c38\u8fdc\u4e0d\u4f1a\u88c5\u5165\u4e00\u4e2a\u4f7f\u7528\u4e0d\u5230\u7684\u6a21\u5757\u3002\u5982\u679c\u7a0b\u5e8f\u4e2d\u5b58\u5728\u7740\u5927\u91cf\u50cf\u51fa\u9519\u5904\u7406\u51fd\u6570\u8fd9\u79cd\u7528\u4e8e\u5904\u7406\u5c0f\u6982\u7387\u4e8b\u4ef6\u7684\u4ee3\u7801\uff0c\u4f7f\u7528\u8fd9\u79cd\u65b9\u6cd5\u65e0\u7591\u662f\u5353\u6709\u6210\u6548\u7684\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5373\u4f7f\u6574\u4e2a\u7a0b\u5e8f\u53ef\u80fd\u5f88\u5927\uff0c\u4f46\u662f\u5b9e\u9645\u7528\u5230\uff08\u56e0\u6b64\u88ab\u88c5\u5165\u5230\u5185\u5b58\u4e2d\uff09\u7684\u90e8\u5206\u5b9e\u9645\u4e0a\u53ef\u80fd\u975e\u5e38\u5c0f\u3002 \u4ecd\u7136\u4ee5\u4e0a\u9762\u63d0\u5230\u7684\u4e24\u4e2a\u7a0b\u5e8f Prog1 \u548c Prog2 \u4e3a\u4f8b\uff0c\u5047\u5982 Prog1 \u8fd0\u884c\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u4e86\u9519\u8bef\u800c Prog2 \u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6ca1\u6709\u51fa\u73b0\u4efb\u4f55\u9519\u8bef\u3002\u5f53\u6211\u4eec\u91c7\u7528\u9759\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u7684\u65b9\u6cd5\uff0c\u540c\u65f6\u8fd0\u884c\u8fd9\u4e24\u4e2a\u7a0b\u5e8f\u65f6\u5185\u5b58\u548c\u786c\u76d8\u7684\u4f7f\u7528\u60c5\u51b5\u5982\u56fe2\u6240\u793a\uff1a \u56fe 2\u91c7\u7528\u9759\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u65b9\u6cd5\uff0c\u540c\u65f6\u8fd0\u884cProg1\u548cProg2\u65f6\u5185\u5b58\u548c\u786c\u76d8\u7684\u4f7f\u7528\u60c5\u51b5 \u53ef\u4ee5\u770b\u5230\uff0c\u5f53\u7a0b\u5e8f\u4e2d\u5b58\u5728\u7740\u5927\u91cf\u50cf\u9519\u8bef\u5904\u7406\u8fd9\u6837\u4f7f\u7528\u6982\u7387\u5f88\u5c0f\u7684\u6a21\u5757\u65f6\uff0c\u91c7\u7528\u9759\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u7684\u65b9\u6cd5\u5728\u5185\u5b58\u7684\u4f7f\u7528\u6548\u7387\u4e0a\u5c31\u4f53\u73b0\u51fa\u4e86\u76f8\u5f53\u5927\u7684\u4f18\u52bf\u3002\u5230\u6b64\u4e3a\u6b62\uff0c\u4eba\u4eec\u5df2\u7ecf\u5411\u7406\u60f3\u7684\u76ee\u6807\u8fc8\u8fdb\u4e86\u4e00\u90e8\uff0c\u4f46\u662f\u95ee\u9898\u8fd8\u6ca1\u6709\u5b8c\u5168\u89e3\u51b3\u2015\u2015\u5185\u5b58\u7684\u4f7f\u7528\u6548\u7387\u63d0\u9ad8\u4e86\uff0c\u786c\u76d8\u5462\uff1f 3\uff0e \u52a8\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165 \u91c7\u7528\u9759\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u7684\u65b9\u6cd5\u540e\u770b\u4f3c\u53ea\u5269\u4e0b\u786c\u76d8\u7a7a\u95f4\u4f7f\u7528\u6548\u7387\u4e0d\u9ad8\u7684\u95ee\u9898\u4e86\uff0c\u5b9e\u9645\u4e0a\u5185\u5b58\u4f7f\u7528\u6548\u7387\u4e0d\u9ad8\u7684\u95ee\u9898\u4ecd\u7136\u6ca1\u6709\u5b8c\u5168\u89e3\u51b3\u3002\u56fe2\u4e2d\uff0c\u65e2\u7136\u4e24\u4e2a\u7a0b\u5e8f\u7528\u5230\u7684\u662f\u76f8\u540c\u7684utilities.o\uff0c\u90a3\u4e48\u7406\u60f3\u7684\u60c5\u51b5\u662f\u7cfb\u7edf\u4e2d\u53ea\u4fdd\u5b58\u4e00\u4efdutilities.o\u7684\u62f7\u8d1d\uff0c\u65e0\u8bba\u662f\u5728\u5185\u5b58\u4e2d\u8fd8\u662f\u5728\u786c\u76d8\u4e0a\uff0c\u4e8e\u662f\u4eba\u4eec\u60f3\u5230\u4e86**\u52a8\u6001\u94fe\u63a5**\u3002 \u5728\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u65f6\uff0c\u9700\u8981\u5728\u7a0b\u5e8f\u6620\u8c61\u4e2d\u6bcf\u4e2a\u8c03\u7528**\u5e93\u51fd**\u6570\u7684\u5730\u65b9\u6253\u4e00\u4e2a**\u6869**\uff08stub\uff09\u3002stub\u662f\u4e00\u5c0f\u6bb5\u4ee3\u7801\uff0c\u7528\u4e8e**\u5b9a\u4f4d**\u5df2\u88c5\u5165\u5185\u5b58\u7684\u76f8\u5e94\u7684**\u5e93**\uff1b\u5982\u679c\u6240\u9700\u7684\u5e93\u8fd8\u4e0d\u5728\u5185\u5b58\u4e2d\uff0cstub\u5c06\u6307\u51fa\u5982\u4f55\u5c06\u8be5\u51fd\u6570\u6240\u5728\u7684\u5e93\u88c5\u5165\u5185\u5b58\u3002 \u5f53\u6267\u884c\u5230\u8fd9\u6837\u4e00\u4e2a**stub**\u65f6\uff0c\u9996\u5148\u68c0\u67e5\u6240\u9700\u7684\u51fd\u6570\u662f\u5426\u5df2\u4f4d\u4e8e\u5185\u5b58\u4e2d\u3002\u5982\u679c\u6240\u9700\u51fd\u6570\u5c1a\u4e0d\u5728\u5185\u5b58\u4e2d\uff0c\u5219\u9996\u5148\u9700\u8981\u5c06\u5176\u88c5\u5165\u3002\u4e0d\u8bba\u600e\u6837\uff0cstub\u6700\u7ec8\u5c06\u88ab\u8c03\u7528\u51fd\u6570\u7684\u5730\u5740\u66ff\u6362\u6389\u3002\u8fd9\u6837\uff0c\u5728\u4e0b\u6b21\u8fd0\u884c\u540c\u4e00\u4e2a\u4ee3\u7801\u6bb5\u65f6\uff0c\u540c\u6837\u7684\u5e93\u51fd\u6570\u5c31\u80fd\u76f4\u63a5\u5f97\u4ee5\u8fd0\u884c\uff0c\u4ece\u800c\u7701\u6389\u4e86\u52a8\u6001\u94fe\u63a5\u7684\u989d\u5916\u5f00\u9500\u3002\u7531\u6b64\uff0c\u7528\u5230\u540c\u4e00\u4e2a\u5e93\u7684\u6240\u6709\u8fdb\u7a0b\u5728\u8fd0\u884c\u65f6\u4f7f\u7528\u7684\u90fd\u662f\u8fd9\u4e2a\u5e93\u7684\u540c\u4e00\u4efd\u62f7\u8d1d\u3002 \u4e0b\u9762\u6211\u4eec\u5c31\u6765\u770b\u770b\u4e0a\u9762\u63d0\u5230\u7684\u4e24\u4e2a\u7a0b\u5e8fProg1\u548cProg2\u5728\u91c7\u7528\u52a8\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u7684\u65b9\u6cd5\uff0c\u540c\u65f6\u8fd0\u884c\u8fd9\u4e24\u4e2a\u7a0b\u5e8f\u65f6\u5185\u5b58\u548c\u786c\u76d8\u7684\u4f7f\u7528\u60c5\u51b5\uff08\u89c1\u56fe3\uff09\u3002\u4ecd\u7136\u5047\u8bbeProg1\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u4e86\u9519\u8bef\u800cProg2\u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6ca1\u6709\u51fa\u73b0\u4efb\u4f55\u9519\u8bef\u3002 \u56fe 3\u91c7\u7528\u52a8\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u65b9\u6cd5\uff0c\u540c\u65f6\u8fd0\u884cProg1\u548cProg2\u65f6\u5185\u5b58\u548c\u786c\u76d8\u7684\u4f7f\u7528\u60c5\u51b5 \u56fe\u4e2d\uff0c\u65e0\u8bba\u662f\u786c\u76d8\u8fd8\u662f\u5185\u5b58\u4e2d\u90fd\u53ea\u5b58\u5728\u4e00\u4efdutilities.o\u7684\u62f7\u8d1d\u3002\u5185\u5b58\u4e2d\uff0c\u4e24\u4e2a\u8fdb\u7a0b\u901a\u8fc7\u5c06\u5730\u5740\u6620\u5c04\u5230\u76f8\u540c\u7684utilities.o\u5b9e\u73b0\u5bf9\u5176\u7684\u5171\u4eab\u3002\u52a8\u6001\u94fe\u63a5\u7684\u8fd9\u4e00\u7279\u6027\u5bf9\u4e8e\u5e93\u7684\u5347\u7ea7\uff08\u6bd4\u5982\u9519\u8bef\u7684\u4fee\u6b63\uff09\u662f\u81f3\u5173\u91cd\u8981\u7684\u3002\u5f53\u4e00\u4e2a\u5e93\u5347\u7ea7\u5230\u4e00\u4e2a\u65b0\u7248\u672c\u65f6\uff0c\u6240\u6709\u7528\u5230\u8fd9\u4e2a\u5e93\u7684\u7a0b\u5e8f\u5c06\u81ea\u52a8\u4f7f\u7528\u65b0\u7684\u7248\u672c\u3002\u5982\u679c\u4e0d\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u6280\u672f\uff0c\u90a3\u4e48\u6240\u6709\u8fd9\u4e9b\u7a0b\u5e8f\u90fd\u9700\u8981\u88ab\u91cd\u65b0\u94fe\u63a5\u624d\u80fd\u5f97\u4ee5\u8bbf\u95ee\u65b0\u7248\u7684\u5e93\u3002\u4e3a\u4e86\u907f\u514d\u7a0b\u5e8f\u610f\u5916\u4f7f\u7528\u5230\u4e00\u4e9b\u4e0d\u517c\u5bb9\u7684\u65b0\u7248\u7684\u5e93\uff0c\u901a\u5e38\u5728\u7a0b\u5e8f\u548c\u5e93\u4e2d\u90fd\u5305\u542b\u5404\u81ea\u7684\u7248\u672c\u4fe1\u606f\u3002\u5185\u5b58\u4e2d\u53ef\u80fd\u4f1a\u540c\u65f6\u5b58\u5728\u7740\u4e00\u4e2a\u5e93\u7684\u51e0\u4e2a\u7248\u672c\uff0c\u4f46\u662f\u6bcf\u4e2a\u7a0b\u5e8f\u53ef\u4ee5\u901a\u8fc7\u7248\u672c\u4fe1\u606f\u6765\u51b3\u5b9a\u5b83\u5230\u5e95\u5e94\u8be5\u4f7f\u7528\u54ea\u4e00\u4e2a\u3002\u5982\u679c\u5bf9\u5e93\u53ea\u505a\u4e86\u5fae\u5c0f\u7684\u6539\u52a8\uff0c\u5e93\u7684\u7248\u672c\u53f7\u5c06\u4fdd\u6301\u4e0d\u53d8\uff1b\u5982\u679c\u6539\u52a8\u8f83\u5927\uff0c\u5219\u76f8\u5e94\u9012\u589e\u7248\u672c\u53f7\u3002\u56e0\u6b64\uff0c\u5982\u679c\u65b0\u7248\u5e93\u4e2d\u542b\u6709\u4e0e\u65e9\u671f\u4e0d\u517c\u5bb9\u7684\u6539\u52a8\uff0c\u53ea\u6709\u90a3\u4e9b\u4f7f\u7528\u65b0\u7248\u5e93\u8fdb\u884c\u7f16\u8bd1\u7684\u7a0b\u5e8f\u624d\u4f1a\u53d7\u5230\u5f71\u54cd\uff0c\u800c\u5728\u65b0\u7248\u5e93\u5b89\u88c5\u4e4b\u524d\u8fdb\u884c\u8fc7\u94fe\u63a5\u7684\u7a0b\u5e8f\u5c06\u7ee7\u7eed\u4f7f\u7528\u4ee5\u524d\u7684\u5e93\u3002\u8fd9\u6837\u7684\u7cfb\u7edf\u88ab\u79f0\u4f5c\u5171\u4eab\u5e93\u7cfb\u7edf\u3002 \u56de\u9875\u9996 Linux\u4e0b\u52a8\u6001\u94fe\u63a5\u7684\u5b9e\u73b0 \u5982\u4eca\u6211\u4eec\u5728Linux\u4e0b\u7f16\u7a0b\u7528\u5230\u7684\u5e93\uff08\u50cflibc\u3001QT\u7b49\u7b49\uff09\u5927\u591a\u90fd\u540c\u65f6\u63d0\u4f9b\u4e86**\u52a8\u6001\u94fe\u63a5\u5e93**\u548c**\u9759\u6001\u94fe\u63a5\u5e93**\u4e24\u4e2a\u7248\u672c\u7684\u5e93\uff0c\u800c gcc \u5728\u7f16\u8bd1\u94fe\u63a5\u65f6\u5982\u679c\u4e0d\u52a0 -static \u9009\u9879\u5219\u9ed8\u8ba4\u4f7f\u7528\u7cfb\u7edf\u4e2d\u7684**\u52a8\u6001\u94fe\u63a5\u5e93**\u3002\u5bf9\u4e8e\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u539f\u7406\u5927\u591a\u6570\u7684\u4e66\u672c\u4e0a\u53ea\u662f\u8fdb\u884c\u4e86\u6cdb\u6cdb\u7684\u4ecb\u7ecd\uff0c\u5728\u6b64\u7b14\u8005\u5c06\u901a\u8fc7\u5728\u5b9e\u9645\u7cfb\u7edf\u4e2d\u53cd\u6c47\u7f16\u51fa\u7684\u4ee3\u7801\u5411\u8bfb\u8005\u5c55\u793a\u8fd9\u4e00\u6280\u672f\u5728Linux\u4e0b\u7684\u5b9e\u73b0\u3002 \u4e0b\u9762\u662f\u4e2a\u6700\u7b80\u5355\u7684C\u7a0b\u5e8fhello.c\uff1a #include <stdio.h> int main () { printf ( \"Hello, world \\n \" ); return 0 ; } \u5728Linux\u4e0b\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528gcc\u5c06\u5176\u7f16\u8bd1\u6210\u53ef\u6267\u884c\u6587\u4ef6a.out\uff1a $ gcc hello.c \u7a0b\u5e8f\u91cc\u7528\u5230\u4e86 printf \uff0c\u5b83\u4f4d\u4e8e\u6807\u51c6C\u5e93\u4e2d\uff0c\u5982\u679c\u5728\u7528 gcc \u7f16\u8bd1\u65f6\u4e0d\u52a0 -static \u7684\u8bdd\uff0c\u9ed8\u8ba4\u662f\u4f7f\u7528 libc.so \uff0c\u4e5f\u5c31\u662f\u52a8\u6001\u94fe\u63a5\u7684\u6807\u51c6C\u5e93\u3002\u5728 gdb \u4e2d\u53ef\u4ee5\u770b\u5230\u7f16\u8bd1\u540e printf \u5bf9\u5e94\u5982\u4e0b\u4ee3\u7801 \uff1a $ gdb -q a.out (gdb) disassemble printf Dump of assembler code for function printf: 0x8048310 <printf>: jmp *0x80495a4 0x8048316 <printf+6>: push $0x18 0x804831b <printf+11>: jmp 0x80482d0 <_init+48> \u8fd9\u4e5f\u5c31\u662f\u901a\u5e38\u5728\u4e66\u672c\u4e0a\u4ee5\u53ca\u524d\u9762\u63d0\u5230\u7684**\u6253\u6869\uff08stub\uff09**\u8fc7\u7a0b\uff0c\u663e\u7136\u8fd9\u5e76\u4e0d\u662f\u771f\u6b63\u7684 printf \u51fd\u6570\u3002\u8fd9\u6bb5stub\u4ee3\u7801\u7684\u4f5c\u7528\u5728\u4e8e\u5230 libc.so \u4e2d\u53bb\u67e5\u627e\u771f\u6b63\u7684 printf \u3002 (gdb) x /w 0x80495a4 0x80495a4 <_GLOBAL_OFFSET_TABLE_+24>: 0x08048316 \u53ef\u4ee5\u770b\u5230 0x80495a4 \u5904\u5b58\u653e\u7684 0x08048316 \u6b63\u662f pushl $0x18 \u8fd9\u6761\u6307\u4ee4\u7684\u5730\u5740\uff0c\u6240\u4ee5\u7b2c\u4e00\u6761 jmp \u6307\u4ee4\u6ca1\u6709\u8d77\u5230\u4efb\u4f55\u4f5c\u7528\uff0c\u5176\u4f5c\u7528\u5c31\u50cf\u7a7a\u64cd\u4f5c\u6307\u4ee4 nop \u4e00\u6837\u3002\u5f53\u7136\u8fd9\u662f\u5728\u6211\u4eec\u7b2c\u4e00\u6b21\u8c03\u7528printf\u65f6\uff0c\u5176\u771f\u6b63\u7684\u4f5c\u7528\u662f\u5728\u4eca\u540e\u518d\u6b21\u8c03\u7528 printf \u65f6\u4f53\u73b0\u51fa\u6765\u7684\u3002\u7b2c\u4e8c\u6761 jmp \u6307\u4ee4\u7684\u76ee\u7684\u5730\u5740\u662f plt \uff0c\u4e5f\u5c31\u662fprocedure linkage table\uff0c\u5176\u5185\u5bb9\u53ef\u4ee5\u901a\u8fc7 objdump \u547d\u4ee4\u67e5\u770b\uff0c\u6211\u4eec\u611f\u5174\u8da3\u7684\u5c31\u662f\u4e0b\u9762\u8fd9\u4e24\u6761\u5bf9\u7a0b\u5e8f\u7684\u63a7\u5236\u6d41\u6709\u5f71\u54cd\u7684\u6307\u4ee4\uff1a $ objdump -dx a.out \u2026\u2026 080482d0 >.plt>: 80482d0: ff 35 90 95 04 08 pushl 0x8049590 80482d6: ff 25 94 95 04 08 jmp *0x8049594 \u2026\u2026 \u7b2c\u4e00\u6761push\u6307\u4ee4\u5c06got\uff08global offset table\uff09\u4e2d\u4e0eprintf\u76f8\u5173\u7684\u8868\u9879\u5730\u5740\u538b\u5165\u5806\u6808\uff0c\u4e4b\u540ejmp\u5230\u5185\u5b58\u5355\u51430x8049594\u4e2d\u6240\u5b58\u653e\u7684\u5730\u57400x4000a960\u5904\u3002\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u4e00\u70b9\u662f\uff0c\u5728\u67e5\u770bgot\u4e4b\u524d\u5fc5\u987b\u5148\u5c06\u7a0b\u5e8fa.out\u542f\u52a8\u8fd0\u884c\uff0c\u5426\u5219\u901a\u8fc7gdb\u4e2d\u7684x\u547d\u4ee4\u57280x8049594\u5904\u770b\u5230\u7684\u7ed3\u679c\u662f\u4e0d\u6b63\u786e\u7684\u3002 (gdb) b main Breakpoint 1 at 0x8048406 (gdb) r Starting program: a.out Breakpoint 1, 0x08048406 in main () (gdb) x /w 0x8049594 0x8049594 <_GLOBAL_OFFSET_TABLE_+8>: 0x4000a960 (gdb) disassemble 0x4000a960 Dump of assembler code for function _dl_runtime_resolve: 0x4000a960 <_dl_runtime_resolve>: pushl %eax 0x4000a961 <_dl_runtime_resolve+1>: pushl %ecx 0x4000a962 <_dl_runtime_resolve+2>: pushl %edx 0x4000a963 <_dl_runtime_resolve+3>: movl 0x10(%esp,1),%edx 0x4000a967 <_dl_runtime_resolve+7>: movl 0xc(%esp,1),%eax 0x4000a96b <_dl_runtime_resolve+11>: call 0x4000a740 <fixup> 0x4000a970 <_dl_runtime_resolve+16>: popl %edx 0x4000a971 <_dl_runtime_resolve+17>: popl %ecx 0x4000a972 <_dl_runtime_resolve+18>: xchgl %eax,(%esp,1) 0x4000a975 <_dl_runtime_resolve+21>: ret $0x8 0x4000a978 <_dl_runtime_resolve+24>: nop 0x4000a979 <_dl_runtime_resolve+25>: leal 0x0(%esi,1),%esi End of assembler dump. \u524d\u9762\u4e09\u6761push\u6307\u4ee4\u6267\u884c\u4e4b\u540e\u5806\u6808\u91cc\u9762\u7684\u5185\u5bb9\u5982\u4e0b\uff1a \u4e0b\u9762\u5c060x18\u5b58\u5165edx\uff0c0x8049590\u5b58\u5165eax\uff0c\u6709\u4e86\u8fd9\u4e24\u4e2a\u53c2\u6570\uff0cfixup\u5c31\u53ef\u4ee5\u627e\u5230printf\u5728libc.so\u4e2d\u7684\u5730\u5740\u3002\u5f53fixup\u8fd4\u56de\u65f6\uff0c\u8be5\u5730\u5740\u5df2\u7ecf\u4fdd\u5b58\u5728\u4e86eax\u4e2d\u3002xchg\u6307\u4ee4\u6267\u884c\u5b8c\u4e4b\u540e\u5806\u6808\u4e2d\u7684\u5185\u5bb9\u5982\u4e0b\uff1a \u6700\u5999\u7684\u8981\u6570\u63a5\u4e0b\u6765\u7684ret\u6307\u4ee4\u7684\u7528\u6cd5\uff0c\u8fd9\u91ccret\u5b9e\u9645\u4e0a\u88ab\u5f53\u6210\u4e86call\u6765\u4f7f\u7528\u3002ret $0x8\u4e4b\u540e\u63a7\u5236\u4fbf\u8f6c\u79fb\u5230\u4e86\u771f\u6b63\u7684printf\u51fd\u6570\u90a3\u91cc\uff0c\u5e76\u4e14\u6e05\u6389\u4e86\u5806\u6808\u4e0a\u76840x18\u548c0x8049584\u8fd9\u4e24\u4e2a\u5df2\u7ecf\u6ca1\u7528\u7684\u53c2\u6570\uff0c\u8fd9\u65f6\u5806\u6808\u4fbf\u6210\u4e86\u4e0b\u9762\u7684\u6837\u5b50\uff1a \u800c\u8fd9\u6b63\u662f\u6211\u4eec\u6240\u671f\u671b\u7684\u7ed3\u679c\u3002\u5e94\u8be5\u8bf4\u8fd9\u91ccret\u7684\u7528\u6cd5\u4e0eLinux\u5185\u6838\u542f\u52a8\u540e\u901a\u8fc7iret\u6307\u4ee4\u5b9e\u73b0\u7531\u5185\u6838\u6001\u5207\u6362\u5230\u7528\u6237\u6001\u7684\u505a\u6cd5\u6709\u7740\u5f02\u66f2\u540c\u5de5\u4e4b\u5999\u3002\u5f88\u591a\u4eba\u90fd\u542c\u8bf4\u8fc7\u4e2d\u65ad\u6307\u4ee4int\u53ef\u4ee5\u5b9e\u73b0\u7528\u6237\u6001\u5230\u5185\u6838\u6001\u8fd9\u79cd\u4f18\u5148\u7ea7\u7531\u4f4e\u5230\u9ad8\u7684\u5207\u6362\uff0c\u5728\u63a5\u53d7\u5b8c\u7cfb\u7edf\u670d\u52a1\u540eiret\u6307\u4ee4\u8d1f\u8d23\u5c06\u4f18\u5148\u7ea7\u91cd\u65b0\u964d\u81f3\u7528\u6237\u6001\u7684\u4f18\u5148\u7ea7\u3002\u7136\u800c\u7cfb\u7edf\u542f\u52a8\u65f6\u9996\u5148\u662f\u5904\u4e8e\u5185\u6838\u6001\u9ad8\u4f18\u5148\u7ea7\u7684\uff0cIntel i386\u5e76\u6ca1\u6709\u5355\u72ec\u63d0\u4f9b\u4e00\u6761\u7279\u6b8a\u7684\u6307\u4ee4\u7528\u4e8e\u5728\u7cfb\u7edf\u542f\u52a8\u5b8c\u6210\u540e\u964d\u4f4e\u4f18\u5148\u7ea7\u4ee5\u8fd0\u884c\u7528\u6237\u7a0b\u5e8f\u3002\u5176\u5b9e\u8fd9\u4e2a\u95ee\u9898\u5f88\u7b80\u5355\uff0c\u53ea\u8981\u53cd\u7528iret\u5c31\u53ef\u4ee5\u4e86\uff0c\u5c31\u50cf\u8fd9\u91cc\u5c06ret\u5f53\u4f5ccall\u4f7f\u7528\u4e00\u6837\u3002\u53e6\u5916\uff0cfixup\u51fd\u6570\u6267\u884c\u5b8c\u8fd8\u6709\u4e00\u4e2a\u526f\u4f5c\u7528\uff0c\u5c31\u662f\u5728got\u4e2d\u4e0eprintf\u76f8\u5173\u7684\u8868\u9879\uff08\u4e5f\u5c31\u662f\u5730\u5740\u4e3a0x80495a4\u7684\u5185\u5b58\u5355\u5143\uff09\u4e2d\u586b\u4e0a\u67e5\u627e\u5230\u7684printf\u51fd\u6570\u5728\u52a8\u6001\u94fe\u63a5\u5e93\u4e2d\u7684\u5730\u5740\u3002\u8fd9\u6837\u5f53\u6211\u4eec\u518d\u6b21\u8c03\u7528printf\u51fd\u6570\u65f6\uff0c\u5176\u5730\u5740\u5c31\u53ef\u4ee5\u76f4\u63a5\u4ecegot\u4e2d\u5f97\u5230\uff0c\u4ece\u800c\u7701\u53bb\u4e86\u901a\u8fc7fixup\u67e5\u627e\u7684\u8fc7\u7a0b\u3002\u4e5f\u5c31\u662f\u8bf4got\u5728\u8fd9\u91cc\u8d77\u5230\u4e86cache\u7684\u4f5c\u7528\u3002 \u56de\u9875\u9996 \u4e00\u70b9\u611f\u60f3 \u5176\u5b9e\u6709\u5f88\u591a\u4e1c\u897f\u53ea\u8981\u52e4\u4e8e\u601d\u8003\uff0c\u8fd8\u662f\u80fd\u591f\u81ea\u5df1\u609f\u51fa\u4e00\u4e9b\u9053\u7406\u7684\u3002\u56fd\u5916\u6709\u4e00\u4e9b\u9ad8\u624b\u5c31\u662f\u901a\u8fc7\u80fd\u591f\u5927\u5bb6\u90fd\u80fd\u89c1\u5230\u7684\u7684\u4e00\u70b9\u70b9\u8d44\u6599\uff0c\u81ea\u5df1\u6478\u7d22\u51fa\u6765\u5f88\u591a\u4e0d\u4e3a\u4eba\u77e5\u7684\u79d8\u5bc6\u3002\u50cf\u5199\u300aUndocument Dos\u300b\u548c\u300aUndocment Windows\u300b\u7684\u4f5c\u8005\uff0c\u4ed6\u5c31\u4e3a\u6211\u4eec\u6811\u7acb\u4e86\u8fd9\u6837\u7684\u699c\u6837\uff01 \u5b66\u4e60\u8ba1\u7b97\u673a\u5f88\u5173\u952e\u7684\u4e00\u70b9\u5728\u4e8e\u4e00\u5b9a\u8981\u5bcc\u4e8e\u63a2\u7d22\u7cbe\u795e\uff0c\u8981\u8ba9\u81ea\u5df1\u505a\u5230\u77e5\u5176\u7136\u5e76\u77e5\u5176\u6240\u4ee5\u7136\u3002\u4faf\u5148\u751f\u5728\u300aSTL\u6e90\u7801\u5256\u6790\u300b\u4e00\u4e66\u5f00\u7bc7\u9898\u8bb0\u4e2d\u5199\u5230\"\u6e90\u7801\u4e4b\u524d\uff0c\u4e86\u65e0\u79d8\u5bc6\"\uff0c\u5f53\u7136\u8fd9\u662f\u5728\u6211\u4eec\u624b\u4e2d\u638c\u63e1\u7740\u6e90\u7801\u7684\u60c5\u51b5\u4e0b\uff0c\u5982\u82e5\u4e0d\u7136\uff0c\u4e0d\u8981\u5fd8\u8bb0Linux\u8fd8\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u5927\u91cf\u7684\u50cfgdb\u3001objdump\u8fd9\u6837\u7684\u5b9e\u7528\u5de5\u5177\u3002\u6709\u4e86\u8fd9\u4e9b\u5f97\u529b\u7684\u52a9\u624b\uff0c\u5373\u4f7f\u6ca1\u6709\u6e90\u7801\uff0c\u6211\u4eec\u4e00\u6837\u53ef\u4ee5\u505a\u5230\"\u4e86\u65e0\u79d8\u5bc6\"\u3002 \u53c2\u8003\u8d44\u6599 John R. Levine.\u300aLinkers & Loaders\u300b. \u300aExecutable and Linkable Format\u300b. Intel. \u300aIntel Architecture Software Developer's Manual\u300b. Intel Corporation, 1997. http://www.cnblogs.com/Anker/p/3527677.html Linux\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4f7f\u7528 1\u3001\u524d\u8a00 \u5728\u5b9e\u9645\u5f00\u53d1\u8fc7\u7a0b\u4e2d\uff0c\u5404\u4e2a\u6a21\u5757\u4e4b\u95f4\u4f1a\u6d89\u53ca\u5230\u4e00\u4e9b\u901a\u7528\u7684\u529f\u80fd\uff0c\u6bd4\u5982\u8bfb\u5199\u6587\u4ef6\uff0c\u67e5\u627e\u3001\u6392\u5e8f\u3002\u4e3a\u4e86\u51cf\u5c11\u4ee3\u7801\u7684\u5197\u4f59\uff0c\u63d0\u9ad8\u4ee3\u7801\u7684\u8d28\u91cf\uff0c\u53ef\u4ee5\u5c06\u8fd9\u4e9b\u901a\u7528\u7684\u90e8\u5206\u63d0\u53d6\u51fa\u6765\uff0c\u505a\u51fa\u516c\u5171\u7684\u6a21\u5757\u5e93\u3002\u901a\u8fc7\u52a8\u6001\u94fe\u63a5\u5e93\u53ef\u4ee5\u5b9e\u73b0\u591a\u4e2a\u6a21\u5757\u4e4b\u95f4\u5171\u4eab\u516c\u5171\u7684\u51fd\u6570\u3002\u4e4b\u524d\u770b\u300a\u7a0b\u5e8f\u5458\u7684\u81ea\u6211\u4fee\u517b\u300b\u4e2d\u8bb2\u5230\u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u8fc7\u7a0b\uff0c\u8fd9\u4e9b\u73a9\u610f\u90fd\u662f\u5e95\u5c42\u7684\uff0c\u5bf9\u4e8e\u7406\u89e3\u7a0b\u5e8f\u7684\u7f16\u8bd1\u8fc7\u7a0b\u6709\u597d\u5904\u3002 http://www.ibm.com/developerworks/cn/linux/l-dynlink/ \u535a\u6587\u4ecb\u7ecd\u4e86\u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u8fc7\u7a0b\u3002\u672c\u6587\u91cd\u70b9\u5728\u4e8e\u5e94\u7528\uff0c\u5982\u4f55\u7f16\u5199\u548c\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u540e\u7eed\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u5e93\u5b9e\u73b0\u4e00\u4e2a\u63d2\u4ef6\u7a0b\u5e8f\u3002 2\u3001\u52a8\u6001\u94fe\u63a5\u5e93\u751f\u4ea7 \u52a8\u6001\u94fe\u63a5\u5e93\u4e0e\u666e\u901a\u7684\u7a0b\u5e8f\u76f8\u6bd4\u800c\u8a00\uff0c\u6ca1\u6709main\u51fd\u6570\uff0c\u662f\u4e00\u7cfb\u5217\u51fd\u6570\u7684\u5b9e\u73b0\u3002\u901a\u8fc7shared\u548cfPIC\u7f16\u8bd1\u53c2\u6570\u751f\u4ea7so\u52a8\u6001\u94fe\u63a5\u5e93\u6587\u4ef6\u3002\u7a0b\u5e8f\u5728\u8c03\u7528\u5e93\u51fd\u6570\u65f6\uff0c\u53ea\u9700\u8981\u8fde\u63a5\u4e0a\u8fd9\u4e2a\u5e93\u5373\u53ef\u3002\u4f8b\u5982\u4e0b\u9762\u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684\u6574\u6570\u56db\u5219\u8fd0\u8f93\u7684\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5b9a\u4e49\u7684caculate.h\u548ccaculate.c\u4e24\u4e2a\u6587\u4ef6\uff0c\u751f\u4ea7libcac.so\u52a8\u6001\u94fe\u63a5\u5e93\u3002 \u7a0b\u5e8f\u4ee3\u7801\u5982\u4e0b\uff1a /*caculate.h*/ #ifndef CACULATE_HEAD_ #define CACULATE_HEAD_ //\u52a0\u6cd5 int add(int a, int b); //\u51cf\u6cd5 int sub(int a, int b); //\u9664\u6cd5 int div(int a, int b); //\u4e58\u6cd5 int mul(int a, int b); #endif /*caculate.c\u6587\u4ef6*/ #include \"caculate.h\" //\u6c42\u4e24\u4e2a\u6570\u7684\u548c int add(int a, int b) { return (a + b); } //\u51cf\u6cd5 int sub(int a, int b) { return (a - b); } //\u9664\u6cd5 int div(int a, int b) { return (int)(a / b); } //\u4e58\u6cd5 int mul(int a, int b) { return (a * b); } \u7f16\u8bd1\u751f\u4ea7libcac.so\u6587\u4ef6\u5982\u4e0b\uff1a gcc -shared -fPIC caculate.c -o libcac.so \u7f16\u5199\u4e00\u4e2a\u6d4b\u8bd5\u7a0b\u5e8f\u8c03\u7528\u6b64\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u51fd\u6570\uff0c\u7a0b\u5e8f\u5982\u4e0b\u6240\u793a\uff1a #include <stdio.h> #include \"caculate.h\" int main() { int a = 20; int b = 10; printf(\"%d + %d = %d\\n\", a, b, add(a, b)); printf(\"%d - %d = %d\\n\", a, b, sub(a, b)); printf(\"%d / %d = %d\\n\", a, b, div(a, b)); printf(\"%d * %d = %d\\n\", a, b, mul(a, b)); return 0; } \u7f16\u8bd1\u751f\u4ea7\u53ef\u6267\u884c\u6587\u4ef6main\u5982\u4e0b\uff1a gcc main.c -o main -L ./ -lcac \uff08\u5176\u4e2d-L\u6307\u660e\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u8def\u5f84\uff0c-l\u540e\u662f\u94fe\u63a5\u5e93\u7684\u540d\u79f0\uff0c\u7701\u7565lib\uff09 \u7a0b\u5e8f\u6267\u884c\u7ed3\u679c\u5982\u4e0b\u6240\u793a\uff1a 3\u3001\u83b7\u53d6\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u51fd\u6570 \u3000\u3000linux\u63d0\u4f9bdlopen\u3001dlsym\u3001dlerror\u548cdlcolose\u51fd\u6570\u83b7\u53d6\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u51fd\u6570\u3002\u901a\u8fc7\u8fd9\u4e2a\u56db\u4e2a\u51fd\u6570\u53ef\u4ee5\u5b9e\u73b0\u4e00\u4e2a\u63d2\u4ef6\u7a0b\u5e8f\uff0c\u65b9\u4fbf\u7a0b\u5e8f\u7684\u6269\u5c55\u548c\u7ef4\u62a4\u3002\u51fd\u6570\u683c\u5f0f\u5982\u4e0b\u6240\u793a\uff1a #include <dlfcn.h> void *dlopen(const char *filename, int flag); char *dlerror(void); void *dlsym(void *handle, const char *symbol); int dlclose(void *handle); Link with -ldl. dlopen()\u662f\u4e00\u4e2a\u5f3a\u5927\u7684\u5e93\u51fd\u6570\u3002\u8be5\u51fd\u6570\u5c06\u6253\u5f00\u4e00\u4e2a\u65b0\u5e93\uff0c\u5e76\u628a\u5b83\u88c5\u5165\u5185\u5b58\u3002\u8be5\u51fd\u6570\u4e3b\u8981\u7528\u6765\u52a0\u8f7d\u5e93\u4e2d\u7684\u7b26\u53f7\uff0c\u8fd9\u4e9b\u7b26\u53f7\u5728\u7f16\u8bd1\u7684\u65f6\u5019\u662f\u4e0d\u77e5\u9053\u7684\u3002\u5199\u4e2a\u6d4b\u8bd5\u7a0b\u5e8f\u8c03\u7528\u4e0a\u9762\u751f\u4ea7libcac.so\u5e93\u5982\u4e0b\u6240\u793a\uff1a #include <stdio.h> #include <dlfcn.h> #define DLL_FILE_NAME \"libcac.so\" int main() { void *handle; int (*func)(int, int); char *error; int a = 30; int b = 5; handle = dlopen(DLL_FILE_NAME, RTLD_NOW); if (handle == NULL) { fprintf(stderr, \"Failed to open libaray %s error:%s\\n\", DLL_FILE_NAME, dlerror()); return -1; } func = dlsym(handle, \"add\"); printf(\"%d + %d = %d\\n\", a, b, func(a, b)); func = dlsym(handle, \"sub\"); printf(\"%d + %d = %d\\n\", a, b, func(a, b)); func = dlsym(handle, \"div\"); printf(\"%d + %d = %d\\n\", a, b, func(a, b)); func = dlsym(handle, \"mul\"); printf(\"%d + %d = %d\\n\", a, b, func(a, b)); dlclose(handle); return 0; } \u7a0b\u5e8f\u6267\u884c\u7ed3\u679c\u5982\u4e0b\u6240\u793a\uff1a gcc call_main.c -o call_main -ldl 4\u3001\u53c2\u8003\u7f51\u5740 http://www.cnblogs.com/xuxm2007/archive/2010/12/08/1900608.html http://blog.csdn.net/leichelle/article/details/7465763","title":"\u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u53caLinux\u4e0b\u52a8\u6001\u94fe\u63a5\u7684\u5b9e\u73b0"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#linux","text":"\u7a0b\u5e8f\u7684**\u94fe\u63a5**\u548c**\u88c5\u5165**\u5b58\u5728\u7740\u591a\u79cd\u65b9\u6cd5\uff0c\u800c\u5982\u4eca\u6700\u4e3a\u6d41\u884c\u7684\u5f53\u5c5e**\u52a8\u6001\u94fe\u63a5**\u3001**\u52a8\u6001\u88c5\u5165**\u65b9\u6cd5\u3002\u672c\u6587\u9996\u5148\u56de\u987e\u4e86**\u94fe\u63a5\u5668**\u548c**\u88c5\u5165\u5668**\u7684\u57fa\u672c\u5de5\u4f5c\u539f\u7406\u53ca\u8fd9\u4e00\u6280\u672f\u7684\u53d1\u5c55\u5386\u53f2\uff0c\u7136\u540e\u901a\u8fc7\u5b9e\u9645\u7684\u4f8b\u5b50\u5256\u6790\u4e86Linux\u7cfb\u7edf\u4e0b**\u52a8\u6001\u94fe\u63a5**\u7684\u5b9e\u73b0\u3002\u4e86\u89e3\u5e95\u5c42\u5173\u952e\u6280\u672f\u7684\u5b9e\u73b0\u7ec6\u8282\u5bf9\u7cfb\u7edf\u5206\u6790\u548c\u8bbe\u8ba1\u4eba\u5458\u65e0\u7591\u662f\u5fc5\u987b\u7684\uff0c\u5c24\u5176\u5f53\u6211\u4eec\u5728\u9762\u5bf9\u5b9e\u65f6\u7cfb\u7edf\uff0c\u9700\u8981\u5bf9\u7a0b\u5e8f\u6267\u884c\u65f6\u7684\u65f6\u7a7a\u6548\u7387\u6709\u7740\u7cbe\u786e\u7684\u5ea6\u91cf\u548c\u628a\u63e1\u65f6\uff0c\u8fd9\u79cd\u77e5\u8bc6\u66f4\u663e\u91cd\u8981","title":"\u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u53caLinux\u4e0b\u52a8\u6001\u94fe\u63a5\u7684\u5b9e\u73b0"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#_1","text":"\u4e00\u4e2a\u7a0b\u5e8f\u8981\u60f3\u5728\u5185\u5b58\u4e2d\u8fd0\u884c\uff0c\u9664\u4e86\u7f16\u8bd1\u4e4b\u5916\u8fd8\u8981\u7ecf\u8fc7**\u94fe\u63a5**\u548c**\u88c5\u5165**\u8fd9\u4e24\u4e2a\u6b65\u9aa4\u3002\u4ece\u7a0b\u5e8f\u5458\u7684\u89d2\u5ea6\u6765\u770b\uff0c\u5f15\u5165\u8fd9\u4e24\u4e2a\u6b65\u9aa4\u5e26\u6765\u7684\u597d\u5904\u5c31\u662f\u53ef\u4ee5\u76f4\u63a5\u5728\u7a0b\u5e8f\u4e2d\u4f7f\u7528 printf \u548c errno \u8fd9\u79cd**\u6709\u610f\u4e49**\u7684**\u51fd\u6570\u540d**\u548c**\u53d8\u91cf\u540d**\uff0c\u800c\u4e0d\u7528\u660e\u786e\u6307\u660e printf \u548c errno \u5728\u6807\u51c6C\u5e93\u4e2d\u7684**\u5730\u5740**\u3002\u5f53\u7136\uff0c\u4e3a\u4e86\u5c06\u7a0b\u5e8f\u5458\u4ece\u65e9\u671f\u76f4\u63a5\u4f7f\u7528**\u5730\u5740\u7f16\u7a0b**\u7684\u68a6\u9b47\u4e2d\u89e3\u6551\u51fa\u6765\uff0c \u7f16\u8bd1\u5668**\u548c**\u6c47\u7f16\u5668**\u5728\u8fd9\u5f53\u4e2d\u505a\u51fa\u4e86\u9769\u547d\u6027\u7684\u8d21\u732e\u3002**\u7f16\u8bd1\u5668**\u548c**\u6c47\u7f16\u5668**\u7684\u51fa\u73b0\u4f7f\u5f97\u7a0b\u5e8f\u5458\u53ef\u4ee5\u5728\u7a0b\u5e8f\u4e2d\u4f7f\u7528**\u66f4\u5177\u610f\u4e49\u7684\u7b26\u53f7**\u6765\u4e3a*\u51fd\u6570*\u548c*\u53d8\u91cf***\u547d\u540d \uff0c\u8fd9\u6837\u4f7f\u5f97\u7a0b\u5e8f\u5728**\u6b63\u786e\u6027**\u548c**\u53ef\u8bfb\u6027**\u7b49\u65b9\u9762\u90fd\u5f97\u5230\u4e86\u6781\u5927\u7684\u63d0\u9ad8\u3002\u4f46\u662f\u968f\u7740C\u8bed\u8a00\u8fd9\u79cd\u652f\u6301\u5206\u522b\u7f16\u8bd1\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u8bed\u8a00\u7684\u6d41\u884c\uff0c\u4e00\u4e2a\u5b8c\u6574\u7684\u7a0b\u5e8f\u5f80\u5f80\u88ab\u5206\u5272\u4e3a\u82e5\u5e72\u4e2a\u72ec\u7acb\u7684\u90e8\u5206\u5e76\u884c\u5f00\u53d1\uff0c\u800c\u5404\u4e2a\u6a21\u5757\u95f4\u901a\u8fc7**\u51fd\u6570\u63a5\u53e3**\u6216**\u5168\u5c40\u53d8\u91cf**\u8fdb\u884c\u901a\u8baf\u3002\u8fd9\u5c31\u5e26\u6765\u4e86\u4e00\u4e2a\u95ee\u9898\uff0c\u7f16\u8bd1\u5668\u53ea\u80fd\u5728*\u4e00\u4e2a\u6a21\u5757*\u5185\u90e8\u5b8c\u6210**\u7b26\u53f7\u540d**\u5230**\u5730\u5740**\u7684\u8f6c\u6362\u5de5\u4f5c\uff0c\u4e0d\u540c\u6a21\u5757\u95f4\u7684**\u7b26\u53f7\u89e3\u6790**\u7531\u8c01\u6765\u505a\u5462\uff1f\u6bd4\u5982\u524d\u9762\u6240\u4e3e\u7684\u4f8b\u5b50\uff0c\u8c03\u7528 printf \u7684\u7528\u6237\u7a0b\u5e8f\u548c\u5b9e\u73b0\u4e86 printf \u7684\u6807\u51c6C\u5e93\u663e\u7136\u5c31\u662f\u4e24\u4e2a\u4e0d\u540c\u7684\u6a21\u5757\u3002\u5b9e\u9645\u4e0a\uff0c\u8fd9\u4e2a\u5de5\u4f5c\u662f\u7531**\u94fe\u63a5\u5668**\u6765\u5b8c\u6210\u7684\u3002","title":"\u94fe\u63a5\u5668\u548c\u88c5\u5165\u5668\u7684\u57fa\u672c\u5de5\u4f5c\u539f\u7406"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#_2","text":"\u4e3a\u4e86\u89e3\u51b3\u4e0d\u540c\u6a21\u5757\u95f4\u7684**\u94fe\u63a5**\u95ee\u9898\uff0c \u94fe\u63a5\u5668**\u4e3b\u8981\u6709\u4e24\u4e2a\u5de5\u4f5c\u8981\u505a\u2015\u2015**\u7b26\u53f7\u89e3\u6790**\u548c**\u91cd\u5b9a\u4f4d \uff1a","title":"\u94fe\u63a5\u5668\u7684\u4e3b\u8981\u529f\u80fd"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#_3","text":"\u7b26\u53f7\u89e3\u6790\uff1a\u5f53\u4e00\u4e2a\u6a21\u5757\u4f7f\u7528\u4e86\u5728\u8be5\u6a21\u5757\u4e2d\u6ca1\u6709\u5b9a\u4e49\u8fc7\u7684**\u51fd\u6570**\u6216**\u5168\u5c40\u53d8\u91cf**\u65f6\uff0c\u7f16\u8bd1\u5668\u751f\u6210\u7684**\u7b26\u53f7\u8868**\u4f1a\u6807\u8bb0\u51fa\u6240\u6709\u8fd9\u6837\u7684\u51fd\u6570\u6216\u5168\u5c40\u53d8\u91cf\uff0c\u800c\u94fe\u63a5\u5668\u7684\u8d23\u4efb\u5c31\u662f\u8981\u5230\u522b\u7684\u6a21\u5757\u4e2d\u53bb\u67e5\u627e\u5b83\u4eec\u7684**\u5b9a\u4e49**\uff0c\u5982\u679c\u6ca1\u6709\u627e\u5230\u5408\u9002\u7684\u5b9a\u4e49\u6216\u8005\u627e\u5230\u7684\u5408\u9002\u7684\u5b9a\u4e49\u4e0d\u552f\u4e00\uff0c\u7b26\u53f7\u89e3\u6790\u90fd\u65e0\u6cd5\u6b63\u5e38\u5b8c\u6210\u3002 \u51fd\u6570\u7684\u58f0\u660e\uff0c\u51fd\u6570\u7684\u5b9a\u4e49\uff0c\u51fd\u6570\u7684\u8c03\u7528\uff1b\u8fd9\u51e0\u70b9\u4e4b\u95f4\u7684\u5173\u8054","title":"\u7b26\u53f7\u89e3\u6790"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#_4","text":"\u91cd\u5b9a\u4f4d\uff1a \u7f16\u8bd1\u5668**\u5728\u7f16\u8bd1\u751f\u6210\u76ee\u6807\u6587\u4ef6\u65f6\uff0c\u901a\u5e38\u90fd\u4f7f\u7528\u4ece**\u96f6**\u5f00\u59cb\u7684**\u76f8\u5bf9\u5730\u5740 \u3002\u7136\u800c\uff0c\u5728**\u94fe\u63a5**\u8fc7\u7a0b\u4e2d\uff0c**\u94fe\u63a5\u5668**\u5c06\u4ece\u4e00\u4e2a**\u6307\u5b9a\u7684\u5730\u5740**\u5f00\u59cb\uff0c\u6839\u636e\u8f93\u5165\u7684\u76ee\u6807\u6587\u4ef6\u7684\u987a\u5e8f\u4ee5\u6bb5\u4e3a\u5355\u4f4d\u5c06\u5b83\u4eec\u4e00\u4e2a\u63a5\u4e00\u4e2a\u7684\u62fc\u88c5\u8d77\u6765\u3002\u9664\u4e86\u76ee\u6807\u6587\u4ef6\u7684\u62fc\u88c5\u4e4b\u5916\uff0c\u5728\u91cd\u5b9a\u4f4d\u7684\u8fc7\u7a0b\u4e2d\u8fd8\u5b8c\u6210\u4e86\u4e24\u4e2a\u4efb\u52a1\uff1a\u4e00\u662f\u751f\u6210\u6700\u7ec8\u7684\u7b26\u53f7\u8868\uff1b\u4e8c\u662f\u5bf9\u4ee3\u7801\u6bb5\u4e2d\u7684\u67d0\u4e9b\u4f4d\u7f6e\u8fdb\u884c\u4fee\u6539\uff0c\u6240\u6709\u9700\u8981\u4fee\u6539\u7684\u4f4d\u7f6e\u90fd\u7531\u7f16\u8bd1\u5668\u751f\u6210\u7684**\u91cd\u5b9a\u4f4d\u8868**\u6307\u51fa\u3002 \u4e3e\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u4e0a\u9762\u7684\u6982\u5ff5\u5bf9\u8bfb\u8005\u6765\u8bf4\u5c31\u4e00\u76ee\u4e86\u7136\u4e86\u3002\u5047\u5982\u6211\u4eec\u6709\u4e00\u4e2a\u7a0b\u5e8f\u7531\u4e24\u90e8\u5206\u6784\u6210\uff0cm.c\u4e2d\u7684main\u51fd\u6570\u8c03\u7528f.c\u4e2d\u5b9e\u73b0\u7684\u51fd\u6570sum\uff1a /* m.c */ int i = 1 ; int j = 2 ; extern int sum (); void main () { int s ; s = sum ( i , j ); } /* f.c */ int sum ( int i , int j ) { return i + j ; } \u5728Linux\u7528gcc\u5206\u522b\u5c06\u4e24\u6bb5\u6e90\u7a0b\u5e8f\u7f16\u8bd1\u6210\u76ee\u6807\u6587\u4ef6\uff1a $ gcc -c m.c $ gcc -c f.c \u6211\u4eec\u901a\u8fc7objdump\u6765\u770b\u770b\u5728\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u751f\u6210\u7684\u7b26\u53f7\u8868\u548c\u91cd\u5b9a\u4f4d\u8868\uff1a $ objdump -x m.o \u2026\u2026 SYMBOL TABLE: \u2026\u2026 00000000 g O .data 00000004 i 00000004 g O .data 00000004 j 00000000 g F .text 00000021 main 00000000 *UND* 00000000 sum RELOCATION RECORDS FOR [ .text ] : OFFSET TYPE VALUE 00000007 R_386_32 j 0000000d R_386_32 i 00000013 R_386_PC32 sum \u9996\u5148\uff0c\u6211\u4eec\u6ce8\u610f\u5230\u7b26\u53f7\u8868\u91cc\u9762\u7684 sum \u88ab\u6807\u8bb0\u4e3a UND\uff08undefined\uff09 \uff0c\u4e5f\u5c31\u662f\u5728 m.o \u4e2d\u6ca1\u6709\u5b9a\u4e49\uff0c\u6240\u4ee5\u5c06\u6765\u8981\u901a\u8fc7 ld \uff08Linux\u4e0b\u7684\u94fe\u63a5\u5668\uff09\u7684\u7b26\u53f7\u89e3\u6790\u529f\u80fd\u5230\u522b\u7684\u6a21\u5757\u4e2d\u53bb\u67e5\u627e\u662f\u5426\u5b58\u5728\u51fd\u6570 sum \u7684\u5b9a\u4e49\u3002\u53e6\u5916\uff0c\u5728\u91cd\u5b9a\u4f4d\u8868\u4e2d\u6709\u4e09\u6761\u8bb0\u5f55\uff0c\u6307\u51fa\u4e86\u5728\u91cd\u5b9a\u4f4d\u8fc7\u7a0b\u4e2d**\u4ee3\u7801\u6bb5**\u4e2d\u4e09\u5904\u9700\u8981\u4fee\u6539\u7684\u4f4d\u7f6e\uff0c\u5206\u522b\u4f4d\u4e8e7\u3001d\u548c13\u3002\u4e0b\u9762\u4ee5\u4e00\u79cd\u66f4\u52a0\u76f4\u89c2\u7684\u65b9\u5f0f\u6765\u770b\u4e00\u4e0b\u8fd9\u4e09\u4e2a\u4f4d\u7f6e\uff1a $ objdump -dx m.o Disassembly of section .text: 00000000 <main>: 0: 55 push %ebp 1: 89 e5 mov %esp,%ebp 3: 83 ec 04 sub $0x4,%esp 6: a1 00 00 00 00 mov 0x0,%eax 7: R_386_32 j b: 50 push %eax c: a1 00 00 00 00 mov 0x0,%eax d: R_386_32 i 11: 50 push %eax 12: e8 fc ff ff ff call 13 <main+0x13> 13: R_386_PC32 sum 17: 83 c4 08 add $0x8,%esp 1a: 89 c0 mov %eax,%eax 1c: 89 45 fc mov %eax,0xfffffffc(%ebp) 1f: c9 leave 20: c3 ret \u4ee5 sum \u4e3a\u4f8b\uff0c\u5bf9\u51fd\u6570 sum \u7684\u8c03\u7528\u662f\u901a\u8fc7 call \u6307\u4ee4\u5b9e\u73b0\u7684\uff0c\u4f7f\u7528**IP\u76f8\u5bf9\u5bfb\u5740\u65b9\u5f0f**\u3002\u53ef\u4ee5\u770b\u5230\uff0c\u5728\u76ee\u6807\u6587\u4ef6 m.o \u4e2d\uff0c call \u6307\u4ee4\u4f4d\u4e8e\u4ece\u96f6\u5f00\u59cb\u7684\u76f8\u5bf9\u5730\u5740 0X12 \u7684\u4f4d\u7f6e\uff0c\u8fd9\u91cc\u5b58\u653e\u7684 e8 \u662f call \u7684**\u64cd\u4f5c\u7801**\uff0c\u800c\u4ece 0x13 \u5f00\u59cb\u76844\u4e2a\u5b57\u8282\u5b58\u653e\u7740 sum \u76f8\u5bf9 call \u7684\u4e0b\u4e00\u6761\u6307\u4ee4 add \u7684\u504f\u79fb\u3002\u663e\u7136\uff0c\u5728\u94fe\u63a5\u4e4b\u524d\u8fd9\u4e2a**\u504f\u79fb\u91cf**\u662f\u4e0d\u77e5\u9053\u7684\uff0c\u6240\u4ee5\u5c06\u6765\u8981\u6765\u4fee\u653913\u8fd9\u91cc\u7684\u4ee3\u7801\u3002\u90a3\u73b0\u5728\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u5b58\u653e\u7740 0xfffffffc \uff08\u6ce8\u610fIntel\u7684CPU\u4f7f\u7528little endian\u7684\u7f16\u5740\u65b9\u5f0f\uff09\u5462\uff1f\u8fd9\u5927\u6982\u662f\u51fa\u4e8e\u5b89\u5168\u7684\u8003\u8651\uff0c\u56e0\u4e3a 0xfffffffc \u6b63\u662f\uff0d4\u7684\u8865\u7801\u8868\u793a\uff08\u8bfb\u8005\u53ef\u4ee5\u5728gdb\u4e2d\u4f7f\u7528p /x -4\u67e5\u770b\uff09\uff0c\u800c call \u6307\u4ee4\u672c\u8eab\u5360\u7528\u4e865\u4e2a\u5b57\u8282\uff0c\u56e0\u6b64\u65e0\u8bba\u5982\u4f55 call \u6307\u4ee4\u4e2d\u7684\u504f\u79fb\u91cf\u4e0d\u53ef\u80fd\u662f\uff0d4\u3002\u6211\u4eec\u518d\u770b\u770b\u91cd\u5b9a\u4f4d\u4e4b\u540ecall\u6307\u4ee4\u4e2d\u7684\u8fd9\u4e2a\u504f\u79fb\u91cf\u88ab\u4fee\u6539\u6210\u4e86\u4ec0\u4e48\uff1a $ gcc m.o f.o $ objdump -dj .text a.out | less Disassembly of section .text: \u2026\u2026 080482c4 <main>: \u2026\u2026 80482d6: e8 0d 00 00 00 call 80482e8 <sum> 80482db: 83 c4 08 add $0x8,%esp \u2026\u2026 080482e8 <sum>: \u2026\u2026 \u53ef\u4ee5\u770b\u5230\u7ecf\u8fc7\u91cd\u5b9a\u4f4d\u4e4b\u540e\uff0ccall\u6307\u4ee4\u4e2d\u7684**\u504f\u79fb\u91cf**\u4fee\u6539\u6210 0x0000000d \u4e86\uff0c\u7b80\u5355\u7684\u8ba1\u7b97\u544a\u8bc9\u6211\u4eec\uff1a0x080482e8\uff0d0x80482db=0xd\u3002\u8fd9\u6837\uff0c\u7ecf\u8fc7\u91cd\u5b9a\u4f4d\u4e4b\u540e\u6700\u7ec8\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u5c31\u751f\u6210\u4e86\u3002 \u53ef\u6267\u884c\u7a0b\u5e8f\u751f\u6210\u540e\uff0c\u4e0b\u4e00\u6b65\u5c31\u662f\u5c06\u5176\u88c5\u5165\u5185\u5b58\u8fd0\u884c\u3002Linux\u4e0b\u7684\u7f16\u8bd1\u5668\uff08C\u8bed\u8a00\uff09\u662f cc1 \uff0c\u6c47\u7f16\u5668\u662f as \uff0c\u94fe\u63a5\u5668\u662f ld \uff0c\u4f46\u662f\u5e76\u6ca1\u6709\u4e00\u4e2a\u5b9e\u9645\u7684\u7a0b\u5e8f\u5bf9\u5e94**\u88c5\u5165\u5668**\u8fd9\u4e2a\u6982\u5ff5\u3002\u5b9e\u9645\u4e0a\uff0c\u5c06\u53ef\u6267\u884c\u7a0b\u5e8f\u88c5\u5165\u5185\u5b58\u8fd0\u884c\u7684\u529f\u80fd\u662f\u7531 execve(2) \u8fd9\u4e00**\u7cfb\u7edf\u8c03\u7528**\u5b9e\u73b0\u7684\u3002\u7b80\u5355\u6765\u8bb2\uff0c\u7a0b\u5e8f\u7684\u88c5\u5165\u4e3b\u8981\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6b65\u9aa4\uff1a \u8bfb\u5165\u53ef\u6267\u884c\u6587\u4ef6\u7684\u5934\u90e8\u4fe1\u606f\u4ee5\u786e\u5b9a\u5176\u6587\u4ef6\u683c\u5f0f\u53ca**\u5730\u5740\u7a7a\u95f4**\u7684\u5927\u5c0f\uff1b \u4ee5\u6bb5\u7684\u5f62\u5f0f\u5212\u5206**\u5730\u5740\u7a7a\u95f4**\uff1b \u5c06**\u53ef\u6267\u884c\u7a0b\u5e8f**\u8bfb\u5165\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u5404\u4e2a\u6bb5\uff0c\u5efa\u7acb\u865a\u5b9e\u5730\u5740\u95f4\u7684\u6620\u5c04\u5173\u7cfb\uff1b \u5c06bbs\u6bb5\u6e05\u96f6\uff1b \u521b\u5efa\u5806\u6808\u6bb5\uff1b \u5efa\u7acb\u7a0b\u5e8f\u53c2\u6570\u3001\u73af\u5883\u53d8\u91cf\u7b49\u7a0b\u5e8f\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6240\u9700\u7684\u4fe1\u606f\uff1b \u542f\u52a8\u8fd0\u884c\u3002 \u56de\u9875\u9996","title":"\u91cd\u5b9a\u4f4d"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#_5","text":"\u4e00\u4e2a\u7a0b\u5e8f\u8981\u60f3\u88c5\u5165\u5185\u5b58\u8fd0\u884c\u5fc5\u7136\u8981\u5148\u7ecf\u8fc7\u7f16\u8bd1\u3001\u94fe\u63a5\u548c\u88c5\u5165\u8fd9\u4e09\u4e2a\u9636\u6bb5\uff0c\u867d\u7136\u662f\u8fd9\u6837\u4e00\u4e2a\u5927\u5bb6\u542c\u8d77\u6765\u8033\u719f\u80fd\u8be6\u7684\u6982\u5ff5\uff0c\u5728\u64cd\u4f5c\u7cfb\u7edf\u53d1\u5c55\u7684\u8fc7\u7a0b\u4e2d\u5374\u5df2\u7ecf\u7ecf\u5386\u4e86\u591a\u6b21\u91cd\u5927\u53d8\u9769\u3002\u7b80\u5355\u6765\u8bb2\uff0c\u53ef\u4ee5\u5c06\u5176\u5212\u5206\u4e3a\u4ee5\u4e0b\u4e09\u4e2a\u9636\u6bb5\uff1a","title":"\u94fe\u63a5\u548c\u88c5\u5165\u6280\u672f\u7684\u53d1\u5c55\u53f2"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#1","text":"\u8fd9\u79cd\u65b9\u6cd5\u6700\u65e9\u88ab\u91c7\u7528\uff0c\u5176\u7279\u70b9\u662f\u7b80\u5355\uff0c\u4e0d\u9700\u8981\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4efb\u4f55\u989d\u5916\u7684\u652f\u6301\u3002\u50cfC\u8fd9\u6837\u7684\u7f16\u7a0b\u8bed\u8a00\u4ece\u5f88\u65e9\u5f00\u59cb\u5c31\u5df2\u7ecf\u652f\u6301\u5206\u522b\u7f16\u8bd1\u4e86\uff0c\u7a0b\u5e8f\u7684\u4e0d\u540c\u6a21\u5757\u53ef\u4ee5\u5e76\u884c\u5f00\u53d1\uff0c\u7136\u540e\u72ec\u7acb\u7f16\u8bd1\u4e3a\u76f8\u5e94\u7684\u76ee\u6807\u6587\u4ef6\u3002\u5728\u5f97\u5230\u4e86\u6240\u6709\u7684\u76ee\u6807\u6587\u4ef6\u540e\uff0c\u9759\u6001\u94fe\u63a5\u3001\u9759\u6001\u88c5\u5165\u7684\u505a\u6cd5\u662f\u5c06\u6240\u6709\u76ee\u6807\u6587\u4ef6\u94fe\u63a5\u6210\u4e00\u4e2a**\u53ef\u6267\u884c\u6620\u8c61**\uff0c\u968f\u540e\u5728\u521b\u5efa\u8fdb\u7a0b\u65f6\u5c06\u8be5**\u53ef\u6267\u884c\u6620\u8c61**\u4e00\u6b21\u5168\u90e8\u88c5\u5165\u5185\u5b58\u3002\u4e3e\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\uff0c\u5047\u8bbe\u6211\u4eec\u5f00\u53d1\u4e86\u4e24\u4e2a\u7a0b\u5e8f Prog1 \u548c Prog2 \uff0c Prog1 \u7531 main1.c \u3001 utilities.c \u4ee5\u53ca errhdl1.c \u4e09\u90e8\u5206\u7ec4\u6210\uff0c\u5206\u522b\u5bf9\u5e94\u7a0b\u5e8f\u7684\u4e3b\u6846\u67b6\u3001\u4e00\u4e9b\u516c\u7528\u7684\u8f85\u52a9\u51fd\u6570\uff08\u5176\u4f5c\u7528\u76f8\u5f53\u4e8e\u5e93\uff09\u4ee5\u53ca\u9519\u8bef\u5904\u7406\u90e8\u5206\uff0c\u8fd9\u4e09\u90e8\u5206\u4ee3\u7801\u7f16\u8bd1\u540e\u5206\u522b\u5f97\u5230\u5404\u81ea\u5bf9\u5e94\u7684\u76ee\u6807\u6587\u4ef6main1.o\u3001utilities.o\u4ee5\u53caerrhdl1.o\u3002\u540c\u6837\uff0cProg2\u7531main2.c\u3001utilities.c\u4ee5\u53caerrhdl2.c\u4e09\u90e8\u5206\u7ec4\u6210\uff0c\u4e09\u90e8\u5206\u4ee3\u7801\u7f16\u8bd1\u540e\u5206\u522b\u5f97\u5230\u5404\u81ea\u5bf9\u5e94\u7684\u76ee\u6807\u6587\u4ef6main2.o\u3001utilities.o\u4ee5\u53caerrhdl2.o\u3002\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u91ccProg1\u548cProg2\u4f7f\u7528\u4e86\u76f8\u540c\u7684\u516c\u7528\u8f85\u52a9\u51fd\u6570utilities.o\u3002\u5f53\u6211\u4eec\u91c7\u7528\u9759\u6001\u94fe\u63a5\u3001\u9759\u6001\u88c5\u5165\u7684\u65b9\u6cd5\uff0c\u540c\u65f6\u8fd0\u884c\u8fd9\u4e24\u4e2a\u7a0b\u5e8f\u65f6\u5185\u5b58\u548c\u786c\u76d8\u7684\u4f7f\u7528\u60c5\u51b5\u5982\u56fe1\u6240\u793a\uff1a \u53ef\u4ee5\u770b\u5230\uff0c\u9996\u5148\u5c31\u786c\u76d8\u7684\u4f7f\u7528\u6765\u8bb2\uff0c\u867d\u7136\u4e24\u4e2a\u7a0b\u5e8f**\u5171\u4eab**\u4f7f\u7528\u4e86utilities\uff0c\u4f46\u8fd9\u5e76\u6ca1\u6709\u5728\u786c\u76d8\u4fdd\u5b58\u7684**\u53ef\u6267\u884c\u7a0b\u5e8f\u6620\u8c61**\u4e0a\u4f53\u73b0\u51fa\u6765\u3002\u76f8\u53cd\uff0c utilities.o \u88ab\u94fe\u63a5\u8fdb\u4e86\u6bcf\u4e00\u4e2a\u7528\u5230\u5b83\u7684\u7a0b\u5e8f\u7684\u53ef\u6267\u884c\u6620\u8c61\u3002\u5185\u5b58\u7684\u4f7f\u7528\u4e5f\u662f\u5982\u6b64\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5728\u521b\u5efa\u8fdb\u7a0b\u65f6\u5c06\u7a0b\u5e8f\u7684\u53ef\u6267\u884c\u6620\u8c61**\u4e00\u6b21\u5168\u90e8**\u88c5\u5165\u5185\u5b58\uff0c\u4e4b\u540e\u8fdb\u7a0b\u624d\u80fd\u5f00\u59cb\u8fd0\u884c\u3002\u5982\u524d\u6240\u8ff0\uff0c\u91c7\u7528\u8fd9\u79cd\u65b9\u6cd5\u4f7f\u5f97\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\u53d8\u5f97\u975e\u5e38\u7b80\u5355\uff0c\u4f46\u5176\u7f3a\u70b9\u4e5f\u662f\u663e\u800c\u6613\u89c1\u7684\u3002\u9996\u5148\uff0c\u65e2\u7136\u4e24\u4e2a\u7a0b\u5e8f\u4f7f\u7528\u7684\u662f\u76f8\u540c\u7684 utilities.o \uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u8981\u5728\u786c\u76d8\u4e0a\u4fdd\u5b58 utilities.o \u7684\u4e00\u4efd\u62f7\u8d1d\u5e94\u8be5\u5c31\u8db3\u591f\u4e86\uff1b\u53e6\u5916\uff0c\u5047\u5982\u7a0b\u5e8f\u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6ca1\u6709\u51fa\u73b0\u4efb\u4f55\u9519\u8bef\uff0c\u90a3\u4e48\u9519\u8bef\u5904\u7406\u90e8\u5206\u7684\u4ee3\u7801\u5c31\u4e0d\u5e94\u8be5\u88ab\u88c5\u5165\u5185\u5b58\u3002\u56e0\u6b64\u9759\u6001\u94fe\u63a5\u3001\u9759\u6001\u88c5\u5165\u7684\u65b9\u6cd5\u4e0d\u4f46\u6d6a\u8d39\u4e86\u786c\u76d8\u7a7a\u95f4\uff0c\u540c\u65f6\u4e5f\u6d6a\u8d39\u4e86\u5185\u5b58\u7a7a\u95f4\u3002\u7531\u4e8e\u65e9\u671f\u7cfb\u7edf\u7684\u5185\u5b58\u8d44\u6e90\u5341\u5206\u5b9d\u8d35\uff0c\u6240\u4ee5\u540e\u8005\u5bf9\u65e9\u671f\u7684\u7cfb\u7edf\u6765\u8bb2\u66f4\u52a0\u81f4\u547d\u3002","title":"1\uff0e \u9759\u6001\u94fe\u63a5\u3001\u9759\u6001\u88c5\u5165"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#2","text":"\u65e2\u7136\u91c7\u7528**\u9759\u6001\u94fe\u63a5**\u3001**\u9759\u6001\u88c5\u5165**\u7684\u65b9\u6cd5\u5f0a\u5927\u4e8e\u5229\uff0c\u6211\u4eec\u6765\u770b\u770b\u4eba\u4eec\u662f\u5982\u4f55\u89e3\u51b3\u8fd9\u4e00\u95ee\u9898\u7684\u3002\u7531\u4e8e\u5185\u5b58\u7d27\u5f20\u7684\u95ee\u9898\u5728\u65e9\u671f\u7684\u7cfb\u7edf\u4e2d\u663e\u5f97\u66f4\u52a0\u7a81\u51fa\uff0c\u56e0\u6b64\u4eba\u4eec\u9996\u5148\u60f3\u5230\u7684\u662f\u8981\u89e3\u51b3\u5185\u5b58\u4f7f\u7528\u6548\u7387\u4e0d\u9ad8\u8fd9\u4e00\u95ee\u9898\uff0c\u4e8e\u662f\u4fbf\u63d0\u51fa\u4e86**\u52a8\u6001\u88c5\u5165**\u7684\u601d\u60f3\u3002\u5176\u60f3\u6cd5\u662f\u975e\u5e38\u7b80\u5355\u7684\uff0c\u5373\u4e00\u4e2a\u51fd\u6570\u53ea\u6709\u5f53\u5b83\u88ab\u8c03\u7528\u65f6\uff0c\u5176\u6240\u5728\u7684\u6a21\u5757\u624d\u4f1a\u88ab\u88c5\u5165\u5185\u5b58\u3002\u6240\u6709\u7684\u6a21\u5757\u90fd\u4ee5\u4e00\u79cd**\u53ef\u91cd\u5b9a\u4f4d\u7684\u88c5\u5165\u683c\u5f0f**\u5b58\u653e\u5728\u78c1\u76d8\u4e0a\u3002\u9996\u5148\uff0c\u4e3b\u7a0b\u5e8f\u88ab\u88c5\u5165\u5185\u5b58\u5e76\u5f00\u59cb\u8fd0\u884c\u3002\u5f53\u4e00\u4e2a\u6a21\u5757\u9700\u8981\u8c03\u7528\u53e6\u4e00\u4e2a\u6a21\u5757\u4e2d\u7684\u51fd\u6570\u65f6\uff0c\u9996\u5148\u8981\u68c0\u67e5\u542b\u6709\u88ab\u8c03\u7528\u51fd\u6570\u7684\u6a21\u5757\u662f\u5426\u5df2\u88c5\u5165\u5185\u5b58\u3002\u5982\u679c\u8be5\u6a21\u5757\u5c1a\u672a\u88ab\u88c5\u5165\u5185\u5b58\uff0c\u90a3\u4e48\u5c06\u7531\u8d1f\u8d23\u91cd\u5b9a\u4f4d\u7684\u94fe\u63a5\u88c5\u5165\u5668\u5c06\u8be5\u6a21\u5757\u88c5\u5165\u5185\u5b58\uff0c\u540c\u65f6\u66f4\u65b0\u6b64\u7a0b\u5e8f\u7684**\u5730\u5740\u8868**\u4ee5\u53cd\u5e94\u8fd9\u4e00\u53d8\u5316\u3002\u4e4b\u540e\uff0c\u63a7\u5236\u4fbf\u8f6c\u79fb\u5230\u4e86\u65b0\u88c5\u5165\u7684\u6a21\u5757\u4e2d\u88ab\u8c03\u7528\u7684\u51fd\u6570\u90a3\u91cc\u3002 \u52a8\u6001\u88c5\u5165\u7684\u4f18\u70b9\u5728\u4e8e\u6c38\u8fdc\u4e0d\u4f1a\u88c5\u5165\u4e00\u4e2a\u4f7f\u7528\u4e0d\u5230\u7684\u6a21\u5757\u3002\u5982\u679c\u7a0b\u5e8f\u4e2d\u5b58\u5728\u7740\u5927\u91cf\u50cf\u51fa\u9519\u5904\u7406\u51fd\u6570\u8fd9\u79cd\u7528\u4e8e\u5904\u7406\u5c0f\u6982\u7387\u4e8b\u4ef6\u7684\u4ee3\u7801\uff0c\u4f7f\u7528\u8fd9\u79cd\u65b9\u6cd5\u65e0\u7591\u662f\u5353\u6709\u6210\u6548\u7684\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5373\u4f7f\u6574\u4e2a\u7a0b\u5e8f\u53ef\u80fd\u5f88\u5927\uff0c\u4f46\u662f\u5b9e\u9645\u7528\u5230\uff08\u56e0\u6b64\u88ab\u88c5\u5165\u5230\u5185\u5b58\u4e2d\uff09\u7684\u90e8\u5206\u5b9e\u9645\u4e0a\u53ef\u80fd\u975e\u5e38\u5c0f\u3002 \u4ecd\u7136\u4ee5\u4e0a\u9762\u63d0\u5230\u7684\u4e24\u4e2a\u7a0b\u5e8f Prog1 \u548c Prog2 \u4e3a\u4f8b\uff0c\u5047\u5982 Prog1 \u8fd0\u884c\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u4e86\u9519\u8bef\u800c Prog2 \u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6ca1\u6709\u51fa\u73b0\u4efb\u4f55\u9519\u8bef\u3002\u5f53\u6211\u4eec\u91c7\u7528\u9759\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u7684\u65b9\u6cd5\uff0c\u540c\u65f6\u8fd0\u884c\u8fd9\u4e24\u4e2a\u7a0b\u5e8f\u65f6\u5185\u5b58\u548c\u786c\u76d8\u7684\u4f7f\u7528\u60c5\u51b5\u5982\u56fe2\u6240\u793a\uff1a \u56fe 2\u91c7\u7528\u9759\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u65b9\u6cd5\uff0c\u540c\u65f6\u8fd0\u884cProg1\u548cProg2\u65f6\u5185\u5b58\u548c\u786c\u76d8\u7684\u4f7f\u7528\u60c5\u51b5 \u53ef\u4ee5\u770b\u5230\uff0c\u5f53\u7a0b\u5e8f\u4e2d\u5b58\u5728\u7740\u5927\u91cf\u50cf\u9519\u8bef\u5904\u7406\u8fd9\u6837\u4f7f\u7528\u6982\u7387\u5f88\u5c0f\u7684\u6a21\u5757\u65f6\uff0c\u91c7\u7528\u9759\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u7684\u65b9\u6cd5\u5728\u5185\u5b58\u7684\u4f7f\u7528\u6548\u7387\u4e0a\u5c31\u4f53\u73b0\u51fa\u4e86\u76f8\u5f53\u5927\u7684\u4f18\u52bf\u3002\u5230\u6b64\u4e3a\u6b62\uff0c\u4eba\u4eec\u5df2\u7ecf\u5411\u7406\u60f3\u7684\u76ee\u6807\u8fc8\u8fdb\u4e86\u4e00\u90e8\uff0c\u4f46\u662f\u95ee\u9898\u8fd8\u6ca1\u6709\u5b8c\u5168\u89e3\u51b3\u2015\u2015\u5185\u5b58\u7684\u4f7f\u7528\u6548\u7387\u63d0\u9ad8\u4e86\uff0c\u786c\u76d8\u5462\uff1f","title":"2\uff0e \u9759\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#3","text":"\u91c7\u7528\u9759\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u7684\u65b9\u6cd5\u540e\u770b\u4f3c\u53ea\u5269\u4e0b\u786c\u76d8\u7a7a\u95f4\u4f7f\u7528\u6548\u7387\u4e0d\u9ad8\u7684\u95ee\u9898\u4e86\uff0c\u5b9e\u9645\u4e0a\u5185\u5b58\u4f7f\u7528\u6548\u7387\u4e0d\u9ad8\u7684\u95ee\u9898\u4ecd\u7136\u6ca1\u6709\u5b8c\u5168\u89e3\u51b3\u3002\u56fe2\u4e2d\uff0c\u65e2\u7136\u4e24\u4e2a\u7a0b\u5e8f\u7528\u5230\u7684\u662f\u76f8\u540c\u7684utilities.o\uff0c\u90a3\u4e48\u7406\u60f3\u7684\u60c5\u51b5\u662f\u7cfb\u7edf\u4e2d\u53ea\u4fdd\u5b58\u4e00\u4efdutilities.o\u7684\u62f7\u8d1d\uff0c\u65e0\u8bba\u662f\u5728\u5185\u5b58\u4e2d\u8fd8\u662f\u5728\u786c\u76d8\u4e0a\uff0c\u4e8e\u662f\u4eba\u4eec\u60f3\u5230\u4e86**\u52a8\u6001\u94fe\u63a5**\u3002 \u5728\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u65f6\uff0c\u9700\u8981\u5728\u7a0b\u5e8f\u6620\u8c61\u4e2d\u6bcf\u4e2a\u8c03\u7528**\u5e93\u51fd**\u6570\u7684\u5730\u65b9\u6253\u4e00\u4e2a**\u6869**\uff08stub\uff09\u3002stub\u662f\u4e00\u5c0f\u6bb5\u4ee3\u7801\uff0c\u7528\u4e8e**\u5b9a\u4f4d**\u5df2\u88c5\u5165\u5185\u5b58\u7684\u76f8\u5e94\u7684**\u5e93**\uff1b\u5982\u679c\u6240\u9700\u7684\u5e93\u8fd8\u4e0d\u5728\u5185\u5b58\u4e2d\uff0cstub\u5c06\u6307\u51fa\u5982\u4f55\u5c06\u8be5\u51fd\u6570\u6240\u5728\u7684\u5e93\u88c5\u5165\u5185\u5b58\u3002 \u5f53\u6267\u884c\u5230\u8fd9\u6837\u4e00\u4e2a**stub**\u65f6\uff0c\u9996\u5148\u68c0\u67e5\u6240\u9700\u7684\u51fd\u6570\u662f\u5426\u5df2\u4f4d\u4e8e\u5185\u5b58\u4e2d\u3002\u5982\u679c\u6240\u9700\u51fd\u6570\u5c1a\u4e0d\u5728\u5185\u5b58\u4e2d\uff0c\u5219\u9996\u5148\u9700\u8981\u5c06\u5176\u88c5\u5165\u3002\u4e0d\u8bba\u600e\u6837\uff0cstub\u6700\u7ec8\u5c06\u88ab\u8c03\u7528\u51fd\u6570\u7684\u5730\u5740\u66ff\u6362\u6389\u3002\u8fd9\u6837\uff0c\u5728\u4e0b\u6b21\u8fd0\u884c\u540c\u4e00\u4e2a\u4ee3\u7801\u6bb5\u65f6\uff0c\u540c\u6837\u7684\u5e93\u51fd\u6570\u5c31\u80fd\u76f4\u63a5\u5f97\u4ee5\u8fd0\u884c\uff0c\u4ece\u800c\u7701\u6389\u4e86\u52a8\u6001\u94fe\u63a5\u7684\u989d\u5916\u5f00\u9500\u3002\u7531\u6b64\uff0c\u7528\u5230\u540c\u4e00\u4e2a\u5e93\u7684\u6240\u6709\u8fdb\u7a0b\u5728\u8fd0\u884c\u65f6\u4f7f\u7528\u7684\u90fd\u662f\u8fd9\u4e2a\u5e93\u7684\u540c\u4e00\u4efd\u62f7\u8d1d\u3002 \u4e0b\u9762\u6211\u4eec\u5c31\u6765\u770b\u770b\u4e0a\u9762\u63d0\u5230\u7684\u4e24\u4e2a\u7a0b\u5e8fProg1\u548cProg2\u5728\u91c7\u7528\u52a8\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u7684\u65b9\u6cd5\uff0c\u540c\u65f6\u8fd0\u884c\u8fd9\u4e24\u4e2a\u7a0b\u5e8f\u65f6\u5185\u5b58\u548c\u786c\u76d8\u7684\u4f7f\u7528\u60c5\u51b5\uff08\u89c1\u56fe3\uff09\u3002\u4ecd\u7136\u5047\u8bbeProg1\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u4e86\u9519\u8bef\u800cProg2\u5728\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u6ca1\u6709\u51fa\u73b0\u4efb\u4f55\u9519\u8bef\u3002 \u56fe 3\u91c7\u7528\u52a8\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165\u65b9\u6cd5\uff0c\u540c\u65f6\u8fd0\u884cProg1\u548cProg2\u65f6\u5185\u5b58\u548c\u786c\u76d8\u7684\u4f7f\u7528\u60c5\u51b5 \u56fe\u4e2d\uff0c\u65e0\u8bba\u662f\u786c\u76d8\u8fd8\u662f\u5185\u5b58\u4e2d\u90fd\u53ea\u5b58\u5728\u4e00\u4efdutilities.o\u7684\u62f7\u8d1d\u3002\u5185\u5b58\u4e2d\uff0c\u4e24\u4e2a\u8fdb\u7a0b\u901a\u8fc7\u5c06\u5730\u5740\u6620\u5c04\u5230\u76f8\u540c\u7684utilities.o\u5b9e\u73b0\u5bf9\u5176\u7684\u5171\u4eab\u3002\u52a8\u6001\u94fe\u63a5\u7684\u8fd9\u4e00\u7279\u6027\u5bf9\u4e8e\u5e93\u7684\u5347\u7ea7\uff08\u6bd4\u5982\u9519\u8bef\u7684\u4fee\u6b63\uff09\u662f\u81f3\u5173\u91cd\u8981\u7684\u3002\u5f53\u4e00\u4e2a\u5e93\u5347\u7ea7\u5230\u4e00\u4e2a\u65b0\u7248\u672c\u65f6\uff0c\u6240\u6709\u7528\u5230\u8fd9\u4e2a\u5e93\u7684\u7a0b\u5e8f\u5c06\u81ea\u52a8\u4f7f\u7528\u65b0\u7684\u7248\u672c\u3002\u5982\u679c\u4e0d\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u6280\u672f\uff0c\u90a3\u4e48\u6240\u6709\u8fd9\u4e9b\u7a0b\u5e8f\u90fd\u9700\u8981\u88ab\u91cd\u65b0\u94fe\u63a5\u624d\u80fd\u5f97\u4ee5\u8bbf\u95ee\u65b0\u7248\u7684\u5e93\u3002\u4e3a\u4e86\u907f\u514d\u7a0b\u5e8f\u610f\u5916\u4f7f\u7528\u5230\u4e00\u4e9b\u4e0d\u517c\u5bb9\u7684\u65b0\u7248\u7684\u5e93\uff0c\u901a\u5e38\u5728\u7a0b\u5e8f\u548c\u5e93\u4e2d\u90fd\u5305\u542b\u5404\u81ea\u7684\u7248\u672c\u4fe1\u606f\u3002\u5185\u5b58\u4e2d\u53ef\u80fd\u4f1a\u540c\u65f6\u5b58\u5728\u7740\u4e00\u4e2a\u5e93\u7684\u51e0\u4e2a\u7248\u672c\uff0c\u4f46\u662f\u6bcf\u4e2a\u7a0b\u5e8f\u53ef\u4ee5\u901a\u8fc7\u7248\u672c\u4fe1\u606f\u6765\u51b3\u5b9a\u5b83\u5230\u5e95\u5e94\u8be5\u4f7f\u7528\u54ea\u4e00\u4e2a\u3002\u5982\u679c\u5bf9\u5e93\u53ea\u505a\u4e86\u5fae\u5c0f\u7684\u6539\u52a8\uff0c\u5e93\u7684\u7248\u672c\u53f7\u5c06\u4fdd\u6301\u4e0d\u53d8\uff1b\u5982\u679c\u6539\u52a8\u8f83\u5927\uff0c\u5219\u76f8\u5e94\u9012\u589e\u7248\u672c\u53f7\u3002\u56e0\u6b64\uff0c\u5982\u679c\u65b0\u7248\u5e93\u4e2d\u542b\u6709\u4e0e\u65e9\u671f\u4e0d\u517c\u5bb9\u7684\u6539\u52a8\uff0c\u53ea\u6709\u90a3\u4e9b\u4f7f\u7528\u65b0\u7248\u5e93\u8fdb\u884c\u7f16\u8bd1\u7684\u7a0b\u5e8f\u624d\u4f1a\u53d7\u5230\u5f71\u54cd\uff0c\u800c\u5728\u65b0\u7248\u5e93\u5b89\u88c5\u4e4b\u524d\u8fdb\u884c\u8fc7\u94fe\u63a5\u7684\u7a0b\u5e8f\u5c06\u7ee7\u7eed\u4f7f\u7528\u4ee5\u524d\u7684\u5e93\u3002\u8fd9\u6837\u7684\u7cfb\u7edf\u88ab\u79f0\u4f5c\u5171\u4eab\u5e93\u7cfb\u7edf\u3002 \u56de\u9875\u9996","title":"3\uff0e \u52a8\u6001\u94fe\u63a5\u3001\u52a8\u6001\u88c5\u5165"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#linux_1","text":"\u5982\u4eca\u6211\u4eec\u5728Linux\u4e0b\u7f16\u7a0b\u7528\u5230\u7684\u5e93\uff08\u50cflibc\u3001QT\u7b49\u7b49\uff09\u5927\u591a\u90fd\u540c\u65f6\u63d0\u4f9b\u4e86**\u52a8\u6001\u94fe\u63a5\u5e93**\u548c**\u9759\u6001\u94fe\u63a5\u5e93**\u4e24\u4e2a\u7248\u672c\u7684\u5e93\uff0c\u800c gcc \u5728\u7f16\u8bd1\u94fe\u63a5\u65f6\u5982\u679c\u4e0d\u52a0 -static \u9009\u9879\u5219\u9ed8\u8ba4\u4f7f\u7528\u7cfb\u7edf\u4e2d\u7684**\u52a8\u6001\u94fe\u63a5\u5e93**\u3002\u5bf9\u4e8e\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u539f\u7406\u5927\u591a\u6570\u7684\u4e66\u672c\u4e0a\u53ea\u662f\u8fdb\u884c\u4e86\u6cdb\u6cdb\u7684\u4ecb\u7ecd\uff0c\u5728\u6b64\u7b14\u8005\u5c06\u901a\u8fc7\u5728\u5b9e\u9645\u7cfb\u7edf\u4e2d\u53cd\u6c47\u7f16\u51fa\u7684\u4ee3\u7801\u5411\u8bfb\u8005\u5c55\u793a\u8fd9\u4e00\u6280\u672f\u5728Linux\u4e0b\u7684\u5b9e\u73b0\u3002 \u4e0b\u9762\u662f\u4e2a\u6700\u7b80\u5355\u7684C\u7a0b\u5e8fhello.c\uff1a #include <stdio.h> int main () { printf ( \"Hello, world \\n \" ); return 0 ; } \u5728Linux\u4e0b\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528gcc\u5c06\u5176\u7f16\u8bd1\u6210\u53ef\u6267\u884c\u6587\u4ef6a.out\uff1a $ gcc hello.c \u7a0b\u5e8f\u91cc\u7528\u5230\u4e86 printf \uff0c\u5b83\u4f4d\u4e8e\u6807\u51c6C\u5e93\u4e2d\uff0c\u5982\u679c\u5728\u7528 gcc \u7f16\u8bd1\u65f6\u4e0d\u52a0 -static \u7684\u8bdd\uff0c\u9ed8\u8ba4\u662f\u4f7f\u7528 libc.so \uff0c\u4e5f\u5c31\u662f\u52a8\u6001\u94fe\u63a5\u7684\u6807\u51c6C\u5e93\u3002\u5728 gdb \u4e2d\u53ef\u4ee5\u770b\u5230\u7f16\u8bd1\u540e printf \u5bf9\u5e94\u5982\u4e0b\u4ee3\u7801 \uff1a $ gdb -q a.out (gdb) disassemble printf Dump of assembler code for function printf: 0x8048310 <printf>: jmp *0x80495a4 0x8048316 <printf+6>: push $0x18 0x804831b <printf+11>: jmp 0x80482d0 <_init+48> \u8fd9\u4e5f\u5c31\u662f\u901a\u5e38\u5728\u4e66\u672c\u4e0a\u4ee5\u53ca\u524d\u9762\u63d0\u5230\u7684**\u6253\u6869\uff08stub\uff09**\u8fc7\u7a0b\uff0c\u663e\u7136\u8fd9\u5e76\u4e0d\u662f\u771f\u6b63\u7684 printf \u51fd\u6570\u3002\u8fd9\u6bb5stub\u4ee3\u7801\u7684\u4f5c\u7528\u5728\u4e8e\u5230 libc.so \u4e2d\u53bb\u67e5\u627e\u771f\u6b63\u7684 printf \u3002 (gdb) x /w 0x80495a4 0x80495a4 <_GLOBAL_OFFSET_TABLE_+24>: 0x08048316 \u53ef\u4ee5\u770b\u5230 0x80495a4 \u5904\u5b58\u653e\u7684 0x08048316 \u6b63\u662f pushl $0x18 \u8fd9\u6761\u6307\u4ee4\u7684\u5730\u5740\uff0c\u6240\u4ee5\u7b2c\u4e00\u6761 jmp \u6307\u4ee4\u6ca1\u6709\u8d77\u5230\u4efb\u4f55\u4f5c\u7528\uff0c\u5176\u4f5c\u7528\u5c31\u50cf\u7a7a\u64cd\u4f5c\u6307\u4ee4 nop \u4e00\u6837\u3002\u5f53\u7136\u8fd9\u662f\u5728\u6211\u4eec\u7b2c\u4e00\u6b21\u8c03\u7528printf\u65f6\uff0c\u5176\u771f\u6b63\u7684\u4f5c\u7528\u662f\u5728\u4eca\u540e\u518d\u6b21\u8c03\u7528 printf \u65f6\u4f53\u73b0\u51fa\u6765\u7684\u3002\u7b2c\u4e8c\u6761 jmp \u6307\u4ee4\u7684\u76ee\u7684\u5730\u5740\u662f plt \uff0c\u4e5f\u5c31\u662fprocedure linkage table\uff0c\u5176\u5185\u5bb9\u53ef\u4ee5\u901a\u8fc7 objdump \u547d\u4ee4\u67e5\u770b\uff0c\u6211\u4eec\u611f\u5174\u8da3\u7684\u5c31\u662f\u4e0b\u9762\u8fd9\u4e24\u6761\u5bf9\u7a0b\u5e8f\u7684\u63a7\u5236\u6d41\u6709\u5f71\u54cd\u7684\u6307\u4ee4\uff1a $ objdump -dx a.out \u2026\u2026 080482d0 >.plt>: 80482d0: ff 35 90 95 04 08 pushl 0x8049590 80482d6: ff 25 94 95 04 08 jmp *0x8049594 \u2026\u2026 \u7b2c\u4e00\u6761push\u6307\u4ee4\u5c06got\uff08global offset table\uff09\u4e2d\u4e0eprintf\u76f8\u5173\u7684\u8868\u9879\u5730\u5740\u538b\u5165\u5806\u6808\uff0c\u4e4b\u540ejmp\u5230\u5185\u5b58\u5355\u51430x8049594\u4e2d\u6240\u5b58\u653e\u7684\u5730\u57400x4000a960\u5904\u3002\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u4e00\u70b9\u662f\uff0c\u5728\u67e5\u770bgot\u4e4b\u524d\u5fc5\u987b\u5148\u5c06\u7a0b\u5e8fa.out\u542f\u52a8\u8fd0\u884c\uff0c\u5426\u5219\u901a\u8fc7gdb\u4e2d\u7684x\u547d\u4ee4\u57280x8049594\u5904\u770b\u5230\u7684\u7ed3\u679c\u662f\u4e0d\u6b63\u786e\u7684\u3002 (gdb) b main Breakpoint 1 at 0x8048406 (gdb) r Starting program: a.out Breakpoint 1, 0x08048406 in main () (gdb) x /w 0x8049594 0x8049594 <_GLOBAL_OFFSET_TABLE_+8>: 0x4000a960 (gdb) disassemble 0x4000a960 Dump of assembler code for function _dl_runtime_resolve: 0x4000a960 <_dl_runtime_resolve>: pushl %eax 0x4000a961 <_dl_runtime_resolve+1>: pushl %ecx 0x4000a962 <_dl_runtime_resolve+2>: pushl %edx 0x4000a963 <_dl_runtime_resolve+3>: movl 0x10(%esp,1),%edx 0x4000a967 <_dl_runtime_resolve+7>: movl 0xc(%esp,1),%eax 0x4000a96b <_dl_runtime_resolve+11>: call 0x4000a740 <fixup> 0x4000a970 <_dl_runtime_resolve+16>: popl %edx 0x4000a971 <_dl_runtime_resolve+17>: popl %ecx 0x4000a972 <_dl_runtime_resolve+18>: xchgl %eax,(%esp,1) 0x4000a975 <_dl_runtime_resolve+21>: ret $0x8 0x4000a978 <_dl_runtime_resolve+24>: nop 0x4000a979 <_dl_runtime_resolve+25>: leal 0x0(%esi,1),%esi End of assembler dump. \u524d\u9762\u4e09\u6761push\u6307\u4ee4\u6267\u884c\u4e4b\u540e\u5806\u6808\u91cc\u9762\u7684\u5185\u5bb9\u5982\u4e0b\uff1a \u4e0b\u9762\u5c060x18\u5b58\u5165edx\uff0c0x8049590\u5b58\u5165eax\uff0c\u6709\u4e86\u8fd9\u4e24\u4e2a\u53c2\u6570\uff0cfixup\u5c31\u53ef\u4ee5\u627e\u5230printf\u5728libc.so\u4e2d\u7684\u5730\u5740\u3002\u5f53fixup\u8fd4\u56de\u65f6\uff0c\u8be5\u5730\u5740\u5df2\u7ecf\u4fdd\u5b58\u5728\u4e86eax\u4e2d\u3002xchg\u6307\u4ee4\u6267\u884c\u5b8c\u4e4b\u540e\u5806\u6808\u4e2d\u7684\u5185\u5bb9\u5982\u4e0b\uff1a \u6700\u5999\u7684\u8981\u6570\u63a5\u4e0b\u6765\u7684ret\u6307\u4ee4\u7684\u7528\u6cd5\uff0c\u8fd9\u91ccret\u5b9e\u9645\u4e0a\u88ab\u5f53\u6210\u4e86call\u6765\u4f7f\u7528\u3002ret $0x8\u4e4b\u540e\u63a7\u5236\u4fbf\u8f6c\u79fb\u5230\u4e86\u771f\u6b63\u7684printf\u51fd\u6570\u90a3\u91cc\uff0c\u5e76\u4e14\u6e05\u6389\u4e86\u5806\u6808\u4e0a\u76840x18\u548c0x8049584\u8fd9\u4e24\u4e2a\u5df2\u7ecf\u6ca1\u7528\u7684\u53c2\u6570\uff0c\u8fd9\u65f6\u5806\u6808\u4fbf\u6210\u4e86\u4e0b\u9762\u7684\u6837\u5b50\uff1a \u800c\u8fd9\u6b63\u662f\u6211\u4eec\u6240\u671f\u671b\u7684\u7ed3\u679c\u3002\u5e94\u8be5\u8bf4\u8fd9\u91ccret\u7684\u7528\u6cd5\u4e0eLinux\u5185\u6838\u542f\u52a8\u540e\u901a\u8fc7iret\u6307\u4ee4\u5b9e\u73b0\u7531\u5185\u6838\u6001\u5207\u6362\u5230\u7528\u6237\u6001\u7684\u505a\u6cd5\u6709\u7740\u5f02\u66f2\u540c\u5de5\u4e4b\u5999\u3002\u5f88\u591a\u4eba\u90fd\u542c\u8bf4\u8fc7\u4e2d\u65ad\u6307\u4ee4int\u53ef\u4ee5\u5b9e\u73b0\u7528\u6237\u6001\u5230\u5185\u6838\u6001\u8fd9\u79cd\u4f18\u5148\u7ea7\u7531\u4f4e\u5230\u9ad8\u7684\u5207\u6362\uff0c\u5728\u63a5\u53d7\u5b8c\u7cfb\u7edf\u670d\u52a1\u540eiret\u6307\u4ee4\u8d1f\u8d23\u5c06\u4f18\u5148\u7ea7\u91cd\u65b0\u964d\u81f3\u7528\u6237\u6001\u7684\u4f18\u5148\u7ea7\u3002\u7136\u800c\u7cfb\u7edf\u542f\u52a8\u65f6\u9996\u5148\u662f\u5904\u4e8e\u5185\u6838\u6001\u9ad8\u4f18\u5148\u7ea7\u7684\uff0cIntel i386\u5e76\u6ca1\u6709\u5355\u72ec\u63d0\u4f9b\u4e00\u6761\u7279\u6b8a\u7684\u6307\u4ee4\u7528\u4e8e\u5728\u7cfb\u7edf\u542f\u52a8\u5b8c\u6210\u540e\u964d\u4f4e\u4f18\u5148\u7ea7\u4ee5\u8fd0\u884c\u7528\u6237\u7a0b\u5e8f\u3002\u5176\u5b9e\u8fd9\u4e2a\u95ee\u9898\u5f88\u7b80\u5355\uff0c\u53ea\u8981\u53cd\u7528iret\u5c31\u53ef\u4ee5\u4e86\uff0c\u5c31\u50cf\u8fd9\u91cc\u5c06ret\u5f53\u4f5ccall\u4f7f\u7528\u4e00\u6837\u3002\u53e6\u5916\uff0cfixup\u51fd\u6570\u6267\u884c\u5b8c\u8fd8\u6709\u4e00\u4e2a\u526f\u4f5c\u7528\uff0c\u5c31\u662f\u5728got\u4e2d\u4e0eprintf\u76f8\u5173\u7684\u8868\u9879\uff08\u4e5f\u5c31\u662f\u5730\u5740\u4e3a0x80495a4\u7684\u5185\u5b58\u5355\u5143\uff09\u4e2d\u586b\u4e0a\u67e5\u627e\u5230\u7684printf\u51fd\u6570\u5728\u52a8\u6001\u94fe\u63a5\u5e93\u4e2d\u7684\u5730\u5740\u3002\u8fd9\u6837\u5f53\u6211\u4eec\u518d\u6b21\u8c03\u7528printf\u51fd\u6570\u65f6\uff0c\u5176\u5730\u5740\u5c31\u53ef\u4ee5\u76f4\u63a5\u4ecegot\u4e2d\u5f97\u5230\uff0c\u4ece\u800c\u7701\u53bb\u4e86\u901a\u8fc7fixup\u67e5\u627e\u7684\u8fc7\u7a0b\u3002\u4e5f\u5c31\u662f\u8bf4got\u5728\u8fd9\u91cc\u8d77\u5230\u4e86cache\u7684\u4f5c\u7528\u3002 \u56de\u9875\u9996","title":"Linux\u4e0b\u52a8\u6001\u94fe\u63a5\u7684\u5b9e\u73b0"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#_6","text":"\u5176\u5b9e\u6709\u5f88\u591a\u4e1c\u897f\u53ea\u8981\u52e4\u4e8e\u601d\u8003\uff0c\u8fd8\u662f\u80fd\u591f\u81ea\u5df1\u609f\u51fa\u4e00\u4e9b\u9053\u7406\u7684\u3002\u56fd\u5916\u6709\u4e00\u4e9b\u9ad8\u624b\u5c31\u662f\u901a\u8fc7\u80fd\u591f\u5927\u5bb6\u90fd\u80fd\u89c1\u5230\u7684\u7684\u4e00\u70b9\u70b9\u8d44\u6599\uff0c\u81ea\u5df1\u6478\u7d22\u51fa\u6765\u5f88\u591a\u4e0d\u4e3a\u4eba\u77e5\u7684\u79d8\u5bc6\u3002\u50cf\u5199\u300aUndocument Dos\u300b\u548c\u300aUndocment Windows\u300b\u7684\u4f5c\u8005\uff0c\u4ed6\u5c31\u4e3a\u6211\u4eec\u6811\u7acb\u4e86\u8fd9\u6837\u7684\u699c\u6837\uff01 \u5b66\u4e60\u8ba1\u7b97\u673a\u5f88\u5173\u952e\u7684\u4e00\u70b9\u5728\u4e8e\u4e00\u5b9a\u8981\u5bcc\u4e8e\u63a2\u7d22\u7cbe\u795e\uff0c\u8981\u8ba9\u81ea\u5df1\u505a\u5230\u77e5\u5176\u7136\u5e76\u77e5\u5176\u6240\u4ee5\u7136\u3002\u4faf\u5148\u751f\u5728\u300aSTL\u6e90\u7801\u5256\u6790\u300b\u4e00\u4e66\u5f00\u7bc7\u9898\u8bb0\u4e2d\u5199\u5230\"\u6e90\u7801\u4e4b\u524d\uff0c\u4e86\u65e0\u79d8\u5bc6\"\uff0c\u5f53\u7136\u8fd9\u662f\u5728\u6211\u4eec\u624b\u4e2d\u638c\u63e1\u7740\u6e90\u7801\u7684\u60c5\u51b5\u4e0b\uff0c\u5982\u82e5\u4e0d\u7136\uff0c\u4e0d\u8981\u5fd8\u8bb0Linux\u8fd8\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u5927\u91cf\u7684\u50cfgdb\u3001objdump\u8fd9\u6837\u7684\u5b9e\u7528\u5de5\u5177\u3002\u6709\u4e86\u8fd9\u4e9b\u5f97\u529b\u7684\u52a9\u624b\uff0c\u5373\u4f7f\u6ca1\u6709\u6e90\u7801\uff0c\u6211\u4eec\u4e00\u6837\u53ef\u4ee5\u505a\u5230\"\u4e86\u65e0\u79d8\u5bc6\"\u3002","title":"\u4e00\u70b9\u611f\u60f3"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#_7","text":"John R. Levine.\u300aLinkers & Loaders\u300b. \u300aExecutable and Linkable Format\u300b. Intel. \u300aIntel Architecture Software Developer's Manual\u300b. Intel Corporation, 1997. http://www.cnblogs.com/Anker/p/3527677.html","title":"\u53c2\u8003\u8d44\u6599"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/program-link-and-load/#linux_2","text":"1\u3001\u524d\u8a00 \u5728\u5b9e\u9645\u5f00\u53d1\u8fc7\u7a0b\u4e2d\uff0c\u5404\u4e2a\u6a21\u5757\u4e4b\u95f4\u4f1a\u6d89\u53ca\u5230\u4e00\u4e9b\u901a\u7528\u7684\u529f\u80fd\uff0c\u6bd4\u5982\u8bfb\u5199\u6587\u4ef6\uff0c\u67e5\u627e\u3001\u6392\u5e8f\u3002\u4e3a\u4e86\u51cf\u5c11\u4ee3\u7801\u7684\u5197\u4f59\uff0c\u63d0\u9ad8\u4ee3\u7801\u7684\u8d28\u91cf\uff0c\u53ef\u4ee5\u5c06\u8fd9\u4e9b\u901a\u7528\u7684\u90e8\u5206\u63d0\u53d6\u51fa\u6765\uff0c\u505a\u51fa\u516c\u5171\u7684\u6a21\u5757\u5e93\u3002\u901a\u8fc7\u52a8\u6001\u94fe\u63a5\u5e93\u53ef\u4ee5\u5b9e\u73b0\u591a\u4e2a\u6a21\u5757\u4e4b\u95f4\u5171\u4eab\u516c\u5171\u7684\u51fd\u6570\u3002\u4e4b\u524d\u770b\u300a\u7a0b\u5e8f\u5458\u7684\u81ea\u6211\u4fee\u517b\u300b\u4e2d\u8bb2\u5230\u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u8fc7\u7a0b\uff0c\u8fd9\u4e9b\u73a9\u610f\u90fd\u662f\u5e95\u5c42\u7684\uff0c\u5bf9\u4e8e\u7406\u89e3\u7a0b\u5e8f\u7684\u7f16\u8bd1\u8fc7\u7a0b\u6709\u597d\u5904\u3002 http://www.ibm.com/developerworks/cn/linux/l-dynlink/ \u535a\u6587\u4ecb\u7ecd\u4e86\u7a0b\u5e8f\u7684\u94fe\u63a5\u548c\u88c5\u5165\u8fc7\u7a0b\u3002\u672c\u6587\u91cd\u70b9\u5728\u4e8e\u5e94\u7528\uff0c\u5982\u4f55\u7f16\u5199\u548c\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u540e\u7eed\u4f7f\u7528\u52a8\u6001\u94fe\u63a5\u5e93\u5b9e\u73b0\u4e00\u4e2a\u63d2\u4ef6\u7a0b\u5e8f\u3002 2\u3001\u52a8\u6001\u94fe\u63a5\u5e93\u751f\u4ea7 \u52a8\u6001\u94fe\u63a5\u5e93\u4e0e\u666e\u901a\u7684\u7a0b\u5e8f\u76f8\u6bd4\u800c\u8a00\uff0c\u6ca1\u6709main\u51fd\u6570\uff0c\u662f\u4e00\u7cfb\u5217\u51fd\u6570\u7684\u5b9e\u73b0\u3002\u901a\u8fc7shared\u548cfPIC\u7f16\u8bd1\u53c2\u6570\u751f\u4ea7so\u52a8\u6001\u94fe\u63a5\u5e93\u6587\u4ef6\u3002\u7a0b\u5e8f\u5728\u8c03\u7528\u5e93\u51fd\u6570\u65f6\uff0c\u53ea\u9700\u8981\u8fde\u63a5\u4e0a\u8fd9\u4e2a\u5e93\u5373\u53ef\u3002\u4f8b\u5982\u4e0b\u9762\u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684\u6574\u6570\u56db\u5219\u8fd0\u8f93\u7684\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5b9a\u4e49\u7684caculate.h\u548ccaculate.c\u4e24\u4e2a\u6587\u4ef6\uff0c\u751f\u4ea7libcac.so\u52a8\u6001\u94fe\u63a5\u5e93\u3002 \u7a0b\u5e8f\u4ee3\u7801\u5982\u4e0b\uff1a /*caculate.h*/ #ifndef CACULATE_HEAD_ #define CACULATE_HEAD_ //\u52a0\u6cd5 int add(int a, int b); //\u51cf\u6cd5 int sub(int a, int b); //\u9664\u6cd5 int div(int a, int b); //\u4e58\u6cd5 int mul(int a, int b); #endif /*caculate.c\u6587\u4ef6*/ #include \"caculate.h\" //\u6c42\u4e24\u4e2a\u6570\u7684\u548c int add(int a, int b) { return (a + b); } //\u51cf\u6cd5 int sub(int a, int b) { return (a - b); } //\u9664\u6cd5 int div(int a, int b) { return (int)(a / b); } //\u4e58\u6cd5 int mul(int a, int b) { return (a * b); } \u7f16\u8bd1\u751f\u4ea7libcac.so\u6587\u4ef6\u5982\u4e0b\uff1a gcc -shared -fPIC caculate.c -o libcac.so \u7f16\u5199\u4e00\u4e2a\u6d4b\u8bd5\u7a0b\u5e8f\u8c03\u7528\u6b64\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u51fd\u6570\uff0c\u7a0b\u5e8f\u5982\u4e0b\u6240\u793a\uff1a #include <stdio.h> #include \"caculate.h\" int main() { int a = 20; int b = 10; printf(\"%d + %d = %d\\n\", a, b, add(a, b)); printf(\"%d - %d = %d\\n\", a, b, sub(a, b)); printf(\"%d / %d = %d\\n\", a, b, div(a, b)); printf(\"%d * %d = %d\\n\", a, b, mul(a, b)); return 0; } \u7f16\u8bd1\u751f\u4ea7\u53ef\u6267\u884c\u6587\u4ef6main\u5982\u4e0b\uff1a gcc main.c -o main -L ./ -lcac \uff08\u5176\u4e2d-L\u6307\u660e\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u8def\u5f84\uff0c-l\u540e\u662f\u94fe\u63a5\u5e93\u7684\u540d\u79f0\uff0c\u7701\u7565lib\uff09 \u7a0b\u5e8f\u6267\u884c\u7ed3\u679c\u5982\u4e0b\u6240\u793a\uff1a 3\u3001\u83b7\u53d6\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u51fd\u6570 \u3000\u3000linux\u63d0\u4f9bdlopen\u3001dlsym\u3001dlerror\u548cdlcolose\u51fd\u6570\u83b7\u53d6\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u51fd\u6570\u3002\u901a\u8fc7\u8fd9\u4e2a\u56db\u4e2a\u51fd\u6570\u53ef\u4ee5\u5b9e\u73b0\u4e00\u4e2a\u63d2\u4ef6\u7a0b\u5e8f\uff0c\u65b9\u4fbf\u7a0b\u5e8f\u7684\u6269\u5c55\u548c\u7ef4\u62a4\u3002\u51fd\u6570\u683c\u5f0f\u5982\u4e0b\u6240\u793a\uff1a #include <dlfcn.h> void *dlopen(const char *filename, int flag); char *dlerror(void); void *dlsym(void *handle, const char *symbol); int dlclose(void *handle); Link with -ldl. dlopen()\u662f\u4e00\u4e2a\u5f3a\u5927\u7684\u5e93\u51fd\u6570\u3002\u8be5\u51fd\u6570\u5c06\u6253\u5f00\u4e00\u4e2a\u65b0\u5e93\uff0c\u5e76\u628a\u5b83\u88c5\u5165\u5185\u5b58\u3002\u8be5\u51fd\u6570\u4e3b\u8981\u7528\u6765\u52a0\u8f7d\u5e93\u4e2d\u7684\u7b26\u53f7\uff0c\u8fd9\u4e9b\u7b26\u53f7\u5728\u7f16\u8bd1\u7684\u65f6\u5019\u662f\u4e0d\u77e5\u9053\u7684\u3002\u5199\u4e2a\u6d4b\u8bd5\u7a0b\u5e8f\u8c03\u7528\u4e0a\u9762\u751f\u4ea7libcac.so\u5e93\u5982\u4e0b\u6240\u793a\uff1a #include <stdio.h> #include <dlfcn.h> #define DLL_FILE_NAME \"libcac.so\" int main() { void *handle; int (*func)(int, int); char *error; int a = 30; int b = 5; handle = dlopen(DLL_FILE_NAME, RTLD_NOW); if (handle == NULL) { fprintf(stderr, \"Failed to open libaray %s error:%s\\n\", DLL_FILE_NAME, dlerror()); return -1; } func = dlsym(handle, \"add\"); printf(\"%d + %d = %d\\n\", a, b, func(a, b)); func = dlsym(handle, \"sub\"); printf(\"%d + %d = %d\\n\", a, b, func(a, b)); func = dlsym(handle, \"div\"); printf(\"%d + %d = %d\\n\", a, b, func(a, b)); func = dlsym(handle, \"mul\"); printf(\"%d + %d = %d\\n\", a, b, func(a, b)); dlclose(handle); return 0; } \u7a0b\u5e8f\u6267\u884c\u7ed3\u679c\u5982\u4e0b\u6240\u793a\uff1a gcc call_main.c -o call_main -ldl 4\u3001\u53c2\u8003\u7f51\u5740 http://www.cnblogs.com/xuxm2007/archive/2010/12/08/1900608.html http://blog.csdn.net/leichelle/article/details/7465763","title":"Linux\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4f7f\u7528"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-loading/","text":"Dynamic loading \u7ef4\u57fa\u767e\u79d1 Dynamic loading","title":"Dynamic loading"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-loading/#dynamic#loading","text":"","title":"Dynamic loading"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-loading/#dynamic#loading_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Dynamic loading"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-loading/Linker-and-loader/Loader/","text":"Loader \u7ef4\u57fa\u767e\u79d1 Loader","title":"Loader"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-loading/Linker-and-loader/Loader/#loader","text":"","title":"Loader"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-loading/Linker-and-loader/Loader/#loader_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Loader"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-loading/Linker-and-loader/ld-linux/","text":"ld-linux ld-linux.so(8) \u2014 Linux manual page ld-linux(8) \u2014 Linux manual page","title":"ld-linux"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-loading/Linker-and-loader/ld-linux/#ld-linux","text":"","title":"ld-linux"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-loading/Linker-and-loader/ld-linux/#ld-linuxso8#linux#manual#page","text":"","title":"ld-linux.so(8) \u2014 Linux manual page"},{"location":"Programming/Object-file/Program-load-and-dynamic-linking/Dynamic-loading/Linker-and-loader/ld-linux/#ld-linux8#linux#manual#page","text":"","title":"ld-linux(8) \u2014 Linux manual page"},{"location":"Programming/Object-file/Shared-library/","text":"\u5173\u4e8e\u672c\u7ae0 \u5bf9\u4e8eshared library\uff0c\u4e3b\u8981\u6d89\u53ca\u5982\u4e0b\u95ee\u9898: 1) link 2) load Linux\u5728\u591a\u4e2a\u5c42\u6b21\u5bf9\u5b83\u4eec\u8fdb\u884c\u4e86\u652f\u6301\u3002 Library interface dlopen http://man7.org/linux/man-pages/man3/dlopen.3.html http://tldp.org/HOWTO/Program-Library-HOWTO/dl-libraries.html https://linux.die.net/man/3/dlopen dlsym https://linux.die.net/man/3/dlsym Application SQLite Run-Time Loadable Extensions Plugin architecture \u5de5\u7a0bsoftware-engineering Software-design\\Architecture\\Plugin-architecture \u7ae0\u8282\u3002","title":"Introduction"},{"location":"Programming/Object-file/Shared-library/#_1","text":"\u5bf9\u4e8eshared library\uff0c\u4e3b\u8981\u6d89\u53ca\u5982\u4e0b\u95ee\u9898: 1) link 2) load Linux\u5728\u591a\u4e2a\u5c42\u6b21\u5bf9\u5b83\u4eec\u8fdb\u884c\u4e86\u652f\u6301\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Object-file/Shared-library/#library#interface","text":"","title":"Library interface"},{"location":"Programming/Object-file/Shared-library/#dlopen","text":"http://man7.org/linux/man-pages/man3/dlopen.3.html http://tldp.org/HOWTO/Program-Library-HOWTO/dl-libraries.html https://linux.die.net/man/3/dlopen","title":"dlopen"},{"location":"Programming/Object-file/Shared-library/#dlsym","text":"https://linux.die.net/man/3/dlsym","title":"dlsym"},{"location":"Programming/Object-file/Shared-library/#application","text":"SQLite Run-Time Loadable Extensions Plugin architecture \u5de5\u7a0bsoftware-engineering Software-design\\Architecture\\Plugin-architecture \u7ae0\u8282\u3002","title":"Application"},{"location":"Programming/Object-file/Shared-library/Symbol-of-shared-library/","text":"Symbol of shared library Symbol exported by a shared library 1) stackoverflow How do I view the list of functions a Linux shared library is exporting? A What you need is nm and its -D option: $ nm -D /usr/lib/libopenal.so.1 . . . 00012ea0 T alcSetThreadContext 000140f0 T alcSuspendContext U atanf U calloc . . . Exported sumbols are indicated by a T . Required symbols that must be loaded from other shared objects have a U . Note that the symbol table does not include just functions, but exported variables as well. See the nm manual page for more information. A On a MAC, you need to use nm *.o | c++filt , as there is no -C option in nm . 2) stackoverflow How do i find out what all symbols are exported from a shared object? A Do you have a \"shared object\" (usually a shared library on AIX), a UNIX shared library, or a Windows DLL? These are all different things, and your question conflates them all :-( For an AIX shared object, use dump -Tv /path/to/foo.o . For an ELF shared library, use readelf -Ws /path/to/libfoo.so , or (if you have GNU nm) nm -D /path/to/libfoo.so . For a non-ELF UNIX shared library, please state which UNIX you are interested in. For a Windows DLL, use dumpbin /EXPORTS foo.dll . TODO: Find where a shared library symbol defined on a live system stackexchange Find where is a shared library symbol defined on a live system / list all symbols exported on a system","title":"Introduction"},{"location":"Programming/Object-file/Shared-library/Symbol-of-shared-library/#symbol#of#shared#library","text":"","title":"Symbol of shared library"},{"location":"Programming/Object-file/Shared-library/Symbol-of-shared-library/#symbol#exported#by#a#shared#library","text":"1) stackoverflow How do I view the list of functions a Linux shared library is exporting? A What you need is nm and its -D option: $ nm -D /usr/lib/libopenal.so.1 . . . 00012ea0 T alcSetThreadContext 000140f0 T alcSuspendContext U atanf U calloc . . . Exported sumbols are indicated by a T . Required symbols that must be loaded from other shared objects have a U . Note that the symbol table does not include just functions, but exported variables as well. See the nm manual page for more information. A On a MAC, you need to use nm *.o | c++filt , as there is no -C option in nm . 2) stackoverflow How do i find out what all symbols are exported from a shared object? A Do you have a \"shared object\" (usually a shared library on AIX), a UNIX shared library, or a Windows DLL? These are all different things, and your question conflates them all :-( For an AIX shared object, use dump -Tv /path/to/foo.o . For an ELF shared library, use readelf -Ws /path/to/libfoo.so , or (if you have GNU nm) nm -D /path/to/libfoo.so . For a non-ELF UNIX shared library, please state which UNIX you are interested in. For a Windows DLL, use dumpbin /EXPORTS foo.dll .","title":"Symbol exported by a shared library"},{"location":"Programming/Object-file/Shared-library/Symbol-of-shared-library/#todo#find#where#a#shared#library#symbol#defined#on#a#live#system","text":"","title":"TODO: Find where a shared library symbol defined on a live system"},{"location":"Programming/Object-file/Shared-library/Symbol-of-shared-library/#stackexchange#find#where#is#a#shared#library#symbol#defined#on#a#live#system#list#all#symbols#exported#on#a#system","text":"","title":"stackexchange Find where is a shared library symbol defined on a live system / list all symbols exported on a system"},{"location":"Programming/Object-file/Shared-library/Tools/ldd/","text":"ldd ldd https://en.wikipedia.org/wiki/Ldd_(Unix ) https://linux.die.net/man/1/ldd stackexchange How to find out the dynamic libraries executables loads when run? A1 ldd A2 readelf -d $executable | grep 'NEEDED' Can be used if you can't run the executable, e.g. if it was cross compiled, or if you don't trust it: In the usual case, ldd invokes the standard dynamic linker (see ld.so(8)) with the LD_TRACE_LOADED_OBJECTS environment variable set to 1, which causes the linker to display the library dependencies. Be aware, however, that in some circumstances, some versions of ldd may attempt to obtain the dependency information by directly executing the program. Thus, you should never employ ldd on an untrusted executable, since this may result in the execution of arbitrary code. \u603b\u7ed3\uff1a\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u6307\u51fa\u4e86 readelf \u548c ldd \u5728\u8fd9\u79cd\u573a\u666f\u4e0b\u7684\u4f7f\u7528\u5dee\u5f02\u6240\u5728\uff1b Example: readelf -d /bin/ls | grep 'NEEDED' Sample ouptut: 0x0000000000000001 (NEEDED) Shared library: [libselinux.so.1] 0x0000000000000001 (NEEDED) Shared library: [libacl.so.1] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] Note that libraries can depend on other libraries, so now you need to find the dependencies. A naive approach that often works is: $ locate libselinux.so.1 /lib/i386-linux-gnu/libselinux.so.1 /lib/x86_64-linux-gnu/libselinux.so.1 /mnt/debootstrap/lib/x86_64-linux-gnu/libselinux.so.1 but the more precise method is to understand the ldd search path / cache. I think ldconfig is the way to go. Choose one, and repeat: readelf -d /lib/x86_64-linux-gnu/libselinux.so.1 | grep 'NEEDED' Sample output: 0x0000000000000001 (NEEDED) Shared library: [libpcre.so.3] 0x0000000000000001 (NEEDED) Shared library: [libdl.so.2] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x0000000000000001 (NEEDED) Shared library: [ld-linux-x86-64.so.2] And so on. See also: Determine direct shared object dependencies of a Linux binary? | Stack Overflow How can I find the dynamic libraries required by an ELF Binary in C++? | Stack Overflow How to know which dynamic libraries are needed by an ELF? | Stack Overflow /proc/<pid>/maps for running processes Mentioned by Basile , this is useful to find all the libraries currently being used by running executables . E.g.: sudo awk '/\\.so/{print $6}' /proc/1/maps | sort -u shows all currently loaded dynamic dependencies of init (PID 1 ): /lib/x86_64-linux-gnu/ld-2.23.so /lib/x86_64-linux-gnu/libapparmor.so.1.4.0 /lib/x86_64-linux-gnu/libaudit.so.1.0.0 /lib/x86_64-linux-gnu/libblkid.so.1.1.0 /lib/x86_64-linux-gnu/libc-2.23.so /lib/x86_64-linux-gnu/libcap.so.2.24 /lib/x86_64-linux-gnu/libdl-2.23.so /lib/x86_64-linux-gnu/libkmod.so.2.3.0 /lib/x86_64-linux-gnu/libmount.so.1.1.0 /lib/x86_64-linux-gnu/libpam.so.0.83.1 /lib/x86_64-linux-gnu/libpcre.so.3.13.2 /lib/x86_64-linux-gnu/libpthread-2.23.so /lib/x86_64-linux-gnu/librt-2.23.so /lib/x86_64-linux-gnu/libseccomp.so.2.2.3 /lib/x86_64-linux-gnu/libselinux.so.1 /lib/x86_64-linux-gnu/libuuid.so.1.3.0 This method also shows libraries opened with dlopen , tested with this minimal setup hacked up with a sleep(1000) on Ubuntu 18.04. See also: How to see the currently loaded shared objects in Linux? | Super User","title":"ldd"},{"location":"Programming/Object-file/Shared-library/Tools/ldd/#ldd","text":"","title":"ldd"},{"location":"Programming/Object-file/Shared-library/Tools/ldd/#ldd_1","text":"https://en.wikipedia.org/wiki/Ldd_(Unix ) https://linux.die.net/man/1/ldd","title":"ldd"},{"location":"Programming/Object-file/Shared-library/Tools/ldd/#stackexchange#how#to#find#out#the#dynamic#libraries#executables#loads#when#run","text":"","title":"stackexchange How to find out the dynamic libraries executables loads when run?"},{"location":"Programming/Object-file/Shared-library/Tools/ldd/#a1","text":"ldd","title":"A1"},{"location":"Programming/Object-file/Shared-library/Tools/ldd/#a2","text":"readelf -d $executable | grep 'NEEDED' Can be used if you can't run the executable, e.g. if it was cross compiled, or if you don't trust it: In the usual case, ldd invokes the standard dynamic linker (see ld.so(8)) with the LD_TRACE_LOADED_OBJECTS environment variable set to 1, which causes the linker to display the library dependencies. Be aware, however, that in some circumstances, some versions of ldd may attempt to obtain the dependency information by directly executing the program. Thus, you should never employ ldd on an untrusted executable, since this may result in the execution of arbitrary code. \u603b\u7ed3\uff1a\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u6307\u51fa\u4e86 readelf \u548c ldd \u5728\u8fd9\u79cd\u573a\u666f\u4e0b\u7684\u4f7f\u7528\u5dee\u5f02\u6240\u5728\uff1b Example: readelf -d /bin/ls | grep 'NEEDED' Sample ouptut: 0x0000000000000001 (NEEDED) Shared library: [libselinux.so.1] 0x0000000000000001 (NEEDED) Shared library: [libacl.so.1] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] Note that libraries can depend on other libraries, so now you need to find the dependencies. A naive approach that often works is: $ locate libselinux.so.1 /lib/i386-linux-gnu/libselinux.so.1 /lib/x86_64-linux-gnu/libselinux.so.1 /mnt/debootstrap/lib/x86_64-linux-gnu/libselinux.so.1 but the more precise method is to understand the ldd search path / cache. I think ldconfig is the way to go. Choose one, and repeat: readelf -d /lib/x86_64-linux-gnu/libselinux.so.1 | grep 'NEEDED' Sample output: 0x0000000000000001 (NEEDED) Shared library: [libpcre.so.3] 0x0000000000000001 (NEEDED) Shared library: [libdl.so.2] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x0000000000000001 (NEEDED) Shared library: [ld-linux-x86-64.so.2] And so on. See also: Determine direct shared object dependencies of a Linux binary? | Stack Overflow How can I find the dynamic libraries required by an ELF Binary in C++? | Stack Overflow How to know which dynamic libraries are needed by an ELF? | Stack Overflow /proc/<pid>/maps for running processes Mentioned by Basile , this is useful to find all the libraries currently being used by running executables . E.g.: sudo awk '/\\.so/{print $6}' /proc/1/maps | sort -u shows all currently loaded dynamic dependencies of init (PID 1 ): /lib/x86_64-linux-gnu/ld-2.23.so /lib/x86_64-linux-gnu/libapparmor.so.1.4.0 /lib/x86_64-linux-gnu/libaudit.so.1.0.0 /lib/x86_64-linux-gnu/libblkid.so.1.1.0 /lib/x86_64-linux-gnu/libc-2.23.so /lib/x86_64-linux-gnu/libcap.so.2.24 /lib/x86_64-linux-gnu/libdl-2.23.so /lib/x86_64-linux-gnu/libkmod.so.2.3.0 /lib/x86_64-linux-gnu/libmount.so.1.1.0 /lib/x86_64-linux-gnu/libpam.so.0.83.1 /lib/x86_64-linux-gnu/libpcre.so.3.13.2 /lib/x86_64-linux-gnu/libpthread-2.23.so /lib/x86_64-linux-gnu/librt-2.23.so /lib/x86_64-linux-gnu/libseccomp.so.2.2.3 /lib/x86_64-linux-gnu/libselinux.so.1 /lib/x86_64-linux-gnu/libuuid.so.1.3.0 This method also shows libraries opened with dlopen , tested with this minimal setup hacked up with a sleep(1000) on Ubuntu 18.04. See also: How to see the currently loaded shared objects in Linux? | Super User","title":"A2"},{"location":"Programming/Object-file/Symbol/","text":"Symbol \u6bcf\u4e2aobject file\u90fd\u6709\u4e00\u4e2asymbol table\uff0c\u8fd9\u662f\u975e\u5e38\u91cd\u8981\u7684\u3002 Classification Dynamic symbol \u4e3b\u8981\u662fshared library\u7684\u3002 nm -D External symbol nm -g \u8fd9\u662f\u5728\u9605\u8bfb Find where is a shared library symbol defined on a live system / list all symbols exported on a system \u65f6\uff0c\u53d1\u73b0\u7684\u3002 nm \u8fd9\u662fLinux OS\u4e2d\u8bfb\u53d6symbol\u7684\u4e3b\u8981\u5de5\u5177\uff0c\u5728 ./nm \u4e2d\u8fdb\u884c\u4e86\u4ecb\u7ecd\u3002","title":"Introduction"},{"location":"Programming/Object-file/Symbol/#symbol","text":"\u6bcf\u4e2aobject file\u90fd\u6709\u4e00\u4e2asymbol table\uff0c\u8fd9\u662f\u975e\u5e38\u91cd\u8981\u7684\u3002","title":"Symbol"},{"location":"Programming/Object-file/Symbol/#classification","text":"","title":"Classification"},{"location":"Programming/Object-file/Symbol/#dynamic#symbol","text":"\u4e3b\u8981\u662fshared library\u7684\u3002 nm -D","title":"Dynamic symbol"},{"location":"Programming/Object-file/Symbol/#external#symbol","text":"nm -g \u8fd9\u662f\u5728\u9605\u8bfb Find where is a shared library symbol defined on a live system / list all symbols exported on a system \u65f6\uff0c\u53d1\u73b0\u7684\u3002","title":"External symbol"},{"location":"Programming/Object-file/Symbol/#nm","text":"\u8fd9\u662fLinux OS\u4e2d\u8bfb\u53d6symbol\u7684\u4e3b\u8981\u5de5\u5177\uff0c\u5728 ./nm \u4e2d\u8fdb\u884c\u4e86\u4ecb\u7ecd\u3002","title":"nm"},{"location":"Programming/Object-file/Symbol/nm/","text":"nm nm(1) \u2014 Linux manual page nm - list symbols from object files wikipedia nm (Unix)","title":"Introduction"},{"location":"Programming/Object-file/Symbol/nm/#nm","text":"","title":"nm"},{"location":"Programming/Object-file/Symbol/nm/#nm1#linux#manual#page","text":"nm - list symbols from object files","title":"nm(1) \u2014 Linux manual page"},{"location":"Programming/Object-file/Symbol/nm/#wikipedia#nm#unix","text":"","title":"wikipedia nm (Unix)"},{"location":"Programming/Philosophy/","text":"\u5173\u4e8e\u672c\u7ae0 \u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 linux kernel \u6240\u91c7\u7528\u7684\u67b6\u6784\u662f monolithic kernel \uff0c\u4e5f\u5c31\u662flinux kernel\u638c\u7ba1\u7740\u8fd9\u4e2a\u7cfb\u7edf\uff0capplication\u901a\u8fc7\u8c03\u7528system call\u6765\u83b7\u5f97\u7cfb\u7edf\u670d\u52a1\u3002\u6309\u7167linux\u7684\u60ef\u4f8b\uff0csystem call\u6240\u8fd4\u56de\u7684\u53eb\u505adescriptor\uff0c\u5728Windows\u7cfb\u7edf\u4e2d\u4e00\u822c\u53eb\u505ahandler\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Philosophy/#_1","text":"\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 linux kernel \u6240\u91c7\u7528\u7684\u67b6\u6784\u662f monolithic kernel \uff0c\u4e5f\u5c31\u662flinux kernel\u638c\u7ba1\u7740\u8fd9\u4e2a\u7cfb\u7edf\uff0capplication\u901a\u8fc7\u8c03\u7528system call\u6765\u83b7\u5f97\u7cfb\u7edf\u670d\u52a1\u3002\u6309\u7167linux\u7684\u60ef\u4f8b\uff0csystem call\u6240\u8fd4\u56de\u7684\u53eb\u505adescriptor\uff0c\u5728Windows\u7cfb\u7edf\u4e2d\u4e00\u822c\u53eb\u505ahandler\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Programming/Philosophy/Unix-philosophy/","text":"Unix philosophy Origin Unix philosophy The Unix philosophy , originated by Ken Thompson , is a set of cultural norms and philosophical approaches to minimalist , modular software development . It is based on the experience of leading developers of the Unix operating system . Early Unix developers were important in bringing the concepts of modularity and reusability into software engineering practice, spawning a \" software tools \" movement. Over time, the leading developers of Unix (and programs that ran on it) established a set of cultural norms for developing software, norms which became as important and influential as the technology of Unix itself; this has been termed the \"Unix philosophy.\" The Unix philosophy emphasizes building simple, short, clear, modular, and extensible code that can be easily maintained and repurposed by developers other than its creators. The Unix philosophy favors composability as opposed to monolithic design . SUMMARY : \u6700\u540e\u4e00\u6bb5\u8bdd\u5f3a\u8c03\u4e86Unix philosophy\u7684\u6838\u5fc3\u6240\u5728\uff0c\u5373composability\u3002 Origin The UNIX philosophy is documented by Doug McIlroy [ 1] in the Bell System Technical Journal from 1978:[ 2] Make each program do one thing well. To do a new job, build a fresh rather than complicate old programs by adding new \"features\". Expect the output of every program to become the input to another, as yet unknown, program. Don't clutter output with extraneous information. Avoid stringently\uff08\u4e25\u683c\u7684\uff09 columnar or binary input formats. Don't insist on interactive input. Design and build software, even\uff08\u751a\u81f3\u662f\uff09 operating systems, to be tried early, ideally within weeks. Don't hesitate to throw away the clumsy parts and rebuild them. \u8bbe\u8ba1\u548c\u6784\u5efa\u8f6f\u4ef6\uff0c\u751a\u81f3\u662f\u64cd\u4f5c\u7cfb\u7edf\uff0c\u8981\u53ca\u65e9\u5c1d\u8bd5\uff0c\u6700\u597d\u5728\u51e0\u5468\u5185\u5b8c\u6210\u3002 \u4e0d\u8981\u72b9\u8c6b\u6254\u6389\u7b28\u62d9\u7684\u90e8\u5206\u5e76\u91cd\u5efa\u5b83\u4eec\u3002 Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you've finished using them. \u4f7f\u7528\u5de5\u5177\u4f18\u5148\u4e8e\u4e0d\u719f\u7ec3\u7684\u5e2e\u52a9\u6765\u51cf\u8f7b\u7f16\u7a0b\u4efb\u52a1\uff0c\u5373\u4f7f\u4f60\u4e0d\u5f97\u4e0d\u7ed5\u9053\u53bb\u6784\u5efa\u5de5\u5177\u5e76\u671f\u671b\u5728\u4f60\u4f7f\u7528\u5b83\u4eec\u4e4b\u540e\u629b\u51fa\u4e00\u4e9b\u5de5\u5177\u3002 It was later summarized by Peter H. Salus in A Quarter-Century of Unix (1994):[ 1] Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. In their award-winning Unix paper of 1974, Ritchie and Thompson quote the following design considerations:[ 3] Make it easy to write, test, and run programs. Interactive use instead of batch processing . Economy and elegance of design due to size constraints (\"salvation through suffering\"). Self-supporting system: all Unix software is maintained under Unix. The whole philosophy of UNIX seems to stay out of assembler . \u2014\u2009 Michael Sean Mahoney [ 4]","title":"Unix philosophy"},{"location":"Programming/Philosophy/Unix-philosophy/#unix#philosophy","text":"The Unix philosophy , originated by Ken Thompson , is a set of cultural norms and philosophical approaches to minimalist , modular software development . It is based on the experience of leading developers of the Unix operating system . Early Unix developers were important in bringing the concepts of modularity and reusability into software engineering practice, spawning a \" software tools \" movement. Over time, the leading developers of Unix (and programs that ran on it) established a set of cultural norms for developing software, norms which became as important and influential as the technology of Unix itself; this has been termed the \"Unix philosophy.\" The Unix philosophy emphasizes building simple, short, clear, modular, and extensible code that can be easily maintained and repurposed by developers other than its creators. The Unix philosophy favors composability as opposed to monolithic design . SUMMARY : \u6700\u540e\u4e00\u6bb5\u8bdd\u5f3a\u8c03\u4e86Unix philosophy\u7684\u6838\u5fc3\u6240\u5728\uff0c\u5373composability\u3002","title":"Unix philosophy"},{"location":"Programming/Philosophy/Unix-philosophy/#origin","text":"The UNIX philosophy is documented by Doug McIlroy [ 1] in the Bell System Technical Journal from 1978:[ 2] Make each program do one thing well. To do a new job, build a fresh rather than complicate old programs by adding new \"features\". Expect the output of every program to become the input to another, as yet unknown, program. Don't clutter output with extraneous information. Avoid stringently\uff08\u4e25\u683c\u7684\uff09 columnar or binary input formats. Don't insist on interactive input. Design and build software, even\uff08\u751a\u81f3\u662f\uff09 operating systems, to be tried early, ideally within weeks. Don't hesitate to throw away the clumsy parts and rebuild them. \u8bbe\u8ba1\u548c\u6784\u5efa\u8f6f\u4ef6\uff0c\u751a\u81f3\u662f\u64cd\u4f5c\u7cfb\u7edf\uff0c\u8981\u53ca\u65e9\u5c1d\u8bd5\uff0c\u6700\u597d\u5728\u51e0\u5468\u5185\u5b8c\u6210\u3002 \u4e0d\u8981\u72b9\u8c6b\u6254\u6389\u7b28\u62d9\u7684\u90e8\u5206\u5e76\u91cd\u5efa\u5b83\u4eec\u3002 Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you've finished using them. \u4f7f\u7528\u5de5\u5177\u4f18\u5148\u4e8e\u4e0d\u719f\u7ec3\u7684\u5e2e\u52a9\u6765\u51cf\u8f7b\u7f16\u7a0b\u4efb\u52a1\uff0c\u5373\u4f7f\u4f60\u4e0d\u5f97\u4e0d\u7ed5\u9053\u53bb\u6784\u5efa\u5de5\u5177\u5e76\u671f\u671b\u5728\u4f60\u4f7f\u7528\u5b83\u4eec\u4e4b\u540e\u629b\u51fa\u4e00\u4e9b\u5de5\u5177\u3002 It was later summarized by Peter H. Salus in A Quarter-Century of Unix (1994):[ 1] Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. In their award-winning Unix paper of 1974, Ritchie and Thompson quote the following design considerations:[ 3] Make it easy to write, test, and run programs. Interactive use instead of batch processing . Economy and elegance of design due to size constraints (\"salvation through suffering\"). Self-supporting system: all Unix software is maintained under Unix. The whole philosophy of UNIX seems to stay out of assembler . \u2014\u2009 Michael Sean Mahoney [ 4]","title":"Origin"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/","text":"Everything is a file \u201cEverything is a file\u201d\u662fUnix-like OS\u7684\u4e00\u4e2aphilosophy\uff0c\u5b83\u5bf9\u4e8e\u5728linux OS\u4e2d\u8fdb\u884cprogramming\u5927\u6709\u88e8\u76ca\u3002 \u7ef4\u57fa\u767e\u79d1 Everything is a file \"Everything is a file\" describes one of the defining(\u6700\u5178\u578b\u7684) features of Unix , and its derivatives \u2014 that a wide range of input/output resources such as documents, directories, hard-drives, modems, keyboards, printers and even some inter-process and network communications are simple streams of bytes exposed through the filesystem name space . NOTE: \u6700\u540e\u4e00\u6bb5\u8bdd\u662f\u5bf9***\"Everything is a file\"*** \u542b\u4e49\u7684\u89e3\u91ca\uff1a\u5373\u5c06\u8fd9\u4e9bresource\u90fd\u770b\u505a\u662ffile\uff08 streams of bytes \uff09 NOTE: \u4e0a\u8ff0 hard-drives\uff0cmodems\uff0ckeyboards\uff0c\u7b49\u90fd\u662fdevice\uff0c\u663e\u7136\u5728Unix\u4e2d\uff0c\u5b83\u4eec\u90fd\u88ab\u770b\u505a\u6210\u4e86file\uff08 streams of bytes \uff09\uff0c\u6240\u4ee5everything is a file\uff0c\u53ef\u4ee5\u89e3\u91ca\u4e3aeverything is a file descriptor\uff0c\u6bcf\u4e2adescriptor\u5bf9\u5e94\u7684\u662f\u4e00\u4e2astream\uff0c\u6240\u4ee5everything is a file descriptor\u53ef\u4ee5\u89e3\u91ca\u4e3aeverything is a stream\u3002 The advantage of this approach is that the same set of tools, utilities and APIs can be used on a wide range of resources. There are a number of file types . When a file is opened, a file descriptor is created. The file path becoming the addressing system and the file descriptor being the byte stream I/O interface. But file descriptors are also created for things like anonymous pipes and network sockets via different methods. So it is more accurate to say \"Everything is a file descriptor\" . Additionally, a range of pseudo and virtual filesystems exists which exposes information about processes and other system information in a hierarchical file-like structure. These are mounted into the single file hierarchy . An example of this purely virtual filesystem is under /proc that exposes many system properties as files. All of these \"files\" have standard Unix file attributes such as an owner and access permissions , and can be queried by the same classic Unix tools and filters . However, this is not universally considered a fast or portable approach. Some operating systems do not even mount /proc by default due to security or speed concerns. It is, though, used heavily by both the widely installed BusyBox [ 5] on embedded systems and by procps, which is used on most Linux systems. In both cases it is used in implementations of process-related POSIX shell commands. It is similarly used on Android systems in the operating system's Toolbox program. Unix's successor Plan 9 took this concept into distributed computing with the 9P protocol. Why is \u201cEverything is a file\u201d unique to the Unix operating systems? A So, why is this unique to Unix? Typical operating systems, prior to Unix, treated files one way and treated each peripheral device(\u5916\u8bbe) according to the characteristics of that device. That is, if the output of a program was written to a file on disk, that was the only place the output could go; you could not send it to the printer or the tape drive. Each program had to be aware of each device used for input and output, and have command options to deal with alternate I/O devices. Unix treats all devices as files , but with special attributes. To simplify programs, standard input and standard output are the default input and output devices of a program(\u8fd9\u53e5\u8bdd\u89e3\u91ca\u4e86*standard input*\uff0c standard output \u7684\u539f\u56e0 ). So program output normally intended for the console screen could go anywhere, to a disk file or a printer or a serial port. This is called I/O redirection . Does other operating systems such as Windows and Macs not operate on files? Of course all modern OSes support various filesystems and can \"operate on files\", but the distinction is how are devices handled? Don't know about Mac, but Windows does offer some I/O redirection. And, compared to what other operating systems is it unique? Not really any more. Linux has the same feature. Of course, if an OS adopts I/O redirection, then it tends to use other Unix features and ends up Unix-like in the end. \u7ef4\u57fa\u767e\u79d1 Event loop \u5728\u8fd9\u7bc7\u6587\u7ae0\u7684 File_interface \u7ae0\u8282\u5bf9every thing is a file\u8fdb\u884c\u9610\u91ca\uff1b \u7ef4\u57fa\u767e\u79d1 Device file \u5c06device\u62bd\u8c61\u4e3afile\uff0c\u8fd9\u5c31\u662feverything is a file\u6700\u597d\u7684\u4f53\u73b0\uff1b Beej's Guide to Network Programming \u5728\u8fd9\u672c\u4e66\u7684\u7b2c\u4e8c\u7ae0 2. What is a socket? \u4e2d\u5bf9everything is a file\u8fdb\u884c\u4e86\u9610\u8ff0\uff1b APUE chapter 16 Network IPC: Sockets \u6628\u5929\u5728\u9605\u8bfbAPUE\u7684\u7684chapter 16 Network IPC: Sockets\u65f6\uff0c\u6240\u60f3\uff1a everything in Unix is a file\uff0c\u6240\u4ee5\u548c\u6211\u5e94\u8be5\u91c7\u7528\u770b\u5f85\u666e\u901a\u6587\u4ef6\u7684\u65b9\u5f0f\u6765\u770b\u5f85Unix\u7684socket\u3002socket\u548cfile\u4e00\u6837\uff0c\u90fd\u662f\u901a\u8fc7**file descriptor**\u6765\u8fdb\u884c\u8bbf\u95ee\u3002POSIX\u4e2d\u63d0\u4f9b\u7684\u64cd\u4f5csocket\u7684\u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u90fd\u662f fd \uff0c\u8868\u793a\u8fd9\u4e2asocket\u7684file descriptor\uff0c\u8fd9\u79cd\u505a\u6cd5\u548cfile\u662f\u975e\u5e38\u7c7b\u4f3c\u7684\u3002 socket() \u51fd\u6570\u5c31\u597d\u6bd4 create() \u51fd\u6570\u3002\u5176\u5b9eAPUE\u7684\u4f5c\u8005\u572816.2\u4e2d\u5c31\u5bf9\u6bd4\u4e86Unix\u7684\u9488\u5bf9file\u7684API\u548c\u9488\u5bf9socket\u7684API\u3002 \u5982\u679c\u4ece\u9762\u5411\u5bf9\u8c61\u7684\u89d2\u5ea6\u6765\u6784\u9020POSIX\u7684\u6587\u4ef6api\u548csocket api\u7684\u8bdd\uff0c\u63a5\u53d7file descriptor\u7684api\u90fd\u53ef\u4ee5\u4f5c\u4e3a\u6210\u5458\u51fd\u6570\uff0c\u6bcf\u4e2a\u5bf9\u8c61\u90fd\u6709\u4e00\u4e2afile descriptor\u3002 \u5728 Beej's Guide to Network Programming \u76842. What is a socket?\u7ae0\u8282\u4e5f\u662f\u4ecefile descriptor\u7684\u89d2\u5ea6\u6765\u63cf\u8ff0socket\u7684\uff1b Why everything in Unix is a file Unix\u662f\u5178\u578b\u7684 Monolithic kernel \uff0c\u6240\u4ee5\u5b83\u9700\u8981\u5c06\u5f88\u591a\u4e1c\u897f\u5c01\u88c5\u597d\u800c\u53ea\u63d0\u4f9b\u4e00\u4e2adescriptor\u6765\u4f9b\u7528\u6237\u4f7f\u7528\uff0c\u8fd9\u4e2adescriptor\u4ece\u7528\u6237\u7684\u89d2\u5ea6\u6765\u770b\u5c31\u662ffile descriptor\u3002\u663e\u7136\uff0ceverything in Unix is a file\u662f\u4e00\u79cd\u7b80\u5316\u7684\u62bd\u8c61\uff0c\u5b83\u8ba9\u7528\u6237\u66f4\u52a0\u5bb9\u6613\u7406\u89e3\u3002 \u5f53\u7136\uff0c\u4ece\u5185\u6838\u7684\u5b9e\u73b0\u4e0a\u662f\u5426\u771f\u7684\u662f\u5982\u6b64\u6211\u76ee\u524d\u8fd8\u4e0d\u5f97\u800c\u77e5\uff0c\u4f46\u662f\u4ece\u7528\u6237\u7684\u89d2\u5ea6\u6765\u770b\uff0c\u8fd9\u662f\u975e\u5e38\u6b63\u786e\u7684\u3002 Everything in Unix is file \u548c file API \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0ceverything in Unix is file\u662f\u4e00\u4e2a\u4e2aphilosophy\uff0c\u5b83\u662f\u6982\u5ff5\u4e0a\u7684\uff0c\u5b83\u66f4\u591a\u7684\u662f\u6307\uff1a\u5c06\u5b83\u770b\u505a\u662f\u4e00\u4e2afile\uff0c\u6211\u4eec\u53ef\u4ee5\u5bf9\u5176\u8fdb\u884cIO\uff0c\u4f46\u662f\u8fd9\u5e76\u4e0d\u662f\u6307\u6211\u4eec\u53ef\u4ee5\u5bf9everything in Unix\u90fd\u4f7f\u7528Unix file\u7684API\u3002 \u5173\u4e8e\u8fd9\u4e00\u70b9\uff0cAPUE\u768416.2 Socket Descriptors\u8fdb\u884c\u4e86\u4e00\u4e9b\u63cf\u8ff0\uff1b \u5173\u4e8e\u8fd9\u4e00\u70b9\uff0c\u5728 pipe(7) - Linux man page \u7684I/O on pipes and FIFOs\u7ae0\u8282\u4e2d\u63d0\u53ca\uff1a It is not possible to apply lseek(2) to a pipe. \u663e\u7136\uff0c\u6211\u4eec\u53ef\u4ee5*\u8ba4\u4e3a*\uff08\u4ece\u903b\u8f91\u4e0a\uff09pipe\u662f\u4e00\u4e2afile\uff0c\u4f46\u662f\u5b83\u5b9e\u9645\u4e0a\u5e76\u4e0d\u662ffile\uff0c\u6240\u4ee5\uff0c\u5e76\u4e0d\u80fd\u591f\u5bf9\u5176\u4f7f\u7528lseek\u7cfb\u7edf\u8c03\u7528\u3002 \u4ecekernel\u5b9e\u73b0\u7684\u89d2\u5ea6\u6765\u770b\u5f85everything in Unix is file \u5f15\u7528\u81ea\u7ef4\u57fa\u767e\u79d1 File descriptor : In Unix-like systems, file descriptors can refer to any Unix file type named in a file system. As well as regular files, this includes directories , block and character devices (also called \"special files\"), Unix domain sockets , and named pipes . File descriptors can also refer to other objects that do not normally exist in the file system, such as anonymous pipes and network sockets . NOTE: Everything is a file \uff1b\u4ecekernel\u5b9e\u73b0\u7684\u89d2\u5ea6\u6765\u770b\u770b\u5f85everything in Unix is file\uff0cUnix-like system\u662f monolithic kernel \uff0c\u4e0a\u9762\u63d0\u5230\u7684\u8fd9\u4e9bdevice\u6216\u8005file\u90fd\u662f\u7531kernel\u6765\u8fdb\u884c\u7ef4\u62a4\uff0c\u5b83\u4eec\u90fd\u6709\u5bf9\u5e94\u7684kernel structure\uff1b\u6211\u4eec\u901a\u8fc7file descriptor\u6765\u5f15\u7528\u8fd9\u4e9bkernel structure\uff0c\u6211\u4eec\u53ea\u80fd\u591f\u901a\u8fc7system call\u6765\u5bf9\u8fd9\u4e9bkernel structure\u8fdb\u884c\u64cd\u4f5c\uff1b \u5bf9\u8fd9\u4e2a\u89c2\u70b9\u7684\u9a8c\u8bc1\u5305\u62ec\uff1a EPOLL instance \u300aUnderstanding.The.Linux.kernel.3 rd .Edition\u300bchapter 1.6.9. Device Drivers\u7684 \u5173\u4e8eeverything is a file\uff0c\u300aUnderstanding.The.Linux.kernel.3 rd .Edition\u300bchapter 1.6.9. Device Drivers\u7684\u5185\u5bb9\u4e0e\u6b64\u6709\u5173\u3002","title":"Everything is a file"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#everything#is#a#file","text":"\u201cEverything is a file\u201d\u662fUnix-like OS\u7684\u4e00\u4e2aphilosophy\uff0c\u5b83\u5bf9\u4e8e\u5728linux OS\u4e2d\u8fdb\u884cprogramming\u5927\u6709\u88e8\u76ca\u3002","title":"Everything is a file"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#everything#is#a#file_1","text":"\"Everything is a file\" describes one of the defining(\u6700\u5178\u578b\u7684) features of Unix , and its derivatives \u2014 that a wide range of input/output resources such as documents, directories, hard-drives, modems, keyboards, printers and even some inter-process and network communications are simple streams of bytes exposed through the filesystem name space . NOTE: \u6700\u540e\u4e00\u6bb5\u8bdd\u662f\u5bf9***\"Everything is a file\"*** \u542b\u4e49\u7684\u89e3\u91ca\uff1a\u5373\u5c06\u8fd9\u4e9bresource\u90fd\u770b\u505a\u662ffile\uff08 streams of bytes \uff09 NOTE: \u4e0a\u8ff0 hard-drives\uff0cmodems\uff0ckeyboards\uff0c\u7b49\u90fd\u662fdevice\uff0c\u663e\u7136\u5728Unix\u4e2d\uff0c\u5b83\u4eec\u90fd\u88ab\u770b\u505a\u6210\u4e86file\uff08 streams of bytes \uff09\uff0c\u6240\u4ee5everything is a file\uff0c\u53ef\u4ee5\u89e3\u91ca\u4e3aeverything is a file descriptor\uff0c\u6bcf\u4e2adescriptor\u5bf9\u5e94\u7684\u662f\u4e00\u4e2astream\uff0c\u6240\u4ee5everything is a file descriptor\u53ef\u4ee5\u89e3\u91ca\u4e3aeverything is a stream\u3002 The advantage of this approach is that the same set of tools, utilities and APIs can be used on a wide range of resources. There are a number of file types . When a file is opened, a file descriptor is created. The file path becoming the addressing system and the file descriptor being the byte stream I/O interface. But file descriptors are also created for things like anonymous pipes and network sockets via different methods. So it is more accurate to say \"Everything is a file descriptor\" . Additionally, a range of pseudo and virtual filesystems exists which exposes information about processes and other system information in a hierarchical file-like structure. These are mounted into the single file hierarchy . An example of this purely virtual filesystem is under /proc that exposes many system properties as files. All of these \"files\" have standard Unix file attributes such as an owner and access permissions , and can be queried by the same classic Unix tools and filters . However, this is not universally considered a fast or portable approach. Some operating systems do not even mount /proc by default due to security or speed concerns. It is, though, used heavily by both the widely installed BusyBox [ 5] on embedded systems and by procps, which is used on most Linux systems. In both cases it is used in implementations of process-related POSIX shell commands. It is similarly used on Android systems in the operating system's Toolbox program. Unix's successor Plan 9 took this concept into distributed computing with the 9P protocol.","title":"\u7ef4\u57fa\u767e\u79d1Everything is a file"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#why#is#everything#is#a#file#unique#to#the#unix#operating#systems","text":"","title":"Why is \u201cEverything is a file\u201d unique to the Unix operating systems?"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#a","text":"So, why is this unique to Unix? Typical operating systems, prior to Unix, treated files one way and treated each peripheral device(\u5916\u8bbe) according to the characteristics of that device. That is, if the output of a program was written to a file on disk, that was the only place the output could go; you could not send it to the printer or the tape drive. Each program had to be aware of each device used for input and output, and have command options to deal with alternate I/O devices. Unix treats all devices as files , but with special attributes. To simplify programs, standard input and standard output are the default input and output devices of a program(\u8fd9\u53e5\u8bdd\u89e3\u91ca\u4e86*standard input*\uff0c standard output \u7684\u539f\u56e0 ). So program output normally intended for the console screen could go anywhere, to a disk file or a printer or a serial port. This is called I/O redirection . Does other operating systems such as Windows and Macs not operate on files? Of course all modern OSes support various filesystems and can \"operate on files\", but the distinction is how are devices handled? Don't know about Mac, but Windows does offer some I/O redirection. And, compared to what other operating systems is it unique? Not really any more. Linux has the same feature. Of course, if an OS adopts I/O redirection, then it tends to use other Unix features and ends up Unix-like in the end.","title":"A"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#event#loop","text":"\u5728\u8fd9\u7bc7\u6587\u7ae0\u7684 File_interface \u7ae0\u8282\u5bf9every thing is a file\u8fdb\u884c\u9610\u91ca\uff1b","title":"\u7ef4\u57fa\u767e\u79d1Event loop"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#device#file","text":"\u5c06device\u62bd\u8c61\u4e3afile\uff0c\u8fd9\u5c31\u662feverything is a file\u6700\u597d\u7684\u4f53\u73b0\uff1b","title":"\u7ef4\u57fa\u767e\u79d1Device file"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#beejs#guide#to#network#programming","text":"\u5728\u8fd9\u672c\u4e66\u7684\u7b2c\u4e8c\u7ae0 2. What is a socket? \u4e2d\u5bf9everything is a file\u8fdb\u884c\u4e86\u9610\u8ff0\uff1b","title":"Beej's Guide to Network Programming"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#apue#chapter#16#network#ipc#sockets","text":"\u6628\u5929\u5728\u9605\u8bfbAPUE\u7684\u7684chapter 16 Network IPC: Sockets\u65f6\uff0c\u6240\u60f3\uff1a everything in Unix is a file\uff0c\u6240\u4ee5\u548c\u6211\u5e94\u8be5\u91c7\u7528\u770b\u5f85\u666e\u901a\u6587\u4ef6\u7684\u65b9\u5f0f\u6765\u770b\u5f85Unix\u7684socket\u3002socket\u548cfile\u4e00\u6837\uff0c\u90fd\u662f\u901a\u8fc7**file descriptor**\u6765\u8fdb\u884c\u8bbf\u95ee\u3002POSIX\u4e2d\u63d0\u4f9b\u7684\u64cd\u4f5csocket\u7684\u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u90fd\u662f fd \uff0c\u8868\u793a\u8fd9\u4e2asocket\u7684file descriptor\uff0c\u8fd9\u79cd\u505a\u6cd5\u548cfile\u662f\u975e\u5e38\u7c7b\u4f3c\u7684\u3002 socket() \u51fd\u6570\u5c31\u597d\u6bd4 create() \u51fd\u6570\u3002\u5176\u5b9eAPUE\u7684\u4f5c\u8005\u572816.2\u4e2d\u5c31\u5bf9\u6bd4\u4e86Unix\u7684\u9488\u5bf9file\u7684API\u548c\u9488\u5bf9socket\u7684API\u3002 \u5982\u679c\u4ece\u9762\u5411\u5bf9\u8c61\u7684\u89d2\u5ea6\u6765\u6784\u9020POSIX\u7684\u6587\u4ef6api\u548csocket api\u7684\u8bdd\uff0c\u63a5\u53d7file descriptor\u7684api\u90fd\u53ef\u4ee5\u4f5c\u4e3a\u6210\u5458\u51fd\u6570\uff0c\u6bcf\u4e2a\u5bf9\u8c61\u90fd\u6709\u4e00\u4e2afile descriptor\u3002 \u5728 Beej's Guide to Network Programming \u76842. What is a socket?\u7ae0\u8282\u4e5f\u662f\u4ecefile descriptor\u7684\u89d2\u5ea6\u6765\u63cf\u8ff0socket\u7684\uff1b","title":"APUE chapter 16 Network IPC: Sockets"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#why#everything#in#unix#is#a#file","text":"Unix\u662f\u5178\u578b\u7684 Monolithic kernel \uff0c\u6240\u4ee5\u5b83\u9700\u8981\u5c06\u5f88\u591a\u4e1c\u897f\u5c01\u88c5\u597d\u800c\u53ea\u63d0\u4f9b\u4e00\u4e2adescriptor\u6765\u4f9b\u7528\u6237\u4f7f\u7528\uff0c\u8fd9\u4e2adescriptor\u4ece\u7528\u6237\u7684\u89d2\u5ea6\u6765\u770b\u5c31\u662ffile descriptor\u3002\u663e\u7136\uff0ceverything in Unix is a file\u662f\u4e00\u79cd\u7b80\u5316\u7684\u62bd\u8c61\uff0c\u5b83\u8ba9\u7528\u6237\u66f4\u52a0\u5bb9\u6613\u7406\u89e3\u3002 \u5f53\u7136\uff0c\u4ece\u5185\u6838\u7684\u5b9e\u73b0\u4e0a\u662f\u5426\u771f\u7684\u662f\u5982\u6b64\u6211\u76ee\u524d\u8fd8\u4e0d\u5f97\u800c\u77e5\uff0c\u4f46\u662f\u4ece\u7528\u6237\u7684\u89d2\u5ea6\u6765\u770b\uff0c\u8fd9\u662f\u975e\u5e38\u6b63\u786e\u7684\u3002","title":"Why everything in Unix is a file"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#everything#in#unix#is#file#file#api","text":"\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0ceverything in Unix is file\u662f\u4e00\u4e2a\u4e2aphilosophy\uff0c\u5b83\u662f\u6982\u5ff5\u4e0a\u7684\uff0c\u5b83\u66f4\u591a\u7684\u662f\u6307\uff1a\u5c06\u5b83\u770b\u505a\u662f\u4e00\u4e2afile\uff0c\u6211\u4eec\u53ef\u4ee5\u5bf9\u5176\u8fdb\u884cIO\uff0c\u4f46\u662f\u8fd9\u5e76\u4e0d\u662f\u6307\u6211\u4eec\u53ef\u4ee5\u5bf9everything in Unix\u90fd\u4f7f\u7528Unix file\u7684API\u3002 \u5173\u4e8e\u8fd9\u4e00\u70b9\uff0cAPUE\u768416.2 Socket Descriptors\u8fdb\u884c\u4e86\u4e00\u4e9b\u63cf\u8ff0\uff1b \u5173\u4e8e\u8fd9\u4e00\u70b9\uff0c\u5728 pipe(7) - Linux man page \u7684I/O on pipes and FIFOs\u7ae0\u8282\u4e2d\u63d0\u53ca\uff1a It is not possible to apply lseek(2) to a pipe. \u663e\u7136\uff0c\u6211\u4eec\u53ef\u4ee5*\u8ba4\u4e3a*\uff08\u4ece\u903b\u8f91\u4e0a\uff09pipe\u662f\u4e00\u4e2afile\uff0c\u4f46\u662f\u5b83\u5b9e\u9645\u4e0a\u5e76\u4e0d\u662ffile\uff0c\u6240\u4ee5\uff0c\u5e76\u4e0d\u80fd\u591f\u5bf9\u5176\u4f7f\u7528lseek\u7cfb\u7edf\u8c03\u7528\u3002","title":"Everything in Unix is file \u548c file API"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#kerneleverything#in#unix#is#file","text":"\u5f15\u7528\u81ea\u7ef4\u57fa\u767e\u79d1 File descriptor : In Unix-like systems, file descriptors can refer to any Unix file type named in a file system. As well as regular files, this includes directories , block and character devices (also called \"special files\"), Unix domain sockets , and named pipes . File descriptors can also refer to other objects that do not normally exist in the file system, such as anonymous pipes and network sockets . NOTE: Everything is a file \uff1b\u4ecekernel\u5b9e\u73b0\u7684\u89d2\u5ea6\u6765\u770b\u770b\u5f85everything in Unix is file\uff0cUnix-like system\u662f monolithic kernel \uff0c\u4e0a\u9762\u63d0\u5230\u7684\u8fd9\u4e9bdevice\u6216\u8005file\u90fd\u662f\u7531kernel\u6765\u8fdb\u884c\u7ef4\u62a4\uff0c\u5b83\u4eec\u90fd\u6709\u5bf9\u5e94\u7684kernel structure\uff1b\u6211\u4eec\u901a\u8fc7file descriptor\u6765\u5f15\u7528\u8fd9\u4e9bkernel structure\uff0c\u6211\u4eec\u53ea\u80fd\u591f\u901a\u8fc7system call\u6765\u5bf9\u8fd9\u4e9bkernel structure\u8fdb\u884c\u64cd\u4f5c\uff1b \u5bf9\u8fd9\u4e2a\u89c2\u70b9\u7684\u9a8c\u8bc1\u5305\u62ec\uff1a EPOLL instance","title":"\u4ecekernel\u5b9e\u73b0\u7684\u89d2\u5ea6\u6765\u770b\u5f85everything in Unix is file"},{"location":"Programming/Philosophy/Everything-is-a-file/Everything-is-a-file/#understandingthelinuxkernel3rdeditionchapter#169#device#drivers","text":"\u5173\u4e8eeverything is a file\uff0c\u300aUnderstanding.The.Linux.kernel.3 rd .Edition\u300bchapter 1.6.9. Device Drivers\u7684\u5185\u5bb9\u4e0e\u6b64\u6709\u5173\u3002","title":"\u300aUnderstanding.The.Linux.kernel.3rd.Edition\u300bchapter 1.6.9. Device Drivers\u7684"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/","text":"File descriptor \u7ef4\u57fa\u767e\u79d1 File descriptor In Unix and related computer operating systems, a file descriptor ( FD , less frequently fildes ) is an abstract indicator ( handle ) used to access a file or other input/output resource , such as a pipe or network socket . File descriptors form part of the POSIX application programming interface . A file descriptor is a non-negative integer , generally represented in the C programming language as the type int (negative values being reserved to indicate \"no value\" or an error condition). Each Unix process (except perhaps a daemon ) should expect to have three standard POSIX file descriptors, corresponding to the three standard streams : Integer value Name unistd.h symbolic constant stdio.h file stream 0 Standard input STDIN_FILENO stdin 1 Standard output STDOUT_FILENO stdout 2 Standard error STDERR_FILENO stderr Overview In the traditional implementation of Unix, file descriptors index into a per-process file descriptor table maintained by the kernel, that in turn indexes into a system-wide table of files opened by all processes, called the file table . This table records the mode with which the file (or other resource) has been opened: for reading, writing, appending, and possibly other modes. It also indexes into a third table called the inode table that describes the actual underlying files. To perform input or output, the process passes the file descriptor to the kernel through a system call , and the kernel will access the file on behalf of the process. The process does not have direct access to the file or inode tables . NOTE : \u5728APUE\u76843.10 File Sharing\u4e5f\u63cf\u8ff0\u4e86\u8fd9\u90e8\u5206\u5185\u5bb9\uff1b\u9700\u8981\u6ce8\u610f\u7684\u662f\uff1athe data structures used by the kernel for all I/O.\u5373\u6240\u6709\u7684IO\u90fd\u662f\u91c7\u7528\u7684\u7c7b\u4f3c\u4e8e\u4e0a\u8ff0\u7684\u7ed3\u6784\uff1b\u5e76\u4e14\u4e0a\u8ff0\u7ed3\u6784\u9700\u8981\u548c Process control block \u4e00\u8d77\u6765\u7406\u89e3\u624d\u80fd\u591f\u5f88\u597d\u7684\u5bf9Unix OS\u7684IO\u6709\u4e00\u4e2a\u6574\u4f53\u7684\u8ba4\u77e5\uff1b NOTE: \u9700\u8981\u6ce8\u610f\uff0c\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u63d0\u53ca file descriptor table \u548c file table \u65f6\uff0c\u524d\u9762\u5206\u522b\u52a0\u4e0a\u4e86\u4fee\u9970\u8bed\uff1a per-process \u548c system-wide \uff1b\u8fd9\u4e24\u4e2a\u4fee\u9970\u8bed\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u9700\u8981\u5c06\u5b83\u4eec\u548cthe data structures used by the kernel for all I/O\u4e00\u8d77\u6765\u8fdb\u884c\u7406\u89e3\uff1b\u56e0\u4e3a file descriptor table \u7684scope\u662fprocess\uff0c\u5373\u6bcf\u4e2aprocess\u90fd\u6709\u4e00\u5957\u81ea\u5df1\u7684 file descriptor table \uff0c\u6240\u4ee5\u6bcf\u4e2aprocess\u7684file descriptor\u90fd\u662f\u4ece0\u5f00\u59cb\u589e\u957f\uff1b\u663e\u7136\u6bd4\u8f83\u4e24\u4e2aprocess\u7684file descriptor\u662f\u6ca1\u6709\u610f\u4e49\u7684\uff08\u5904\u74060,1,2\uff0c\u56e0\u4e3a\u5b83\u4eec\u90fd\u5df2\u7ecf\u88ab\u9ed8\u8ba4\u7ed1\u5b9a\u5230 STDIN_FILENO , STDOUT_FILENO , STDERR_FILENO \uff09\uff1b\u800cfile table\u7684scope\u662fsystem\uff0c\u5373\u6240\u6709\u7684process\u90fd\u5c06\u5171\u4eabfile table\uff1b NOTE: \u6bcf\u6b21\u8c03\u7528 open \u7cfb\u7edf\u8c03\u7528\uff0c\u90fd\u4f1a\u521b\u5efa\u4e00\u4e2afile table entry On Linux , the set of file descriptors open in a process can be accessed under the path /proc/PID/fd/ , where PID is the process identifier . In Unix-like systems, file descriptors can refer to any Unix file type named in a file system. As well as regular files, this includes directories , block and character devices (also called \"special files\"), Unix domain sockets , and named pipes . File descriptors can also refer to other objects that do not normally exist in the file system, such as anonymous pipes and network sockets . SUMMARY : Everything is a file \uff1b\u4ecekernel\u5b9e\u73b0\u7684\u89d2\u5ea6\u6765\u770b\u770b\u5f85everything in Unix is file\uff0cUnix-like system\u662f monolithic kernel \uff0c\u4e0a\u9762\u63d0\u5230\u7684\u8fd9\u4e9bdevice\u6216\u8005file\u90fd\u662f\u7531kernel\u6765\u8fdb\u884c\u7ef4\u62a4\uff0c\u5b83\u4eec\u90fd\u6709\u5bf9\u5e94\u7684kernel structure\uff1b\u6211\u4eec\u901a\u8fc7file descriptor\u6765\u5f15\u7528\u8fd9\u4e9bkernel structure\uff0c\u6211\u4eec\u53ea\u80fd\u591f\u901a\u8fc7system call\u6765\u5bf9\u8fd9\u4e9bkernel structure\u8fdb\u884c\u64cd\u4f5c\uff1b The FILE data structure in the C standard I/O library usually includes a low level file descriptor for the object in question on Unix-like systems. The overall data structure provides additional abstraction and is instead known as a file handle. File descriptors for a single process, file table and inode table. Note that multiple file descriptors can refer to the same file table entry (e.g., as a result of the dup system call[ 3] :104 and that multiple file table entries can in turn refer to the same inode (if it has been opened multiple times; the table is still simplified because it represents inodes by file names, even though an inode can have multiple names ). File descriptor 3 does not refer to anything in the file table, signifying that it has been closed. NOTE: \u4e0a\u8ff0\u7684\u4e09\u5c42\u5bf9\u5e94\u5173\u7cfb\u5b58\u5728\u7740\u591a\u79cd\u53ef\u80fd\u7684\u60c5\u51b5\uff0c\u518d\u52a0\u4e0aOS\u63d0\u4f9b\u7684fork\u673a\u5236\uff08\u5b50\u8fdb\u7a0b\u7ee7\u627f\u7236\u8fdb\u7a0b\u7684file descriptor\u548cfile table entry\uff09\uff0c\u5404\u79cdIO\u64cd\u4f5c\uff08\u6bd4\u5982dup\uff0cread\uff0cwrite\uff09\u7b49\u7b49\u90fd\u5bfc\u81f4\u4e86\u95ee\u9898\u7684\u590d\u6742\u6027\uff1b \u6bd4\u5982\u5b58\u5728\u7740\u8fd9\u4e9b\u53ef\u80fd\u7684\u60c5\u51b5\uff1a - dup \uff0c\u540c\u4e00\u8fdb\u7a0b\u4e2d\uff0c\u591a\u4e2afile descriptor\u6307\u5411\u4e86\u540c\u4e00\u4e2afile table entry fork \u540e\uff0c\u7236\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u7684\u540c\u4e00\u4e2afile descriptor\u5171\u4eab\u540c\u4e00\u4e2afile table entry\uff08\u56e0\u4e3afile descriptor table\u662f\u6bcf\u4e2a\u8fdb\u7a0b\u79c1\u6709\u7684\uff0c\u6240\u4ee5\u8fd9\u79cd\u60c5\u51b5\u5176\u5b9e\u7c7b\u4f3c\u4e8e\u7b2c\u4e00\u79cd\u60c5\u51b5\uff0c\u5373\u591a\u4e2afile descriptor\u6307\u5411\u4e86\u540c\u4e00\u4e2afile table entry\uff09 \u4e0a\u9762\u63cf\u8ff0\u4e86file descriptor\u548cfile table entry\u4e4b\u95f4\u7684\u5bf9\u5e94\u5173\u7cfb\uff0c\u4e0b\u9762\u63cf\u8ff0file table entry\u548ciNode\u4e4b\u95f4\u7684\u5173\u7cfb\uff1a \u662f\u6709\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\u4e0d\u540c\u7684file table entry\u6307\u5411\u4e86\u540c\u4e00\u4e2aiNode\u7684\uff1b \u663e\u7136OS\u7684\u8fd9\u79cd\u8bbe\u8ba1\uff0c\u5c31\u5bfc\u81f4\u5f53\u4e00\u4e2a\u6587\u4ef6\u88ab\u591a\u4e2a\u4e0d\u540c\u7684process\u8fdb\u884cshare\u7684\u65f6\u5019\uff0c\u800c\u6bcf\u4e2aprocess\u90fd\u53ef\u4ee5\u6267\u884c\u4e00\u7cfb\u5217\u7684IO\u64cd\u4f5c\uff0c\u8fd9\u5c31\u5bfc\u81f4\u4e86\u53ef\u80fd\u5b58\u5728\u7684\u6570\u636e\u51b2\u7a81\u95ee\u9898\uff1b \u603b\u7684\u6765\u8bf4\uff0c\u6309\u7167OS\u7684\u8fd9\u603b\u7ed3\u6784\u8bbe\u8ba1\uff0c\u4ee5\u53caOS\u63d0\u4f9b\u7684\u5404\u79cd\u64cd\u4f5c\uff0c\u662f\u53ef\u4ee5\u603b\u7ed3\u51fa\u53ef\u80fd\u7684\u6240\u6709\u60c5\u5f62\u7684\uff1b Operations on file descriptors The following lists typical operations on file descriptors on modern Unix-like systems. Most of these functions are declared in the <unistd.h> header, but some are in the <fcntl.h> header instead. Creating file descriptors open () creat() socket() accept() socketpair () pipe() opendir() open_by_handle_at() (Linux) signalfd() (Linux) eventfd() (Linux) timerfd_create() (Linux) memfd_create() (Linux) userfaultfd() (Linux) Deriving file descriptors dirfd() fileno() Operations on a single file descriptor read (), write () readv(), writev() pread(), pwrite() recv(), send() recvmsg(), sendmsg() (including allowing sending FDs) sendfile() lseek() fstat() fchmod() fchown() fdopen() ftruncate() fsync() fdatasync() fstatvfs() dprintf() vmsplice() (Linux) Operations on multiple file descriptors select() , pselect() poll() epoll() (for Linux) kqueue() (for BSD-based systems). sendfile() splice() , tee() (for Linux) Operations on the file descriptor table The fcntl() function is used to perform various operations on a file descriptor, depending on the command argument passed to it. There are commands to get and set attributes associated with a file descriptor, including F_GETFD , F_SETFD , F_GETFL and F_SETFL . close() closefrom() (BSD and Solaris only; deletes all file descriptors greater than or equal to specified number) dup() (duplicates an existing file descriptor guaranteeing to be the lowest number available file descriptor) dup2() (the new file descriptor will have the value passed as an argument) fcntl ( F_DUPFD ) Operations that modify process state fchdir() (sets the process's current working directory based on a directory file descriptor) mmap() (maps ranges of a file into the process's address space) File locking flock() fcntl() ( F_GETLK , F_SETLK ) and F_SETLKW lockf() Sockets connect() bind() listen() accept() (creates a new file descriptor for an incoming connection) getsockname() getpeername() getsockopt() setsockopt() shutdown() (shuts down one or both halves of a full duplex connection) Miscellaneous ioctl() (a large collection of miscellaneous operations on a single file descriptor, often associated with a device) Upcoming operations A series of new operations on file descriptors has been added to many modern Unix-like systems, as well as numerous C libraries, to be standardized in a future version of POSIX .[ 5] The at suffix signifies that the function takes an additional first argument supplying a file descriptor from which relative paths are resolved, the forms lacking the at suffix thus becoming equivalent to passing a file descriptor corresponding to the current working directory . The purpose of these new operations is to defend against a certain class of TOCTTOU attacks. openat() faccessat() fchmodat() fchownat() fstatat() futimesat() linkat() mkdirat() mknodat() readlinkat() renameat() symlinkat() unlinkat() mkfifoat() fdopendir() File descriptors as capabilities Unix file descriptors behave in many ways as capabilities . They can be passed between processes across Unix domain sockets using the sendmsg() system call. Note, however, that what is actually passed is a reference to an \"open file description\" that has mutable state (the file offset, and the file status and access flags). This complicates the secure use of file descriptors as capabilities, since when programs share access to the same open file description, they can interfere with each other's use of it by changing its offset or whether it is blocking or non-blocking, for example.[ 6] [ 7] In operating systems that are specifically designed as capability systems, there is very rarely any mutable state associated with a capability itself. A Unix process' file descriptor table is an example of a C-list .","title":"File descriptor"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#file#descriptor","text":"","title":"File descriptor"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#file#descriptor_1","text":"In Unix and related computer operating systems, a file descriptor ( FD , less frequently fildes ) is an abstract indicator ( handle ) used to access a file or other input/output resource , such as a pipe or network socket . File descriptors form part of the POSIX application programming interface . A file descriptor is a non-negative integer , generally represented in the C programming language as the type int (negative values being reserved to indicate \"no value\" or an error condition). Each Unix process (except perhaps a daemon ) should expect to have three standard POSIX file descriptors, corresponding to the three standard streams : Integer value Name unistd.h symbolic constant stdio.h file stream 0 Standard input STDIN_FILENO stdin 1 Standard output STDOUT_FILENO stdout 2 Standard error STDERR_FILENO stderr","title":"\u7ef4\u57fa\u767e\u79d1File descriptor"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#overview","text":"In the traditional implementation of Unix, file descriptors index into a per-process file descriptor table maintained by the kernel, that in turn indexes into a system-wide table of files opened by all processes, called the file table . This table records the mode with which the file (or other resource) has been opened: for reading, writing, appending, and possibly other modes. It also indexes into a third table called the inode table that describes the actual underlying files. To perform input or output, the process passes the file descriptor to the kernel through a system call , and the kernel will access the file on behalf of the process. The process does not have direct access to the file or inode tables . NOTE : \u5728APUE\u76843.10 File Sharing\u4e5f\u63cf\u8ff0\u4e86\u8fd9\u90e8\u5206\u5185\u5bb9\uff1b\u9700\u8981\u6ce8\u610f\u7684\u662f\uff1athe data structures used by the kernel for all I/O.\u5373\u6240\u6709\u7684IO\u90fd\u662f\u91c7\u7528\u7684\u7c7b\u4f3c\u4e8e\u4e0a\u8ff0\u7684\u7ed3\u6784\uff1b\u5e76\u4e14\u4e0a\u8ff0\u7ed3\u6784\u9700\u8981\u548c Process control block \u4e00\u8d77\u6765\u7406\u89e3\u624d\u80fd\u591f\u5f88\u597d\u7684\u5bf9Unix OS\u7684IO\u6709\u4e00\u4e2a\u6574\u4f53\u7684\u8ba4\u77e5\uff1b NOTE: \u9700\u8981\u6ce8\u610f\uff0c\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u63d0\u53ca file descriptor table \u548c file table \u65f6\uff0c\u524d\u9762\u5206\u522b\u52a0\u4e0a\u4e86\u4fee\u9970\u8bed\uff1a per-process \u548c system-wide \uff1b\u8fd9\u4e24\u4e2a\u4fee\u9970\u8bed\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u9700\u8981\u5c06\u5b83\u4eec\u548cthe data structures used by the kernel for all I/O\u4e00\u8d77\u6765\u8fdb\u884c\u7406\u89e3\uff1b\u56e0\u4e3a file descriptor table \u7684scope\u662fprocess\uff0c\u5373\u6bcf\u4e2aprocess\u90fd\u6709\u4e00\u5957\u81ea\u5df1\u7684 file descriptor table \uff0c\u6240\u4ee5\u6bcf\u4e2aprocess\u7684file descriptor\u90fd\u662f\u4ece0\u5f00\u59cb\u589e\u957f\uff1b\u663e\u7136\u6bd4\u8f83\u4e24\u4e2aprocess\u7684file descriptor\u662f\u6ca1\u6709\u610f\u4e49\u7684\uff08\u5904\u74060,1,2\uff0c\u56e0\u4e3a\u5b83\u4eec\u90fd\u5df2\u7ecf\u88ab\u9ed8\u8ba4\u7ed1\u5b9a\u5230 STDIN_FILENO , STDOUT_FILENO , STDERR_FILENO \uff09\uff1b\u800cfile table\u7684scope\u662fsystem\uff0c\u5373\u6240\u6709\u7684process\u90fd\u5c06\u5171\u4eabfile table\uff1b NOTE: \u6bcf\u6b21\u8c03\u7528 open \u7cfb\u7edf\u8c03\u7528\uff0c\u90fd\u4f1a\u521b\u5efa\u4e00\u4e2afile table entry On Linux , the set of file descriptors open in a process can be accessed under the path /proc/PID/fd/ , where PID is the process identifier . In Unix-like systems, file descriptors can refer to any Unix file type named in a file system. As well as regular files, this includes directories , block and character devices (also called \"special files\"), Unix domain sockets , and named pipes . File descriptors can also refer to other objects that do not normally exist in the file system, such as anonymous pipes and network sockets . SUMMARY : Everything is a file \uff1b\u4ecekernel\u5b9e\u73b0\u7684\u89d2\u5ea6\u6765\u770b\u770b\u5f85everything in Unix is file\uff0cUnix-like system\u662f monolithic kernel \uff0c\u4e0a\u9762\u63d0\u5230\u7684\u8fd9\u4e9bdevice\u6216\u8005file\u90fd\u662f\u7531kernel\u6765\u8fdb\u884c\u7ef4\u62a4\uff0c\u5b83\u4eec\u90fd\u6709\u5bf9\u5e94\u7684kernel structure\uff1b\u6211\u4eec\u901a\u8fc7file descriptor\u6765\u5f15\u7528\u8fd9\u4e9bkernel structure\uff0c\u6211\u4eec\u53ea\u80fd\u591f\u901a\u8fc7system call\u6765\u5bf9\u8fd9\u4e9bkernel structure\u8fdb\u884c\u64cd\u4f5c\uff1b The FILE data structure in the C standard I/O library usually includes a low level file descriptor for the object in question on Unix-like systems. The overall data structure provides additional abstraction and is instead known as a file handle. File descriptors for a single process, file table and inode table. Note that multiple file descriptors can refer to the same file table entry (e.g., as a result of the dup system call[ 3] :104 and that multiple file table entries can in turn refer to the same inode (if it has been opened multiple times; the table is still simplified because it represents inodes by file names, even though an inode can have multiple names ). File descriptor 3 does not refer to anything in the file table, signifying that it has been closed. NOTE: \u4e0a\u8ff0\u7684\u4e09\u5c42\u5bf9\u5e94\u5173\u7cfb\u5b58\u5728\u7740\u591a\u79cd\u53ef\u80fd\u7684\u60c5\u51b5\uff0c\u518d\u52a0\u4e0aOS\u63d0\u4f9b\u7684fork\u673a\u5236\uff08\u5b50\u8fdb\u7a0b\u7ee7\u627f\u7236\u8fdb\u7a0b\u7684file descriptor\u548cfile table entry\uff09\uff0c\u5404\u79cdIO\u64cd\u4f5c\uff08\u6bd4\u5982dup\uff0cread\uff0cwrite\uff09\u7b49\u7b49\u90fd\u5bfc\u81f4\u4e86\u95ee\u9898\u7684\u590d\u6742\u6027\uff1b \u6bd4\u5982\u5b58\u5728\u7740\u8fd9\u4e9b\u53ef\u80fd\u7684\u60c5\u51b5\uff1a - dup \uff0c\u540c\u4e00\u8fdb\u7a0b\u4e2d\uff0c\u591a\u4e2afile descriptor\u6307\u5411\u4e86\u540c\u4e00\u4e2afile table entry fork \u540e\uff0c\u7236\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u7684\u540c\u4e00\u4e2afile descriptor\u5171\u4eab\u540c\u4e00\u4e2afile table entry\uff08\u56e0\u4e3afile descriptor table\u662f\u6bcf\u4e2a\u8fdb\u7a0b\u79c1\u6709\u7684\uff0c\u6240\u4ee5\u8fd9\u79cd\u60c5\u51b5\u5176\u5b9e\u7c7b\u4f3c\u4e8e\u7b2c\u4e00\u79cd\u60c5\u51b5\uff0c\u5373\u591a\u4e2afile descriptor\u6307\u5411\u4e86\u540c\u4e00\u4e2afile table entry\uff09 \u4e0a\u9762\u63cf\u8ff0\u4e86file descriptor\u548cfile table entry\u4e4b\u95f4\u7684\u5bf9\u5e94\u5173\u7cfb\uff0c\u4e0b\u9762\u63cf\u8ff0file table entry\u548ciNode\u4e4b\u95f4\u7684\u5173\u7cfb\uff1a \u662f\u6709\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\u4e0d\u540c\u7684file table entry\u6307\u5411\u4e86\u540c\u4e00\u4e2aiNode\u7684\uff1b \u663e\u7136OS\u7684\u8fd9\u79cd\u8bbe\u8ba1\uff0c\u5c31\u5bfc\u81f4\u5f53\u4e00\u4e2a\u6587\u4ef6\u88ab\u591a\u4e2a\u4e0d\u540c\u7684process\u8fdb\u884cshare\u7684\u65f6\u5019\uff0c\u800c\u6bcf\u4e2aprocess\u90fd\u53ef\u4ee5\u6267\u884c\u4e00\u7cfb\u5217\u7684IO\u64cd\u4f5c\uff0c\u8fd9\u5c31\u5bfc\u81f4\u4e86\u53ef\u80fd\u5b58\u5728\u7684\u6570\u636e\u51b2\u7a81\u95ee\u9898\uff1b \u603b\u7684\u6765\u8bf4\uff0c\u6309\u7167OS\u7684\u8fd9\u603b\u7ed3\u6784\u8bbe\u8ba1\uff0c\u4ee5\u53caOS\u63d0\u4f9b\u7684\u5404\u79cd\u64cd\u4f5c\uff0c\u662f\u53ef\u4ee5\u603b\u7ed3\u51fa\u53ef\u80fd\u7684\u6240\u6709\u60c5\u5f62\u7684\uff1b","title":"Overview"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#operations#on#file#descriptors","text":"The following lists typical operations on file descriptors on modern Unix-like systems. Most of these functions are declared in the <unistd.h> header, but some are in the <fcntl.h> header instead.","title":"Operations on file descriptors"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#creating#file#descriptors","text":"open () creat() socket() accept() socketpair () pipe() opendir() open_by_handle_at() (Linux) signalfd() (Linux) eventfd() (Linux) timerfd_create() (Linux) memfd_create() (Linux) userfaultfd() (Linux)","title":"Creating file descriptors"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#deriving#file#descriptors","text":"dirfd() fileno()","title":"Deriving file descriptors"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#operations#on#a#single#file#descriptor","text":"read (), write () readv(), writev() pread(), pwrite() recv(), send() recvmsg(), sendmsg() (including allowing sending FDs) sendfile() lseek() fstat() fchmod() fchown() fdopen() ftruncate() fsync() fdatasync() fstatvfs() dprintf() vmsplice() (Linux)","title":"Operations on a single file descriptor"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#operations#on#multiple#file#descriptors","text":"select() , pselect() poll() epoll() (for Linux) kqueue() (for BSD-based systems). sendfile() splice() , tee() (for Linux)","title":"Operations on multiple file descriptors"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#operations#on#the#file#descriptor#table","text":"The fcntl() function is used to perform various operations on a file descriptor, depending on the command argument passed to it. There are commands to get and set attributes associated with a file descriptor, including F_GETFD , F_SETFD , F_GETFL and F_SETFL . close() closefrom() (BSD and Solaris only; deletes all file descriptors greater than or equal to specified number) dup() (duplicates an existing file descriptor guaranteeing to be the lowest number available file descriptor) dup2() (the new file descriptor will have the value passed as an argument) fcntl ( F_DUPFD )","title":"Operations on the file descriptor table"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#operations#that#modify#process#state","text":"fchdir() (sets the process's current working directory based on a directory file descriptor) mmap() (maps ranges of a file into the process's address space)","title":"Operations that modify process state"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#file#locking","text":"flock() fcntl() ( F_GETLK , F_SETLK ) and F_SETLKW lockf()","title":"File locking"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#sockets","text":"connect() bind() listen() accept() (creates a new file descriptor for an incoming connection) getsockname() getpeername() getsockopt() setsockopt() shutdown() (shuts down one or both halves of a full duplex connection)","title":"Sockets"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#miscellaneous","text":"ioctl() (a large collection of miscellaneous operations on a single file descriptor, often associated with a device)","title":"Miscellaneous"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#upcoming#operations","text":"A series of new operations on file descriptors has been added to many modern Unix-like systems, as well as numerous C libraries, to be standardized in a future version of POSIX .[ 5] The at suffix signifies that the function takes an additional first argument supplying a file descriptor from which relative paths are resolved, the forms lacking the at suffix thus becoming equivalent to passing a file descriptor corresponding to the current working directory . The purpose of these new operations is to defend against a certain class of TOCTTOU attacks. openat() faccessat() fchmodat() fchownat() fstatat() futimesat() linkat() mkdirat() mknodat() readlinkat() renameat() symlinkat() unlinkat() mkfifoat() fdopendir()","title":"Upcoming operations"},{"location":"Programming/Philosophy/Everything-is-a-file/File-descriptor/#file#descriptors#as#capabilities","text":"Unix file descriptors behave in many ways as capabilities . They can be passed between processes across Unix domain sockets using the sendmsg() system call. Note, however, that what is actually passed is a reference to an \"open file description\" that has mutable state (the file offset, and the file status and access flags). This complicates the secure use of file descriptors as capabilities, since when programs share access to the same open file description, they can interfere with each other's use of it by changing its offset or whether it is blocking or non-blocking, for example.[ 6] [ 7] In operating systems that are specifically designed as capability systems, there is very rarely any mutable state associated with a capability itself. A Unix process' file descriptor table is an example of a C-list .","title":"File descriptors as capabilities"},{"location":"Programming/Signal/","text":"Signal \u5185\u5bb9\uff1a APUE Chapter 10 Signals signal\u662f\u4ec0\u4e48\uff1f 10.2 Signal Concepts\uff1aSignals are software interrupts. \u4fe1\u53f7\u7684\u6765\u6e90\uff1f 10.2 Signal Concepts \u8fd9\u4e00\u8282\u5bf9\u4fe1\u53f7\u6765\u6e90\u603b\u7ed3\u7684\u975e\u5e38\u597d\u3002\u53ef\u4ee5\u770b\u5230signal\u7684\u6765\u6e90\u662f\u975e\u5e38\u5e7f\u6cdb\u7684\u3002\u5728\u9605\u8bfb Understanding.The.Linux.kernel.3 rd .Edition \u7684Chapter 4. Interrupts and Exceptions\u65f6\uff0c\u6211\u601d\u8003\u4e86\u5982\u4e0b\u95ee\u9898\uff1aUnix signal\u90fd\u5bf9\u5e94\u7684\u662fexceptions\uff1f\u663e\u7136\u4e0d\u662f\u7684\uff0c\u6bd4\u5982 SIGINT \u5c31\u4e0d\u662f\u6e90\u81ea\u4e8eexception\u3002\u5728\u672c\u7ae0\u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u603b\u7ed3\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u8be5\u6e05\u695a\uff0cexception\u662f\u4fe1\u53f7\u7684\u4f17\u591a\u6765\u6e90\u4e2d\u7684\u4e00\u79cd\u3002 Understanding.The.Linux.kernel.3 rd .Edition Chapter 4. Interrupts and Exceptions Chapter 11. Signals SIGNAL(7)","title":"Introduction"},{"location":"Programming/Signal/#signal","text":"\u5185\u5bb9\uff1a","title":"Signal"},{"location":"Programming/Signal/#apue","text":"","title":"APUE"},{"location":"Programming/Signal/#chapter#10#signals","text":"signal\u662f\u4ec0\u4e48\uff1f 10.2 Signal Concepts\uff1aSignals are software interrupts. \u4fe1\u53f7\u7684\u6765\u6e90\uff1f 10.2 Signal Concepts \u8fd9\u4e00\u8282\u5bf9\u4fe1\u53f7\u6765\u6e90\u603b\u7ed3\u7684\u975e\u5e38\u597d\u3002\u53ef\u4ee5\u770b\u5230signal\u7684\u6765\u6e90\u662f\u975e\u5e38\u5e7f\u6cdb\u7684\u3002\u5728\u9605\u8bfb Understanding.The.Linux.kernel.3 rd .Edition \u7684Chapter 4. Interrupts and Exceptions\u65f6\uff0c\u6211\u601d\u8003\u4e86\u5982\u4e0b\u95ee\u9898\uff1aUnix signal\u90fd\u5bf9\u5e94\u7684\u662fexceptions\uff1f\u663e\u7136\u4e0d\u662f\u7684\uff0c\u6bd4\u5982 SIGINT \u5c31\u4e0d\u662f\u6e90\u81ea\u4e8eexception\u3002\u5728\u672c\u7ae0\u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u603b\u7ed3\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u8be5\u6e05\u695a\uff0cexception\u662f\u4fe1\u53f7\u7684\u4f17\u591a\u6765\u6e90\u4e2d\u7684\u4e00\u79cd\u3002","title":"Chapter 10 Signals"},{"location":"Programming/Signal/#understandingthelinuxkernel3rdedition","text":"","title":"Understanding.The.Linux.kernel.3rd.Edition"},{"location":"Programming/Signal/#chapter#4#interrupts#and#exceptions","text":"","title":"Chapter 4. Interrupts and Exceptions"},{"location":"Programming/Signal/#chapter#11#signals","text":"","title":"Chapter 11. Signals"},{"location":"Programming/Signal/#signal7","text":"","title":"SIGNAL(7)"},{"location":"Programming/Signal/Signal-handler/","text":"Signal handler Linux C catching kill signal for graceful termination Terminating a program with calling atexit functions (Linux) What's different between Ctrl+Z and Ctrl+C in Unix command line? What is the difference between Ctrl-z and Ctrl-c in the terminal?","title":"Signal handler"},{"location":"Programming/Signal/Signal-handler/#signal#handler","text":"Linux C catching kill signal for graceful termination Terminating a program with calling atexit functions (Linux) What's different between Ctrl+Z and Ctrl+C in Unix command line? What is the difference between Ctrl-z and Ctrl-c in the terminal?","title":"Signal handler"},{"location":"Programming/Signal/Signal-note/","text":"\u5728APUE\u7684chapter 10 signals\u4e2d\u6709\u8fd9\u6837\u7684\u63cf\u8ff0\uff1a Signals are software interrupts. Signals are classic examples of asynchronous events . They occur at what appear to be random times to the process. The process can\u2019t simply test a variable (such as errno ) to see whether a signal has occurred; instead, the process has to tell the kernel \u2018\u2018if and when this signal occurs, do the following.\u2019\u2019 **\u5f02\u6b65**\u503e\u5411\u4e8e\u662f\u5f53\uff0c\u67d0\u4e2a\u4e8b\u60c5\u53d1\u751f\uff0c\u65f6\u6211\u5e94\u8be5\u505a\u4ec0\u4e48\u3002\u6240\u4ee5\u5f02\u6b65\u5f80\u5f80\u5c31\u9700\u8981\u6ce8\u518c\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u5c31\u50cfAPUE\u7684\u7b2c\u5341\u7ae0\u7684\u7b2c\u4e00\u8282\u4e2d\u6240\u4ecb\u7ecd\u7684\u90a3\u6837\u3002Unix\u4e2d\u7684\u5f02\u6b65IO\u90fd\u662f\u57fa\u4e8e\u4fe1\u53f7\u7684\u3002 event\u7684executor\u5728\u6ca1\u6709event\u7684\u60c5\u51b5\u4e0b\u5f80\u5f80\u4f1a\u963b\u585e\u81ea\u5df1\u3002 \u800c\u5f53\u63d0\u53casignal\u65f6\u4ed6\u548cevent\u7684\u8bed\u4e49\u5c31\u6709\u6240\u4e0d\u540c\u4e86\uff0c\u4fe1\u53f7\u5f80\u5f80\u662f\u7531\u64cd\u4f5c\u7cfb\u7edf\u800c\u4ea7\u751f\u7684\uff0c\u800c\u4e0d\u662f\u7531\u5e94\u7528\u7a0b\u5e8f\u6765\u3002\u6240\u4ee5\u6211\u4eec\u5e94\u7528\u7a0b\u5e8f\u662f\u4fe1\u53f7\u7684\u63a5\u53d7\u8005\uff0c\u4fe1\u53f7\u7684\u4ea7\u751f\u8005\u662f\u64cd\u4f5c\u7cfb\u7edf\u3002\u8fd9\u662f\u4fe1\u53f7\u548c\u4e8b\u4ef6\u4e4b\u95f4\u7684\u5dee\u5f02\u4e4b\u4e00\uff1b\u53ef\u4ee5\u8bf4\u7b2c\u4e00\u79cd\u5dee\u5f02\u51b3\u5b9a\u4e86\u5728\u5bf9\u4fe1\u53f7\u548c\u6d88\u606f\u8fdb\u884creact\u7684\u65f6\u5019\u91c7\u53d6\u7684\u662f\u5b8c\u5168\u4e0d\u540c\u7684\u65b9\u5f0f\uff1a\u7531\u4e8e\u4fe1\u53f7\u662f\u7531**OS**\u6240\u4ea7\u751f\uff0c\u6240\u4ee5\u5bf9signal\u7684\u6240\u6709\u7684\u64cd\u4f5c\u90fd\u662f\u6309\u7167OS\u7684\u63a5\u53e3\u6765\u8fdb\u884c\uff0c\u5e76\u4e14\u4fe1\u53f7\u7684\u4ea7\u751f\u662frandom\u7684\uff1aSignals are classic examples of asynchronous events \uff0c\u5e76\u4e14process\u7684 flow of execution \u662f\u7531OS\u6765\u8fdb\u884c\u63a7\u5236\u7684\uff0c\u6240\u4ee5OS\u6709\u80fd\u529b\u6765\u51b3\u5b9a\u5f53\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\uff0cinterrupts the target process' normal flow of execution to deliver the signal\uff08\u8fd9\u4e2a\u89c2\u70b9\u6458\u53d6\u81ea Signal (IPC) \uff09\uff0c\u5373OS\u6709\u80fd\u529b\u5728\u6536\u5230signal\u7684\u65f6\u5019\uff0c\u4e2d\u65adprocess\u5f53\u524d\u7684\u6267\u884c\u800c\u8f6c\u53bb\u6267\u884csignal handler\uff1b\u800cmessage\u7b49\u5f80\u5f80\u90fd\u662f\u7531application\u4ea7\u751f\u7684\uff0capplication\u65e0\u6cd5\u5411OS\u90a3\u6837\u6765interrupt process' normal flow of execution \uff0c\u800c\u53ea\u80fd\u591f\u5728\u6ca1\u6709message\u7684\u65f6\u5019\uff0c\u5c31\u963b\u585e\u81ea\u5df1\uff0c\u5728\u6536\u5230message\u7684\u65f6\u5019\uff0c\u8f6c\u53bb\u6267\u884c\u76f8\u5e94\u7684\u51fd\u6570\uff1b \u9700\u8981\u6ce8\u610f\u7684\u662f\u4fe1\u53f7\u662f\u5f02\u6b65\u4e8b\u4ef6\uff0c\u4f46\u662f\u5f02\u6b65\u4e8b\u4ef6\u4e0d\u4e00\u5b9a\u662f\u4fe1\u53f7\u3002","title":"Signal-note"},{"location":"Programming/Terminal/","text":"","title":"Introduction"},{"location":"Programming/Terminal/Diary/","text":"Q&A 20180912 \u4eca\u5929\u5728\u9605\u8bfbAPUE CH9 \u8fdb\u7a0b\u5173\u7cfb\u7ae0\u8282\u7684\u65f6\u5019\uff0c\u4ea7\u751f\u4e86\u5982\u4e0b\u95ee\u9898\uff1a /etc/ttys \u8bbe\u5907\u914d\u7f6e\u6587\u4ef6\u4f55\u5728\uff1f gettty \u7684\u529f\u80fd\u662f\u4ec0\u4e48\uff1f \u5728\u767b\u5f55\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f55\u65f6\u8c03\u7528 setsid \u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u4f1a\u8bdd\uff1f \u603b\u7ed3 \u901a\u8fc7**\u4e32\u884c\u7ec8\u7aef**\u767b\u5f55\u7cfb\u7edf\u548c\u901a\u8fc7**\u7f51\u7edc**\u767b\u5f55\u7cfb\u7edf\u4e4b\u95f4\u7684\u5dee\u5f02 \u7f51\u7edc\u767b\u5f55\u7684\u4f18\u52bf\uff1a\u4e00\u4e2a\u7cfb\u7edf\u53ef\u4ee5\u540c\u65f6\u5141\u8bb8\u591a\u4e2a\u7528\u6237\u767b\u5f55 20200318 \u4eca\u5929\u5728\u9605\u8bfb linenoise \u7684\u6587\u6863\u65f6\uff0c\u5176\u4e2d\u6709\u5173\u4e8etty\u7684\u63cf\u8ff0\u3002","title":"Q&A"},{"location":"Programming/Terminal/Diary/#qa","text":"","title":"Q&amp;A"},{"location":"Programming/Terminal/Diary/#20180912","text":"\u4eca\u5929\u5728\u9605\u8bfbAPUE CH9 \u8fdb\u7a0b\u5173\u7cfb\u7ae0\u8282\u7684\u65f6\u5019\uff0c\u4ea7\u751f\u4e86\u5982\u4e0b\u95ee\u9898\uff1a /etc/ttys \u8bbe\u5907\u914d\u7f6e\u6587\u4ef6\u4f55\u5728\uff1f gettty \u7684\u529f\u80fd\u662f\u4ec0\u4e48\uff1f \u5728\u767b\u5f55\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f55\u65f6\u8c03\u7528 setsid \u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u4f1a\u8bdd\uff1f","title":"20180912"},{"location":"Programming/Terminal/Diary/#_1","text":"\u901a\u8fc7**\u4e32\u884c\u7ec8\u7aef**\u767b\u5f55\u7cfb\u7edf\u548c\u901a\u8fc7**\u7f51\u7edc**\u767b\u5f55\u7cfb\u7edf\u4e4b\u95f4\u7684\u5dee\u5f02 \u7f51\u7edc\u767b\u5f55\u7684\u4f18\u52bf\uff1a\u4e00\u4e2a\u7cfb\u7edf\u53ef\u4ee5\u540c\u65f6\u5141\u8bb8\u591a\u4e2a\u7528\u6237\u767b\u5f55","title":"\u603b\u7ed3"},{"location":"Programming/Terminal/Diary/#20200318","text":"\u4eca\u5929\u5728\u9605\u8bfb linenoise \u7684\u6587\u6863\u65f6\uff0c\u5176\u4e2d\u6709\u5173\u4e8etty\u7684\u63cf\u8ff0\u3002","title":"20200318"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/","text":"The TTY demystified History The use cases Processes Jobs and sessions The following shell interactions... ...correspond to these processes... ...and these kernel structures. Signal madness SIGHUP SIGINT SIGQUIT SIGPIPE SIGCHLD SIGSTOP SIGCONT SIGTSTP SIGTTIN SIGTTOU SIGWINCH An example Flow control and blocking I/O Configuring the TTY device Conclusion The TTY demystified \u6ce8\uff1ademystify \u63ed\u79d8 The TTY subsystem is central to the design of Linux, and UNIX in general. Unfortunately, its importance is often overlooked, and it is difficult to find good introductory articles about it. I believe that a basic understanding of TTYs in Linux is essential for the developer and the advanced user. \u5728\u8fd9\u7bc7\u6587\u7ae0: tty \u4e2d\u4ecb\u7ecd\u4e86TTY\u6240\u4ee3\u8868\u7684\u542b\u4e49 Beware, though: What you are about to see is not particularly elegant. In fact, the TTY subsystem \u2014 while quite functional from a user's point of view \u2014 is a twisty(\u66f2\u6298) little mess of special cases. To understand how this came to be, we have to go back in time. History In 1869, the stock ticker (\u80a1\u7968\u62a5\u4ef7\u673a) was invented. It was an electro-mechanical machine consisting of a typewriter, a long pair of wires and a ticker tape printer, and its purpose was to distribute stock prices over long distances in realtime. This concept gradually evolved into the faster, ASCII-based teletype . Teletypes were once connected across the world in a large network, called Telex , which was used for transferring commercial telegrams(\u5546\u4e1a\u7535\u62a5), but the teletypes weren't connected to any computers yet. TRANSLAITION : 1869\u5e74\uff0c\u80a1\u7968\u4ee3\u7801\u88ab\u53d1\u660e\u4e86\u3002 \u5b83\u662f\u4e00\u53f0\u673a\u7535\u4e00\u4f53\u673a\uff0c\u7531\u4e00\u53f0\u6253\u5b57\u673a\uff0c\u4e00\u5bf9\u957f\u7535\u7ebf\u548c\u4e00\u53f0\u81ea\u52a8\u6536\u62a5\u673a\u7ec4\u6210\uff0c\u5176\u76ee\u7684\u662f\u5b9e\u65f6\u5206\u914d\u957f\u8ddd\u79bb\u7684\u80a1\u7968\u4ef7\u683c\u3002 \u8fd9\u4e2a\u6982\u5ff5\u9010\u6e10\u6f14\u53d8\u6210\u66f4\u5feb\uff0c\u57fa\u4e8eASCII\u7684\u7535\u4f20\u6253\u5b57\u673a\u3002 Teletypes\u66fe\u7ecf\u5728\u4e00\u4e2a\u540d\u4e3aTelex\u7684\u5927\u578b\u7f51\u7edc\u4e2d\u8fde\u63a5\u5230\u4e16\u754c\u5404\u5730\uff0c\u8be5\u7f51\u7edc\u7528\u4e8e\u4f20\u8f93\u5546\u4e1a\u7535\u62a5\uff0c\u4f46\u7535\u8bdd\u7c7b\u578b\u5c1a\u672a\u8fde\u63a5\u5230\u4efb\u4f55\u8ba1\u7b97\u673a\u3002 Meanwhile, however, the computers \u2014 still quite large and primitive, but able to multitask \u2014 were becoming powerful enough to be able to interact with users in realtime. When the command line eventually replaced the old batch processing model, teletypes were used as input and output devices , because they were readily available on the market. \u603b\u7ed3\uff1a\u53c2\u89c1 getty \uff0c\u8fd9\u7bc7\u6587\u7ae0\u4e2d\u4ecb\u7ecd\u7684\u5185\u5bb9\u548c\u4e0a\u9762\u8fd9\u6bb5\u6709\u5173\u3002 There was a plethora\uff08\u8fc7\u591a\uff0c\u8fc7\u5269\uff09 of teletype models around, all slightly different, so some kind of software compatibility layer was called for\uff08\u9700\u8981\uff09. In the UNIX world, the approach was to let the operating system kernel handle all the low-level details, such as word length, baud rate\uff08\u6ce2\u7279\u7387\uff09, flow control, parity\uff08\u5947\u5076\u6821\u9a8c\uff09, control codes for rudimentary line editing\uff08\u7528\u4e8e\u57fa\u672c\u884c\u7f16\u8f91\u7684\u63a7\u5236\u4ee3\u7801\uff09 and so on. Fancy cursor movements, color output and other advanced features made possible in the late 1970s by solid state video terminals \uff08\u56fa\u6001\u89c6\u9891\u7ec8\u7aef\uff09 such as the VT-100, were left to the applications. In present time, we find ourselves in a world where physical teletypes and video terminals are practically extinct\uff08\u7edd\u8ff9\uff09. Unless you visit a museum or a hardware enthusiast\uff08\u786c\u4ef6\u7231\u597d\u8005\uff09, all the TTYs you're likely to see will be emulated video terminals \u2014 software simulations of the real thing. But as we shall see, the legacy from the old cast-iron beasts is still lurking beneath the surface. \u603b\u7ed3\uff1a\u5982\u4eca\u6211\u4eec\u6240\u89c1\u7684TTY\u90fd\u662femulated video terminals \uff1b\u6700\u540e\u4e00\u53e5\u8bdd\u7684\u8868\u540d\u610f\u601d\u662f\uff1a\u6765\u81ea\u65e7\u94f8\u94c1\u91ce\u517d\u7684\u9057\u4ea7\u4ecd\u6f5c\u4f0f\u5728\u6c34\u9762\u4e4b\u4e0b\uff1b\u5f15\u7533\u7684\u542b\u4e49\u5c31\u662f\uff1a\u867d\u7136\u5916\u5728\u53d8\u5316\u4e86\uff0c\u4f46\u662f\u672c\u8d28\u662f\u672a\u53d8\u7684\u3002 The use cases A user types at a terminal (a physical teletype). This terminal is connected through a pair of wires to a UART (Universal Asynchronous Receiver and Transmitter) on the computer. The operating system contains a UART driver which manages the physical transmission of bytes, including parity checks(\u5947\u5076\u6821\u9a8c) and flow control. In a na\u00efve system, the UART driver would then deliver the incoming bytes directly to some application process. But such an approach would lack the following essential features: \u603b\u7ed3\uff1a\u4ece\u4e0a\u56fe\u6765\u770b\uff0c UART*\u5e76\u6ca1\u6709\u76f4\u63a5\u548capplication process \u8fdb\u884cconnect\uff0c\u800c\u662f\u4e2d\u95f4\u8fd8\u6709*line discipline*\u548c*tty Line editing \uff08\u884c\u7f16\u8f91\uff09. Most users make mistakes while typing, so a backspace key\uff08\u9000\u683c\u952e\uff09 is often useful. This could of course be implemented by the applications themselves, but in accordance with the UNIX design philosophy, applications should be kept as simple as possible. So as a convenience, the operating system provides an editing buffer\uff08\u7f16\u8f91\u7f13\u51b2\u533a\uff09 and some rudimentary\uff08\u57fa\u672c\u7684\uff09 editing commands (backspace, erase word, clear line, reprint), which are enabled by default inside the line discipline \uff08\u884c\u89c4\u5219\uff09. Advanced applications may disable these features by putting the line discipline \uff08\u884c\u89c4\u5219\uff09 in raw mode instead of the default cooked (or canonical ) mode. Most interactive applications (editors, mail user agents, shells, all programs relying on curses or readline ) run in raw mode, and handle all the line editing commands themselves. The line discipline also contains options for character echoing and automatic conversion between carriage returns and linefeeds. Think of it as a primitive kernel-level sed(1) , if you like. Incidentally, the kernel provides several different line disciplines . Only one of them is attached to a given serial device at a time. The default discipline, which provides line editing, is called N_TTY ( drivers/char/n_tty.c , if you're feeling adventurous). Other disciplines are used for other purposes, such as managing packet switched data (ppp, IrDA, serial mice), but that is outside the scope of this article. \u603b\u7ed3\uff1a\u4e0a\u56fe\u4e2d\u7684**Line discipline**\u5c31\u662f\u4e3a\u4e86**Line Editing**\u529f\u80fd\u7684\u3002 Session management. The user probably wants to run several programs simultaneously, and interact with them one at a time\uff08\u4e00\u6b21\u4e00\u4e2a\uff09. If a program goes into an endless loop, the user may want to kill it or suspend it. Programs that are started in the background should be able to execute until they try to write to the terminal, at which point they should be suspended. Likewise, user input should be directed to the foreground program only. The operating system implements these features in the TTY driver ( drivers/char/tty_io.c ). An operating system process is \"alive\" (has an execution context ), which means that it can perform actions. The TTY driver is not alive; in object oriented terminology, the TTY driver is a passive object \uff08\u88ab\u52a8\uff09. It has some data fields and some methods, but the only way it can actually do something is when one of its methods gets called from the context of a process or a kernel interrupt handler. The line discipline is likewise a passive entity. \u603b\u7ed3\uff1a\u5173\u4e8epassive object\u53c2\u89c1 Passive data structure .\u5176\u5b9e\u662f\u770b\u4e86\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u6211\u624d\u60f3\u8d77passive object\u7684\u542b\u4e49\uff0c\u5b83\u7684\u6b63\u786e\u542b\u4e49\u5728\u4e8epassive\u3002 \u603b\u7ed3\uff1a\u4e0a\u56fe\u4e2d\u7684TTY driver\u5c31\u662f\u4e3a\u4e86\u5b9e\u73b0Session management\u7684\u3002 Together, a particular triplet of UART driver, line discipline instance and TTY driver may be referred to as a TTY device , or sometimes just TTY. A user process can affect the behaviour of any TTY device by manipulating the corresponding device file under /dev . Write permissions to the device file are required, so when a user logs in on a particular TTY, that user must become the owner of the device file . This is traditionally done by the login(1) program, which runs with root privileges. \u603b\u7ed3\uff1a\u6b64\u5904\u7ed9\u51fa\u4e86\u5728\u73b0\u5728\u7684linux\u7cfb\u7edf\u4e2d\uff0cTTY\u7684\u8be6\u7ec6\u7684\uff0c\u5e95\u5c42\u7684\u542b\u4e49\u3002 \u603b\u7ed3\uff1a\u901a\u8fc7 tty \u547d\u4ee4\u53ef\u4ee5\u83b7\u5f97\u5f53\u524dterminal\u7684device file \u3002 The physical line in the previous diagram could of course be a long-distance phone line: SUMMARY : \u8fd9\u79cd\u60c5\u51b5\u663e\u7136\u662f\u901a\u8fc7\u7f51\u7edc\u8fdb\u884c\u8fde\u63a5\u7684\u60c5\u51b5\uff1b This does not change much, except that the system now has to handle a modem hangup situation as well. Let's move on to a typical desktop system. This is how the Linux console works: The TTY driver and line discipline behave just like in the previous examples, but there is no UART or physical terminal involved anymore. Instead, a video terminal (a complex state machine including a frame buffer of characters and graphical character attributes) is emulated in software, and rendered to a VGA display. \u603b\u7ed3\uff1a\u5bf9\u6bd4\u8be5\u56fe\u548c\u524d\u56fe\uff0c\u5c31\u53ef\u4ee5\u5bf9\u6bd4\u5b83\u4eec\u4e4b\u95f4\u7684\u5dee\u5f02\uff0c\u8fd9\u79cd\u5bf9\u6bd4\u4e5f\u5370\u8bc1\u4e86\u4f5c\u8005\u5728\u7b2c\u516d\u6bb5\u4e2d\u6240\u63d0\u53ca\u7684**emulated video terminals**\u3002\u4ece\u4e0a\u56fe\u53ef\u4ee5\u770b\u51fa\uff0c**terminal emulator**\u7684output\u662fVGA driver\uff0c\u5b83\u7684input\u662fkeyboard driver\uff1b The console subsystem is somewhat rigid\uff08\u6b7b\u677f\u7684\uff09. Things get more flexible (and abstract) if we move the terminal emulation into userland. This is how xterm(1) and its clones work: \u603b\u7ed3\uff1a\u4ece\u4e0b\u56fe\u53ef\u4ee5\u770b\u51fa\uff0c\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f\u5c06terminal emulation\u4ecekernel\u4e2d\u79fb\u9664\uff0c\u79fb\u5230userland\u5373\u7528\u6237\u7a7a\u95f4\u4e2d\u3002\u76ee\u7684\u662f\u589e\u52a0\u7075\u6d3b\u6027\uff1b To facilitate moving the terminal emulation into userland, while still keeping the TTY subsystem ( session management and line discipline ) intact\uff08\u5b8c\u6574\uff09, the pseudo terminal or pty was invented. And as you may have guessed, things get even more complicated when you start running pseudo terminals inside pseudo terminals, \u00e0 la screen(1) or ssh(1) . \u603b\u7ed3\uff1apseudo teminal\u6216pty\u662f\u4e3a\u4e86\u5b9e\u73b0moving terminal emulation into userland\u800c\u521b\u5efa\u7684\u3002\u9700\u8981\u4ed4\u7ec6\u5730\u6765\u7814\u7a76\u4e0a\u56fe\uff0c\u5e76\u4e14\u9700\u8981\u7ed3\u5408\u4e0a\u56fe\u548c\u4e0a\u4e0a\u56fe\u4e00\u8d77\u6765\u8fdb\u884c\u7406\u89e3\uff1bTTY driver\u662f\u548cUser process\u8fde\u63a5\uff0c\u8054\u7cfb\u4e0a\u9762\u5bf9TTY driver\u7684\u4ecb\u7ecd\uff0c\u5b83\u7684\u4e00\u4e2a\u4e3b\u8981\u529f\u80fd\u662f\u4e3a\u4e86\u5b9e\u73b0**Session management. \uff0c\u800cPTY\u662f\u548c xterm \u8fde\u63a5\uff0c\u5b83\u4e3b\u8981\u662f\u4e3a\u4e86\u5b9e\u73b0**video terminal \uff1b Now let's take a step back and see how all of this fits into the process model . Processes A Linux process can be in one of the following states: ||\u542b\u4e49| | ---- | ------------------------------------------------------------ | | R | Running or runnable (on run queue) | | D | Uninterruptible sleep (waiting for some event) | | S | Interruptible sleep (waiting for some event or signal) | | T | Stopped, either by a job control signal or because it is being traced by a debugger. | | Z | Zombie process, terminated but not yet reaped by its parent. | By running ps l , you can see which processes are running, and which are sleeping. If a process is sleeping, the WCHAN column (\"wait channel\", the name of the wait queue) will tell you what kernel event the process is waiting for. $ ps l F UID PID PPID PRI NI VSZ RSS WCHAN STAT TTY TIME COMMAND 0 500 5942 5928 15 0 12916 1460 wait Ss pts/14 0 :00 -/bin/bash 0 500 12235 5942 15 0 21004 3572 wait S+ pts/14 0 :01 vim index.php 0 500 12580 12235 15 0 8080 1440 wait S+ pts/14 0 :00 /bin/bash -c ( ps l ) >/tmp/v727757/1 2 > & 1 0 500 12581 12580 15 0 4412 824 - R+ pts/14 0 :00 ps l The \" wait \" wait queue corresponds to the wait(2) syscall, so these processes will be moved to the running state whenever there's a state change in one of their child processes. There are two sleeping states: Interruptible sleep and uninterruptible sleep . Interruptible sleep (the most common case) means that while the process is part of a wait queue, it may actually also be moved to the running state when a signal is sent to it. If you look inside the kernel source code, you will find that any kernel code which is waiting for an event must check if a signal is pending after schedule() returns, and abort the syscall in that case. In the ps listing above, the STAT column displays the current state of each process. The same column may also contain one or more attributes, or flags: ||\u542b\u4e49| | ---- | --------------------------------------------------- | | s | This process is a session leader. | | + | This process is part of a foreground process group. | These attributes are used for job control. Jobs and sessions Job control is what happens when you press ^Z to suspend a program, or when you start a program in the background using & . A job is the same as a process group . Internal shell commands like jobs , fg and bg can be used to manipulate the existing jobs within a session . Each session is managed by a session leader , the shell, which is cooperating tightly with the kernel using a complex protocol of signals and system calls . \u603b\u7ed3\uff1a\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u8bf4\u660e\u4e86\u4f55\u65f6\u4f1a\u89e6\u53d1job control\uff0c\u5982\u4f55\u64cd\u4f5cjob\u3002\u66f4\u591a\u5173\u4e8e\u4f5c\u4e1a\u63a7\u5236\u7684\u5185\u5bb9\u53ef\u4ee5\u53c2\u89c1APUE\u7684\u300a9.8\u4f5c\u4e1a\u63a7\u5236\u300b\u3002\u540c\u65f6\u4e0a\u9762\u8fd9\u6bb5\u7684\u6700\u540e\u4e00\u53e5\u8bdd\u544a\u8bc9\u4e86\u6211\u4eec\u5f80\u5f80session leader\u662f\u7531shell\u6765\u5145\u5f53\u7684\u3002 The following example illustrates the relationship between processes, jobs and sessions: The following shell interactions... ...correspond to these processes... ...and these kernel structures. TTY Driver (/dev/pts/0). bash Size: 45x13 Controlling process group: (101) Foreground process group: (103) UART configuration (ignored, since this is an xterm): Baud rate, parity, word length and much more. Line discipline configuration: cooked/raw mode, linefeed correction, meaning of interrupt characters etc. Line discipline state: edit buffer (currently empty), cursor position within buffer etc. pipe0 Readable end ( connected to PID 104 as file descriptor 0 ) Writable end ( connected to PID 103 as file descriptor 1 ) Buffer The basic idea is that every pipeline is a job, because every process in a pipeline should be manipulated (stopped, resumed, killed) simultaneously\uff08\u540c\u65f6\uff09. That's why kill(2) allows you to send signals to entire process groups . By default, fork(2) places a newly created child process in the same process group as its parent, so that e.g. a ^C from the keyboard will affect both parent and child. But the shell, as part of its session leader duties, creates a new process group every time it launches a pipeline. \u603b\u7ed3\uff1ashell\uff0c\u4f5c\u4e3asession leader\u7684\u804c\u8d23\u5305\u62ec\u6bcf\u6b21\u542f\u52a8\u7ba1\u9053\u65f6\u90fd\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fdb\u7a0b\u7ec4 The TTY driver keeps track of the foreground process group id, but only in a passive way. The session leader has to update this information explicitly when necessary. Similarly, the TTY driver keeps track of the size of the connected terminal, but this information has to be updated explicitly, by the terminal emulator or even by the user. As you can see in the diagram above, several processes have /dev/pts/0 attached to their standard input. But only the foreground job (the ls | sort pipeline) will receive input from the TTY. Likewise, only the foreground job will be allowed to write to the TTY device (in the default configuration). If the cat process were to attempt to write to the TTY, the kernel would suspend it using a signal. \u603b\u7ed3\uff1aterminal\u548cjob\u4e4b\u95f4\u7684\u5173\u7cfb\u3002 Signal madness Now let's take a closer look at how the TTY drivers , the line disciplines and the UART drivers in the kernel communicate with the userland processes \uff08\u7528\u6237\u8fdb\u7a0b\uff09. UNIX files, including the TTY device file, can of course be read from and written to, and further manipulated by means of the magic ioctl(2) call (the Swiss army-knife of UNIX) for which lots of TTY related operations have been defined. Still, ioctl requests have to be initiated from processes, so they can't be used when the kernel needs to communicate asynchronously with an application\uff08 ioctl \u8bf7\u6c42\u5fc5\u987b\u4ece\u8fdb\u7a0b\u542f\u52a8\uff0c\u56e0\u6b64\u5f53\u5185\u6838\u9700\u8981\u4e0e\u5e94\u7528\u7a0b\u5e8f\u5f02\u6b65\u901a\u4fe1\u65f6\uff0c\u4e0d\u80fd\u4f7f\u7528\u5b83\u4eec\uff09. In The Hitchhiker's Guide to the Galaxy , Douglas Adams mentions an extremely dull planet, inhabited by a bunch of depressed humans and a certain breed of animals with sharp teeth which communicate with the humans by biting them very hard in the thighs. This is strikingly similar to UNIX, in which the kernel communicates with processes by sending paralyzing or deadly signals to them. Processes may intercept(\u62e6\u622a) some of the signals, and try to adapt to the situation, but most of them don't. \u603b\u7ed3\uff1akernel \u901a\u8fc7\u5411process\u53d1\u9001\u4fe1\u53f7\u6765\u4e0eprocess\u8fdb\u884c\u901a\u4fe1\uff0c\u8fd9\u4e9b\u4fe1\u53f7\u5305\u62ecparalyzing signal\uff08\u9ebb\u75f9\u4fe1\u53f7\uff09\u6216deadly signal\uff08\u81f4\u547d\u4fe1\u53f7\uff09\u3002\u8fdb\u7a0b\u53ef\u4ee5\u62e6\u622a\u4e00\u4e9b\u4fe1\u53f7\uff0c\u5e76\u5c1d\u8bd5\u9002\u5e94\u8fd9\u79cd\u60c5\u51b5\uff0c\u4f46\u5927\u591a\u6570\u4fe1\u53f7\u90fd\u6ca1\u6709\u3002 So a signal is a crude mechanism that allows the kernel to communicate asynchronously with a process. Signals in UNIX aren't clean or general; rather, each signal is unique, and must be studied individually. \u603b\u7ed3\uff1a\u4fe1\u53f7\u662f\u4e00\u79cd\u5141\u8bb8kernel\u548cprocess\u8fdb\u884c\u5f02\u6b65\u4ea4\u6d41\u7684\u975e\u5e38\u7c97\u7565\u7684\u673a\u5236\u3002 You can use the command kill -l to see which signals your system implements. This is what it may look like: $ kill -l 1 ) SIGHUP 2 ) SIGINT 3 ) SIGQUIT 4 ) SIGILL 5 ) SIGTRAP 6 ) SIGABRT 7 ) SIGBUS 8 ) SIGFPE 9 ) SIGKILL 10 ) SIGUSR1 11 ) SIGSEGV 12 ) SIGUSR2 13 ) SIGPIPE 14 ) SIGALRM 15 ) SIGTERM 16 ) SIGSTKFLT 17 ) SIGCHLD 18 ) SIGCONT 19 ) SIGSTOP 20 ) SIGTSTP 21 ) SIGTTIN 22 ) SIGTTOU 23 ) SIGURG 24 ) SIGXCPU 25 ) SIGXFSZ 26 ) SIGVTALRM 27 ) SIGPROF 28 ) SIGWINCH 29 ) SIGIO 30 ) SIGPWR 31 ) SIGSYS 34 ) SIGRTMIN 35 ) SIGRTMIN+1 36 ) SIGRTMIN+2 37 ) SIGRTMIN+3 38 ) SIGRTMIN+4 39 ) SIGRTMIN+5 40 ) SIGRTMIN+6 41 ) SIGRTMIN+7 42 ) SIGRTMIN+8 43 ) SIGRTMIN+9 44 ) SIGRTMIN+10 45 ) SIGRTMIN+11 46 ) SIGRTMIN+12 47 ) SIGRTMIN+13 48 ) SIGRTMIN+14 49 ) SIGRTMIN+15 50 ) SIGRTMAX-14 51 ) SIGRTMAX-13 52 ) SIGRTMAX-12 53 ) SIGRTMAX-11 54 ) SIGRTMAX-10 55 ) SIGRTMAX-9 56 ) SIGRTMAX-8 57 ) SIGRTMAX-7 58 ) SIGRTMAX-6 59 ) SIGRTMAX-5 60 ) SIGRTMAX-4 61 ) SIGRTMAX-3 62 ) SIGRTMAX-2 63 ) SIGRTMAX-1 64 ) SIGRTMAX As you can see, signals are numbered starting with 1. However, when they are used in bitmasks (e.g. in the output of ps s ), the least significant bit corresponds to signal 1. \u603b\u7ed3\uff1a\u5982\u60a8\u6240\u89c1\uff0c\u4fe1\u53f7\u4ece1\u5f00\u59cb\u7f16\u53f7\u3002\u4f46\u662f\uff0c\u5f53\u5b83\u4eec\u7528\u4e8e\u4f4d\u63a9\u7801\u65f6\uff08\u4f8b\u5982\u5728ps s\u7684\u8f93\u51fa\u4e2d\uff09\uff0c\u6700\u4f4e\u6709\u6548\u4f4d\u5bf9\u5e94\u4e8e\u4fe1\u53f71\u3002 This article will focus on the following signals: SIGHUP , SIGINT , SIGQUIT , SIGPIPE , SIGCHLD , SIGSTOP , SIGCONT , SIGTSTP , SIGTTIN , SIGTTOU and SIGWINCH . SIGHUP Default action: Terminate Possible actions: Terminate, Ignore, Function call SIGHUP is sent by the UART driver to the entire session when a hangup condition \uff08\u6302\u8d77\u6761\u4ef6\uff09 has been detected. Normally, this will kill all the processes. Some programs, such as nohup(1) and screen(1) , detach\uff08\u8131\u79bb\uff09 from their session (and TTY), so that their child processes won't notice a hangup. SIGINT Default action: Terminate Possible actions: Terminate, Ignore, Function call SIGINT is sent by the TTY driver to the current foreground job when the interactive attention character (typically ^C , which has ASCII code 3) appears in the input stream , unless this behaviour has been turned off. Anybody with access permissions to the TTY device can change the interactive attention character and toggle\uff08\u5207\u6362\uff09 this feature; additionally, the session manager keeps track of the TTY configuration of each job, and updates the TTY whenever there is a job switch. \u603b\u7ed3\uff1a\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u51fa\u73b0\u4e86input stream\uff0c\u8fd9\u4e2a\u6982\u5ff5\u6211\u4e4b\u524d\u4e00\u76f4\u662f\u6bd4\u8f83\u6a21\u7cca\u7684\uff0c\u4eca\u5929\u770b\u4e86\u8fd9\u7bc7\u6587\u7ae0\uff0c\u624d\u53d1\u73b0\u8fd9\u4e2a\u6982\u5ff5\u662f\u548cterminal\u5bc6\u5207\u76f8\u5173\u7684\u3002 SIGQUIT Default action: Core dump Possible actions: Core dump, Ignore, Function call SIGQUIT works just like SIGINT , but the quit character is typically ^\\ and the default action is different. SIGPIPE Default action: Terminate Possible actions: Terminate, Ignore, Function call The kernel sends SIGPIPE to any process which tries to write to a pipe with no readers. This is useful, because otherwise jobs like yes | head would never terminate. SIGCHLD Default action: Ignore Possible actions: Ignore, Function call When a process dies or changes state (stop/continue), the kernel sends a SIGCHLD to its parent process . The SIGCHLD signal carries additional information, namely the process id, the user id, the exit status (or termination signal) of the terminated process and some execution time statistics. The session leader (shell) keeps track of its jobs using this signal. SIGSTOP Default action: Suspend Possible actions: Suspend This signal will unconditionally suspend the recipient, i.e. its signal action can't be reconfigured. Please note, however, that SIGSTOP isn't sent by the kernel during job control. Instead, ^Z typically triggers a SIGTSTP , which can be intercepted by the application. The application may then e.g. move the cursor to the bottom of the screen or otherwise put the terminal in a known state, and subsequently put itself to sleep using SIGSTOP . SIGCONT Default action: Wake up Possible actions: Wake up, Wake up + Function call SIGCONT will un-suspend a stopped process. It is sent explicitly by the shell when the user invokes the fg command. Since SIGSTOP can't be intercepted by an application, an unexpected SIGCONT signal might indicate that the process was suspended some time ago, and then un-suspended. SIGTSTP Default action: Suspend Possible actions: Suspend, Ignore, Function call SIGTSTP works just like SIGINT and SIGQUIT , but the magic character is typically ^Z and the default action is to suspend the process. SIGTTIN Default action: Suspend Possible actions: Suspend, Ignore, Function call If a process within a background job tries to read from a TTY device, the TTY sends a SIGTTIN signal to the entire job. This will normally suspend the job. SIGTTOU Default action: Suspend Possible actions: Suspend, Ignore, Function call If a process within a background job tries to write to a TTY device, the TTY sends a SIGTTOU signal to the entire job. This will normally suspend the job. It is possible to turn off this feature on a per-TTY basis. SIGWINCH Default action: Ignore Possible actions: Ignore, Function call As mentioned, the TTY device keeps track of the terminal size, but this information needs to be updated manually. Whenever that happens, the TTY device sends SIGWINCH to the foreground job . Well-behaving interactive applications, such as editors, react upon this, fetch the new terminal size from the TTY device and redraw themselves accordingly. An example Suppose that you are editing a file in your (terminal based) editor of choice. The cursor is somewhere in the middle of the screen, and the editor is busy executing some processor intensive task, such as a search and replace operation on a large file. Now you press ^Z . Since the line discipline has been configured to intercept this character ( ^Z is a single byte, with ASCII code 26), you don't have to wait for the editor to complete its task and start reading from the TTY device. Instead, the line discipline subsystem instantly sends SIGTSTP to the foreground process group . This process group contains the editor, as well as any child processes created by it. \u603b\u7ed3\uff1a SIGTSTP \u662f\u88ab\u53d1\u9001\u90fd\u4e86 foreground process group \uff0c\u800c\u975e\u76f4\u63a5\u53d1\u9001\u5230\u4e86\u76ee\u6807\u8fdb\u7a0b\u3002 The editor has installed a signal handler for SIGTSTP , so the kernel diverts\uff08\u8f6c\u63a5\uff09 the process into executing the signal handler code\uff08\u5728process\u6536\u5230signal\u7684\u60c5\u51b5\u4e0b\u662f\u7531kernel\u6765\u8fdb\u884cdivert\u7136\u540e\u8c03\u7528\u5b83\u7684signal handler code\u7684\uff09. This code moves the cursor to the last line on the screen, by writing the corresponding control sequences to the TTY device. Since the editor is still in the foreground, the control sequences are transmitted as requested. But then the editor sends a SIGSTOP to its own process group . The editor has now been stopped\uff08\u6b64\u65f6editor process\u5c31\u505c\u6b62\u4e86\uff09. This fact is reported to the session leader using a SIGCHLD signal, which includes the id of the suspended process\uff08\u505c\u6b62session leader\uff09. When all processes in the foreground job have been suspended, the session leader reads the current configuration from the TTY device, and stores it for later retrieval\uff08\u601d\u8003\uff1a\u6b64\u5904\u7684it\u662f\u6307current configuration\u5417\uff09. The session leader goes on to install itself as the current foreground process group for the TTY using an ioctl call. Then, it prints something like \"[1]+ Stopped\" to inform the user that a job was just suspended. At this point, ps(1) will tell you that the editor process is in the stopped state (\" T \"). If we try to wake it up, either by using the bg built-in shell command, or by using kill(1) to send SIGCONT to the process(es), the editor will start executing its SIGCONT signal handler. This signal handler will probably attempt to redraw the editor GUI by writing to the TTY device. But since the editor is now a background job , the TTY device will not allow it. Instead, the TTY will send SIGTTOU to the editor, stopping it again. This fact will be communicated to the session leader using SIGCHLD , and the shell will once again write \"[1]+ Stopped\" to the terminal. When we type fg , however, the shell first restores the line discipline configuration that was saved earlier. It informs the TTY driver that the editor job should be treated as the foreground job from now on. And finally, it sends a SIGCONT signal to the process group. The editor process attempts to redraw its GUI, and this time it will not be interrupted by SIGTTOU since it is now a part of the foreground job . Flow control and blocking I/O Run yes in an xterm , and you will see a lot of \" y \" lines swooshing past your eyes. Naturally, the yes process is able to generate \" y \" lines much faster than the xterm application is able to parse them, update its frame buffer, communicate with the X server in order to scroll the window and so on. How is it possible for these programs to cooperate? The answer lies in blocking I/O . The pseudo terminal can only keep a certain amount of data inside its kernel buffer, and when that buffer is full and yes tries to call write(2) , then write(2) will block , moving the yes process into the interruptible sleep state where it remains until the xterm process has had a chance to read off some of the buffered bytes. The same thing happens if the TTY is connected to a serial port. yes would be able to transmit data at a much higher rate than, say, 9600 baud, but if the serial port is limited to that speed, the kernel buffer soon fills up and any subsequent write(2) calls block the process (or fail with the error code EAGAIN if the process has requested non-blocking I/O). What if I told you, that it is possible to explicitly put the TTY in a blocking state even though there is space left in the kernel buffer? That until further notice, every process trying to write(2) to the TTY automatically blocks. What would be the use of such a feature? Suppose we're talking to some old VT-100 hardware at 9600 baud. We just sent a complex control sequence asking the terminal to scroll the display. At this point, the terminal gets so bogged down with the scrolling operation\uff08\u7ec8\u7aef\u56e0\u6eda\u52a8\u64cd\u4f5c\u9677\u5165\u56f0\u5883\uff09, that it's unable to receive new data at the full rate of 9600 baud. Well, physically, the terminal UART still runs at 9600 baud, but there won't be enough buffer space in the terminal to keep a backlog of received characters. This is when it would be a good time to put the TTY in a blocking state. But how do we do that from the terminal? We have already seen that a TTY device may be configured to give certain data bytes a special treatment. In the default configuration, for instance, a received ^C byte won't be handed off to the application through read(2) , but will instead cause a SIGINT to be delivered to the foreground job . In a similar way, it is possible to configure the TTY to react on a stop flow byte and a start flow byte. These are typically ^S (ASCII code 19) and ^Q (ASCII code 17) respectively. Old hardware terminals transmit these bytes automatically, and expect the operating system to regulate\uff08\u8c03\u8282\uff09 its flow of data accordingly. This is called flow control , and it's the reason why your xterm sometimes appears to lock up when you accidentally press ^S . There's an important difference here: Writing to a TTY which is stopped due to flow control , or due to lack of kernel buffer space , will block your process, whereas writing to a TTY from a background job will cause a SIGTTOU to suspend the entire process group. I don't know why the designers of UNIX had to go all the way to invent SIGTTOU and SIGTTIN instead of relying on blocking I/O , but my best guess is that the TTY driver, being in charge of job control, was designed to monitor and manipulate whole jobs; never the individual processes within them. Configuring the TTY device To find out what the controlling TTY for your shell is called, you could refer to the ps l listing as described earlier, or you could simply run the tty(1) command. A process may read or modify the configuration of an open TTY device using ioctl(2) . The API is described in tty_ioctl(4) . Since it's part of the binary interface between Linux applications and the kernel , it will remain stable across Linux versions. However, the interface is non-portable, and applications should rather use the POSIX wrappers described in the termios(3) man page. I won't go into the details of the termios(3) interface, but if you're writing a C program and would like to intercept ^C before it becomes a SIGINT , disable line editing or character echoing, change the baud rate of a serial port, turn off flow control etc. then you will find what you need in the aforementioned man page. There is also a command line tool, called stty(1) , to manipulate TTY devices. It uses the termios(3) API. Let's try it! $ stty -a speed 38400 baud ; rows 73 ; columns 238 ; line = 0 ; intr = ^C ; quit = ^ \\; erase = ^? ; kill = ^U ; eof = ^D ; eol = <undef> ; eol2 = <undef> ; swtch = <undef> ; start = ^Q ; stop = ^S ; susp = ^Z ; rprnt = ^R ; werase = ^W ; lnext = ^V ; flush = ^O ; min = 1 ; time = 0 ; -parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -ignbrk brkint ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany imaxbel -iutf8 opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke The -a flag tells stty to display all settings. By default, it will look at the TTY device attached to your shell, but you can specify another device with -F . Some of these settings refer to UART parameters, some affect the line discipline and some are for job control. All mixed up in a bucket for monsieur. Let's have a look at the first line: speed UART The baud rate. Ignored for pseudo terminals. rows, columns TTY driver Somebody's idea of the size, in characters, of the terminal attached to this TTY device. Basically, it's just a pair of variables within kernel space, that you may freely set and get. Setting them will cause the TTY driver to dispatch a SIGWINCH to the foreground job. line Line discipline The line discipline attached to the TTY device. 0 is N_TTY . All valid numbers are listed in /proc/tty/ldiscs . Unlisted numbers appear to be aliases for N_TTY , but don't rely on it. Try the following: Start an xterm . Make a note of its TTY device (as reported by tty ) and its size (as reported by stty -a ). Start vim (or some other full-screen terminal application) in the xterm . The editor queries the TTY device for the current terminal size in order to fill the entire window. Now, from a different shell window, type: stty -F X rows Y where X is the TTY device, and Y is half the terminal height. This will update the TTY data structure in kernel memory, and send a SIGWINCH to the editor, which will promptly redraw itself using only the upper half of the available window area. The second line of stty -a output lists all the special characters. Start a new xterm and try this: stty intr o Now \" o \", rather than ^C , will send a SIGINT to the foreground job. Try starting something, such as cat , and verify that you can't kill it using ^C . Then, try typing \" hello \" into it. Occasionally, you may come across a UNIX system where the backspace key doesn't work. This happens when the terminal emulator transmits a backspace code (either ASCII 8 or ASCII 127) which doesn't match the erase setting in the TTY device. To remedy the problem, one usually types stty erase ^H (for ASCII 8) or stty erase ^? (for ASCII 127). But please remember that many terminal applications use readline , which puts the line discipline in raw mode. Those applications aren't affected. Finally, stty -a lists a bunch of switches. As expected, they are listed in no particular order. Some of them are UART-related, some affect the line discipline behaviour, some are for flow control and some are for job control. A dash ( - ) indicates that the switch is off; otherwise it is on. All of the switches are explained in the stty(1) man page, so I'll just briefly mention a few: icanon toggles the canonical (line-based) mode. Try this in a new xterm : stty -icanon ; cat Note how all the line editing characters, such as backspace and ^U , have stopped working. Also note that cat is receiving (and consequently outputting) one character at a time, rather than one line at a time. echo enables character echoing, and is on by default. Re-enable canonical mode ( stty icanon ), and then try: stty -echo ; cat As you type, your terminal emulator transmits information to the kernel. Usually, the kernel echoes the same information back to the terminal emulator, allowing you to see what you type. Without character echoing, you can't see what you type, but we're in cooked mode so the line editing facilities are still working. Once you press enter, the line discipline will transmit the edit buffer to cat , which will reveal what your wrote. tostop controls whether background jobs are allowed to write to the terminal. First try this: stty tostop ; ( sleep 5 ; echo hello, world ) & The & causes the command to run as a background job. After five seconds, the job will attempt to write to the TTY. The TTY driver will suspend it using SIGTTOU , and your shell will probably report this fact, either immediately, or when it's about to issue a new prompt to you. Now kill the background job, and try the following instead: stty -tostop ; ( sleep 5 ; echo hello, world ) & You will get your prompt back, but after five seconds, the background job transmits hello, world to the terminal, in the middle of whatever you were typing. Finally, stty sane will restore your TTY device configuration to something reasonable. Conclusion I hope this article has provided you with enough information to get to terms with TTY drivers and line disciplines, and how they are related to terminals, line editing and job control. Further details can be found in the various man pages I've mentioned, as well as in the glibc manual ( info libc , \"Job Control\"). Finally, while I don't have enough time to answer all the questions I get, I do welcome feedback on this and other pages on the site. Thanks for reading!","title":"Unix The TTY demystified"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#the#tty#demystified","text":"\u6ce8\uff1ademystify \u63ed\u79d8 The TTY subsystem is central to the design of Linux, and UNIX in general. Unfortunately, its importance is often overlooked, and it is difficult to find good introductory articles about it. I believe that a basic understanding of TTYs in Linux is essential for the developer and the advanced user. \u5728\u8fd9\u7bc7\u6587\u7ae0: tty \u4e2d\u4ecb\u7ecd\u4e86TTY\u6240\u4ee3\u8868\u7684\u542b\u4e49 Beware, though: What you are about to see is not particularly elegant. In fact, the TTY subsystem \u2014 while quite functional from a user's point of view \u2014 is a twisty(\u66f2\u6298) little mess of special cases. To understand how this came to be, we have to go back in time.","title":"The TTY demystified"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#history","text":"In 1869, the stock ticker (\u80a1\u7968\u62a5\u4ef7\u673a) was invented. It was an electro-mechanical machine consisting of a typewriter, a long pair of wires and a ticker tape printer, and its purpose was to distribute stock prices over long distances in realtime. This concept gradually evolved into the faster, ASCII-based teletype . Teletypes were once connected across the world in a large network, called Telex , which was used for transferring commercial telegrams(\u5546\u4e1a\u7535\u62a5), but the teletypes weren't connected to any computers yet. TRANSLAITION : 1869\u5e74\uff0c\u80a1\u7968\u4ee3\u7801\u88ab\u53d1\u660e\u4e86\u3002 \u5b83\u662f\u4e00\u53f0\u673a\u7535\u4e00\u4f53\u673a\uff0c\u7531\u4e00\u53f0\u6253\u5b57\u673a\uff0c\u4e00\u5bf9\u957f\u7535\u7ebf\u548c\u4e00\u53f0\u81ea\u52a8\u6536\u62a5\u673a\u7ec4\u6210\uff0c\u5176\u76ee\u7684\u662f\u5b9e\u65f6\u5206\u914d\u957f\u8ddd\u79bb\u7684\u80a1\u7968\u4ef7\u683c\u3002 \u8fd9\u4e2a\u6982\u5ff5\u9010\u6e10\u6f14\u53d8\u6210\u66f4\u5feb\uff0c\u57fa\u4e8eASCII\u7684\u7535\u4f20\u6253\u5b57\u673a\u3002 Teletypes\u66fe\u7ecf\u5728\u4e00\u4e2a\u540d\u4e3aTelex\u7684\u5927\u578b\u7f51\u7edc\u4e2d\u8fde\u63a5\u5230\u4e16\u754c\u5404\u5730\uff0c\u8be5\u7f51\u7edc\u7528\u4e8e\u4f20\u8f93\u5546\u4e1a\u7535\u62a5\uff0c\u4f46\u7535\u8bdd\u7c7b\u578b\u5c1a\u672a\u8fde\u63a5\u5230\u4efb\u4f55\u8ba1\u7b97\u673a\u3002 Meanwhile, however, the computers \u2014 still quite large and primitive, but able to multitask \u2014 were becoming powerful enough to be able to interact with users in realtime. When the command line eventually replaced the old batch processing model, teletypes were used as input and output devices , because they were readily available on the market. \u603b\u7ed3\uff1a\u53c2\u89c1 getty \uff0c\u8fd9\u7bc7\u6587\u7ae0\u4e2d\u4ecb\u7ecd\u7684\u5185\u5bb9\u548c\u4e0a\u9762\u8fd9\u6bb5\u6709\u5173\u3002 There was a plethora\uff08\u8fc7\u591a\uff0c\u8fc7\u5269\uff09 of teletype models around, all slightly different, so some kind of software compatibility layer was called for\uff08\u9700\u8981\uff09. In the UNIX world, the approach was to let the operating system kernel handle all the low-level details, such as word length, baud rate\uff08\u6ce2\u7279\u7387\uff09, flow control, parity\uff08\u5947\u5076\u6821\u9a8c\uff09, control codes for rudimentary line editing\uff08\u7528\u4e8e\u57fa\u672c\u884c\u7f16\u8f91\u7684\u63a7\u5236\u4ee3\u7801\uff09 and so on. Fancy cursor movements, color output and other advanced features made possible in the late 1970s by solid state video terminals \uff08\u56fa\u6001\u89c6\u9891\u7ec8\u7aef\uff09 such as the VT-100, were left to the applications. In present time, we find ourselves in a world where physical teletypes and video terminals are practically extinct\uff08\u7edd\u8ff9\uff09. Unless you visit a museum or a hardware enthusiast\uff08\u786c\u4ef6\u7231\u597d\u8005\uff09, all the TTYs you're likely to see will be emulated video terminals \u2014 software simulations of the real thing. But as we shall see, the legacy from the old cast-iron beasts is still lurking beneath the surface. \u603b\u7ed3\uff1a\u5982\u4eca\u6211\u4eec\u6240\u89c1\u7684TTY\u90fd\u662femulated video terminals \uff1b\u6700\u540e\u4e00\u53e5\u8bdd\u7684\u8868\u540d\u610f\u601d\u662f\uff1a\u6765\u81ea\u65e7\u94f8\u94c1\u91ce\u517d\u7684\u9057\u4ea7\u4ecd\u6f5c\u4f0f\u5728\u6c34\u9762\u4e4b\u4e0b\uff1b\u5f15\u7533\u7684\u542b\u4e49\u5c31\u662f\uff1a\u867d\u7136\u5916\u5728\u53d8\u5316\u4e86\uff0c\u4f46\u662f\u672c\u8d28\u662f\u672a\u53d8\u7684\u3002","title":"History"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#the#use#cases","text":"A user types at a terminal (a physical teletype). This terminal is connected through a pair of wires to a UART (Universal Asynchronous Receiver and Transmitter) on the computer. The operating system contains a UART driver which manages the physical transmission of bytes, including parity checks(\u5947\u5076\u6821\u9a8c) and flow control. In a na\u00efve system, the UART driver would then deliver the incoming bytes directly to some application process. But such an approach would lack the following essential features: \u603b\u7ed3\uff1a\u4ece\u4e0a\u56fe\u6765\u770b\uff0c UART*\u5e76\u6ca1\u6709\u76f4\u63a5\u548capplication process \u8fdb\u884cconnect\uff0c\u800c\u662f\u4e2d\u95f4\u8fd8\u6709*line discipline*\u548c*tty Line editing \uff08\u884c\u7f16\u8f91\uff09. Most users make mistakes while typing, so a backspace key\uff08\u9000\u683c\u952e\uff09 is often useful. This could of course be implemented by the applications themselves, but in accordance with the UNIX design philosophy, applications should be kept as simple as possible. So as a convenience, the operating system provides an editing buffer\uff08\u7f16\u8f91\u7f13\u51b2\u533a\uff09 and some rudimentary\uff08\u57fa\u672c\u7684\uff09 editing commands (backspace, erase word, clear line, reprint), which are enabled by default inside the line discipline \uff08\u884c\u89c4\u5219\uff09. Advanced applications may disable these features by putting the line discipline \uff08\u884c\u89c4\u5219\uff09 in raw mode instead of the default cooked (or canonical ) mode. Most interactive applications (editors, mail user agents, shells, all programs relying on curses or readline ) run in raw mode, and handle all the line editing commands themselves. The line discipline also contains options for character echoing and automatic conversion between carriage returns and linefeeds. Think of it as a primitive kernel-level sed(1) , if you like. Incidentally, the kernel provides several different line disciplines . Only one of them is attached to a given serial device at a time. The default discipline, which provides line editing, is called N_TTY ( drivers/char/n_tty.c , if you're feeling adventurous). Other disciplines are used for other purposes, such as managing packet switched data (ppp, IrDA, serial mice), but that is outside the scope of this article. \u603b\u7ed3\uff1a\u4e0a\u56fe\u4e2d\u7684**Line discipline**\u5c31\u662f\u4e3a\u4e86**Line Editing**\u529f\u80fd\u7684\u3002 Session management. The user probably wants to run several programs simultaneously, and interact with them one at a time\uff08\u4e00\u6b21\u4e00\u4e2a\uff09. If a program goes into an endless loop, the user may want to kill it or suspend it. Programs that are started in the background should be able to execute until they try to write to the terminal, at which point they should be suspended. Likewise, user input should be directed to the foreground program only. The operating system implements these features in the TTY driver ( drivers/char/tty_io.c ). An operating system process is \"alive\" (has an execution context ), which means that it can perform actions. The TTY driver is not alive; in object oriented terminology, the TTY driver is a passive object \uff08\u88ab\u52a8\uff09. It has some data fields and some methods, but the only way it can actually do something is when one of its methods gets called from the context of a process or a kernel interrupt handler. The line discipline is likewise a passive entity. \u603b\u7ed3\uff1a\u5173\u4e8epassive object\u53c2\u89c1 Passive data structure .\u5176\u5b9e\u662f\u770b\u4e86\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u6211\u624d\u60f3\u8d77passive object\u7684\u542b\u4e49\uff0c\u5b83\u7684\u6b63\u786e\u542b\u4e49\u5728\u4e8epassive\u3002 \u603b\u7ed3\uff1a\u4e0a\u56fe\u4e2d\u7684TTY driver\u5c31\u662f\u4e3a\u4e86\u5b9e\u73b0Session management\u7684\u3002 Together, a particular triplet of UART driver, line discipline instance and TTY driver may be referred to as a TTY device , or sometimes just TTY. A user process can affect the behaviour of any TTY device by manipulating the corresponding device file under /dev . Write permissions to the device file are required, so when a user logs in on a particular TTY, that user must become the owner of the device file . This is traditionally done by the login(1) program, which runs with root privileges. \u603b\u7ed3\uff1a\u6b64\u5904\u7ed9\u51fa\u4e86\u5728\u73b0\u5728\u7684linux\u7cfb\u7edf\u4e2d\uff0cTTY\u7684\u8be6\u7ec6\u7684\uff0c\u5e95\u5c42\u7684\u542b\u4e49\u3002 \u603b\u7ed3\uff1a\u901a\u8fc7 tty \u547d\u4ee4\u53ef\u4ee5\u83b7\u5f97\u5f53\u524dterminal\u7684device file \u3002 The physical line in the previous diagram could of course be a long-distance phone line: SUMMARY : \u8fd9\u79cd\u60c5\u51b5\u663e\u7136\u662f\u901a\u8fc7\u7f51\u7edc\u8fdb\u884c\u8fde\u63a5\u7684\u60c5\u51b5\uff1b This does not change much, except that the system now has to handle a modem hangup situation as well. Let's move on to a typical desktop system. This is how the Linux console works: The TTY driver and line discipline behave just like in the previous examples, but there is no UART or physical terminal involved anymore. Instead, a video terminal (a complex state machine including a frame buffer of characters and graphical character attributes) is emulated in software, and rendered to a VGA display. \u603b\u7ed3\uff1a\u5bf9\u6bd4\u8be5\u56fe\u548c\u524d\u56fe\uff0c\u5c31\u53ef\u4ee5\u5bf9\u6bd4\u5b83\u4eec\u4e4b\u95f4\u7684\u5dee\u5f02\uff0c\u8fd9\u79cd\u5bf9\u6bd4\u4e5f\u5370\u8bc1\u4e86\u4f5c\u8005\u5728\u7b2c\u516d\u6bb5\u4e2d\u6240\u63d0\u53ca\u7684**emulated video terminals**\u3002\u4ece\u4e0a\u56fe\u53ef\u4ee5\u770b\u51fa\uff0c**terminal emulator**\u7684output\u662fVGA driver\uff0c\u5b83\u7684input\u662fkeyboard driver\uff1b The console subsystem is somewhat rigid\uff08\u6b7b\u677f\u7684\uff09. Things get more flexible (and abstract) if we move the terminal emulation into userland. This is how xterm(1) and its clones work: \u603b\u7ed3\uff1a\u4ece\u4e0b\u56fe\u53ef\u4ee5\u770b\u51fa\uff0c\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f\u5c06terminal emulation\u4ecekernel\u4e2d\u79fb\u9664\uff0c\u79fb\u5230userland\u5373\u7528\u6237\u7a7a\u95f4\u4e2d\u3002\u76ee\u7684\u662f\u589e\u52a0\u7075\u6d3b\u6027\uff1b To facilitate moving the terminal emulation into userland, while still keeping the TTY subsystem ( session management and line discipline ) intact\uff08\u5b8c\u6574\uff09, the pseudo terminal or pty was invented. And as you may have guessed, things get even more complicated when you start running pseudo terminals inside pseudo terminals, \u00e0 la screen(1) or ssh(1) . \u603b\u7ed3\uff1apseudo teminal\u6216pty\u662f\u4e3a\u4e86\u5b9e\u73b0moving terminal emulation into userland\u800c\u521b\u5efa\u7684\u3002\u9700\u8981\u4ed4\u7ec6\u5730\u6765\u7814\u7a76\u4e0a\u56fe\uff0c\u5e76\u4e14\u9700\u8981\u7ed3\u5408\u4e0a\u56fe\u548c\u4e0a\u4e0a\u56fe\u4e00\u8d77\u6765\u8fdb\u884c\u7406\u89e3\uff1bTTY driver\u662f\u548cUser process\u8fde\u63a5\uff0c\u8054\u7cfb\u4e0a\u9762\u5bf9TTY driver\u7684\u4ecb\u7ecd\uff0c\u5b83\u7684\u4e00\u4e2a\u4e3b\u8981\u529f\u80fd\u662f\u4e3a\u4e86\u5b9e\u73b0**Session management. \uff0c\u800cPTY\u662f\u548c xterm \u8fde\u63a5\uff0c\u5b83\u4e3b\u8981\u662f\u4e3a\u4e86\u5b9e\u73b0**video terminal \uff1b Now let's take a step back and see how all of this fits into the process model .","title":"The use cases"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#processes","text":"A Linux process can be in one of the following states: ||\u542b\u4e49| | ---- | ------------------------------------------------------------ | | R | Running or runnable (on run queue) | | D | Uninterruptible sleep (waiting for some event) | | S | Interruptible sleep (waiting for some event or signal) | | T | Stopped, either by a job control signal or because it is being traced by a debugger. | | Z | Zombie process, terminated but not yet reaped by its parent. | By running ps l , you can see which processes are running, and which are sleeping. If a process is sleeping, the WCHAN column (\"wait channel\", the name of the wait queue) will tell you what kernel event the process is waiting for. $ ps l F UID PID PPID PRI NI VSZ RSS WCHAN STAT TTY TIME COMMAND 0 500 5942 5928 15 0 12916 1460 wait Ss pts/14 0 :00 -/bin/bash 0 500 12235 5942 15 0 21004 3572 wait S+ pts/14 0 :01 vim index.php 0 500 12580 12235 15 0 8080 1440 wait S+ pts/14 0 :00 /bin/bash -c ( ps l ) >/tmp/v727757/1 2 > & 1 0 500 12581 12580 15 0 4412 824 - R+ pts/14 0 :00 ps l The \" wait \" wait queue corresponds to the wait(2) syscall, so these processes will be moved to the running state whenever there's a state change in one of their child processes. There are two sleeping states: Interruptible sleep and uninterruptible sleep . Interruptible sleep (the most common case) means that while the process is part of a wait queue, it may actually also be moved to the running state when a signal is sent to it. If you look inside the kernel source code, you will find that any kernel code which is waiting for an event must check if a signal is pending after schedule() returns, and abort the syscall in that case. In the ps listing above, the STAT column displays the current state of each process. The same column may also contain one or more attributes, or flags: ||\u542b\u4e49| | ---- | --------------------------------------------------- | | s | This process is a session leader. | | + | This process is part of a foreground process group. | These attributes are used for job control.","title":"Processes"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#jobs#and#sessions","text":"Job control is what happens when you press ^Z to suspend a program, or when you start a program in the background using & . A job is the same as a process group . Internal shell commands like jobs , fg and bg can be used to manipulate the existing jobs within a session . Each session is managed by a session leader , the shell, which is cooperating tightly with the kernel using a complex protocol of signals and system calls . \u603b\u7ed3\uff1a\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u8bf4\u660e\u4e86\u4f55\u65f6\u4f1a\u89e6\u53d1job control\uff0c\u5982\u4f55\u64cd\u4f5cjob\u3002\u66f4\u591a\u5173\u4e8e\u4f5c\u4e1a\u63a7\u5236\u7684\u5185\u5bb9\u53ef\u4ee5\u53c2\u89c1APUE\u7684\u300a9.8\u4f5c\u4e1a\u63a7\u5236\u300b\u3002\u540c\u65f6\u4e0a\u9762\u8fd9\u6bb5\u7684\u6700\u540e\u4e00\u53e5\u8bdd\u544a\u8bc9\u4e86\u6211\u4eec\u5f80\u5f80session leader\u662f\u7531shell\u6765\u5145\u5f53\u7684\u3002 The following example illustrates the relationship between processes, jobs and sessions:","title":"Jobs and sessions"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#the#following#shell#interactions","text":"","title":"The following shell interactions..."},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#correspond#to#these#processes","text":"","title":"...correspond to these processes..."},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#and#these#kernel#structures","text":"TTY Driver (/dev/pts/0). bash Size: 45x13 Controlling process group: (101) Foreground process group: (103) UART configuration (ignored, since this is an xterm): Baud rate, parity, word length and much more. Line discipline configuration: cooked/raw mode, linefeed correction, meaning of interrupt characters etc. Line discipline state: edit buffer (currently empty), cursor position within buffer etc. pipe0 Readable end ( connected to PID 104 as file descriptor 0 ) Writable end ( connected to PID 103 as file descriptor 1 ) Buffer The basic idea is that every pipeline is a job, because every process in a pipeline should be manipulated (stopped, resumed, killed) simultaneously\uff08\u540c\u65f6\uff09. That's why kill(2) allows you to send signals to entire process groups . By default, fork(2) places a newly created child process in the same process group as its parent, so that e.g. a ^C from the keyboard will affect both parent and child. But the shell, as part of its session leader duties, creates a new process group every time it launches a pipeline. \u603b\u7ed3\uff1ashell\uff0c\u4f5c\u4e3asession leader\u7684\u804c\u8d23\u5305\u62ec\u6bcf\u6b21\u542f\u52a8\u7ba1\u9053\u65f6\u90fd\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fdb\u7a0b\u7ec4 The TTY driver keeps track of the foreground process group id, but only in a passive way. The session leader has to update this information explicitly when necessary. Similarly, the TTY driver keeps track of the size of the connected terminal, but this information has to be updated explicitly, by the terminal emulator or even by the user. As you can see in the diagram above, several processes have /dev/pts/0 attached to their standard input. But only the foreground job (the ls | sort pipeline) will receive input from the TTY. Likewise, only the foreground job will be allowed to write to the TTY device (in the default configuration). If the cat process were to attempt to write to the TTY, the kernel would suspend it using a signal. \u603b\u7ed3\uff1aterminal\u548cjob\u4e4b\u95f4\u7684\u5173\u7cfb\u3002","title":"...and these kernel structures."},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#signal#madness","text":"Now let's take a closer look at how the TTY drivers , the line disciplines and the UART drivers in the kernel communicate with the userland processes \uff08\u7528\u6237\u8fdb\u7a0b\uff09. UNIX files, including the TTY device file, can of course be read from and written to, and further manipulated by means of the magic ioctl(2) call (the Swiss army-knife of UNIX) for which lots of TTY related operations have been defined. Still, ioctl requests have to be initiated from processes, so they can't be used when the kernel needs to communicate asynchronously with an application\uff08 ioctl \u8bf7\u6c42\u5fc5\u987b\u4ece\u8fdb\u7a0b\u542f\u52a8\uff0c\u56e0\u6b64\u5f53\u5185\u6838\u9700\u8981\u4e0e\u5e94\u7528\u7a0b\u5e8f\u5f02\u6b65\u901a\u4fe1\u65f6\uff0c\u4e0d\u80fd\u4f7f\u7528\u5b83\u4eec\uff09. In The Hitchhiker's Guide to the Galaxy , Douglas Adams mentions an extremely dull planet, inhabited by a bunch of depressed humans and a certain breed of animals with sharp teeth which communicate with the humans by biting them very hard in the thighs. This is strikingly similar to UNIX, in which the kernel communicates with processes by sending paralyzing or deadly signals to them. Processes may intercept(\u62e6\u622a) some of the signals, and try to adapt to the situation, but most of them don't. \u603b\u7ed3\uff1akernel \u901a\u8fc7\u5411process\u53d1\u9001\u4fe1\u53f7\u6765\u4e0eprocess\u8fdb\u884c\u901a\u4fe1\uff0c\u8fd9\u4e9b\u4fe1\u53f7\u5305\u62ecparalyzing signal\uff08\u9ebb\u75f9\u4fe1\u53f7\uff09\u6216deadly signal\uff08\u81f4\u547d\u4fe1\u53f7\uff09\u3002\u8fdb\u7a0b\u53ef\u4ee5\u62e6\u622a\u4e00\u4e9b\u4fe1\u53f7\uff0c\u5e76\u5c1d\u8bd5\u9002\u5e94\u8fd9\u79cd\u60c5\u51b5\uff0c\u4f46\u5927\u591a\u6570\u4fe1\u53f7\u90fd\u6ca1\u6709\u3002 So a signal is a crude mechanism that allows the kernel to communicate asynchronously with a process. Signals in UNIX aren't clean or general; rather, each signal is unique, and must be studied individually. \u603b\u7ed3\uff1a\u4fe1\u53f7\u662f\u4e00\u79cd\u5141\u8bb8kernel\u548cprocess\u8fdb\u884c\u5f02\u6b65\u4ea4\u6d41\u7684\u975e\u5e38\u7c97\u7565\u7684\u673a\u5236\u3002 You can use the command kill -l to see which signals your system implements. This is what it may look like: $ kill -l 1 ) SIGHUP 2 ) SIGINT 3 ) SIGQUIT 4 ) SIGILL 5 ) SIGTRAP 6 ) SIGABRT 7 ) SIGBUS 8 ) SIGFPE 9 ) SIGKILL 10 ) SIGUSR1 11 ) SIGSEGV 12 ) SIGUSR2 13 ) SIGPIPE 14 ) SIGALRM 15 ) SIGTERM 16 ) SIGSTKFLT 17 ) SIGCHLD 18 ) SIGCONT 19 ) SIGSTOP 20 ) SIGTSTP 21 ) SIGTTIN 22 ) SIGTTOU 23 ) SIGURG 24 ) SIGXCPU 25 ) SIGXFSZ 26 ) SIGVTALRM 27 ) SIGPROF 28 ) SIGWINCH 29 ) SIGIO 30 ) SIGPWR 31 ) SIGSYS 34 ) SIGRTMIN 35 ) SIGRTMIN+1 36 ) SIGRTMIN+2 37 ) SIGRTMIN+3 38 ) SIGRTMIN+4 39 ) SIGRTMIN+5 40 ) SIGRTMIN+6 41 ) SIGRTMIN+7 42 ) SIGRTMIN+8 43 ) SIGRTMIN+9 44 ) SIGRTMIN+10 45 ) SIGRTMIN+11 46 ) SIGRTMIN+12 47 ) SIGRTMIN+13 48 ) SIGRTMIN+14 49 ) SIGRTMIN+15 50 ) SIGRTMAX-14 51 ) SIGRTMAX-13 52 ) SIGRTMAX-12 53 ) SIGRTMAX-11 54 ) SIGRTMAX-10 55 ) SIGRTMAX-9 56 ) SIGRTMAX-8 57 ) SIGRTMAX-7 58 ) SIGRTMAX-6 59 ) SIGRTMAX-5 60 ) SIGRTMAX-4 61 ) SIGRTMAX-3 62 ) SIGRTMAX-2 63 ) SIGRTMAX-1 64 ) SIGRTMAX As you can see, signals are numbered starting with 1. However, when they are used in bitmasks (e.g. in the output of ps s ), the least significant bit corresponds to signal 1. \u603b\u7ed3\uff1a\u5982\u60a8\u6240\u89c1\uff0c\u4fe1\u53f7\u4ece1\u5f00\u59cb\u7f16\u53f7\u3002\u4f46\u662f\uff0c\u5f53\u5b83\u4eec\u7528\u4e8e\u4f4d\u63a9\u7801\u65f6\uff08\u4f8b\u5982\u5728ps s\u7684\u8f93\u51fa\u4e2d\uff09\uff0c\u6700\u4f4e\u6709\u6548\u4f4d\u5bf9\u5e94\u4e8e\u4fe1\u53f71\u3002 This article will focus on the following signals: SIGHUP , SIGINT , SIGQUIT , SIGPIPE , SIGCHLD , SIGSTOP , SIGCONT , SIGTSTP , SIGTTIN , SIGTTOU and SIGWINCH .","title":"Signal madness"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sighup","text":"Default action: Terminate Possible actions: Terminate, Ignore, Function call SIGHUP is sent by the UART driver to the entire session when a hangup condition \uff08\u6302\u8d77\u6761\u4ef6\uff09 has been detected. Normally, this will kill all the processes. Some programs, such as nohup(1) and screen(1) , detach\uff08\u8131\u79bb\uff09 from their session (and TTY), so that their child processes won't notice a hangup.","title":"SIGHUP"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sigint","text":"Default action: Terminate Possible actions: Terminate, Ignore, Function call SIGINT is sent by the TTY driver to the current foreground job when the interactive attention character (typically ^C , which has ASCII code 3) appears in the input stream , unless this behaviour has been turned off. Anybody with access permissions to the TTY device can change the interactive attention character and toggle\uff08\u5207\u6362\uff09 this feature; additionally, the session manager keeps track of the TTY configuration of each job, and updates the TTY whenever there is a job switch. \u603b\u7ed3\uff1a\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u51fa\u73b0\u4e86input stream\uff0c\u8fd9\u4e2a\u6982\u5ff5\u6211\u4e4b\u524d\u4e00\u76f4\u662f\u6bd4\u8f83\u6a21\u7cca\u7684\uff0c\u4eca\u5929\u770b\u4e86\u8fd9\u7bc7\u6587\u7ae0\uff0c\u624d\u53d1\u73b0\u8fd9\u4e2a\u6982\u5ff5\u662f\u548cterminal\u5bc6\u5207\u76f8\u5173\u7684\u3002","title":"SIGINT"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sigquit","text":"Default action: Core dump Possible actions: Core dump, Ignore, Function call SIGQUIT works just like SIGINT , but the quit character is typically ^\\ and the default action is different.","title":"SIGQUIT"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sigpipe","text":"Default action: Terminate Possible actions: Terminate, Ignore, Function call The kernel sends SIGPIPE to any process which tries to write to a pipe with no readers. This is useful, because otherwise jobs like yes | head would never terminate.","title":"SIGPIPE"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sigchld","text":"Default action: Ignore Possible actions: Ignore, Function call When a process dies or changes state (stop/continue), the kernel sends a SIGCHLD to its parent process . The SIGCHLD signal carries additional information, namely the process id, the user id, the exit status (or termination signal) of the terminated process and some execution time statistics. The session leader (shell) keeps track of its jobs using this signal.","title":"SIGCHLD"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sigstop","text":"Default action: Suspend Possible actions: Suspend This signal will unconditionally suspend the recipient, i.e. its signal action can't be reconfigured. Please note, however, that SIGSTOP isn't sent by the kernel during job control. Instead, ^Z typically triggers a SIGTSTP , which can be intercepted by the application. The application may then e.g. move the cursor to the bottom of the screen or otherwise put the terminal in a known state, and subsequently put itself to sleep using SIGSTOP .","title":"SIGSTOP"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sigcont","text":"Default action: Wake up Possible actions: Wake up, Wake up + Function call SIGCONT will un-suspend a stopped process. It is sent explicitly by the shell when the user invokes the fg command. Since SIGSTOP can't be intercepted by an application, an unexpected SIGCONT signal might indicate that the process was suspended some time ago, and then un-suspended.","title":"SIGCONT"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sigtstp","text":"Default action: Suspend Possible actions: Suspend, Ignore, Function call SIGTSTP works just like SIGINT and SIGQUIT , but the magic character is typically ^Z and the default action is to suspend the process.","title":"SIGTSTP"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sigttin","text":"Default action: Suspend Possible actions: Suspend, Ignore, Function call If a process within a background job tries to read from a TTY device, the TTY sends a SIGTTIN signal to the entire job. This will normally suspend the job.","title":"SIGTTIN"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sigttou","text":"Default action: Suspend Possible actions: Suspend, Ignore, Function call If a process within a background job tries to write to a TTY device, the TTY sends a SIGTTOU signal to the entire job. This will normally suspend the job. It is possible to turn off this feature on a per-TTY basis.","title":"SIGTTOU"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#sigwinch","text":"Default action: Ignore Possible actions: Ignore, Function call As mentioned, the TTY device keeps track of the terminal size, but this information needs to be updated manually. Whenever that happens, the TTY device sends SIGWINCH to the foreground job . Well-behaving interactive applications, such as editors, react upon this, fetch the new terminal size from the TTY device and redraw themselves accordingly.","title":"SIGWINCH"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#an#example","text":"Suppose that you are editing a file in your (terminal based) editor of choice. The cursor is somewhere in the middle of the screen, and the editor is busy executing some processor intensive task, such as a search and replace operation on a large file. Now you press ^Z . Since the line discipline has been configured to intercept this character ( ^Z is a single byte, with ASCII code 26), you don't have to wait for the editor to complete its task and start reading from the TTY device. Instead, the line discipline subsystem instantly sends SIGTSTP to the foreground process group . This process group contains the editor, as well as any child processes created by it. \u603b\u7ed3\uff1a SIGTSTP \u662f\u88ab\u53d1\u9001\u90fd\u4e86 foreground process group \uff0c\u800c\u975e\u76f4\u63a5\u53d1\u9001\u5230\u4e86\u76ee\u6807\u8fdb\u7a0b\u3002 The editor has installed a signal handler for SIGTSTP , so the kernel diverts\uff08\u8f6c\u63a5\uff09 the process into executing the signal handler code\uff08\u5728process\u6536\u5230signal\u7684\u60c5\u51b5\u4e0b\u662f\u7531kernel\u6765\u8fdb\u884cdivert\u7136\u540e\u8c03\u7528\u5b83\u7684signal handler code\u7684\uff09. This code moves the cursor to the last line on the screen, by writing the corresponding control sequences to the TTY device. Since the editor is still in the foreground, the control sequences are transmitted as requested. But then the editor sends a SIGSTOP to its own process group . The editor has now been stopped\uff08\u6b64\u65f6editor process\u5c31\u505c\u6b62\u4e86\uff09. This fact is reported to the session leader using a SIGCHLD signal, which includes the id of the suspended process\uff08\u505c\u6b62session leader\uff09. When all processes in the foreground job have been suspended, the session leader reads the current configuration from the TTY device, and stores it for later retrieval\uff08\u601d\u8003\uff1a\u6b64\u5904\u7684it\u662f\u6307current configuration\u5417\uff09. The session leader goes on to install itself as the current foreground process group for the TTY using an ioctl call. Then, it prints something like \"[1]+ Stopped\" to inform the user that a job was just suspended. At this point, ps(1) will tell you that the editor process is in the stopped state (\" T \"). If we try to wake it up, either by using the bg built-in shell command, or by using kill(1) to send SIGCONT to the process(es), the editor will start executing its SIGCONT signal handler. This signal handler will probably attempt to redraw the editor GUI by writing to the TTY device. But since the editor is now a background job , the TTY device will not allow it. Instead, the TTY will send SIGTTOU to the editor, stopping it again. This fact will be communicated to the session leader using SIGCHLD , and the shell will once again write \"[1]+ Stopped\" to the terminal. When we type fg , however, the shell first restores the line discipline configuration that was saved earlier. It informs the TTY driver that the editor job should be treated as the foreground job from now on. And finally, it sends a SIGCONT signal to the process group. The editor process attempts to redraw its GUI, and this time it will not be interrupted by SIGTTOU since it is now a part of the foreground job .","title":"An example"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#flow#control#and#blocking#io","text":"Run yes in an xterm , and you will see a lot of \" y \" lines swooshing past your eyes. Naturally, the yes process is able to generate \" y \" lines much faster than the xterm application is able to parse them, update its frame buffer, communicate with the X server in order to scroll the window and so on. How is it possible for these programs to cooperate? The answer lies in blocking I/O . The pseudo terminal can only keep a certain amount of data inside its kernel buffer, and when that buffer is full and yes tries to call write(2) , then write(2) will block , moving the yes process into the interruptible sleep state where it remains until the xterm process has had a chance to read off some of the buffered bytes. The same thing happens if the TTY is connected to a serial port. yes would be able to transmit data at a much higher rate than, say, 9600 baud, but if the serial port is limited to that speed, the kernel buffer soon fills up and any subsequent write(2) calls block the process (or fail with the error code EAGAIN if the process has requested non-blocking I/O). What if I told you, that it is possible to explicitly put the TTY in a blocking state even though there is space left in the kernel buffer? That until further notice, every process trying to write(2) to the TTY automatically blocks. What would be the use of such a feature? Suppose we're talking to some old VT-100 hardware at 9600 baud. We just sent a complex control sequence asking the terminal to scroll the display. At this point, the terminal gets so bogged down with the scrolling operation\uff08\u7ec8\u7aef\u56e0\u6eda\u52a8\u64cd\u4f5c\u9677\u5165\u56f0\u5883\uff09, that it's unable to receive new data at the full rate of 9600 baud. Well, physically, the terminal UART still runs at 9600 baud, but there won't be enough buffer space in the terminal to keep a backlog of received characters. This is when it would be a good time to put the TTY in a blocking state. But how do we do that from the terminal? We have already seen that a TTY device may be configured to give certain data bytes a special treatment. In the default configuration, for instance, a received ^C byte won't be handed off to the application through read(2) , but will instead cause a SIGINT to be delivered to the foreground job . In a similar way, it is possible to configure the TTY to react on a stop flow byte and a start flow byte. These are typically ^S (ASCII code 19) and ^Q (ASCII code 17) respectively. Old hardware terminals transmit these bytes automatically, and expect the operating system to regulate\uff08\u8c03\u8282\uff09 its flow of data accordingly. This is called flow control , and it's the reason why your xterm sometimes appears to lock up when you accidentally press ^S . There's an important difference here: Writing to a TTY which is stopped due to flow control , or due to lack of kernel buffer space , will block your process, whereas writing to a TTY from a background job will cause a SIGTTOU to suspend the entire process group. I don't know why the designers of UNIX had to go all the way to invent SIGTTOU and SIGTTIN instead of relying on blocking I/O , but my best guess is that the TTY driver, being in charge of job control, was designed to monitor and manipulate whole jobs; never the individual processes within them.","title":"Flow control and blocking I/O"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#configuring#the#tty#device","text":"To find out what the controlling TTY for your shell is called, you could refer to the ps l listing as described earlier, or you could simply run the tty(1) command. A process may read or modify the configuration of an open TTY device using ioctl(2) . The API is described in tty_ioctl(4) . Since it's part of the binary interface between Linux applications and the kernel , it will remain stable across Linux versions. However, the interface is non-portable, and applications should rather use the POSIX wrappers described in the termios(3) man page. I won't go into the details of the termios(3) interface, but if you're writing a C program and would like to intercept ^C before it becomes a SIGINT , disable line editing or character echoing, change the baud rate of a serial port, turn off flow control etc. then you will find what you need in the aforementioned man page. There is also a command line tool, called stty(1) , to manipulate TTY devices. It uses the termios(3) API. Let's try it! $ stty -a speed 38400 baud ; rows 73 ; columns 238 ; line = 0 ; intr = ^C ; quit = ^ \\; erase = ^? ; kill = ^U ; eof = ^D ; eol = <undef> ; eol2 = <undef> ; swtch = <undef> ; start = ^Q ; stop = ^S ; susp = ^Z ; rprnt = ^R ; werase = ^W ; lnext = ^V ; flush = ^O ; min = 1 ; time = 0 ; -parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -ignbrk brkint ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany imaxbel -iutf8 opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke The -a flag tells stty to display all settings. By default, it will look at the TTY device attached to your shell, but you can specify another device with -F . Some of these settings refer to UART parameters, some affect the line discipline and some are for job control. All mixed up in a bucket for monsieur. Let's have a look at the first line: speed UART The baud rate. Ignored for pseudo terminals. rows, columns TTY driver Somebody's idea of the size, in characters, of the terminal attached to this TTY device. Basically, it's just a pair of variables within kernel space, that you may freely set and get. Setting them will cause the TTY driver to dispatch a SIGWINCH to the foreground job. line Line discipline The line discipline attached to the TTY device. 0 is N_TTY . All valid numbers are listed in /proc/tty/ldiscs . Unlisted numbers appear to be aliases for N_TTY , but don't rely on it. Try the following: Start an xterm . Make a note of its TTY device (as reported by tty ) and its size (as reported by stty -a ). Start vim (or some other full-screen terminal application) in the xterm . The editor queries the TTY device for the current terminal size in order to fill the entire window. Now, from a different shell window, type: stty -F X rows Y where X is the TTY device, and Y is half the terminal height. This will update the TTY data structure in kernel memory, and send a SIGWINCH to the editor, which will promptly redraw itself using only the upper half of the available window area. The second line of stty -a output lists all the special characters. Start a new xterm and try this: stty intr o Now \" o \", rather than ^C , will send a SIGINT to the foreground job. Try starting something, such as cat , and verify that you can't kill it using ^C . Then, try typing \" hello \" into it. Occasionally, you may come across a UNIX system where the backspace key doesn't work. This happens when the terminal emulator transmits a backspace code (either ASCII 8 or ASCII 127) which doesn't match the erase setting in the TTY device. To remedy the problem, one usually types stty erase ^H (for ASCII 8) or stty erase ^? (for ASCII 127). But please remember that many terminal applications use readline , which puts the line discipline in raw mode. Those applications aren't affected. Finally, stty -a lists a bunch of switches. As expected, they are listed in no particular order. Some of them are UART-related, some affect the line discipline behaviour, some are for flow control and some are for job control. A dash ( - ) indicates that the switch is off; otherwise it is on. All of the switches are explained in the stty(1) man page, so I'll just briefly mention a few: icanon toggles the canonical (line-based) mode. Try this in a new xterm : stty -icanon ; cat Note how all the line editing characters, such as backspace and ^U , have stopped working. Also note that cat is receiving (and consequently outputting) one character at a time, rather than one line at a time. echo enables character echoing, and is on by default. Re-enable canonical mode ( stty icanon ), and then try: stty -echo ; cat As you type, your terminal emulator transmits information to the kernel. Usually, the kernel echoes the same information back to the terminal emulator, allowing you to see what you type. Without character echoing, you can't see what you type, but we're in cooked mode so the line editing facilities are still working. Once you press enter, the line discipline will transmit the edit buffer to cat , which will reveal what your wrote. tostop controls whether background jobs are allowed to write to the terminal. First try this: stty tostop ; ( sleep 5 ; echo hello, world ) & The & causes the command to run as a background job. After five seconds, the job will attempt to write to the TTY. The TTY driver will suspend it using SIGTTOU , and your shell will probably report this fact, either immediately, or when it's about to issue a new prompt to you. Now kill the background job, and try the following instead: stty -tostop ; ( sleep 5 ; echo hello, world ) & You will get your prompt back, but after five seconds, the background job transmits hello, world to the terminal, in the middle of whatever you were typing. Finally, stty sane will restore your TTY device configuration to something reasonable.","title":"Configuring the TTY device"},{"location":"Programming/Terminal/Unix-The-TTY-demystified/#conclusion","text":"I hope this article has provided you with enough information to get to terms with TTY drivers and line disciplines, and how they are related to terminals, line editing and job control. Further details can be found in the various man pages I've mentioned, as well as in the glibc manual ( info libc , \"Job Control\"). Finally, while I don't have enough time to answer all the questions I get, I do welcome feedback on this and other pages on the site. Thanks for reading!","title":"Conclusion"},{"location":"Programming/Terminal/Unix-terminal-shell-tty-console/","text":"What is the exact difference between a 'terminal', a 'shell', a 'tty' and a 'console'? I think these terms almost refer to the same thing, when used loosely: terminal shell tty console What exactly does each of these terms refer to? COMMENTS : 76 The TTY demystified \u2013 firo Mar 7 '13 at 7:54 27 I'd like to add 'command line' to that :-) \u2013 teeks99 Sep 7 '14 at 13:32 1 The command line is simply the language used to send commands to the command-line interpreter running in a shell from the terminal/terminal emulator. \u2013 Marty Fried Sep 7 '14 at 18:03 1 The teletypewriter (TTY) was first put in operation and exhibited at the Mechanics Institute in New York in 1844. en.wikipedia.org/wiki/Teleprinter \u2013 Serge Stroobandt Dec 10 '15 at 20:28 Two more useful links - feyrer.de/NetBSD/ttys.html and quora.com/\u2026 \u2013 Nishant Dec 25 '18 at 19:58 A A terminal is at the end of an electric wire, a shell is the home of a turtle, tty is a strange abbreviation and a console is a kind of cabinet. Well, etymologically speaking, anyway. In unix terminology, the short answer is that terminal = tty = text input/output environment console = physical terminal shell = command line interpreter Console, terminal and tty are closely related. Originally, they meant a piece of equipment through which you could interact with a computer: in the early days of unix, that meant a teleprinter -style device resembling a typewriter, sometimes called a teletypewriter, or \u201ctty\u201d in shorthand. The name \u201cterminal\u201d came from the electronic point of view, and the name \u201cconsole\u201d from the furniture point of view. Very early in unix history, electronic keyboards and displays became the norm for terminals. In unix terminology, a tty is a particular kind of device file which implements a number of additional commands ( ioctls ) beyond read and write. In its most common meaning, terminal is synonymous with tty. Some ttys are provided by the kernel on behalf of a hardware device, for example with the input coming from the keyboard and the output going to a text mode screen, or with the input and output transmitted over a serial line. Other ttys, sometimes called pseudo-ttys , are provided (through a thin kernel layer) by programs called terminal emulators , such as Xterm (running in the X Window System ), Screen (which provides a layer of isolation between a program and another terminal), Ssh (which connects a terminal on one machine with programs on another machine), Expect (for scripting terminal interactions), etc. The word terminal can also have a more traditional meaning of a device through which one interacts with a computer, typically with a keyboard and display. For example an X terminal is a kind of thin client , a special-purpose computer whose only purpose is to drive a keyboard, display, mouse and occasionally other human interaction peripherals, with the actual applications running on another, more powerful computer. A console is generally a terminal in the physical sense that is by some definition the primary terminal directly connected to a machine. The console appears to the operating system as a (kernel-implemented) tty. On some systems, such as Linux and FreeBSD, the console appears as several ttys (special key combinations switch between these ttys); just to confuse matters, the name given to each particular tty can be \u201cconsole\u201d, \u201dvirtual console\u201d, \u201dvirtual terminal\u201d, and other variations. See also Why is a Virtual Terminal \u201cvirtual\u201d, and what/why/where is the \u201creal\u201d Terminal? . A shell is the primary interface that users see when they log in, whose primary purpose is to start other programs. (I don't know whether the original metaphor is that the shell is the home environment for the user, or that the shell is what other programs are running in.) In unix circles, shell has specialized to mean a command-line shell , centered around entering the name of the application one wants to start, followed by the names of files or other objects that the application should act on, and pressing the Enter key. Other types of environments don't use the word \u201cshell\u201d; for example, window systems involve \u201c window managers \u201d and \u201c desktop environments \u201d, not a \u201cshell\u201d. There are many different unix shells. Popular shells for interactive use include Bash (the default on most Linux installations), zsh (which emphasizes power and customizability) and fish (which emphasizes simplicity). Command-line shells include flow control constructs to combine commands. In addition to typing commands at an interactive prompt, users can write scripts. The most common shells have a common syntax based on the Bourne_shell . When discussing \u201c shell programming \u201d, the shell is almost always implied to be a Bourne-style shell. Some shells that are often used for scripting but lack advanced interactive features include the Korn shell (ksh) and many ash variants. Pretty much any Unix-like system has a Bourne-style shell installed as /bin/sh , usually ash, ksh or bash. In unix system administration, a user's shell is the program that is invoked when they log in. Normal user accounts have a command-line shell, but users with restricted access may have a restricted shell or some other specific command (e.g. for file-transfer-only accounts). The division of labor between the terminal and the shell is not completely obvious. Here are their main tasks. Input: the terminal converts keys into control sequences (e.g. Left \u2192 \\e[D ). The shell converts control sequences into commands (e.g. \\e[D \u2192 backward-char ). Line editing, input history and completion are provided by the shell. The terminal may provide its own line editing, history and completion instead, and only send a line to the shell when it's ready to be executed. The only common terminal that operates in this way is M-x shell in Emacs. Output: the shell emits instructions such as \u201cdisplay foo \u201d, \u201cswitch the foreground color to green\u201d, \u201cmove the cursor to the next line\u201d, etc. The terminal acts on these instructions. The prompt is purely a shell concept. The shell never sees the output of the commands it runs (unless redirected). Output history (scrollback) is purely a terminal concept. Inter-application copy-paste is provided by the terminal (usually with the mouse or key sequences such as Ctrl+Shift+V or Shift+Insert). The shell may have its own internal copy-paste mechanism as well (e.g. Meta+W and Ctrl+Y). Job control (launching programs in the background and managing them) is mostly performed by the shell. However, it's the terminal that handles key combinations like Ctrl+C to kill the foreground job and Ctrl+Z to suspend it.","title":"[What is the exact difference between a 'terminal', a 'shell', a 'tty' and a 'console'?](https://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con)"},{"location":"Programming/Terminal/Unix-terminal-shell-tty-console/#what#is#the#exact#difference#between#a#terminal#a#shell#a#tty#and#a#console","text":"I think these terms almost refer to the same thing, when used loosely: terminal shell tty console What exactly does each of these terms refer to? COMMENTS : 76 The TTY demystified \u2013 firo Mar 7 '13 at 7:54 27 I'd like to add 'command line' to that :-) \u2013 teeks99 Sep 7 '14 at 13:32 1 The command line is simply the language used to send commands to the command-line interpreter running in a shell from the terminal/terminal emulator. \u2013 Marty Fried Sep 7 '14 at 18:03 1 The teletypewriter (TTY) was first put in operation and exhibited at the Mechanics Institute in New York in 1844. en.wikipedia.org/wiki/Teleprinter \u2013 Serge Stroobandt Dec 10 '15 at 20:28 Two more useful links - feyrer.de/NetBSD/ttys.html and quora.com/\u2026 \u2013 Nishant Dec 25 '18 at 19:58","title":"What is the exact difference between a 'terminal', a 'shell', a 'tty' and a 'console'?"},{"location":"Programming/Terminal/Unix-terminal-shell-tty-console/#a","text":"A terminal is at the end of an electric wire, a shell is the home of a turtle, tty is a strange abbreviation and a console is a kind of cabinet. Well, etymologically speaking, anyway. In unix terminology, the short answer is that terminal = tty = text input/output environment console = physical terminal shell = command line interpreter Console, terminal and tty are closely related. Originally, they meant a piece of equipment through which you could interact with a computer: in the early days of unix, that meant a teleprinter -style device resembling a typewriter, sometimes called a teletypewriter, or \u201ctty\u201d in shorthand. The name \u201cterminal\u201d came from the electronic point of view, and the name \u201cconsole\u201d from the furniture point of view. Very early in unix history, electronic keyboards and displays became the norm for terminals. In unix terminology, a tty is a particular kind of device file which implements a number of additional commands ( ioctls ) beyond read and write. In its most common meaning, terminal is synonymous with tty. Some ttys are provided by the kernel on behalf of a hardware device, for example with the input coming from the keyboard and the output going to a text mode screen, or with the input and output transmitted over a serial line. Other ttys, sometimes called pseudo-ttys , are provided (through a thin kernel layer) by programs called terminal emulators , such as Xterm (running in the X Window System ), Screen (which provides a layer of isolation between a program and another terminal), Ssh (which connects a terminal on one machine with programs on another machine), Expect (for scripting terminal interactions), etc. The word terminal can also have a more traditional meaning of a device through which one interacts with a computer, typically with a keyboard and display. For example an X terminal is a kind of thin client , a special-purpose computer whose only purpose is to drive a keyboard, display, mouse and occasionally other human interaction peripherals, with the actual applications running on another, more powerful computer. A console is generally a terminal in the physical sense that is by some definition the primary terminal directly connected to a machine. The console appears to the operating system as a (kernel-implemented) tty. On some systems, such as Linux and FreeBSD, the console appears as several ttys (special key combinations switch between these ttys); just to confuse matters, the name given to each particular tty can be \u201cconsole\u201d, \u201dvirtual console\u201d, \u201dvirtual terminal\u201d, and other variations. See also Why is a Virtual Terminal \u201cvirtual\u201d, and what/why/where is the \u201creal\u201d Terminal? . A shell is the primary interface that users see when they log in, whose primary purpose is to start other programs. (I don't know whether the original metaphor is that the shell is the home environment for the user, or that the shell is what other programs are running in.) In unix circles, shell has specialized to mean a command-line shell , centered around entering the name of the application one wants to start, followed by the names of files or other objects that the application should act on, and pressing the Enter key. Other types of environments don't use the word \u201cshell\u201d; for example, window systems involve \u201c window managers \u201d and \u201c desktop environments \u201d, not a \u201cshell\u201d. There are many different unix shells. Popular shells for interactive use include Bash (the default on most Linux installations), zsh (which emphasizes power and customizability) and fish (which emphasizes simplicity). Command-line shells include flow control constructs to combine commands. In addition to typing commands at an interactive prompt, users can write scripts. The most common shells have a common syntax based on the Bourne_shell . When discussing \u201c shell programming \u201d, the shell is almost always implied to be a Bourne-style shell. Some shells that are often used for scripting but lack advanced interactive features include the Korn shell (ksh) and many ash variants. Pretty much any Unix-like system has a Bourne-style shell installed as /bin/sh , usually ash, ksh or bash. In unix system administration, a user's shell is the program that is invoked when they log in. Normal user accounts have a command-line shell, but users with restricted access may have a restricted shell or some other specific command (e.g. for file-transfer-only accounts). The division of labor between the terminal and the shell is not completely obvious. Here are their main tasks. Input: the terminal converts keys into control sequences (e.g. Left \u2192 \\e[D ). The shell converts control sequences into commands (e.g. \\e[D \u2192 backward-char ). Line editing, input history and completion are provided by the shell. The terminal may provide its own line editing, history and completion instead, and only send a line to the shell when it's ready to be executed. The only common terminal that operates in this way is M-x shell in Emacs. Output: the shell emits instructions such as \u201cdisplay foo \u201d, \u201cswitch the foreground color to green\u201d, \u201cmove the cursor to the next line\u201d, etc. The terminal acts on these instructions. The prompt is purely a shell concept. The shell never sees the output of the commands it runs (unless redirected). Output history (scrollback) is purely a terminal concept. Inter-application copy-paste is provided by the terminal (usually with the mouse or key sequences such as Ctrl+Shift+V or Shift+Insert). The shell may have its own internal copy-paste mechanism as well (e.g. Meta+W and Ctrl+Y). Job control (launching programs in the background and managing them) is mostly performed by the shell. However, it's the terminal that handles key combinations like Ctrl+C to kill the foreground job and Ctrl+Z to suspend it.","title":"A"},{"location":"Programming/Terminal/Unix-tty-pty/","text":"tty (unix) In computing , tty is a command in Unix and Unix-like operating systems to print the file name of the terminal connected to standard input .[ 1] tty stands for TeleTYpewriter.[ 2] Example Given below is a sample output when the command is run $ tty /dev/pts/10 man 4 tty NAME \u200b tty - controlling terminal DESCRIPTION The file /dev/tty is a character file with major number 5 and minor number 0, usually of mode 0666 and owner.group root.tty. It is a synonym for the controlling terminal of a process, if any. In addition to the ioctl(2) requests supported by the device that tty refers to, the ioctl(2) request TIOCNOTTY is supported. TIOCNOTTY Detach the calling process from its controlling terminal .If the process is the session leader , then SIGHUP and SIGCONT signals are sent to the foreground process group and all processes in the current session lose their controlling tty . This ioctl(2) call works only on file descriptors connected to /dev/tty . It is used by daemon processes when they are invoked by a user at a terminal. This ioctl(2) call works only on file descriptors connected to /dev/tty . It is used by daemon processes when they are invoked by a user at a terminal. The process attempts to open /dev/tty . If the open succeeds, it detaches itself from the terminal by using TIOCNOTTY , while if the open fails, it is obviously not attached to a terminal and does not need to detach itself. man 1 tty NAME \u200b tty - print the file name of the terminal connected to standard input SYNOPSIS \u200b tty [OPTION]... DESCRIPTION Print the file name of the terminal connected to standard input . man 8 agetty NAME agetty - alternative Linux getty SYNOPSIS agetty [options] port [baud_rate...] [term] DESCRIPTION agetty opens a tty port , prompts for a login name and invokes the /bin/login command.It is normally invoked by init(8) . agetty has several non-standard features that are useful for hard-wired and for dial-in lines: Difference between pts and tty Possible Duplicate: What is the exact difference between a 'terminal', a 'shell', a 'tty' and a 'console'? I always see pts and tty when I use the who command but I never understand how they are different? Can somebody please explain me this? COMMENTS : See also How does a Linux terminal work? and what is stored in /dev/pts files and Can we open those? \u2013 Gilles Nov 14 '13 at 20:07 A A tty is a native terminal device, the backend is either hardware or kernel emulated. A pty (pseudo terminal device) is a terminal device which is emulated by an other program (example: xterm , screen , or ssh are such programs). A pts is the slave part of a pty . (More info can be found in man pty .) Short summary : A pty is created by a process through posix_openpt() (which usually opens the special device /dev/ptmx ), and is constituted by a pair of bidirectional character devices: The master part, which is the file descriptor obtained by this process through this call, is used to emulate a terminal. After some initialization, the second part can be unlocked with unlockpt() , and the master is used to receive or send characters to this second part (slave). The slave part, which is anchored in the filesystem as /dev/pts/x (the real name can be obtained by the master through ptsname() ) behaves like a native terminal device ( /dev/ttyx ). In most cases, a shell is started that uses it as a controlling terminal.","title":"[tty (unix)](https://en.wikipedia.org/wiki/Tty_(unix))"},{"location":"Programming/Terminal/Unix-tty-pty/#tty#unix","text":"In computing , tty is a command in Unix and Unix-like operating systems to print the file name of the terminal connected to standard input .[ 1] tty stands for TeleTYpewriter.[ 2]","title":"tty (unix)"},{"location":"Programming/Terminal/Unix-tty-pty/#example","text":"Given below is a sample output when the command is run $ tty /dev/pts/10","title":"Example"},{"location":"Programming/Terminal/Unix-tty-pty/#man#4#tty","text":"","title":"man 4 tty"},{"location":"Programming/Terminal/Unix-tty-pty/#name","text":"\u200b tty - controlling terminal","title":"NAME"},{"location":"Programming/Terminal/Unix-tty-pty/#description","text":"The file /dev/tty is a character file with major number 5 and minor number 0, usually of mode 0666 and owner.group root.tty. It is a synonym for the controlling terminal of a process, if any. In addition to the ioctl(2) requests supported by the device that tty refers to, the ioctl(2) request TIOCNOTTY is supported.","title":"DESCRIPTION"},{"location":"Programming/Terminal/Unix-tty-pty/#tiocnotty","text":"Detach the calling process from its controlling terminal .If the process is the session leader , then SIGHUP and SIGCONT signals are sent to the foreground process group and all processes in the current session lose their controlling tty . This ioctl(2) call works only on file descriptors connected to /dev/tty . It is used by daemon processes when they are invoked by a user at a terminal. This ioctl(2) call works only on file descriptors connected to /dev/tty . It is used by daemon processes when they are invoked by a user at a terminal. The process attempts to open /dev/tty . If the open succeeds, it detaches itself from the terminal by using TIOCNOTTY , while if the open fails, it is obviously not attached to a terminal and does not need to detach itself.","title":"TIOCNOTTY"},{"location":"Programming/Terminal/Unix-tty-pty/#man#1#tty","text":"","title":"man 1 tty"},{"location":"Programming/Terminal/Unix-tty-pty/#name_1","text":"\u200b tty - print the file name of the terminal connected to standard input","title":"NAME"},{"location":"Programming/Terminal/Unix-tty-pty/#synopsis","text":"\u200b tty [OPTION]...","title":"SYNOPSIS"},{"location":"Programming/Terminal/Unix-tty-pty/#description_1","text":"Print the file name of the terminal connected to standard input .","title":"DESCRIPTION"},{"location":"Programming/Terminal/Unix-tty-pty/#man#8#agetty","text":"","title":"man 8 agetty"},{"location":"Programming/Terminal/Unix-tty-pty/#name_2","text":"agetty - alternative Linux getty","title":"NAME"},{"location":"Programming/Terminal/Unix-tty-pty/#synopsis_1","text":"agetty [options] port [baud_rate...] [term]","title":"SYNOPSIS"},{"location":"Programming/Terminal/Unix-tty-pty/#description_2","text":"agetty opens a tty port , prompts for a login name and invokes the /bin/login command.It is normally invoked by init(8) . agetty has several non-standard features that are useful for hard-wired and for dial-in lines:","title":"DESCRIPTION"},{"location":"Programming/Terminal/Unix-tty-pty/#difference#between#pts#and#tty","text":"Possible Duplicate: What is the exact difference between a 'terminal', a 'shell', a 'tty' and a 'console'? I always see pts and tty when I use the who command but I never understand how they are different? Can somebody please explain me this? COMMENTS : See also How does a Linux terminal work? and what is stored in /dev/pts files and Can we open those? \u2013 Gilles Nov 14 '13 at 20:07","title":"Difference between pts and tty"},{"location":"Programming/Terminal/Unix-tty-pty/#a","text":"A tty is a native terminal device, the backend is either hardware or kernel emulated. A pty (pseudo terminal device) is a terminal device which is emulated by an other program (example: xterm , screen , or ssh are such programs). A pts is the slave part of a pty . (More info can be found in man pty .) Short summary : A pty is created by a process through posix_openpt() (which usually opens the special device /dev/ptmx ), and is constituted by a pair of bidirectional character devices: The master part, which is the file descriptor obtained by this process through this call, is used to emulate a terminal. After some initialization, the second part can be unlocked with unlockpt() , and the master is used to receive or send characters to this second part (slave). The slave part, which is anchored in the filesystem as /dev/pts/x (the real name can be obtained by the master through ptsname() ) behaves like a native terminal device ( /dev/ttyx ). In most cases, a shell is started that uses it as a controlling terminal.","title":"A"},{"location":"Programming/Terminal/unix-shell-and-terminal/","text":"what is terminal \u7406\u89e3chapter9.2 Terminal Logins\u7684\u4e00\u4e2a\u5173\u952e\u662f\u77e5\u9053what is terminal\uff1b\u5728chapter 9.2\u4e2d\u6709\u4e00\u6bb5\u8bdd\u70b9\u5230\u4e86\u5173\u952e\u6240\u5728\uff1a A host had a fixed number of these terminal devices, so there was a known upper limit on the number of simultaneous logins. \u663e\u7136\uff0c\u6807\u9898\u4e2d\u7684***terminal***\u7684\u542b\u4e49\u662fterminal device\uff0c\u5373\u7ec8\u7aef\u8bbe\u5907\uff1b\u663e\u7136\u6b64\u8bbe\u5907\u5c31\u5982\u540ccomputer\u4e2d\u7684\u5f88\u591a\u5176\u4ed6\u8bbe\u5907\u5982keyboard\u4e00\u822c\uff1b\u5728\u6587\u7ae0 The TTY demystified \u5bf9\u6b64\u6709\u975e\u5e38\u597d\u7684\u89e3\u91ca\uff1b \u4e00\u4e2a\u76f4\u89c2\u7684\u7406\u89e3\u5c31\u662f\uff1a\u6bcf\u6b21\u6211\u4eec\u4f7f\u7528\u6211\u4eec\u7684\u7b14\u8bb0\u672c\u7535\u8111\uff0c\u5f00\u673a\u540e\u5c4f\u5e55\u4e2d\u90fd\u80fd\u591f\u663e\u793a\u767b\u5f55\u754c\u9762\uff0c\u6211\u4eec\u5728\u6b64\u767b\u5f55\u754c\u9762\u4e2d\u8f93\u5165\u7528\u6237\u540d\u5f88\u5bc6\u7801\uff1b\u6b64\u5373terminal login\uff1bUnix\u4e2d\u7684terminal login\u548c\u6b64\u662f\u76f8\u540c\u7684\uff1b terminal \u548c shell\u4e4b\u95f4\u7684\u5173\u7cfb\uff1f shell\u5c06\u5b83\u7684\u6807\u51c6\u8f93\u5165\u548c\u6807\u51c6\u8f93\u51fa\u90fd\u8fde\u5230terminal\uff1b","title":"what is terminal"},{"location":"Programming/Terminal/unix-shell-and-terminal/#what#is#terminal","text":"\u7406\u89e3chapter9.2 Terminal Logins\u7684\u4e00\u4e2a\u5173\u952e\u662f\u77e5\u9053what is terminal\uff1b\u5728chapter 9.2\u4e2d\u6709\u4e00\u6bb5\u8bdd\u70b9\u5230\u4e86\u5173\u952e\u6240\u5728\uff1a A host had a fixed number of these terminal devices, so there was a known upper limit on the number of simultaneous logins. \u663e\u7136\uff0c\u6807\u9898\u4e2d\u7684***terminal***\u7684\u542b\u4e49\u662fterminal device\uff0c\u5373\u7ec8\u7aef\u8bbe\u5907\uff1b\u663e\u7136\u6b64\u8bbe\u5907\u5c31\u5982\u540ccomputer\u4e2d\u7684\u5f88\u591a\u5176\u4ed6\u8bbe\u5907\u5982keyboard\u4e00\u822c\uff1b\u5728\u6587\u7ae0 The TTY demystified \u5bf9\u6b64\u6709\u975e\u5e38\u597d\u7684\u89e3\u91ca\uff1b \u4e00\u4e2a\u76f4\u89c2\u7684\u7406\u89e3\u5c31\u662f\uff1a\u6bcf\u6b21\u6211\u4eec\u4f7f\u7528\u6211\u4eec\u7684\u7b14\u8bb0\u672c\u7535\u8111\uff0c\u5f00\u673a\u540e\u5c4f\u5e55\u4e2d\u90fd\u80fd\u591f\u663e\u793a\u767b\u5f55\u754c\u9762\uff0c\u6211\u4eec\u5728\u6b64\u767b\u5f55\u754c\u9762\u4e2d\u8f93\u5165\u7528\u6237\u540d\u5f88\u5bc6\u7801\uff1b\u6b64\u5373terminal login\uff1bUnix\u4e2d\u7684terminal login\u548c\u6b64\u662f\u76f8\u540c\u7684\uff1b","title":"what is terminal"},{"location":"Programming/Terminal/unix-shell-and-terminal/#terminal#shell","text":"shell\u5c06\u5b83\u7684\u6807\u51c6\u8f93\u5165\u548c\u6807\u51c6\u8f93\u51fa\u90fd\u8fde\u5230terminal\uff1b","title":"terminal \u548c shell\u4e4b\u95f4\u7684\u5173\u7cfb\uff1f"},{"location":"Programming/Time/","text":"","title":"Introduction"},{"location":"Programming/Time/Date-and-Time/","text":"Date and time Glibc Date and Time","title":"Date-and-Time"},{"location":"Programming/Time/Date-and-Time/#date#and#time","text":"","title":"Date and time"},{"location":"Programming/Time/Date-and-Time/#glibc#date#and#time","text":"","title":"Glibc Date and Time"},{"location":"Programming/Time/man-clock_gettime/","text":"clock_gettime https://linux.die.net/man/2/clock_gettime","title":"man-clock_gettime"},{"location":"Programming/Time/man-clock_gettime/#clock_gettime","text":"https://linux.die.net/man/2/clock_gettime","title":"clock_gettime"},{"location":"Programming/Util/","text":"","title":"Introduction"},{"location":"Programming/Util/Log/Linux-log-files/","text":"LinuxLogFiles","title":"Linux-log-files"},{"location":"Programming/Util/Log/Linux-log-files/#linuxlogfiles","text":"","title":"LinuxLogFiles"},{"location":"Programming/Util/Log/Syslog/Syslog/","text":"syslog Syslog Tutorial: How It Works, Examples, Best Practices, and More 10.5 The UNIX System Log (syslog) Facility","title":"Syslog"},{"location":"Programming/Util/Log/Syslog/Syslog/#syslog","text":"Syslog Tutorial: How It Works, Examples, Best Practices, and More 10.5 The UNIX System Log (syslog) Facility","title":"syslog"},{"location":"Programming/Virtualization/","text":"\u524d\u8a00 \u672c\u7ae0\u4e3b\u8981\u4ecb\u7ecd virtualization \u6280\u672f\uff0c\u91cd\u70b9\u5173\u6ce8linux OS-level virtualization \u3002 \u7136\u540e\u91cd\u70b9\u4ecb\u7ecdlinux kernel\u662f\u5982\u4f55\u5b9e\u73b0 OS-level virtualization \u7684\u3002","title":"Introduction"},{"location":"Programming/Virtualization/#_1","text":"\u672c\u7ae0\u4e3b\u8981\u4ecb\u7ecd virtualization \u6280\u672f\uff0c\u91cd\u70b9\u5173\u6ce8linux OS-level virtualization \u3002 \u7136\u540e\u91cd\u70b9\u4ecb\u7ecdlinux kernel\u662f\u5982\u4f55\u5b9e\u73b0 OS-level virtualization \u7684\u3002","title":"\u524d\u8a00"},{"location":"Programming/Virtualization/Linux-containers/","text":"Linux containers LXC","title":"Linux-containers"},{"location":"Programming/Virtualization/Linux-containers/#linux#containers","text":"","title":"Linux containers"},{"location":"Programming/Virtualization/Linux-containers/#lxc","text":"","title":"LXC"},{"location":"Programming/Virtualization/Linux-control-groups/Control-groups/","text":"NAMESPACES(7) cgroups","title":"Introduction"},{"location":"Programming/Virtualization/Linux-control-groups/Control-groups/#namespaces7","text":"","title":"NAMESPACES(7)"},{"location":"Programming/Virtualization/Linux-control-groups/Control-groups/#cgroups","text":"","title":"cgroups"},{"location":"Programming/Virtualization/Linux-namespaces/","text":"\u524d\u8a00 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u7c7b\u6bd4\u7684\u65b9\u6cd5\u6765\u7406\u89e3linux namespace\uff0c\u5373\u4ece\u5176\u4ed6\u4f7f\u7528\u4e86namespace\u7684\u9886\u57df\u6765\u7c7b\u6bd4\u7406\u89e3linux namespace\uff0c\u6bd4\u5982 c++ \u4e2d\u7684 namespace \u3002\u7ef4\u57fa\u767e\u79d1\u7684 Namespace \u5bf9\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u7684 namespace \u8fdb\u884c\u4e86\u603b\u7ed3\uff0c\u8fd9\u7bc7\u6587\u7ae0\u6bd4\u8f83\u597d\u3002\u663e\u7136\uff0c\u65e0\u8bba\u5728\u54ea\u4e2a\u5c42\u7ea7\uff08programming language\u3001operating system\uff09\uff0c\u4f7f\u7528namespace\u7684\u76ee\u7684\u662f\uff1a separation \u4ee5Hierarchy\u7684\u7ed3\u6784\u6765\u7ec4\u7ec7\u6570\u636e \u5728\u7406\u89e3\u4e86\u4f7f\u7528namespace\u7684\u76ee\u7684\u540e\uff0c\u63a8\u8350\u9605\u8bfb Separation Anxiety: A Tutorial for Isolating Your System with Linux Namespaces \uff0c\u8fd9\u7bc7\u6587\u7ae0\u6bd4\u8f83\u8f93\u5165\u6d45\u51fa\uff0c\u9605\u8bfb\u5b8c\u6210\u540e\uff0c\u57fa\u672c\u4e0a\u80fd\u591f\u77e5\u9053linux namespace\u6240\u89e3\u51b3\u7684\u5b9e\u9645\u95ee\u9898\u548c\u5b83\u7684\u4ef7\u503c\u4e86\u3002 \u638c\u63e1\u4e86\u8fd9\u4e9b\u540e\uff0c\u518d\u53bb\u9605\u8bfbman\u4e2d\u5bf9\u5b83\u7684\u89e3\u91ca\u5c31\u4f1a\u975e\u5e38\u5bb9\u6613\u4e86\u3002","title":"Introduction"},{"location":"Programming/Virtualization/Linux-namespaces/#_1","text":"\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u7c7b\u6bd4\u7684\u65b9\u6cd5\u6765\u7406\u89e3linux namespace\uff0c\u5373\u4ece\u5176\u4ed6\u4f7f\u7528\u4e86namespace\u7684\u9886\u57df\u6765\u7c7b\u6bd4\u7406\u89e3linux namespace\uff0c\u6bd4\u5982 c++ \u4e2d\u7684 namespace \u3002\u7ef4\u57fa\u767e\u79d1\u7684 Namespace \u5bf9\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u7684 namespace \u8fdb\u884c\u4e86\u603b\u7ed3\uff0c\u8fd9\u7bc7\u6587\u7ae0\u6bd4\u8f83\u597d\u3002\u663e\u7136\uff0c\u65e0\u8bba\u5728\u54ea\u4e2a\u5c42\u7ea7\uff08programming language\u3001operating system\uff09\uff0c\u4f7f\u7528namespace\u7684\u76ee\u7684\u662f\uff1a separation \u4ee5Hierarchy\u7684\u7ed3\u6784\u6765\u7ec4\u7ec7\u6570\u636e \u5728\u7406\u89e3\u4e86\u4f7f\u7528namespace\u7684\u76ee\u7684\u540e\uff0c\u63a8\u8350\u9605\u8bfb Separation Anxiety: A Tutorial for Isolating Your System with Linux Namespaces \uff0c\u8fd9\u7bc7\u6587\u7ae0\u6bd4\u8f83\u8f93\u5165\u6d45\u51fa\uff0c\u9605\u8bfb\u5b8c\u6210\u540e\uff0c\u57fa\u672c\u4e0a\u80fd\u591f\u77e5\u9053linux namespace\u6240\u89e3\u51b3\u7684\u5b9e\u9645\u95ee\u9898\u548c\u5b83\u7684\u4ef7\u503c\u4e86\u3002 \u638c\u63e1\u4e86\u8fd9\u4e9b\u540e\uff0c\u518d\u53bb\u9605\u8bfbman\u4e2d\u5bf9\u5b83\u7684\u89e3\u91ca\u5c31\u4f1a\u975e\u5e38\u5bb9\u6613\u4e86\u3002","title":"\u524d\u8a00"},{"location":"Programming/Virtualization/Linux-namespaces/Linux-Namespaces/","text":"Linux namespaces Separation Anxiety: A Tutorial for Isolating Your System with Linux Namespaces With the advent of tools like Docker , Linux Containers , and others, it has become super easy to isolate Linux processes into their own little system environments. This makes it possible to run a whole range of applications on a single real Linux machine and ensure no two of them can interfere with each other, without having to resort to using virtual machines . These tools have been a huge boon to PaaS providers. But what exactly happens under the hood? These tools rely on a number of features and components of the Linux kernel. Some of these features were introduced fairly recently, while others still require you to patch the kernel itself. But one of the key components, using Linux namespaces , has been a feature of Linux since version 2.6.24 was released in 2008. Anyone familiar with chroot already has a basic idea of what Linux namespaces can do and how to use namespace generally. Just as chroot allows processes to see any arbitrary directory as the root of the system (independent of the rest of the processes), Linux namespaces allow other aspects of the operating system to be independently modified as well. This includes the process tree , networking interfaces, mount points , inter-process communication resources and more. Why Use Namespaces for Process Isolation? In a single-user computer, a single system environment may be fine. But on a server, where you want to run multiple services, it is essential to security and stability that the services are as isolated from each other as possible. Imagine a server running multiple services, one of which gets compromised by an intruder. In such a case, the intruder may be able to exploit that service and work his way to the other services, and may even be able compromise the entire server. Namespace isolation can provide a secure environment to eliminate this risk. For example, using namespacing, it is possible to safely execute arbitrary or unknown programs on your server. Recently, there has been a growing number of programming contest and \u201chackathon\u201d platforms, such as HackerRank , TopCoder , Codeforces , and many more. A lot of them utilize automated pipelines to run and validate programs that are submitted by the contestants. It is often impossible to know in advance the true nature of contestants\u2019 programs, and some may even contain malicious elements. By running these programs namespaced in complete isolation from the rest of the system, the software can be tested and validated without putting the rest of the machine at risk. Similarly, online continuous integration services, such as Drone.io , automatically fetch your code repository and execute the test scripts on their own servers. Again, namespace isolation is what makes it possible to provide these services safely. Namespacing tools like Docker also allow better control over processes\u2019 use of system resources, making such tools extremely popular for use by PaaS providers. Services like Heroku and Google App Engine use such tools to isolate and run multiple web server applications on the same real hardware. These tools allow them to run each application (which may have been deployed by any of a number of different users) without worrying about one of them using too many system resources, or interfering and/or conflicting with other deployed services on the same machine. With such process isolation, it is even possible to have entirely different stacks of dependency softwares (and versions) for each isolated environment! If you\u2019ve used tools like Docker, you already know that these tools are capable of isolating processes in small \u201ccontainers\u201d. Running processes in Docker containers is like running them in virtual machines, only these containers are significantly lighter than virtual machines. Process Namespace Historically, the Linux kernel has maintained a single process tree . The tree contains a reference to every process currently running in a parent-child hierarchy . A process, given it has sufficient privileges and satisfies certain conditions, can inspect another process by attaching a tracer to it or may even be able to kill it. With the introduction of Linux namespaces , it became possible to have multiple \u201cnested\u201d process trees. Each process tree can have an entirely isolated set of processes. This can ensure that processes belonging to one process tree cannot inspect or kill - in fact cannot even know of the existence of - processes in other sibling or parent process trees. Every time a computer with Linux boots up, it starts with just one process, with process identifier (PID) 1. This process is the root of the process tree , and it initiates the rest of the system by performing the appropriate maintenance work and starting the correct daemons/services. All the other processes start below this process in the tree. The PID namespace allows one to spin off a new tree, with its own PID 1 process . The process that does this remains in the parent namespace , in the original tree, but makes the child the root of its own process tree . With PID namespace isolation , processes in the child namespace have no way of knowing of the parent process\u2019s existence. However, processes in the parent namespace have a complete view of processes in the child namespace , as if they were any other process in the parent namespace . It is possible to create a nested set of child namespaces : one process starts a child process in a new PID namespace, and that child process spawns yet another process in a new PID namespace, and so on. With the introduction of PID namespaces , a single process can now have multiple PIDs associated with it, one for each namespace it falls under. In the Linux source code, we can see that a struct named pid , which used to keep track of just a single PID, now tracks multiple PIDs through the use of a struct named upid : struct upid { int nr ; // the PID value struct pid_namespace * ns ; // namespace where this PID is relevant // ... }; struct pid { // ... int level ; // number of upids struct upid numbers [ 0 ]; // array of upids }; To create a new PID namespace , one must call the clone() system call with a special flag CLONE_NEWPID . (C provides a wrapper to expose this system call, and so do many other popular languages.) Whereas the other namespaces discussed below can also be created using the unshare() system call, a PID namespace can only be created at the time a new process is spawned using clone() . Once clone() is called with this flag, the new process immediately starts in a new PID namespace, under a new process tree. This can be demonstrated with a simple C program: #define _GNU_SOURCE #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <sys/wait.h> #include <unistd.h> static char child_stack [ 1048576 ]; static int child_fn () { printf ( \"PID: %ld \\n \" , ( long ) getpid ()); return 0 ; } int main () { pid_t child_pid = clone ( child_fn , child_stack + 1048576 , CLONE_NEWPID | SIGCHLD , NULL ); printf ( \"clone() = %ld \\n \" , ( long ) child_pid ); waitpid ( child_pid , NULL , 0 ); return 0 ; } Compile and run this program with root privileges and you will notice an output that resembles this: clone() = 5304 PID: 1 The PID, as printed from within the child_fn , will be 1 . Try replacing the static int child_fn() function with the following, to print the parent PID from the isolated process\u2019s perspective: static int child_fn () { printf ( \"Parent PID: %ld \\n \" , ( long ) getppid ()); return 0 ; } Running the program this time yields the following output: clone() = 11449 Parent PID: 0 Notice how the parent PID from the isolated process\u2019s perspective is 0, indicating no parent. Try running the same program again, but this time, remove the CLONE_NEWPID flag from within the clone() function call: pid_t child_pid = clone ( child_fn , child_stack + 1048576 , SIGCHLD , NULL ); This time, you will notice that the parent PID is no longer 0: clone() = 11561 Parent PID: 11560 However, this is just the first step in our tutorial. These processes still have unrestricted access to other common or shared resources. For example, the networking interface: if the child process created above were to listen on port 80, it would prevent every other process on the system from being able to listen on it. Linux Network Namespace This is where a network namespace becomes useful. A network namespace allows each of these processes to see an entirely different set of networking interfaces . Even the loopback interface is different for each network namespace. Isolating a process into its own network namespace involves introducing another flag to the clone() function call: CLONE_NEWNET ; #define _GNU_SOURCE #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <sys/wait.h> #include <unistd.h> static char child_stack [ 1048576 ]; static int child_fn () { printf ( \"New `net` Namespace: \\n \" ); system ( \"ip link\" ); printf ( \" \\n\\n \" ); return 0 ; } int main () { printf ( \"Original `net` Namespace: \\n \" ); system ( \"ip link\" ); printf ( \" \\n\\n \" ); pid_t child_pid = clone ( child_fn , child_stack + 1048576 , CLONE_NEWPID | CLONE_NEWNET | SIGCHLD , NULL ); waitpid ( child_pid , NULL , 0 ); return 0 ; } Output: Original `net` Namespace: 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: enp4s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:24:8c:a1:ac:e7 brd ff:ff:ff:ff:ff:ff New `net` Namespace: 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 What\u2019s going on here? The physical ethernet device enp4s0 belongs to the global network namespace , as indicated by the \u201c ip \u201d tool run from this namespace. However, the physical interface is not available in the new network namespace . Moreover, the loopback device is active in the original network namespace , but is \u201cdown\u201d in the child network namespace . In order to provide a usable network interface in the child namespace , it is necessary to set up additional \u201cvirtual\u201d network interfaces which span multiple namespaces. Once that is done, it is then possible to create Ethernet bridges , and even route packets between the namespaces. Finally, to make the whole thing work, a \u201crouting process\u201d must be running in the global network namespace to receive traffic from the physical interface, and route it through the appropriate virtual interfaces to to the correct child network namespaces . Maybe you can see why tools like Docker, which do all this heavy lifting for you, are so popular! To do this by hand, you can create a pair of virtual Ethernet connections between a parent and a child namespace by running a single command from the parent namespace : ip link add name veth0 type veth peer name veth1 netns <pid> Here, <pid> should be replaced by the process ID of the process in the child namespace as observed by the parent. Running this command establishes a pipe-like connection between these two namespaces. The parent namespace retains the veth0 device, and passes the veth1 device to the child namespace. Anything that enters one of the ends, comes out through the other end, just as you would expect from a real Ethernet connection between two real nodes. Accordingly, both sides of this virtual Ethernet connection must be assigned IP addresses. Mount Namespace Linux also maintains a data structure for all the mountpoints of the system. It includes information like what disk partitions are mounted, where they are mounted, whether they are readonly, et cetera. With Linux namespaces, one can have this data structure cloned, so that processes under different namespaces can change the mountpoints without affecting each other. Creating separate mount namespace has an effect similar to doing a chroot() . chroot() is good, but it does not provide complete isolation, and its effects are restricted to the root mountpoint only. Creating a separate mount namespace allows each of these isolated processes to have a completely different view of the entire system\u2019s mountpoint structure from the original one. This allows you to have a different root for each isolated process, as well as other mountpoints that are specific to those processes. Used with care per this tutorial, you can avoid exposing any information about the underlying system. The clone() flag required to achieve this is CLONE_NEWNS : clone ( child_fn , child_stack + 1048576 , CLONE_NEWPID | CLONE_NEWNET | CLONE_NEWNS | SIGCHLD , NULL ) Initially, the child process sees the exact same mountpoints as its parent process would. However, being under a new mount namespace , the child process can mount or unmount whatever endpoints it wants to, and the change will affect neither its parent\u2019s namespace, nor any other mount namespace in the entire system. For example, if the parent process has a particular disk partition mounted at root, the isolated process will see the exact same disk partition mounted at the root in the beginning. But the benefit of isolating the mount namespace is apparent when the isolated process tries to change the root partition to something else, as the change will only affect the isolated mount namespace. Interestingly, this actually makes it a bad idea to spawn the target child process directly with the CLONE_NEWNS flag. A better approach is to start a special \u201cinit\u201d process with the CLONE_NEWNS flag, have that \u201cinit\u201d process change the \u201c/\u201d, \u201c/proc\u201d, \u201c/dev\u201d or other mountpoints as desired, and then start the target process. This is discussed in a little more detail near the end of this namespace tutorial. Other Namespaces There are other namespaces that these processes can be isolated into, namely user, IPC, and UTS. The user namespace allows a process to have root privileges within the namespace , without giving it that access to processes outside of the namespace. Isolating a process by the IPC namespace gives it its own interprocess communication resources, for example, System V IPC and POSIX messages. The UTS namespace isolates two specific identifiers of the system: nodename and domainname . A quick example to show how UTS namespace is isolated is shown below: #define _GNU_SOURCE #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <sys/utsname.h> #include <sys/wait.h> #include <unistd.h> static char child_stack [ 1048576 ]; static void print_nodename () { struct utsname utsname ; uname ( & utsname ); printf ( \"%s \\n \" , utsname . nodename ); } static int child_fn () { printf ( \"New UTS namespace nodename: \" ); print_nodename (); printf ( \"Changing nodename inside new UTS namespace \\n \" ); sethostname ( \"GLaDOS\" , 6 ); printf ( \"New UTS namespace nodename: \" ); print_nodename (); return 0 ; } int main () { printf ( \"Original UTS namespace nodename: \" ); print_nodename (); pid_t child_pid = clone ( child_fn , child_stack + 1048576 , CLONE_NEWUTS | SIGCHLD , NULL ); sleep ( 1 ); printf ( \"Original UTS namespace nodename: \" ); print_nodename (); waitpid ( child_pid , NULL , 0 ); return 0 ; } This program yields the following output: Original UTS namespace nodename: XT New UTS namespace nodename: XT Changing nodename inside new UTS namespace New UTS namespace nodename: GLaDOS Original UTS namespace nodename: XT Here, child_fn() prints the nodename , changes it to something else, and prints it again. Naturally, the change happens only inside the new UTS namespace. More information on what all of the namespaces provide and isolate can be found in the tutorial here Cross-Namespace Communication Often it is necessary to establish some sort of communication between the parent and the child namespace. This might be for doing configuration work within an isolated environment, or it can simply be to retain the ability to peek into the condition of that environment from outside. One way of doing that is to keep an SSH daemon running within that environment. You can have a separate SSH daemon inside each network namespace. However, having multiple SSH daemons running uses a lot of valuable resources like memory. This is where having a special \u201cinit\u201d process proves to be a good idea again. The \u201cinit\u201d process can establish a communication channel between the parent namespace and the child namespace. This channel can be based on UNIX sockets or can even use TCP. To create a UNIX socket that spans two different mount namespaces, you need to first create the child process, then create the UNIX socket, and then isolate the child into a separate mount namespace. But how can we create the process first, and isolate it later? Linux provides unshare() . This special system call allows a process to isolate itself from the original namespace, instead of having the parent isolate the child in the first place. For example, the following code has the exact same effect as the code previously mentioned in the network namespace section: #define _GNU_SOURCE #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <sys/wait.h> #include <unistd.h> static char child_stack [ 1048576 ]; static int child_fn () { // calling unshare() from inside the init process lets you create a new namespace after a new process has been spawned unshare ( CLONE_NEWNET ); printf ( \"New `net` Namespace: \\n \" ); system ( \"ip link\" ); printf ( \" \\n\\n \" ); return 0 ; } int main () { printf ( \"Original `net` Namespace: \\n \" ); system ( \"ip link\" ); printf ( \" \\n\\n \" ); pid_t child_pid = clone ( child_fn , child_stack + 1048576 , CLONE_NEWPID | SIGCHLD , NULL ); waitpid ( child_pid , NULL , 0 ); return 0 ; } And since the \u201cinit\u201d process is something you have devised, you can make it do all the necessary work first, and then isolate itself from the rest of the system before executing the target child. Conclusion This tutorial is just an overview of how to use namespaces in Linux. It should give you a basic idea of how a Linux developer might start to implement system isolation, an integral part of the architecture of tools like Docker or Linux Containers. In most cases, it would be best to simply use one of these existing tools, which are already well-known and tested. But in some cases, it might make sense to have your very own, customized process isolation mechanism, and in that case, this namespace tutorial will help you out tremendously. There is a lot more going on under the hood than I\u2019ve covered in this article, and there are more ways you might want to limit your target processes for added safety and isolation. But, hopefully, this can serve as a useful starting point for someone who is interested in knowing more about how namespace isolation with Linux really works. Tags Sandboxing SystemIsolation Linux Namespaces","title":"Linux-Namespaces"},{"location":"Programming/Virtualization/Linux-namespaces/Linux-Namespaces/#linux#namespaces","text":"","title":"Linux namespaces"},{"location":"Programming/Virtualization/Linux-namespaces/Linux-Namespaces/#separation#anxiety#a#tutorial#for#isolating#your#system#with#linux#namespaces","text":"With the advent of tools like Docker , Linux Containers , and others, it has become super easy to isolate Linux processes into their own little system environments. This makes it possible to run a whole range of applications on a single real Linux machine and ensure no two of them can interfere with each other, without having to resort to using virtual machines . These tools have been a huge boon to PaaS providers. But what exactly happens under the hood? These tools rely on a number of features and components of the Linux kernel. Some of these features were introduced fairly recently, while others still require you to patch the kernel itself. But one of the key components, using Linux namespaces , has been a feature of Linux since version 2.6.24 was released in 2008. Anyone familiar with chroot already has a basic idea of what Linux namespaces can do and how to use namespace generally. Just as chroot allows processes to see any arbitrary directory as the root of the system (independent of the rest of the processes), Linux namespaces allow other aspects of the operating system to be independently modified as well. This includes the process tree , networking interfaces, mount points , inter-process communication resources and more.","title":"Separation Anxiety: A Tutorial for Isolating Your System with Linux Namespaces"},{"location":"Programming/Virtualization/Linux-namespaces/Linux-Namespaces/#why#use#namespaces#for#process#isolation","text":"In a single-user computer, a single system environment may be fine. But on a server, where you want to run multiple services, it is essential to security and stability that the services are as isolated from each other as possible. Imagine a server running multiple services, one of which gets compromised by an intruder. In such a case, the intruder may be able to exploit that service and work his way to the other services, and may even be able compromise the entire server. Namespace isolation can provide a secure environment to eliminate this risk. For example, using namespacing, it is possible to safely execute arbitrary or unknown programs on your server. Recently, there has been a growing number of programming contest and \u201chackathon\u201d platforms, such as HackerRank , TopCoder , Codeforces , and many more. A lot of them utilize automated pipelines to run and validate programs that are submitted by the contestants. It is often impossible to know in advance the true nature of contestants\u2019 programs, and some may even contain malicious elements. By running these programs namespaced in complete isolation from the rest of the system, the software can be tested and validated without putting the rest of the machine at risk. Similarly, online continuous integration services, such as Drone.io , automatically fetch your code repository and execute the test scripts on their own servers. Again, namespace isolation is what makes it possible to provide these services safely. Namespacing tools like Docker also allow better control over processes\u2019 use of system resources, making such tools extremely popular for use by PaaS providers. Services like Heroku and Google App Engine use such tools to isolate and run multiple web server applications on the same real hardware. These tools allow them to run each application (which may have been deployed by any of a number of different users) without worrying about one of them using too many system resources, or interfering and/or conflicting with other deployed services on the same machine. With such process isolation, it is even possible to have entirely different stacks of dependency softwares (and versions) for each isolated environment! If you\u2019ve used tools like Docker, you already know that these tools are capable of isolating processes in small \u201ccontainers\u201d. Running processes in Docker containers is like running them in virtual machines, only these containers are significantly lighter than virtual machines.","title":"Why Use Namespaces for Process Isolation?"},{"location":"Programming/Virtualization/Linux-namespaces/Linux-Namespaces/#process#namespace","text":"Historically, the Linux kernel has maintained a single process tree . The tree contains a reference to every process currently running in a parent-child hierarchy . A process, given it has sufficient privileges and satisfies certain conditions, can inspect another process by attaching a tracer to it or may even be able to kill it. With the introduction of Linux namespaces , it became possible to have multiple \u201cnested\u201d process trees. Each process tree can have an entirely isolated set of processes. This can ensure that processes belonging to one process tree cannot inspect or kill - in fact cannot even know of the existence of - processes in other sibling or parent process trees. Every time a computer with Linux boots up, it starts with just one process, with process identifier (PID) 1. This process is the root of the process tree , and it initiates the rest of the system by performing the appropriate maintenance work and starting the correct daemons/services. All the other processes start below this process in the tree. The PID namespace allows one to spin off a new tree, with its own PID 1 process . The process that does this remains in the parent namespace , in the original tree, but makes the child the root of its own process tree . With PID namespace isolation , processes in the child namespace have no way of knowing of the parent process\u2019s existence. However, processes in the parent namespace have a complete view of processes in the child namespace , as if they were any other process in the parent namespace . It is possible to create a nested set of child namespaces : one process starts a child process in a new PID namespace, and that child process spawns yet another process in a new PID namespace, and so on. With the introduction of PID namespaces , a single process can now have multiple PIDs associated with it, one for each namespace it falls under. In the Linux source code, we can see that a struct named pid , which used to keep track of just a single PID, now tracks multiple PIDs through the use of a struct named upid : struct upid { int nr ; // the PID value struct pid_namespace * ns ; // namespace where this PID is relevant // ... }; struct pid { // ... int level ; // number of upids struct upid numbers [ 0 ]; // array of upids }; To create a new PID namespace , one must call the clone() system call with a special flag CLONE_NEWPID . (C provides a wrapper to expose this system call, and so do many other popular languages.) Whereas the other namespaces discussed below can also be created using the unshare() system call, a PID namespace can only be created at the time a new process is spawned using clone() . Once clone() is called with this flag, the new process immediately starts in a new PID namespace, under a new process tree. This can be demonstrated with a simple C program: #define _GNU_SOURCE #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <sys/wait.h> #include <unistd.h> static char child_stack [ 1048576 ]; static int child_fn () { printf ( \"PID: %ld \\n \" , ( long ) getpid ()); return 0 ; } int main () { pid_t child_pid = clone ( child_fn , child_stack + 1048576 , CLONE_NEWPID | SIGCHLD , NULL ); printf ( \"clone() = %ld \\n \" , ( long ) child_pid ); waitpid ( child_pid , NULL , 0 ); return 0 ; } Compile and run this program with root privileges and you will notice an output that resembles this: clone() = 5304 PID: 1 The PID, as printed from within the child_fn , will be 1 . Try replacing the static int child_fn() function with the following, to print the parent PID from the isolated process\u2019s perspective: static int child_fn () { printf ( \"Parent PID: %ld \\n \" , ( long ) getppid ()); return 0 ; } Running the program this time yields the following output: clone() = 11449 Parent PID: 0 Notice how the parent PID from the isolated process\u2019s perspective is 0, indicating no parent. Try running the same program again, but this time, remove the CLONE_NEWPID flag from within the clone() function call: pid_t child_pid = clone ( child_fn , child_stack + 1048576 , SIGCHLD , NULL ); This time, you will notice that the parent PID is no longer 0: clone() = 11561 Parent PID: 11560 However, this is just the first step in our tutorial. These processes still have unrestricted access to other common or shared resources. For example, the networking interface: if the child process created above were to listen on port 80, it would prevent every other process on the system from being able to listen on it.","title":"Process Namespace"},{"location":"Programming/Virtualization/Linux-namespaces/Linux-Namespaces/#linux#network#namespace","text":"This is where a network namespace becomes useful. A network namespace allows each of these processes to see an entirely different set of networking interfaces . Even the loopback interface is different for each network namespace. Isolating a process into its own network namespace involves introducing another flag to the clone() function call: CLONE_NEWNET ; #define _GNU_SOURCE #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <sys/wait.h> #include <unistd.h> static char child_stack [ 1048576 ]; static int child_fn () { printf ( \"New `net` Namespace: \\n \" ); system ( \"ip link\" ); printf ( \" \\n\\n \" ); return 0 ; } int main () { printf ( \"Original `net` Namespace: \\n \" ); system ( \"ip link\" ); printf ( \" \\n\\n \" ); pid_t child_pid = clone ( child_fn , child_stack + 1048576 , CLONE_NEWPID | CLONE_NEWNET | SIGCHLD , NULL ); waitpid ( child_pid , NULL , 0 ); return 0 ; } Output: Original `net` Namespace: 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: enp4s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:24:8c:a1:ac:e7 brd ff:ff:ff:ff:ff:ff New `net` Namespace: 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 What\u2019s going on here? The physical ethernet device enp4s0 belongs to the global network namespace , as indicated by the \u201c ip \u201d tool run from this namespace. However, the physical interface is not available in the new network namespace . Moreover, the loopback device is active in the original network namespace , but is \u201cdown\u201d in the child network namespace . In order to provide a usable network interface in the child namespace , it is necessary to set up additional \u201cvirtual\u201d network interfaces which span multiple namespaces. Once that is done, it is then possible to create Ethernet bridges , and even route packets between the namespaces. Finally, to make the whole thing work, a \u201crouting process\u201d must be running in the global network namespace to receive traffic from the physical interface, and route it through the appropriate virtual interfaces to to the correct child network namespaces . Maybe you can see why tools like Docker, which do all this heavy lifting for you, are so popular! To do this by hand, you can create a pair of virtual Ethernet connections between a parent and a child namespace by running a single command from the parent namespace : ip link add name veth0 type veth peer name veth1 netns <pid> Here, <pid> should be replaced by the process ID of the process in the child namespace as observed by the parent. Running this command establishes a pipe-like connection between these two namespaces. The parent namespace retains the veth0 device, and passes the veth1 device to the child namespace. Anything that enters one of the ends, comes out through the other end, just as you would expect from a real Ethernet connection between two real nodes. Accordingly, both sides of this virtual Ethernet connection must be assigned IP addresses.","title":"Linux Network Namespace"},{"location":"Programming/Virtualization/Linux-namespaces/Linux-Namespaces/#mount#namespace","text":"Linux also maintains a data structure for all the mountpoints of the system. It includes information like what disk partitions are mounted, where they are mounted, whether they are readonly, et cetera. With Linux namespaces, one can have this data structure cloned, so that processes under different namespaces can change the mountpoints without affecting each other. Creating separate mount namespace has an effect similar to doing a chroot() . chroot() is good, but it does not provide complete isolation, and its effects are restricted to the root mountpoint only. Creating a separate mount namespace allows each of these isolated processes to have a completely different view of the entire system\u2019s mountpoint structure from the original one. This allows you to have a different root for each isolated process, as well as other mountpoints that are specific to those processes. Used with care per this tutorial, you can avoid exposing any information about the underlying system. The clone() flag required to achieve this is CLONE_NEWNS : clone ( child_fn , child_stack + 1048576 , CLONE_NEWPID | CLONE_NEWNET | CLONE_NEWNS | SIGCHLD , NULL ) Initially, the child process sees the exact same mountpoints as its parent process would. However, being under a new mount namespace , the child process can mount or unmount whatever endpoints it wants to, and the change will affect neither its parent\u2019s namespace, nor any other mount namespace in the entire system. For example, if the parent process has a particular disk partition mounted at root, the isolated process will see the exact same disk partition mounted at the root in the beginning. But the benefit of isolating the mount namespace is apparent when the isolated process tries to change the root partition to something else, as the change will only affect the isolated mount namespace. Interestingly, this actually makes it a bad idea to spawn the target child process directly with the CLONE_NEWNS flag. A better approach is to start a special \u201cinit\u201d process with the CLONE_NEWNS flag, have that \u201cinit\u201d process change the \u201c/\u201d, \u201c/proc\u201d, \u201c/dev\u201d or other mountpoints as desired, and then start the target process. This is discussed in a little more detail near the end of this namespace tutorial.","title":"Mount Namespace"},{"location":"Programming/Virtualization/Linux-namespaces/Linux-Namespaces/#other#namespaces","text":"There are other namespaces that these processes can be isolated into, namely user, IPC, and UTS. The user namespace allows a process to have root privileges within the namespace , without giving it that access to processes outside of the namespace. Isolating a process by the IPC namespace gives it its own interprocess communication resources, for example, System V IPC and POSIX messages. The UTS namespace isolates two specific identifiers of the system: nodename and domainname . A quick example to show how UTS namespace is isolated is shown below: #define _GNU_SOURCE #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <sys/utsname.h> #include <sys/wait.h> #include <unistd.h> static char child_stack [ 1048576 ]; static void print_nodename () { struct utsname utsname ; uname ( & utsname ); printf ( \"%s \\n \" , utsname . nodename ); } static int child_fn () { printf ( \"New UTS namespace nodename: \" ); print_nodename (); printf ( \"Changing nodename inside new UTS namespace \\n \" ); sethostname ( \"GLaDOS\" , 6 ); printf ( \"New UTS namespace nodename: \" ); print_nodename (); return 0 ; } int main () { printf ( \"Original UTS namespace nodename: \" ); print_nodename (); pid_t child_pid = clone ( child_fn , child_stack + 1048576 , CLONE_NEWUTS | SIGCHLD , NULL ); sleep ( 1 ); printf ( \"Original UTS namespace nodename: \" ); print_nodename (); waitpid ( child_pid , NULL , 0 ); return 0 ; } This program yields the following output: Original UTS namespace nodename: XT New UTS namespace nodename: XT Changing nodename inside new UTS namespace New UTS namespace nodename: GLaDOS Original UTS namespace nodename: XT Here, child_fn() prints the nodename , changes it to something else, and prints it again. Naturally, the change happens only inside the new UTS namespace. More information on what all of the namespaces provide and isolate can be found in the tutorial here","title":"Other Namespaces"},{"location":"Programming/Virtualization/Linux-namespaces/Linux-Namespaces/#cross-namespace#communication","text":"Often it is necessary to establish some sort of communication between the parent and the child namespace. This might be for doing configuration work within an isolated environment, or it can simply be to retain the ability to peek into the condition of that environment from outside. One way of doing that is to keep an SSH daemon running within that environment. You can have a separate SSH daemon inside each network namespace. However, having multiple SSH daemons running uses a lot of valuable resources like memory. This is where having a special \u201cinit\u201d process proves to be a good idea again. The \u201cinit\u201d process can establish a communication channel between the parent namespace and the child namespace. This channel can be based on UNIX sockets or can even use TCP. To create a UNIX socket that spans two different mount namespaces, you need to first create the child process, then create the UNIX socket, and then isolate the child into a separate mount namespace. But how can we create the process first, and isolate it later? Linux provides unshare() . This special system call allows a process to isolate itself from the original namespace, instead of having the parent isolate the child in the first place. For example, the following code has the exact same effect as the code previously mentioned in the network namespace section: #define _GNU_SOURCE #include <sched.h> #include <stdio.h> #include <stdlib.h> #include <sys/wait.h> #include <unistd.h> static char child_stack [ 1048576 ]; static int child_fn () { // calling unshare() from inside the init process lets you create a new namespace after a new process has been spawned unshare ( CLONE_NEWNET ); printf ( \"New `net` Namespace: \\n \" ); system ( \"ip link\" ); printf ( \" \\n\\n \" ); return 0 ; } int main () { printf ( \"Original `net` Namespace: \\n \" ); system ( \"ip link\" ); printf ( \" \\n\\n \" ); pid_t child_pid = clone ( child_fn , child_stack + 1048576 , CLONE_NEWPID | SIGCHLD , NULL ); waitpid ( child_pid , NULL , 0 ); return 0 ; } And since the \u201cinit\u201d process is something you have devised, you can make it do all the necessary work first, and then isolate itself from the rest of the system before executing the target child.","title":"Cross-Namespace Communication"},{"location":"Programming/Virtualization/Linux-namespaces/Linux-Namespaces/#conclusion","text":"This tutorial is just an overview of how to use namespaces in Linux. It should give you a basic idea of how a Linux developer might start to implement system isolation, an integral part of the architecture of tools like Docker or Linux Containers. In most cases, it would be best to simply use one of these existing tools, which are already well-known and tested. But in some cases, it might make sense to have your very own, customized process isolation mechanism, and in that case, this namespace tutorial will help you out tremendously. There is a lot more going on under the hood than I\u2019ve covered in this article, and there are more ways you might want to limit your target processes for added safety and isolation. But, hopefully, this can serve as a useful starting point for someone who is interested in knowing more about how namespace isolation with Linux really works. Tags Sandboxing SystemIsolation Linux Namespaces","title":"Conclusion"},{"location":"Programming/Virtualization/Linux-namespaces/man-7-namespaces/","text":"NAMESPACES(7) CGROUP_NAMESPACES(7) IPC_NAMESPACES(7) NETWORK_NAMESPACES(7) MOUNT_NAMESPACES(7) PID_NAMESPACES(7) USER_NAMESPACES(7) UTS_NAMESPACES(7) NAMESPACES(7) CGROUP_NAMESPACES(7) IPC_NAMESPACES(7) NETWORK_NAMESPACES(7) MOUNT_NAMESPACES(7) PID_NAMESPACES(7) USER_NAMESPACES(7) UTS_NAMESPACES(7)","title":"man-7-namespaces"},{"location":"Programming/Virtualization/Linux-namespaces/man-7-namespaces/#namespaces7","text":"","title":"NAMESPACES(7)"},{"location":"Programming/Virtualization/Linux-namespaces/man-7-namespaces/#cgroup_namespaces7","text":"","title":"CGROUP_NAMESPACES(7)"},{"location":"Programming/Virtualization/Linux-namespaces/man-7-namespaces/#ipc_namespaces7","text":"","title":"IPC_NAMESPACES(7)"},{"location":"Programming/Virtualization/Linux-namespaces/man-7-namespaces/#network_namespaces7","text":"","title":"NETWORK_NAMESPACES(7)"},{"location":"Programming/Virtualization/Linux-namespaces/man-7-namespaces/#mount_namespaces7","text":"","title":"MOUNT_NAMESPACES(7)"},{"location":"Programming/Virtualization/Linux-namespaces/man-7-namespaces/#pid_namespaces7","text":"","title":"PID_NAMESPACES(7)"},{"location":"Programming/Virtualization/Linux-namespaces/man-7-namespaces/#user_namespaces7","text":"","title":"USER_NAMESPACES(7)"},{"location":"Programming/Virtualization/Linux-namespaces/man-7-namespaces/#uts_namespaces7","text":"","title":"UTS_NAMESPACES(7)"},{"location":"Programming/Virtualization/Virtualization/","text":"Virtualization NOTE: \u4e0b\u9762\u4ecb\u7ecd\u5404\u4e2a\u5c42\u7ea7\u7684\u7684virtualization Hardware virtualization Main article: Hardware virtualization See also: Mobile virtualization Desktop virtualization Main article: Desktop virtualization Containerization Main article: Operating-system-level virtualization NOTE: \u8fd9\u662f\u672c\u7ae0\u4e3b\u8981\u5173\u6ce8\u7684 OS-level virtualization OS-level virtualization refers to an operating system paradigm in which the kernel allows the existence of multiple isolated user space instances. Such instances, called containers ( Solaris , Docker ), Zones ( Solaris ), virtual private servers ( OpenVZ ), partitions , virtual environments (VEs), virtual kernel ( DragonFly BSD ), or jails ( FreeBSD jail or chroot jail ),[ 1] may look like real computers from the point of view of programs running in them. A computer program running on an ordinary operating system can see all resources (connected devices, files and folders, network shares , CPU power, quantifiable hardware capabilities) of that computer. However, programs running inside of a container can only see the container's contents and devices assigned to the container. NOTE: \u5e38\u5e38\u542c\u5230\u7684 Docker \uff0c**container**\u6240\u4f7f\u7528\u7684\u5c31\u662f OS-level virtualization On Unix-like operating systems, this feature can be seen as an advanced implementation of the standard chroot mechanism, which changes the apparent root folder for the current running process and its children. In addition to isolation mechanisms, the kernel often provides resource-management features to limit the impact of one container's activities on other containers. NOTE: linux kernel\u7279\u6027 Linux namespaces \u7528\u4e8e\u652f\u6301isolation\uff1b linux kernel\u7279\u6027 Linux control groups \u7528\u4e8e\u652f\u6301 resource-management \uff1b The term \"container,\" while most popularly referring to OS-level virtualization systems, is sometimes ambiguously used to refer to fuller virtual machine environments operating in varying degrees of concert with the host OS, e.g. Microsoft's \" Hyper-V Containers.\" List of Linux containers","title":"Introduction"},{"location":"Programming/Virtualization/Virtualization/#virtualization","text":"NOTE: \u4e0b\u9762\u4ecb\u7ecd\u5404\u4e2a\u5c42\u7ea7\u7684\u7684virtualization","title":"Virtualization"},{"location":"Programming/Virtualization/Virtualization/#hardware#virtualization","text":"Main article: Hardware virtualization See also: Mobile virtualization","title":"Hardware virtualization"},{"location":"Programming/Virtualization/Virtualization/#desktop#virtualization","text":"Main article: Desktop virtualization","title":"Desktop virtualization"},{"location":"Programming/Virtualization/Virtualization/#containerization","text":"Main article: Operating-system-level virtualization NOTE: \u8fd9\u662f\u672c\u7ae0\u4e3b\u8981\u5173\u6ce8\u7684","title":"Containerization"},{"location":"Programming/Virtualization/Virtualization/#os-level#virtualization","text":"OS-level virtualization refers to an operating system paradigm in which the kernel allows the existence of multiple isolated user space instances. Such instances, called containers ( Solaris , Docker ), Zones ( Solaris ), virtual private servers ( OpenVZ ), partitions , virtual environments (VEs), virtual kernel ( DragonFly BSD ), or jails ( FreeBSD jail or chroot jail ),[ 1] may look like real computers from the point of view of programs running in them. A computer program running on an ordinary operating system can see all resources (connected devices, files and folders, network shares , CPU power, quantifiable hardware capabilities) of that computer. However, programs running inside of a container can only see the container's contents and devices assigned to the container. NOTE: \u5e38\u5e38\u542c\u5230\u7684 Docker \uff0c**container**\u6240\u4f7f\u7528\u7684\u5c31\u662f OS-level virtualization On Unix-like operating systems, this feature can be seen as an advanced implementation of the standard chroot mechanism, which changes the apparent root folder for the current running process and its children. In addition to isolation mechanisms, the kernel often provides resource-management features to limit the impact of one container's activities on other containers. NOTE: linux kernel\u7279\u6027 Linux namespaces \u7528\u4e8e\u652f\u6301isolation\uff1b linux kernel\u7279\u6027 Linux control groups \u7528\u4e8e\u652f\u6301 resource-management \uff1b The term \"container,\" while most popularly referring to OS-level virtualization systems, is sometimes ambiguously used to refer to fuller virtual machine environments operating in varying degrees of concert with the host OS, e.g. Microsoft's \" Hyper-V Containers.\"","title":"OS-level virtualization"},{"location":"Programming/Virtualization/Virtualization/#list#of#linux#containers","text":"","title":"List of Linux containers"},{"location":"Programming/Virtualization/Virtualization/Memory-virtualization/","text":"Memory virtualization wikipedia Memory virtualization","title":"Introduction"},{"location":"Programming/Virtualization/Virtualization/Memory-virtualization/#memory#virtualization","text":"","title":"Memory virtualization"},{"location":"Programming/Virtualization/Virtualization/Memory-virtualization/#wikipedia#memory#virtualization","text":"","title":"wikipedia Memory virtualization"},{"location":"Security/","text":"Computer security wikipedia Computer security","title":"Introduction"},{"location":"Security/#computer#security","text":"","title":"Computer security"},{"location":"Security/#wikipedia#computer#security","text":"","title":"wikipedia Computer security"},{"location":"Security/Capability-based-security/","text":"wikipedia Capability-based security Capability-based security is a concept in the design of secure computing systems, one of the existing security models . A capability (known in some systems as a key ) is a communicable(\u53ef\u4f20\u8fbe\u7684), unforgeable(\u4e0d\u53ef\u7be1\u6539\u7684) token of authority. It refers to a value that references an object along with an associated set of access rights . NOTE: 1\u3001\u663e\u7136Linux OS file descriptor\u662f\u5178\u578b\u7684capability-based security\u3002 Introduction Capabilities achieve their objective of improving system security by being used in place of forgeable references . A forgeable reference (for example, a path name ) identifies an object, but does not specify which access rights are appropriate for that object and the user program which holds that reference. Consequently, any attempt to access the referenced object must be validated by the operating system, based on the ambient authority of the requesting program, typically via the use of an access control list (ACL). Instead, in a system with capabilities, the mere fact that a user program possesses(\u62e5\u6709) that capability entitles(\u4f7f\u6709\u8d44\u683c\uff0c\u4f7f\u6709\u6743) it to use the referenced object in accordance with (\u6309\u7167) the rights that are specified by that capability. In theory, a system with capabilities removes the need for any access control list or similar mechanism by giving all entities(\u5b9e\u4f53) all and only the capabilities they will actually need. NOTE: \u7ffb\u8bd1\u5982\u4e0b: \"\u529f\u80fd\u901a\u8fc7\u66ff\u4ee3\u53ef\u4f2a\u9020\u7684\u5f15\u7528\u6765\u5b9e\u73b0\u63d0\u9ad8\u7cfb\u7edf\u5b89\u5168\u6027\u7684\u76ee\u6807\u3002\u53ef\u4f2a\u9020\u7684\u5f15\u7528(\u4f8b\u5982\uff0c\u8def\u5f84\u540d)\u6807\u8bc6\u4e00\u4e2a\u5bf9\u8c61\uff0c\u4f46\u4e0d\u6307\u5b9a\u54ea\u4e9b\u8bbf\u95ee\u6743\u9650\u9002\u5408\u8be5\u5bf9\u8c61\u548c\u6301\u6709\u8be5\u5f15\u7528\u7684\u7528\u6237\u7a0b\u5e8f\u3002\u56e0\u6b64\uff0c\u4efb\u4f55\u8bbf\u95ee\u88ab\u5f15\u7528\u5bf9\u8c61\u7684\u5c1d\u8bd5\u90fd\u5fc5\u987b\u7531\u64cd\u4f5c\u7cfb\u7edf\u9a8c\u8bc1\uff0c\u57fa\u4e8e\u8bf7\u6c42\u7a0b\u5e8f\u7684\u73af\u5883\u6743\u9650\uff0c\u901a\u5e38\u901a\u8fc7\u4f7f\u7528\u8bbf\u95ee\u63a7\u5236\u5217\u8868(ACL)\u3002 \u76f8\u53cd\uff0c\u5728\u4e00\u4e2a\u5177\u6709\u529f\u80fd\u7684\u7cfb\u7edf\u4e2d\uff0c\u7528\u6237\u7a0b\u5e8f\u62e5\u6709\u8be5\u529f\u80fd\u8fd9\u4e00\u4e8b\u5b9e\u4f7f\u5b83\u6709\u6743\u6839\u636e\u8be5\u529f\u80fd\u6307\u5b9a\u7684\u6743\u5229\u6765\u4f7f\u7528\u6240\u5f15\u7528\u7684\u5bf9\u8c61\u3002\u4ece\u7406\u8bba\u4e0a\u8bb2\uff0c\u5177\u6709\u529f\u80fd\u7684\u7cfb\u7edf\u901a\u8fc7\u7ed9\u4e88\u6240\u6709\u5b9e\u4f53\u6240\u6709\u4e14\u4ec5\u63d0\u4f9b\u5b83\u4eec\u5b9e\u9645\u9700\u8981\u7684\u529f\u80fd\uff0c\u4ece\u800c\u6d88\u9664\u4e86\u5bf9\u4efb\u4f55\u8bbf\u95ee\u63a7\u5236\u5217\u8868\u6216\u7c7b\u4f3c\u673a\u5236\u7684\u9700\u6c42\u3002\" \u603b\u7684\u6765\u8bf4\uff0c\u4f7f\u7528\"Capability-based security\"\u53ef\u4ee5\u66ff\u4ee3ACL\u3002 Implementation A capability is typically implemented as a privileged data structure that consists of a section that specifies access rights , and a section that uniquely identifies the object to be accessed. The user does not access the data structure or object directly, but instead via a handle . In practice, it is used much like a file descriptor in a traditional operating system (a traditional handle), but to access every object on the system. Capabilities are typically stored by the operating system in a list, with some mechanism in place to prevent the program from directly modifying the contents of the capability (so as to forge(\u7be1\u6539) access rights or change the object it points to). Some systems have also been based on capability-based addressing (hardware support for capabilities), such as Plessey System 250 . Use capability Programs possessing capabilities can perform functions on them, such as passing them on to other programs, converting them to a less-privileged version, or deleting them. The operating system must ensure that only specific operations can occur to the capabilities in the system, in order to maintain the integrity of the security policy. Examples File descriptor NOTE: File descriptor is a capacity. Now suppose that the user program successfully executes the following statement: int fd = open ( \"/etc/passwd\" , O_RDWR ); The variable fd now contains the index of a file descriptor in the process's file descriptor table. This file descriptor is a capability. Its existence in the process's file descriptor table is sufficient to know that the process does indeed have legitimate(\u5408\u6cd5\u7684) access to the object. A key feature of this arrangement is that the file descriptor table is in kernel memory and cannot be directly manipulated by the user program. POSIX capabilities POSIX draft 1003.1e specifies a concept of permissions(\u6743\u9650) called \"capabilities\". However, POSIX capabilities differ from capabilities in this article\u2014POSIX capability is not associated with any object; a process having CAP_NET_BIND_SERVICE capability can listen on any TCP port under 1024. This system is found in Linux.[ 1] NOTE: POSIX capabilities\u672c\u8d28\u4e0a\u662fpermission\uff0c\u800c\u4e0d\u662f\u672c\u6587\u7684capacity\u3002 Implementations NOTE: \u672a\u8bfb","title":"Introduction"},{"location":"Security/Capability-based-security/#wikipedia#capability-based#security","text":"Capability-based security is a concept in the design of secure computing systems, one of the existing security models . A capability (known in some systems as a key ) is a communicable(\u53ef\u4f20\u8fbe\u7684), unforgeable(\u4e0d\u53ef\u7be1\u6539\u7684) token of authority. It refers to a value that references an object along with an associated set of access rights . NOTE: 1\u3001\u663e\u7136Linux OS file descriptor\u662f\u5178\u578b\u7684capability-based security\u3002","title":"wikipedia Capability-based security"},{"location":"Security/Capability-based-security/#introduction","text":"Capabilities achieve their objective of improving system security by being used in place of forgeable references . A forgeable reference (for example, a path name ) identifies an object, but does not specify which access rights are appropriate for that object and the user program which holds that reference. Consequently, any attempt to access the referenced object must be validated by the operating system, based on the ambient authority of the requesting program, typically via the use of an access control list (ACL). Instead, in a system with capabilities, the mere fact that a user program possesses(\u62e5\u6709) that capability entitles(\u4f7f\u6709\u8d44\u683c\uff0c\u4f7f\u6709\u6743) it to use the referenced object in accordance with (\u6309\u7167) the rights that are specified by that capability. In theory, a system with capabilities removes the need for any access control list or similar mechanism by giving all entities(\u5b9e\u4f53) all and only the capabilities they will actually need. NOTE: \u7ffb\u8bd1\u5982\u4e0b: \"\u529f\u80fd\u901a\u8fc7\u66ff\u4ee3\u53ef\u4f2a\u9020\u7684\u5f15\u7528\u6765\u5b9e\u73b0\u63d0\u9ad8\u7cfb\u7edf\u5b89\u5168\u6027\u7684\u76ee\u6807\u3002\u53ef\u4f2a\u9020\u7684\u5f15\u7528(\u4f8b\u5982\uff0c\u8def\u5f84\u540d)\u6807\u8bc6\u4e00\u4e2a\u5bf9\u8c61\uff0c\u4f46\u4e0d\u6307\u5b9a\u54ea\u4e9b\u8bbf\u95ee\u6743\u9650\u9002\u5408\u8be5\u5bf9\u8c61\u548c\u6301\u6709\u8be5\u5f15\u7528\u7684\u7528\u6237\u7a0b\u5e8f\u3002\u56e0\u6b64\uff0c\u4efb\u4f55\u8bbf\u95ee\u88ab\u5f15\u7528\u5bf9\u8c61\u7684\u5c1d\u8bd5\u90fd\u5fc5\u987b\u7531\u64cd\u4f5c\u7cfb\u7edf\u9a8c\u8bc1\uff0c\u57fa\u4e8e\u8bf7\u6c42\u7a0b\u5e8f\u7684\u73af\u5883\u6743\u9650\uff0c\u901a\u5e38\u901a\u8fc7\u4f7f\u7528\u8bbf\u95ee\u63a7\u5236\u5217\u8868(ACL)\u3002 \u76f8\u53cd\uff0c\u5728\u4e00\u4e2a\u5177\u6709\u529f\u80fd\u7684\u7cfb\u7edf\u4e2d\uff0c\u7528\u6237\u7a0b\u5e8f\u62e5\u6709\u8be5\u529f\u80fd\u8fd9\u4e00\u4e8b\u5b9e\u4f7f\u5b83\u6709\u6743\u6839\u636e\u8be5\u529f\u80fd\u6307\u5b9a\u7684\u6743\u5229\u6765\u4f7f\u7528\u6240\u5f15\u7528\u7684\u5bf9\u8c61\u3002\u4ece\u7406\u8bba\u4e0a\u8bb2\uff0c\u5177\u6709\u529f\u80fd\u7684\u7cfb\u7edf\u901a\u8fc7\u7ed9\u4e88\u6240\u6709\u5b9e\u4f53\u6240\u6709\u4e14\u4ec5\u63d0\u4f9b\u5b83\u4eec\u5b9e\u9645\u9700\u8981\u7684\u529f\u80fd\uff0c\u4ece\u800c\u6d88\u9664\u4e86\u5bf9\u4efb\u4f55\u8bbf\u95ee\u63a7\u5236\u5217\u8868\u6216\u7c7b\u4f3c\u673a\u5236\u7684\u9700\u6c42\u3002\" \u603b\u7684\u6765\u8bf4\uff0c\u4f7f\u7528\"Capability-based security\"\u53ef\u4ee5\u66ff\u4ee3ACL\u3002","title":"Introduction"},{"location":"Security/Capability-based-security/#implementation","text":"A capability is typically implemented as a privileged data structure that consists of a section that specifies access rights , and a section that uniquely identifies the object to be accessed. The user does not access the data structure or object directly, but instead via a handle . In practice, it is used much like a file descriptor in a traditional operating system (a traditional handle), but to access every object on the system. Capabilities are typically stored by the operating system in a list, with some mechanism in place to prevent the program from directly modifying the contents of the capability (so as to forge(\u7be1\u6539) access rights or change the object it points to). Some systems have also been based on capability-based addressing (hardware support for capabilities), such as Plessey System 250 .","title":"Implementation"},{"location":"Security/Capability-based-security/#use#capability","text":"Programs possessing capabilities can perform functions on them, such as passing them on to other programs, converting them to a less-privileged version, or deleting them. The operating system must ensure that only specific operations can occur to the capabilities in the system, in order to maintain the integrity of the security policy.","title":"Use capability"},{"location":"Security/Capability-based-security/#examples","text":"","title":"Examples"},{"location":"Security/Capability-based-security/#file#descriptor","text":"NOTE: File descriptor is a capacity. Now suppose that the user program successfully executes the following statement: int fd = open ( \"/etc/passwd\" , O_RDWR ); The variable fd now contains the index of a file descriptor in the process's file descriptor table. This file descriptor is a capability. Its existence in the process's file descriptor table is sufficient to know that the process does indeed have legitimate(\u5408\u6cd5\u7684) access to the object. A key feature of this arrangement is that the file descriptor table is in kernel memory and cannot be directly manipulated by the user program.","title":"File descriptor"},{"location":"Security/Capability-based-security/#posix#capabilities","text":"POSIX draft 1003.1e specifies a concept of permissions(\u6743\u9650) called \"capabilities\". However, POSIX capabilities differ from capabilities in this article\u2014POSIX capability is not associated with any object; a process having CAP_NET_BIND_SERVICE capability can listen on any TCP port under 1024. This system is found in Linux.[ 1] NOTE: POSIX capabilities\u672c\u8d28\u4e0a\u662fpermission\uff0c\u800c\u4e0d\u662f\u672c\u6587\u7684capacity\u3002","title":"POSIX capabilities"},{"location":"Security/Capability-based-security/#implementations","text":"NOTE: \u672a\u8bfb","title":"Implementations"},{"location":"Shell-and-tools/","text":"\u5173\u4e8e\u672c\u7ae0 Linux OS\u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684command line tool\u6765\u4f9b\u7528\u6237troubleshoot\uff0c\u6240\u4ee5\u638c\u63e1\u5e38\u89c1\u7684\u5de5\u5177\uff0c\u5bf9\u4e8eprogrammer\u6765\u8bf4\u81f3\u5173\u91cd\u8981\u3002Linux OS\u7684tool\u662f\u975e\u5e38\u591a\u7684\uff0c\u672c\u7ae0\u5e76\u6ca1\u6709\u5c06\u6240\u6709\u7684tool\u90fd\u6536\u5f55\u8fdb\u884c\uff0c\u800c\u662f\u5c06\u90e8\u5206tool\u653e\u5230\u4e86programming\u7ae0\u8282\u7684\u5bf9\u5e94\u4e3b\u9898\u4e2d\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/#_1","text":"Linux OS\u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684command line tool\u6765\u4f9b\u7528\u6237troubleshoot\uff0c\u6240\u4ee5\u638c\u63e1\u5e38\u89c1\u7684\u5de5\u5177\uff0c\u5bf9\u4e8eprogrammer\u6765\u8bf4\u81f3\u5173\u91cd\u8981\u3002Linux OS\u7684tool\u662f\u975e\u5e38\u591a\u7684\uff0c\u672c\u7ae0\u5e76\u6ca1\u6709\u5c06\u6240\u6709\u7684tool\u90fd\u6536\u5f55\u8fdb\u884c\uff0c\u800c\u662f\u5c06\u90e8\u5206tool\u653e\u5230\u4e86programming\u7ae0\u8282\u7684\u5bf9\u5e94\u4e3b\u9898\u4e2d\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Shell/","text":"\u5173\u4e8e\u672c\u7ae0 \u8d44\u6e90 Linux\u5de5\u5177\u5feb\u901f\u6559\u7a0b","title":"Introduction"},{"location":"Shell-and-tools/Shell/#_1","text":"","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Shell/#_2","text":"Linux\u5de5\u5177\u5feb\u901f\u6559\u7a0b","title":"\u8d44\u6e90"},{"location":"Shell-and-tools/Shell/Run-command/","text":"Run command Run command multiple times for https://serverfault.com/a/273241 \uff1a For starters you can use a dummy for loop: for i in ` seq 10 ` ; do command ; done Or equivalently as per JimB's suggestion, using the Bash builtin for generating sequences: for i in { 1 ..10 } ; do command ; done This iterates ten times executing command each time - it can be a pipe or a series of commands separated by ; or && . You can use the $i variable to know which iteration you're in. If you consider this one-liner a script and so for some unspecified (but perhaps valid) reason undesireable you can implement it as a command, perhaps something like this on your .bashrc (untested): #function run run () { number = $1 shift for i in ` seq $number ` ; do $@ done } Usage: run 10 command Example: run 5 echo 'Hello World!' https://stackoverflow.com/a/3737773 for run in { 1 ..10 } do command done Or as a one-liner for those that want to copy and paste easily: for run in { 1 ..10 } ; do command ; done seq Shell\u4e0b\u91cd\u590d\u591a\u6b21\u6267\u884c\u547d\u4ee4 : seq 10 | xargs -i date Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 seq \u751f\u6210\u4e00\u4e2a1-10\u7684\u6570\u7ec4\u3002 xargs \u5174\u9ad8\u5f69\u70c8\u7684\u62ff\u7740\u8fd9\u4e2a\u6570\u7ec4\uff0c\u51c6\u5907\u5c06\u6570\u7ec4\u5143\u7d20\u4f20\u7ed9 date \u547d\u4ee4\u505a\u53c2\u6570\u3002 xargs -i \u4f1a\u67e5\u627e\u547d\u4ee4\u5b57\u7b26\u4e32\u4e2d\u7684 {} \uff0c\u5e76\u7528\u6570\u7ec4\u5143\u7d20\u66ff\u6362 {} \u3002\u4f46\u662f xargs \u4e00\u770b\uff0cWTF\uff01\u547d\u4ee4\u91cc\u9762\u5c45\u7136\u6ca1\u6709\u5360\u4f4d\u7b26\u3002\u90a3\u597d\u5427\uff0c\u5c31\u6267\u884c10\u904d\u547d\u4ee4\uff0c\u8ba9\u53c2\u6570\u968f\u98ce\u53bb\u5427\u3002 Run command periodically watch man 1 watch Shell\u4e0b\u91cd\u590d\u591a\u6b21\u6267\u884c\u547d\u4ee4 watch -n 1 date while true; do ... ; sleep ...; done Shell\u4e0b\u91cd\u590d\u591a\u6b21\u6267\u884c\u547d\u4ee4 $ while true; do date; sleep 1; done Fri Jul 21 14:20:24 CST 2017 Fri Jul 21 14:20:25 CST 2017 Fri Jul 21 14:20:26 CST 2017 Fri Jul 21 14:20:27 CST 2017","title":"Run-command"},{"location":"Shell-and-tools/Shell/Run-command/#run#command","text":"","title":"Run command"},{"location":"Shell-and-tools/Shell/Run-command/#run#command#multiple#times","text":"","title":"Run command multiple times"},{"location":"Shell-and-tools/Shell/Run-command/#for","text":"https://serverfault.com/a/273241 \uff1a For starters you can use a dummy for loop: for i in ` seq 10 ` ; do command ; done Or equivalently as per JimB's suggestion, using the Bash builtin for generating sequences: for i in { 1 ..10 } ; do command ; done This iterates ten times executing command each time - it can be a pipe or a series of commands separated by ; or && . You can use the $i variable to know which iteration you're in. If you consider this one-liner a script and so for some unspecified (but perhaps valid) reason undesireable you can implement it as a command, perhaps something like this on your .bashrc (untested): #function run run () { number = $1 shift for i in ` seq $number ` ; do $@ done } Usage: run 10 command Example: run 5 echo 'Hello World!' https://stackoverflow.com/a/3737773 for run in { 1 ..10 } do command done Or as a one-liner for those that want to copy and paste easily: for run in { 1 ..10 } ; do command ; done","title":"for"},{"location":"Shell-and-tools/Shell/Run-command/#seq","text":"Shell\u4e0b\u91cd\u590d\u591a\u6b21\u6267\u884c\u547d\u4ee4 : seq 10 | xargs -i date Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 Fri Jul 21 14:20:55 CST 2017 seq \u751f\u6210\u4e00\u4e2a1-10\u7684\u6570\u7ec4\u3002 xargs \u5174\u9ad8\u5f69\u70c8\u7684\u62ff\u7740\u8fd9\u4e2a\u6570\u7ec4\uff0c\u51c6\u5907\u5c06\u6570\u7ec4\u5143\u7d20\u4f20\u7ed9 date \u547d\u4ee4\u505a\u53c2\u6570\u3002 xargs -i \u4f1a\u67e5\u627e\u547d\u4ee4\u5b57\u7b26\u4e32\u4e2d\u7684 {} \uff0c\u5e76\u7528\u6570\u7ec4\u5143\u7d20\u66ff\u6362 {} \u3002\u4f46\u662f xargs \u4e00\u770b\uff0cWTF\uff01\u547d\u4ee4\u91cc\u9762\u5c45\u7136\u6ca1\u6709\u5360\u4f4d\u7b26\u3002\u90a3\u597d\u5427\uff0c\u5c31\u6267\u884c10\u904d\u547d\u4ee4\uff0c\u8ba9\u53c2\u6570\u968f\u98ce\u53bb\u5427\u3002","title":"seq"},{"location":"Shell-and-tools/Shell/Run-command/#run#command#periodically","text":"","title":"Run command periodically"},{"location":"Shell-and-tools/Shell/Run-command/#watch","text":"","title":"watch"},{"location":"Shell-and-tools/Shell/Run-command/#man#1#watch","text":"","title":"man 1 watch"},{"location":"Shell-and-tools/Shell/Run-command/#shell","text":"watch -n 1 date","title":"Shell\u4e0b\u91cd\u590d\u591a\u6b21\u6267\u884c\u547d\u4ee4"},{"location":"Shell-and-tools/Shell/Run-command/#while#true#do#sleep#done","text":"Shell\u4e0b\u91cd\u590d\u591a\u6b21\u6267\u884c\u547d\u4ee4 $ while true; do date; sleep 1; done Fri Jul 21 14:20:24 CST 2017 Fri Jul 21 14:20:25 CST 2017 Fri Jul 21 14:20:26 CST 2017 Fri Jul 21 14:20:27 CST 2017","title":"while true; do ... ; sleep ...; done"},{"location":"Shell-and-tools/Tools/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u603b\u7ed3Linux\u4e2d\u7684\u5e38\u89c1\u5de5\u5177\u3002 Command\u603b\u89c8 \u67e5\u8be2process\u3001thread \u67e5\u8be2file\uff1a open files \u52a8\u6001 file \u9759\u6001 process \u4e0e file \u4e4b\u95f4\u7684\u6620\u5c04\u5173\u7cfb\uff1a fuser lsof ** stat vmstat netstat \u5728 sysstat \u4e2d\uff0c\u5305\u542b\u4e86\u4e00\u7cfb\u5217performance monitor tools\uff0c\u8fd9\u4e9btools\u4e00\u822c\u90fd\u4ee5 ** stat\u547d\u540d\uff1a iostat (1) reports basic CPU statistics and input/output statistics for devices, partitions and network filesystems. mpstat (1) reports individual or combined processor related statistics. pidstat (1) reports statistics for Linux tasks (processes) : I/O, CPU, memory, etc. nfsiostat (1) reports input/output statistics for network filesystems (NFS). cifsiostat (1) reports I/O statistics for CIFS resources.","title":"Introduction"},{"location":"Shell-and-tools/Tools/#_1","text":"\u672c\u7ae0\u603b\u7ed3Linux\u4e2d\u7684\u5e38\u89c1\u5de5\u5177\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Tools/#command","text":"\u67e5\u8be2process\u3001thread \u67e5\u8be2file\uff1a open files \u52a8\u6001 file \u9759\u6001 process \u4e0e file \u4e4b\u95f4\u7684\u6620\u5c04\u5173\u7cfb\uff1a fuser lsof","title":"Command\u603b\u89c8"},{"location":"Shell-and-tools/Tools/#stat","text":"vmstat netstat \u5728 sysstat \u4e2d\uff0c\u5305\u542b\u4e86\u4e00\u7cfb\u5217performance monitor tools\uff0c\u8fd9\u4e9btools\u4e00\u822c\u90fd\u4ee5 ** stat\u547d\u540d\uff1a iostat (1) reports basic CPU statistics and input/output statistics for devices, partitions and network filesystems. mpstat (1) reports individual or combined processor related statistics. pidstat (1) reports statistics for Linux tasks (processes) : I/O, CPU, memory, etc. nfsiostat (1) reports input/output statistics for network filesystems (NFS). cifsiostat (1) reports I/O statistics for CIFS resources.","title":"**stat"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/","text":"Autoconf 1 Introduction Autoconf is a tool for producing shell scripts that automatically configure software source code packages to adapt to many kinds of Posix-like systems . The configuration scripts produced by Autoconf are independent of Autoconf when they are run, so their users do not need to have Autoconf. The configuration scripts produced by Autoconf require no manual user intervention when run; they do not normally even need an argument specifying the system type. Instead, they individually test for the presence of each feature that the software package they are for might need. (Before each check, they print a one-line message stating what they are checking for, so the user doesn't get too bored while waiting for the script to finish.) As a result, they deal well with systems that are hybrids or customized from the more common Posix variants. There is no need to maintain files that list the features supported by each release of each variant of Posix. For each software package that Autoconf is used with, it creates a configuration script from a template file that lists the system features that the package needs or can use. After the shell code to recognize and respond to a system feature has been written, Autoconf allows it to be shared by many software packages that can use (or need) that feature. If it later turns out that the shell code needs adjustment for some reason, it needs to be changed in only one place; all of the configuration scripts can be regenerated automatically to take advantage of the updated code. NOTE: Autoconf \u7684\u8f93\u5165\uff1atemplate file\uff0c\u6309\u7167\u60ef\u4f8b\uff0c\u6587\u4ef6\u540d\u4e3a configure.ac Autoconf \u7684\u8f93\u51fa\uff1aconfiguration script\uff0c\u6309\u7167\u60ef\u4f8b\uff0c\u6587\u4ef6\u540d\u4e3a configure 2 The GNU Build System 2.1 Automake 2.2 Gnulib 2.3 Libtool 2.4 Pointers 3 Making configure Scripts The configuration scripts that Autoconf produces are by convention called configure . When run, configure creates several files, replacing configuration parameters in them with appropriate values. The files that configure creates are: one or more Makefile files, usually one in each subdirectory of the package (see Makefile Substitutions ); optionally, a C header file, the name of which is configurable, containing #define directives (see Configuration Headers ); a shell script called config.status that, when run, recreates the files listed above (see config.status Invocation ); an optional shell script normally called config.cache (created when using \u2018 configure --config-cache \u2019) that saves the results of running many of the tests (see Cache Files ); a file called config.log containing any messages produced by compilers, to help debugging if configure makes a mistake. To create a configure script with Autoconf, you need to write an Autoconf input file configure.ac (or configure.in ) and run autoconf on it. If you write your own feature tests to supplement those that come with Autoconf, you might also write files called aclocal.m4 and acsite.m4 . If you use a C header file to contain #define directives, you might also run autoheader , and you can distribute the generated file config.h.in with the package. Here is a diagram showing how the files that can be used in configuration are produced. Programs that are executed are suffixed by \u2018 * \u2019. Optional files are enclosed in square brackets (\u2018 [] \u2019). autoconf and autoheader also read the installed Autoconf macro files (by reading autoconf.m4 ). Files used in preparing a software package for distribution, when using just Autoconf: your source files --> [autoscan*] --> [configure.scan] --> configure.ac configure.ac --. | .------> autoconf* -----> configure [aclocal.m4] --+---+ | `-----> [autoheader*] --> [config.h.in] [acsite.m4] ---' Makefile.in Additionally, if you use Automake, the following additional productions come into play: [acinclude.m4] --. | [local macros] --+--> aclocal* --> aclocal.m4 | configure.ac ----' configure.ac --. +--> automake* --> Makefile.in Makefile.am ---' 3.1 Writing configure.ac To produce a configure script for a software package, create a file called configure.ac that contains invocations of the Autoconf macros that test the system features your package needs or can use. Autoconf macros already exist to check for many features; see Existing Tests , for their descriptions. For most other features, you can use Autoconf template macros to produce custom checks ; see Writing Tests , for information about them. For especially tricky or specialized features, configure.ac might need to contain some hand-crafted shell commands; see Portable Shell Programming . The autoscan program can give you a good start in writing configure.ac (see autoscan Invocation , for more information). Shell Script Compiler : Autoconf as solution of a problem Autoconf Language : Programming in Autoconf Autoconf Input Layout : Standard organization of configure.ac 3.1.1 A Shell Script Compiler Just as for any other computer language, in order to properly program configure.ac in Autoconf you must understand what problem the language tries to address and how it does so. The problem Autoconf addresses is that the world is a mess. After all, you are using Autoconf in order to have your package compile easily on all sorts of different systems, some of them being extremely hostile. Autoconf itself bears the price for these differences: configure must run on all those systems, and thus configure must limit itself to their lowest common denominator of features. Naturally, you might then think of shell scripts; who needs autoconf? A set of properly written shell functions is enough to make it easy to write configure scripts by hand. Sigh! Unfortunately, even in 2008, where shells without any function support are far and few between, there are pitfalls to avoid when making use of them. Also, finding a Bourne shell that accepts shell functions is not trivial, even though there is almost always one on interesting porting targets. So, what is really needed is some kind of compiler, autoconf , that takes an Autoconf program, configure.ac , and transforms it into a portable shell script, configure . How does autoconf perform this task? There are two obvious possibilities: creating a brand new language or extending an existing one. The former option is attractive: all sorts of optimizations could easily be implemented in the compiler and many rigorous checks could be performed on the Autoconf program (e.g., rejecting any non-portable construct). Alternatively, you can extend an existing language, such as the sh (Bourne shell) language. Autoconf does the latter: it is a layer on top of sh . It was therefore most convenient to implement autoconf as a macro expander : a program that repeatedly performs macro expansions on text input, replacing macro calls with macro bodies and producing a pure sh script in the end. Instead of implementing a dedicated Autoconf macro expander , it is natural to use an existing general-purpose macro language , such as M4, and implement the extensions as a set of M4 macros. 3.1.2 The Autoconf Language The Autoconf language differs from many other computer languages because it treats actual code the same as plain text. Whereas in C, for instance, data and instructions have different syntactic status, in Autoconf their status is rigorously the same. Therefore, we need a means to distinguish literal strings from text to be expanded: quotation. When calling macros that take arguments, there must not be any white space between the macro name and the open parenthesis. AC_INIT ([oops], [1.0]) # incorrect AC_INIT([hello], [1.0]) # good Arguments should be enclosed within the quote characters \u2018 [ \u2019 and \u2018 ] \u2019, and be separated by commas. Any leading blanks or newlines in arguments are ignored, unless they are quoted. You should always quote an argument that might contain a macro name, comma, parenthesis, or a leading blank or newline. This rule applies recursively for every macro call, including macros called from other macros. For more details on quoting rules, see Programming in M4 . For instance: AC_CHECK_HEADER([stdio.h], [AC_DEFINE([HAVE_STDIO_H], [1], [Define to 1 if you have <stdio.h>.])], [AC_MSG_ERROR([sorry, can't do anything for you])]) is quoted properly. You may safely simplify its quotation to: AC_CHECK_HEADER([stdio.h], [AC_DEFINE([HAVE_STDIO_H], 1, [Define to 1 if you have <stdio.h>.])], [AC_MSG_ERROR([sorry, can't do anything for you])]) because \u20181\u2019 cannot contain a macro call. Here, the argument of AC_MSG_ERROR must be quoted; otherwise, its comma would be interpreted as an argument separator. Also, the second and third arguments of \u2018 AC_CHECK_HEADER \u2019 must be quoted, since they contain macro calls. The three arguments \u2018 HAVE_STDIO_H \u2019, \u2018 stdio.h \u2019, and \u2018 Define to 1 if you have <stdio.h>. \u2019 do not need quoting, but if you unwisely defined a macro with a name like \u2018 Define \u2019 or \u2018 stdio \u2019 then they would need quoting. Cautious Autoconf users would keep the quotes, but many Autoconf users find such precautions annoying, and would rewrite the example as follows: AC_CHECK_HEADER(stdio.h, [AC_DEFINE(HAVE_STDIO_H, 1, [Define to 1 if you have <stdio.h>.])], [AC_MSG_ERROR([sorry, can't do anything for you])]) 3.1.3 Standard configure.ac Layout The order in which configure.ac calls the Autoconf macros is not important, with a few exceptions. Every configure.ac must contain a call to AC_INIT before the checks, and a call to AC_OUTPUT at the end (see Output ). Additionally, some macros rely on other macros having been called first, because they check previously set values of some variables to decide what to do. These macros are noted in the individual descriptions (see Existing Tests ), and they also warn you when configure is created if they are called out of order. To encourage consistency, here is a suggested order for calling the Autoconf macros. Generally speaking, the things near the end of this list are those that could depend on things earlier in it. For example, library functions could be affected by types and libraries. Autoconf requirements AC_INIT(package, version, bug-report-address) information on the package checks for programs checks for libraries checks for header files checks for types checks for structures checks for compiler characteristics checks for library functions checks for system services AC_CONFIG_FILES([file...]) AC_OUTPUT 3.2 Using autoscan to Create configure.ac 3.3 Using ifnames to List Conditionals 3.4 Using autoconf to Create configure 3.5 Using autoreconf to Update configure Scripts","title":"Autoconf"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/#autoconf","text":"","title":"Autoconf"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/#1#introduction","text":"Autoconf is a tool for producing shell scripts that automatically configure software source code packages to adapt to many kinds of Posix-like systems . The configuration scripts produced by Autoconf are independent of Autoconf when they are run, so their users do not need to have Autoconf. The configuration scripts produced by Autoconf require no manual user intervention when run; they do not normally even need an argument specifying the system type. Instead, they individually test for the presence of each feature that the software package they are for might need. (Before each check, they print a one-line message stating what they are checking for, so the user doesn't get too bored while waiting for the script to finish.) As a result, they deal well with systems that are hybrids or customized from the more common Posix variants. There is no need to maintain files that list the features supported by each release of each variant of Posix. For each software package that Autoconf is used with, it creates a configuration script from a template file that lists the system features that the package needs or can use. After the shell code to recognize and respond to a system feature has been written, Autoconf allows it to be shared by many software packages that can use (or need) that feature. If it later turns out that the shell code needs adjustment for some reason, it needs to be changed in only one place; all of the configuration scripts can be regenerated automatically to take advantage of the updated code. NOTE: Autoconf \u7684\u8f93\u5165\uff1atemplate file\uff0c\u6309\u7167\u60ef\u4f8b\uff0c\u6587\u4ef6\u540d\u4e3a configure.ac Autoconf \u7684\u8f93\u51fa\uff1aconfiguration script\uff0c\u6309\u7167\u60ef\u4f8b\uff0c\u6587\u4ef6\u540d\u4e3a configure","title":"1 Introduction"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/#2#the#gnu#build#system","text":"2.1 Automake 2.2 Gnulib 2.3 Libtool 2.4 Pointers","title":"2 The GNU Build System"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/#3#making#configure#scripts","text":"The configuration scripts that Autoconf produces are by convention called configure . When run, configure creates several files, replacing configuration parameters in them with appropriate values. The files that configure creates are: one or more Makefile files, usually one in each subdirectory of the package (see Makefile Substitutions ); optionally, a C header file, the name of which is configurable, containing #define directives (see Configuration Headers ); a shell script called config.status that, when run, recreates the files listed above (see config.status Invocation ); an optional shell script normally called config.cache (created when using \u2018 configure --config-cache \u2019) that saves the results of running many of the tests (see Cache Files ); a file called config.log containing any messages produced by compilers, to help debugging if configure makes a mistake. To create a configure script with Autoconf, you need to write an Autoconf input file configure.ac (or configure.in ) and run autoconf on it. If you write your own feature tests to supplement those that come with Autoconf, you might also write files called aclocal.m4 and acsite.m4 . If you use a C header file to contain #define directives, you might also run autoheader , and you can distribute the generated file config.h.in with the package. Here is a diagram showing how the files that can be used in configuration are produced. Programs that are executed are suffixed by \u2018 * \u2019. Optional files are enclosed in square brackets (\u2018 [] \u2019). autoconf and autoheader also read the installed Autoconf macro files (by reading autoconf.m4 ). Files used in preparing a software package for distribution, when using just Autoconf: your source files --> [autoscan*] --> [configure.scan] --> configure.ac configure.ac --. | .------> autoconf* -----> configure [aclocal.m4] --+---+ | `-----> [autoheader*] --> [config.h.in] [acsite.m4] ---' Makefile.in Additionally, if you use Automake, the following additional productions come into play: [acinclude.m4] --. | [local macros] --+--> aclocal* --> aclocal.m4 | configure.ac ----' configure.ac --. +--> automake* --> Makefile.in Makefile.am ---'","title":"3 Making configure Scripts"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/#31#writing#configureac","text":"To produce a configure script for a software package, create a file called configure.ac that contains invocations of the Autoconf macros that test the system features your package needs or can use. Autoconf macros already exist to check for many features; see Existing Tests , for their descriptions. For most other features, you can use Autoconf template macros to produce custom checks ; see Writing Tests , for information about them. For especially tricky or specialized features, configure.ac might need to contain some hand-crafted shell commands; see Portable Shell Programming . The autoscan program can give you a good start in writing configure.ac (see autoscan Invocation , for more information). Shell Script Compiler : Autoconf as solution of a problem Autoconf Language : Programming in Autoconf Autoconf Input Layout : Standard organization of configure.ac","title":"3.1 Writing configure.ac"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/#311#a#shell#script#compiler","text":"Just as for any other computer language, in order to properly program configure.ac in Autoconf you must understand what problem the language tries to address and how it does so. The problem Autoconf addresses is that the world is a mess. After all, you are using Autoconf in order to have your package compile easily on all sorts of different systems, some of them being extremely hostile. Autoconf itself bears the price for these differences: configure must run on all those systems, and thus configure must limit itself to their lowest common denominator of features. Naturally, you might then think of shell scripts; who needs autoconf? A set of properly written shell functions is enough to make it easy to write configure scripts by hand. Sigh! Unfortunately, even in 2008, where shells without any function support are far and few between, there are pitfalls to avoid when making use of them. Also, finding a Bourne shell that accepts shell functions is not trivial, even though there is almost always one on interesting porting targets. So, what is really needed is some kind of compiler, autoconf , that takes an Autoconf program, configure.ac , and transforms it into a portable shell script, configure . How does autoconf perform this task? There are two obvious possibilities: creating a brand new language or extending an existing one. The former option is attractive: all sorts of optimizations could easily be implemented in the compiler and many rigorous checks could be performed on the Autoconf program (e.g., rejecting any non-portable construct). Alternatively, you can extend an existing language, such as the sh (Bourne shell) language. Autoconf does the latter: it is a layer on top of sh . It was therefore most convenient to implement autoconf as a macro expander : a program that repeatedly performs macro expansions on text input, replacing macro calls with macro bodies and producing a pure sh script in the end. Instead of implementing a dedicated Autoconf macro expander , it is natural to use an existing general-purpose macro language , such as M4, and implement the extensions as a set of M4 macros.","title":"3.1.1 A Shell Script Compiler"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/#312#the#autoconf#language","text":"The Autoconf language differs from many other computer languages because it treats actual code the same as plain text. Whereas in C, for instance, data and instructions have different syntactic status, in Autoconf their status is rigorously the same. Therefore, we need a means to distinguish literal strings from text to be expanded: quotation. When calling macros that take arguments, there must not be any white space between the macro name and the open parenthesis. AC_INIT ([oops], [1.0]) # incorrect AC_INIT([hello], [1.0]) # good Arguments should be enclosed within the quote characters \u2018 [ \u2019 and \u2018 ] \u2019, and be separated by commas. Any leading blanks or newlines in arguments are ignored, unless they are quoted. You should always quote an argument that might contain a macro name, comma, parenthesis, or a leading blank or newline. This rule applies recursively for every macro call, including macros called from other macros. For more details on quoting rules, see Programming in M4 . For instance: AC_CHECK_HEADER([stdio.h], [AC_DEFINE([HAVE_STDIO_H], [1], [Define to 1 if you have <stdio.h>.])], [AC_MSG_ERROR([sorry, can't do anything for you])]) is quoted properly. You may safely simplify its quotation to: AC_CHECK_HEADER([stdio.h], [AC_DEFINE([HAVE_STDIO_H], 1, [Define to 1 if you have <stdio.h>.])], [AC_MSG_ERROR([sorry, can't do anything for you])]) because \u20181\u2019 cannot contain a macro call. Here, the argument of AC_MSG_ERROR must be quoted; otherwise, its comma would be interpreted as an argument separator. Also, the second and third arguments of \u2018 AC_CHECK_HEADER \u2019 must be quoted, since they contain macro calls. The three arguments \u2018 HAVE_STDIO_H \u2019, \u2018 stdio.h \u2019, and \u2018 Define to 1 if you have <stdio.h>. \u2019 do not need quoting, but if you unwisely defined a macro with a name like \u2018 Define \u2019 or \u2018 stdio \u2019 then they would need quoting. Cautious Autoconf users would keep the quotes, but many Autoconf users find such precautions annoying, and would rewrite the example as follows: AC_CHECK_HEADER(stdio.h, [AC_DEFINE(HAVE_STDIO_H, 1, [Define to 1 if you have <stdio.h>.])], [AC_MSG_ERROR([sorry, can't do anything for you])])","title":"3.1.2 The Autoconf Language"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/#313#standard#configureac#layout","text":"The order in which configure.ac calls the Autoconf macros is not important, with a few exceptions. Every configure.ac must contain a call to AC_INIT before the checks, and a call to AC_OUTPUT at the end (see Output ). Additionally, some macros rely on other macros having been called first, because they check previously set values of some variables to decide what to do. These macros are noted in the individual descriptions (see Existing Tests ), and they also warn you when configure is created if they are called out of order. To encourage consistency, here is a suggested order for calling the Autoconf macros. Generally speaking, the things near the end of this list are those that could depend on things earlier in it. For example, library functions could be affected by types and libraries. Autoconf requirements AC_INIT(package, version, bug-report-address) information on the package checks for programs checks for libraries checks for header files checks for types checks for structures checks for compiler characteristics checks for library functions checks for system services AC_CONFIG_FILES([file...]) AC_OUTPUT","title":"3.1.3 Standard configure.ac Layout"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/#32#using#autoscan#to#create#configureac","text":"","title":"3.2 Using autoscan to Create configure.ac"},{"location":"Shell-and-tools/Tools/Build/Autoconf/Autoconf/#33#using#ifnames#to#list#conditionals","text":"3.4 Using autoconf to Create configure 3.5 Using autoreconf to Update configure Scripts","title":"3.3 Using ifnames to List Conditionals"},{"location":"Shell-and-tools/Tools/Build/Automake/Automake/","text":"automake","title":"Automake"},{"location":"Shell-and-tools/Tools/Build/Automake/Automake/#automake","text":"","title":"automake"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/","text":"Autotools Mythbuster Chapter 1. Configuring The Build \u2014 autoconf Configuring the build consists of running a series of tests to identify the build environment and the presence of the required tools and libraries. It is a crucial step in allowing portability between different operating systems to detect this build environment system. In the autotools chain, this is done by the autoconf tool. The autoconf tool translates a configure.ac file, written in a mixture of m4 and shell scripting, into a configure POSIX shell script that executes the tests that determines what the build environment is. 1. M4sh The language used to write the configure.ac is called M4sh , to make clear that it's based off both sh and the macro language M4 . 2. Canonical Systems When using autoconf, there are three system definitions (or machine definitions ) that are used to identify the \u201cactors\u201d in the build process; each definition relates to a similarly-named variable which will be illustrated in detail later. These three definitions are: host ( CHOST ) The system that is going to run the software once it is built, which is the main actor. Once the software has been built, it will execute on this particular system. build ( CBUILD ) The system where the build process is being executed. For most uses this would be the same as the host system, but in case of cross-compilation the two obviously differ. target ( CTARGET ) The system against which the software being built will run on. This actor only exists, or rather has a meaning, when the software being built may interact specifically with a system that differs from the one it's being executed on (our host ). This is the case for compilers, debuggers, profilers and analyzers and other tools in general. To identify the current actors involved in the build process, autoconf provides three macros that take care of finding the so-called \u201ccanonical\u201d values (see Section 2.1, \u201cThe System Definition Tuples\u201d for their format): AC_CANONICAL_HOST , AC_CANONICAL_BUILD and AC_CANONICAL_TARGET . These three macros then provide to the configure script the sh variables with the name of the actor ( $host , $build and $target ), and three parameters with the same name to the configure script so that the user can override the default discovered values. The most basic autoconf based build systems won't need to know any of these values, at least directly. Some other tools, such as libtool, will require discovery of canonical systems by themselves. Since adding these macros unconditionally adds direct and indirect code to the configure script (and a dependency on the two support files config.sub and config.guess ); it is recommended not to call them unconditionally. It is actually quite easy to decide whether canonical system definitions are needed or not. We just have to look for the use of the related actor variable. For instance if the configure.ac script uses the $build variable, we would need to call AC_CANONICAL_BUILD to discover its value. If the system definition variables are used in a macro instead, we should use the AC_REQUIRE macro to ensure that they are executed before entering. Don't fear calling them in more than one place. See Section 6.2, \u201cOnce-Expansion\u201d for more details. One common mistake is to \u201cgo all the way\u201d and always use the AC_CANONICAL_TARGET macro, or its misnamed predecessor AC_CANONICAL_SYSTEM . This is particularly a problem; because most of the software will not have a target actor at all. This actor is only meaningful when the software that is being built manages data that is specific to a different system than the one it is being executed on (the host system). In practice, the only places where the target actor is meaningful are to the parts of a compile toolchain: assemblers, linkers, compilers, debuggers, profilers, analysers, \u2026 For the rest of the software, the presence of an extraneous --target option to configure is likely to just be confusing. Especially for software that processes the output of the script to identify some information about the package being built. 2.1. The System Definition Tuples The system definitions used by autoconf (but also by other packages like GCC and Binutils) are simple tuples in the form of strings. These are designed to provide, in a format easy to parse with \u201cglob masks\u201d; the major details that describe a computer system . The number of elements in these tuples is variable, for some uses that only deal with very low-level code, there can be just a single element, the system architecture ( i386 , x86_64 , powerpc , \u2026); others will have two, defining either the operating system or, most often for definition pairs, the executable format ( elf , coff , \u2026). These two formats though are usually, only related to components of the toolchain and not to autoconf directly. The tuples commonly used with autoconf are triples and quadruples, which define three components: architecture , vendor and operating system . These three components usually map directly into the triples, but for quadruple you have to split the operating system into kernel and userland (usually the C library). While the architecture is most obvious; and operating systems differ slightly from one another (still being probably the most important data), the vendor value is usually just ignored. It is meant to actually be the vendor of the hardware system, rather than the vendor of the software, although presently it is mostly used by distributions to brand their toolchain ( i386-redhat-linux-gnu ) or their special systems ( i386-gentoo-freebsd7.0 ) and by vendors that provide their own specific toolchain ( i686-apple-darwin9 ). Most operating systems don't split their definitions further in kernel and userland because they only work as an \u201censemble\u201d: FreeBSD, (Open)Solaris, Darwin, \u2026 There are, though, a few operating systems that have a split between kernel and userland, being managed by different projects or even being replaceable independently. This is the case for instance of Linux, which can use (among others) the GNU C Library (GNU/Linux) or uClibc, which become respectively *-linux-gnu and *-linux-uclibc . Also, most operating systems using triples also have a single standardised version for both kernel and userland, and thus provide it as a suffix to the element ( *-freebsd7.0 , *-netbsd4.0 ). For a few operating systems, this value might differ from the one that is used as the \u201cproduct version\u201d used in public. For instance Solaris 10 uses as a definition *-solaris2.10 and Apple's Mac OS X 10.5 uses *-darwin9 . 2.2. When To Use System Definitions To be extended 3. Adding Options 4. Finding Libraries 5. Custom Autoconf Tests 6. Autoconf Building Blocks: Macros 7. Caching Results","title":"Introduction"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#autotools#mythbuster","text":"","title":"Autotools Mythbuster"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#chapter#1#configuring#the#build#autoconf","text":"Configuring the build consists of running a series of tests to identify the build environment and the presence of the required tools and libraries. It is a crucial step in allowing portability between different operating systems to detect this build environment system. In the autotools chain, this is done by the autoconf tool. The autoconf tool translates a configure.ac file, written in a mixture of m4 and shell scripting, into a configure POSIX shell script that executes the tests that determines what the build environment is.","title":"Chapter 1. Configuring The Build \u2014 autoconf"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#1#m4sh","text":"The language used to write the configure.ac is called M4sh , to make clear that it's based off both sh and the macro language M4 .","title":"1. M4sh"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#2#canonical#systems","text":"When using autoconf, there are three system definitions (or machine definitions ) that are used to identify the \u201cactors\u201d in the build process; each definition relates to a similarly-named variable which will be illustrated in detail later. These three definitions are: host ( CHOST ) The system that is going to run the software once it is built, which is the main actor. Once the software has been built, it will execute on this particular system. build ( CBUILD ) The system where the build process is being executed. For most uses this would be the same as the host system, but in case of cross-compilation the two obviously differ. target ( CTARGET ) The system against which the software being built will run on. This actor only exists, or rather has a meaning, when the software being built may interact specifically with a system that differs from the one it's being executed on (our host ). This is the case for compilers, debuggers, profilers and analyzers and other tools in general. To identify the current actors involved in the build process, autoconf provides three macros that take care of finding the so-called \u201ccanonical\u201d values (see Section 2.1, \u201cThe System Definition Tuples\u201d for their format): AC_CANONICAL_HOST , AC_CANONICAL_BUILD and AC_CANONICAL_TARGET . These three macros then provide to the configure script the sh variables with the name of the actor ( $host , $build and $target ), and three parameters with the same name to the configure script so that the user can override the default discovered values. The most basic autoconf based build systems won't need to know any of these values, at least directly. Some other tools, such as libtool, will require discovery of canonical systems by themselves. Since adding these macros unconditionally adds direct and indirect code to the configure script (and a dependency on the two support files config.sub and config.guess ); it is recommended not to call them unconditionally. It is actually quite easy to decide whether canonical system definitions are needed or not. We just have to look for the use of the related actor variable. For instance if the configure.ac script uses the $build variable, we would need to call AC_CANONICAL_BUILD to discover its value. If the system definition variables are used in a macro instead, we should use the AC_REQUIRE macro to ensure that they are executed before entering. Don't fear calling them in more than one place. See Section 6.2, \u201cOnce-Expansion\u201d for more details. One common mistake is to \u201cgo all the way\u201d and always use the AC_CANONICAL_TARGET macro, or its misnamed predecessor AC_CANONICAL_SYSTEM . This is particularly a problem; because most of the software will not have a target actor at all. This actor is only meaningful when the software that is being built manages data that is specific to a different system than the one it is being executed on (the host system). In practice, the only places where the target actor is meaningful are to the parts of a compile toolchain: assemblers, linkers, compilers, debuggers, profilers, analysers, \u2026 For the rest of the software, the presence of an extraneous --target option to configure is likely to just be confusing. Especially for software that processes the output of the script to identify some information about the package being built.","title":"2. Canonical Systems"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#21#the#system#definition#tuples","text":"The system definitions used by autoconf (but also by other packages like GCC and Binutils) are simple tuples in the form of strings. These are designed to provide, in a format easy to parse with \u201cglob masks\u201d; the major details that describe a computer system . The number of elements in these tuples is variable, for some uses that only deal with very low-level code, there can be just a single element, the system architecture ( i386 , x86_64 , powerpc , \u2026); others will have two, defining either the operating system or, most often for definition pairs, the executable format ( elf , coff , \u2026). These two formats though are usually, only related to components of the toolchain and not to autoconf directly. The tuples commonly used with autoconf are triples and quadruples, which define three components: architecture , vendor and operating system . These three components usually map directly into the triples, but for quadruple you have to split the operating system into kernel and userland (usually the C library). While the architecture is most obvious; and operating systems differ slightly from one another (still being probably the most important data), the vendor value is usually just ignored. It is meant to actually be the vendor of the hardware system, rather than the vendor of the software, although presently it is mostly used by distributions to brand their toolchain ( i386-redhat-linux-gnu ) or their special systems ( i386-gentoo-freebsd7.0 ) and by vendors that provide their own specific toolchain ( i686-apple-darwin9 ). Most operating systems don't split their definitions further in kernel and userland because they only work as an \u201censemble\u201d: FreeBSD, (Open)Solaris, Darwin, \u2026 There are, though, a few operating systems that have a split between kernel and userland, being managed by different projects or even being replaceable independently. This is the case for instance of Linux, which can use (among others) the GNU C Library (GNU/Linux) or uClibc, which become respectively *-linux-gnu and *-linux-uclibc . Also, most operating systems using triples also have a single standardised version for both kernel and userland, and thus provide it as a suffix to the element ( *-freebsd7.0 , *-netbsd4.0 ). For a few operating systems, this value might differ from the one that is used as the \u201cproduct version\u201d used in public. For instance Solaris 10 uses as a definition *-solaris2.10 and Apple's Mac OS X 10.5 uses *-darwin9 .","title":"2.1. The System Definition Tuples"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#22#when#to#use#system#definitions","text":"To be extended","title":"2.2. When To Use System Definitions"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#3#adding#options","text":"","title":"3. Adding Options"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#4#finding#libraries","text":"","title":"4. Finding Libraries"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#5#custom#autoconf#tests","text":"","title":"5. Custom Autoconf Tests"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#6#autoconf#building#blocks#macros","text":"","title":"6. Autoconf Building Blocks: Macros"},{"location":"Shell-and-tools/Tools/Build/Autotools-Mythbuster/#7#caching#results","text":"","title":"7. Caching Results"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/","text":"Make and makefile Make \u7ef4\u57fa\u767e\u79d1 Make (software) Makefile \u7ef4\u57fa\u767e\u79d1 Makefile Macro in makefile $@ $@ is a macro that refers to the target\u3002\u5176\u5b9e\u8fd9\u4e2a\u975e\u5e38\u597d\u7406\u89e3\uff0c @ \u6709\u6307\u5411\u7684\u542b\u4e49\u3002 \"$$?\" What does \u201c$$?\u201d mean in this makefile snippet? makefile and dependency graph \u6211\u4eec\u4f7f\u7528makefile\u672c\u8d28\u4e0a\u662f\u63cf\u8ff0\u4e86\u4e00\u5f20dependency graph\uff0c\u8fd9\u5f20\u56fe\u7531\u591a\u4e2anode\u7ec4\u6210\uff0c\u8fd9\u4e9bnode\u4e4b\u95f4\u53ef\u80fd\u5b58\u5728\u4e2ddependency \u5173\u7cfb\uff0c\u6709\u53ef\u80fd\u4e0d\u5b58\u5728\u3002\u5e94\u8be5\u662f\u53ef\u4ee5\u5355\u72ec\u8bbf\u95ee\u6bcf\u4e2anode\u7684\u3002\u5173\u4e8e\u8fd9\u4e00\u70b9\uff0c\u53ef\u4ee5\u53c2\u89c1https:// www.cs.princeton.edu/courses/archive/spr01/cs217/slides/5.make.pdf \u53e6\u5916\u53c2\u89c1 makefile2graph Creates a graph of dependencies from GNU-Make; Output is a graphiz-dot file or a Gexf-XML file. Is there a tool to analyse makefiles?","title":"Make-and-makefile"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#make#and#makefile","text":"","title":"Make and makefile"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#make","text":"","title":"Make"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#make#software","text":"","title":"\u7ef4\u57fa\u767e\u79d1Make (software)"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#makefile","text":"","title":"Makefile"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#makefile_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1Makefile"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#macro#in#makefile","text":"","title":"Macro in makefile"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#_1","text":"$@ is a macro that refers to the target\u3002\u5176\u5b9e\u8fd9\u4e2a\u975e\u5e38\u597d\u7406\u89e3\uff0c @ \u6709\u6307\u5411\u7684\u542b\u4e49\u3002","title":"$@"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#_2","text":"What does \u201c$$?\u201d mean in this makefile snippet?","title":"\"$$?\""},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#makefile#and#dependency#graph","text":"\u6211\u4eec\u4f7f\u7528makefile\u672c\u8d28\u4e0a\u662f\u63cf\u8ff0\u4e86\u4e00\u5f20dependency graph\uff0c\u8fd9\u5f20\u56fe\u7531\u591a\u4e2anode\u7ec4\u6210\uff0c\u8fd9\u4e9bnode\u4e4b\u95f4\u53ef\u80fd\u5b58\u5728\u4e2ddependency \u5173\u7cfb\uff0c\u6709\u53ef\u80fd\u4e0d\u5b58\u5728\u3002\u5e94\u8be5\u662f\u53ef\u4ee5\u5355\u72ec\u8bbf\u95ee\u6bcf\u4e2anode\u7684\u3002\u5173\u4e8e\u8fd9\u4e00\u70b9\uff0c\u53ef\u4ee5\u53c2\u89c1https:// www.cs.princeton.edu/courses/archive/spr01/cs217/slides/5.make.pdf \u53e6\u5916\u53c2\u89c1","title":"makefile and  dependency graph"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#makefile2graph","text":"Creates a graph of dependencies from GNU-Make; Output is a graphiz-dot file or a Gexf-XML file.","title":"makefile2graph"},{"location":"Shell-and-tools/Tools/Build/Make/Make-and-makefile/#is#there#a#tool#to#analyse#makefiles","text":"","title":"Is there a tool to analyse makefiles?"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Makefile/","text":"Makefile \u672c\u6587\u8bb0\u5f55\u6211\u5b66\u4e60makefile\u7684\u8fc7\u7a0b\u3002 Makefile funciton Define your own function in a Makefile Define your own function in a Makefile Defining custom GNU make functions \u5b9e\u4f8b\u5982\u4e0b\uff1a # \u5207\u6362\u5230\u6307\u5b9a\u76ee\u5f55\uff0c\u7136\u540e\u5c31\u8fdb\u884c\u7f16\u8bd1 define cd_and_compile make -C $( 1 ) || exit \" $$ ?\" endef # \u5207\u6362\u5230\u6307\u5b9a\u76ee\u5f55\uff0c\u7136\u540e\u5c31\u8fdb\u884c\u6e05\u7a7a define cd_and_clean make -C $( 1 ) clean || exit \" $$ ?\" endef # \u6240\u6709\u9700\u8981\u7f16\u8bd1\u7684\u6a21\u5757\uff0c\u5df2\u7ecf\u6309\u7167\u4f9d\u8d56\u5173\u7cfb\u6392\u5e8f MOD := mod1 mod1 mod1 mod1 # \u5148\u5168\u90e8\u6e05\u7a7a\uff0c\u7136\u540e\u8fdb\u884c\u5168\u7f16 all : clean $( MOD ) # \u5355\u7f16 mod1 mod1 : $( call cd_and_compile, $@ ) \u5b98\u65b9\u6587\u6863 8 Functions for Transforming Text Text Functions \u5728\u5b98\u65b9\u6587\u6863\u7684\u8fd9\u4e00\u7ae0\u8282\u5b9a\u4e49\u4e86\u5f88\u591a\u975e\u5e38\u597d\u7528\u7684\u7531\u4e8e\u6587\u672c\u64cd\u4f5c\u7684\u51fd\u6570\u3002 patsubst CSDN\u7684 makefile\u4e2d\u7684patsubst \u7ed3\u5408\u5177\u4f53\u4f8b\u5b50\uff0c\u4ecb\u7ecd\u5730\u8f83\u597d\u3002 \u95ee\u9898\uff1apatsubst\u4e2d\u6dfb\u52a0 or \u7b54\uff1a\u5728 How to add \u201cor\u201d in pathsubst in Makefile \u4e2d\uff0c\u7ed9\u51fa\u4e86\u6bd4\u8f83\u597d\u7684\u65b9\u6cd5\u3002 Invoke shell command in makefile \u5982\u4f55\u5728makefile\u4e2d\u6267\u884cshell\u547d\u4ee4\uff1f \u4e0b\u9762\u7ed9\u51fa\u4e86\u4f8b\u5b50\uff1a $( shell mkdir -p .. / appcom ) make install \u6700\u597d\u4f7f\u7528 install \u547d\u4ee4 $( shell mkdir -p ../appcom ) install -v ./lib/* ../appcom \u6e90\u4ee3\u7801\u5206\u5e03\u5728\u591a\u4e2a\u76ee\u5f55 \u6709\u7684\u65f6\u5019\uff0c\u4e00\u4e2atarget\u7684source code\u6587\u4ef6\u5206\u5e03\u5728\u591a\u4e2a\u76ee\u5f55\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0b\u5982\u4f55\u6765\u5904\u7406\u5462\uff1f \u4e0b\u9762\u7ed9\u51fa\u4e86\u4f8b\u5b50 VPATH = .:../core:../core/celery:../core/data_model:../core/datetime:../core/feature INC = -I. -I.. -I../hundsun -I../third_party SRCS := $( wildcard *.cpp ) #SRCS += $(wildcard ../core/celery/*.cpp) SRCS += $( wildcard ../core/datetime/*.cpp ) SRCS += $( wildcard ../core/data_model/*.cpp ) SRCS += $( wildcard ../core/feature/*.cpp ) OBJS := $( patsubst %.cpp,%.o, $( SRCS )) TARGET := libfsc_quote_predict.so LIBS = -lalgo_public -lh5api -lhiredis -lredis++ -ltensorflow include ../make/master.mk","title":"Makefile"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Makefile/#makefile","text":"\u672c\u6587\u8bb0\u5f55\u6211\u5b66\u4e60makefile\u7684\u8fc7\u7a0b\u3002","title":"Makefile"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Makefile/#makefile#funciton","text":"","title":"Makefile funciton"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Makefile/#define#your#own#function#in#a#makefile","text":"Define your own function in a Makefile Defining custom GNU make functions \u5b9e\u4f8b\u5982\u4e0b\uff1a # \u5207\u6362\u5230\u6307\u5b9a\u76ee\u5f55\uff0c\u7136\u540e\u5c31\u8fdb\u884c\u7f16\u8bd1 define cd_and_compile make -C $( 1 ) || exit \" $$ ?\" endef # \u5207\u6362\u5230\u6307\u5b9a\u76ee\u5f55\uff0c\u7136\u540e\u5c31\u8fdb\u884c\u6e05\u7a7a define cd_and_clean make -C $( 1 ) clean || exit \" $$ ?\" endef # \u6240\u6709\u9700\u8981\u7f16\u8bd1\u7684\u6a21\u5757\uff0c\u5df2\u7ecf\u6309\u7167\u4f9d\u8d56\u5173\u7cfb\u6392\u5e8f MOD := mod1 mod1 mod1 mod1 # \u5148\u5168\u90e8\u6e05\u7a7a\uff0c\u7136\u540e\u8fdb\u884c\u5168\u7f16 all : clean $( MOD ) # \u5355\u7f16 mod1 mod1 : $( call cd_and_compile, $@ )","title":"Define your own function in a Makefile"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Makefile/#8#functions#for#transforming#text","text":"","title":"\u5b98\u65b9\u6587\u6863 8 Functions for Transforming Text"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Makefile/#text#functions","text":"\u5728\u5b98\u65b9\u6587\u6863\u7684\u8fd9\u4e00\u7ae0\u8282\u5b9a\u4e49\u4e86\u5f88\u591a\u975e\u5e38\u597d\u7528\u7684\u7531\u4e8e\u6587\u672c\u64cd\u4f5c\u7684\u51fd\u6570\u3002","title":"Text Functions"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Makefile/#patsubst","text":"CSDN\u7684 makefile\u4e2d\u7684patsubst \u7ed3\u5408\u5177\u4f53\u4f8b\u5b50\uff0c\u4ecb\u7ecd\u5730\u8f83\u597d\u3002 \u95ee\u9898\uff1apatsubst\u4e2d\u6dfb\u52a0 or \u7b54\uff1a\u5728 How to add \u201cor\u201d in pathsubst in Makefile \u4e2d\uff0c\u7ed9\u51fa\u4e86\u6bd4\u8f83\u597d\u7684\u65b9\u6cd5\u3002","title":"patsubst"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Makefile/#invoke#shell#command#in#makefile","text":"\u5982\u4f55\u5728makefile\u4e2d\u6267\u884cshell\u547d\u4ee4\uff1f \u4e0b\u9762\u7ed9\u51fa\u4e86\u4f8b\u5b50\uff1a $( shell mkdir -p .. / appcom )","title":"Invoke shell command in makefile"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Makefile/#make#install","text":"\u6700\u597d\u4f7f\u7528 install \u547d\u4ee4 $( shell mkdir -p ../appcom ) install -v ./lib/* ../appcom","title":"make install"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Makefile/#_1","text":"\u6709\u7684\u65f6\u5019\uff0c\u4e00\u4e2atarget\u7684source code\u6587\u4ef6\u5206\u5e03\u5728\u591a\u4e2a\u76ee\u5f55\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0b\u5982\u4f55\u6765\u5904\u7406\u5462\uff1f \u4e0b\u9762\u7ed9\u51fa\u4e86\u4f8b\u5b50 VPATH = .:../core:../core/celery:../core/data_model:../core/datetime:../core/feature INC = -I. -I.. -I../hundsun -I../third_party SRCS := $( wildcard *.cpp ) #SRCS += $(wildcard ../core/celery/*.cpp) SRCS += $( wildcard ../core/datetime/*.cpp ) SRCS += $( wildcard ../core/data_model/*.cpp ) SRCS += $( wildcard ../core/feature/*.cpp ) OBJS := $( patsubst %.cpp,%.o, $( SRCS )) TARGET := libfsc_quote_predict.so LIBS = -lalgo_public -lh5api -lhiredis -lredis++ -ltensorflow include ../make/master.mk","title":"\u6e90\u4ee3\u7801\u5206\u5e03\u5728\u591a\u4e2a\u76ee\u5f55"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Code/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u7ed9\u51fa\u4e86\u51e0\u4e2amakefile\u4f8b\u5b50\uff0c\u5982\u4e0b\uff1a Code1 \u4f7f\u7528\u4e00\u4e2a\u5927\u7684makefile\u6765\u5c06\u7531\u591a\u4e2a**\u5b50\u6a21\u5757**\u6784\u6210\u7684\u5de5\u7a0b\u7684\u6784\u5efa\u4e32\u8054\u8d77\u6765\uff0c\u6bd4\u8f83\u9002\u5408\u4e8e\u4f5c\u4e3a\u7531\u591a\u4e2a\u6a21\u5757\u6784\u6210\u7684\u9879\u76ee\u7684\u7f16\u8bd1\u3002 Code2 A smart Makefile template for GNU/LINUX programming Code3 makefile template for so Code4 makefile template for executable GenericMakefile","title":"Introduction"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Code/#_1","text":"\u672c\u7ae0\u7ed9\u51fa\u4e86\u51e0\u4e2amakefile\u4f8b\u5b50\uff0c\u5982\u4e0b\uff1a Code1 \u4f7f\u7528\u4e00\u4e2a\u5927\u7684makefile\u6765\u5c06\u7531\u591a\u4e2a**\u5b50\u6a21\u5757**\u6784\u6210\u7684\u5de5\u7a0b\u7684\u6784\u5efa\u4e32\u8054\u8d77\u6765\uff0c\u6bd4\u8f83\u9002\u5408\u4e8e\u4f5c\u4e3a\u7531\u591a\u4e2a\u6a21\u5757\u6784\u6210\u7684\u9879\u76ee\u7684\u7f16\u8bd1\u3002 Code2 A smart Makefile template for GNU/LINUX programming Code3 makefile template for so Code4 makefile template for executable GenericMakefile","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Code/Code1/","text":"# \u6574\u4e2a\u5de5\u7a0b\u7531\u591a\u4e2a\u6e90\u4ee3\u7801\u76ee\u5f55\u7ec4\u6210\uff0c\u6bcf\u4e2a\u76ee\u5f55\u6709\u81ea\u5df1\u72ec\u7acb\u7684\u4e00\u4e2amakefile\uff0c\u8fd9\u4e2amakefile\u662f\u4e00\u4e2a\u5927\u7684\u3001\u6574\u4f53\u7684Makefile\u6765\u6784\u5efa\u6574\u4e2a\u5de5\u7a0b\uff0c # \u9ed8\u8ba4\u60c5\u51b5\u662f\u5168\u7f16\uff0c\u4e5f\u63d0\u4f9b\u5355\u7f16\u67d0\u4e2a\u6a21\u5757\u7684\u6307\u4ee4\uff0c\u6bd4\u5982\u5de5\u7a0bproj\u7531mod1\u3001mod2\u3001mod3\u8fd9\u51e0\u4e2a\u7f16\u8bd1\u5355\u5143\u7ec4\u6210\uff0c\u5b83\u4eec\u4e4b\u95f4\u8fd8\u5b58\u5728\u7740\u4f9d\u8d56\u5173\u7cfb\u3002\u6211\u5199\u4e86\u4e00\u4e2a\u8fd9\u6837\u7684Makefile\uff1a # make # \u5168\u7f16 # make mod1 # \u5355\u7f16mod1\u76ee\u5f55 # make mod2 # \u5355\u7f16mod2\u76ee\u5f55 # ... # make clean # \u6e05\u9664\u5df2\u7ecf\u7f16\u8bd1\u7684 # \u5207\u6362\u5230\u6307\u5b9a\u76ee\u5f55\uff0c\u7136\u540e\u5c31\u8fdb\u884c\u7f16\u8bd1 define cd_and_compile make -C $( 1 ) || exit \" $$ ?\" endef # \u5207\u6362\u5230\u6307\u5b9a\u76ee\u5f55\uff0c\u7136\u540e\u5c31\u8fdb\u884c\u6e05\u7a7a define cd_and_clean make -C $( 1 ) clean || exit \" $$ ?\" endef # \u6240\u6709\u9700\u8981\u7f16\u8bd1\u7684\u6a21\u5757\uff0c\u5df2\u7ecf\u6309\u7167\u4f9d\u8d56\u5173\u7cfb\u6392\u5e8f MOD := mod1 mod2 mod3 # \u5148\u5168\u90e8\u6e05\u7a7a\uff0c\u7136\u540e\u8fdb\u884c\u5168\u7f16 all : clean $( MOD ) # \u5355\u7f16mod3\uff0c\u8f93\u51falibmod3.so mod3 : $( call cd_and_compile, $@ ) # \u5355\u7f16mod1\uff0c\u8f93\u51falibmod1.a mod1 : $( call cd_and_compile, $@ ) # \u5355\u7f16mod2\uff0c\u8f93\u51falibmod2.a mod2 : $( call cd_and_compile, $@ ) # \u6e05\u7a7amod3 clean_mod3 : $( call cd_and_clean, mod3 ) # \u6e05\u7a7amod1 clean_mod1 : $( call cd_and_clean, mod1 ) # \u6e05\u7a7amod2 clean_mod2 : $( call cd_and_clean, mod2 ) # \u6e05\u7a7a clean : @for dir in $( MOD ) ; do \\ $( call cd_and_clean, $$ dir ) ; \\ done .PHONY : all $( MOD ) clean clean_mod 3 clean_mod 2 clean_mod 1","title":"Introduction"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Code/Code2/","text":"GNU/Linux\u667a\u80fdMakefile\u6a21\u677f\uff08\u591a\u76ee\u5f55\uff0c\u591a\u6587\u4ef6\uff09 \u53c2\u8003\uff1a http://www.voidcn.com/article/p-rkpadnqa-bkn.html http://www.voidcn.com/article/p-mpuyxady-kg.html http://bbs.chinaunix.net/thread-3553668-1-1.html https://gist.github.com/mauriciopoppe/de8908f67923091982c8c8136a063ea6 ############################################################################### # # A smart Makefile template for GNU/LINUX programming # # Author: PRC (ijkxyz AT msn DOT com) # Date: 2011/06/17 # # Usage: # $ make Compile and link (or archive) # $ make clean Clean the objectives and target. ############################################################################### CROSS_COMPILE = OPTIMIZE := -O2 #\u5176\u4ed6\u9009\u9879:\u8c03\u8bd5: -g WARNINGS := -Wall -Wno-unused -Wno-format #\u5176\u4ed6\u9009\u62e9: -Wno-deprecated -Wno-write-strings #macro define DEFS := -DOS_COMMON_EXT -DNDEBUG -D_FILE_OFFSET_BITS = 64 EXTRA_CFLAGS := -c -fvisibility = hidden -std = c++11 # \u8f93\u51fa\u8def\u5f84 OUT_DIR = ../lib/linux.x64 # \u591a\u4e2a\u8def\u5f84\uff0c\u4f7f\u7528 \u7a7a\u683c \u9694\u5f00 INC_DIR = . ../include ../../.. # \u591a\u4e2a\u8def\u5f84\uff0c\u4f7f\u7528 \u7a7a\u683c \u9694\u5f00 SRC_DIR = ./src1 . ./src2 ./src3 # \u9700\u8981\u94fe\u63a5\u7684\u52a8\u6001\u5e93\u7684\u8def\u5f84 LIB_DIR = -L../lib/linux.x64 -L../../../../lib/linux.x64 # \u5b58\u653eobject file\u7684\u8def\u5f84 OBJ_DIR = build EXTRA_SRC = EXCLUDE_FILES = # \u9700\u8981\u94fe\u63a5\u7684\u52a8\u6001\u5e93 EXTRA_LIBS := -llib1 -llib2 -Wl,--whole-archive -lssl -lcrypto -Wl,--no-whole-archive SUFFIX = c cpp cc cxx TARGET = $( OUT_DIR ) /libTest.so #TARGET_TYPE := ar #TARGET_TYPE := app TARGET_TYPE := so ##################################################################################### # Do not change any part of them unless you have understood this script very well # # This is a kind remind. # ##################################################################################### #FUNC# Add a new line to the input stream. define add_newline $1 endef #FUNC# set the variable `src-x' according to the input $1 define set_src_x src-$1 = $( filter-out $4 , $( foreach d, $2 , $( wildcard $d /*. $1 )) $( filter %. $1 , $3 )) endef #FUNC# set the variable `obj-x' according to the input $1 define set_obj_x obj-$1 = $( patsubst %. $1 , $3 %.o, $( notdir $2 )) endef #VAR# Get the uniform representation of the object directory path name ifneq ($(OBJ_DIR),) prefix_objdir = $( shell echo $( OBJ_DIR ) | sed 's:\\(\\./*\\)*::' ) prefix_objdir := $( filter-out /, $( prefix_objdir ) / ) endif GCC := $( CROSS_COMPILE ) gcc G++ : = $( CROSS_COMPILE ) g ++ SRC_DIR := $( sort . $( SRC_DIR )) inc_dir = $( foreach d, $( sort $( INC_DIR ) $( SRC_DIR )) ,-I $d ) #--# Do smart deduction automatically $( eval $( foreach i , $( SUFFIX ) , $( call set_src_x , $ i , $( SRC_DIR ) , $( EXTRA_SRC ) , $( EXCLUDE_FILES )))) $( eval $( foreach i , $( SUFFIX ) , $( call set_obj_x , $ i , $( src- $ i ) , $( prefix_objdir )))) $( eval $( foreach f , $( EXTRA_SRC ) , $( call add_newline , vpath $( notdir $ f ) $( dir $ f )))) $( eval $( foreach d , $( SRC_DIR ) , $( foreach i , $( SUFFIX ) , $( call add_newline , vpath % . $ i $ d )))) all_objs = $( foreach i, $( SUFFIX ) , $( obj- $i )) all_srcs = $( foreach i, $( SUFFIX ) , $( src- $i )) CFLAGS = $( EXTRA_CFLAGS ) $( WARNINGS ) $( OPTIMIZE ) $( DEFS ) TARGET_TYPE := $( strip $( TARGET_TYPE )) ifeq ($(filter $(TARGET_TYPE),so ar app),) $( error Unexpected TARGET_TYPE ` $( TARGET_TYPE ) ' ) endif ifeq ($(TARGET_TYPE),so) CFLAGS += -fpic -shared LDFLAGS += -shared endif PHONY = all .mkdir clean all : . mkdir $( TARGET ) define cmd_o $$ (obj-$1) : $2%. o : %.$1 $( MAKEFILE_LIST ) $( GCC ) $( inc_dir ) -Wp,-MT, $$ @ -Wp,-MMD, $$ @.d $( CFLAGS ) -c -o $$ @ $$ < endef $( eval $( foreach i , $( SUFFIX ) , $( call cmd_o , $ i , $( prefix_objdir )))) ifeq ($(TARGET_TYPE),ar) $(TARGET) : AR := $( CROSS_COMPILE ) ar $(TARGET) : $( all_objs ) rm -f $@ $( AR ) rcvs $@ $( all_objs ) else $(TARGET) : LD = $( if $( strip $( src-cpp ) $( src-cc ) $( src-cxx )) , $( G ++ ) , $( GCC )) $(TARGET) : $( all_objs ) $( LD ) $( LDFLAGS ) $( all_objs ) $( LIB_DIR ) $( EXTRA_LIBS ) -o $@ endif .mkdir : @if [ ! -d $( OBJ_DIR ) ] ; then mkdir -p $( OBJ_DIR ) ; fi clean : rm -f $( prefix_objdir ) *.o $( TARGET ) rm -f $( prefix_objdir ) *.o.d -include $(patsubst %.o,%.o.d,$(all_objs)) .PHONY : $( PHONY )","title":"Introduction"},{"location":"Shell-and-tools/Tools/Build/Make/Makefile/Code/Code2/#gnulinuxmakefile","text":"\u53c2\u8003\uff1a http://www.voidcn.com/article/p-rkpadnqa-bkn.html http://www.voidcn.com/article/p-mpuyxady-kg.html http://bbs.chinaunix.net/thread-3553668-1-1.html https://gist.github.com/mauriciopoppe/de8908f67923091982c8c8136a063ea6 ############################################################################### # # A smart Makefile template for GNU/LINUX programming # # Author: PRC (ijkxyz AT msn DOT com) # Date: 2011/06/17 # # Usage: # $ make Compile and link (or archive) # $ make clean Clean the objectives and target. ############################################################################### CROSS_COMPILE = OPTIMIZE := -O2 #\u5176\u4ed6\u9009\u9879:\u8c03\u8bd5: -g WARNINGS := -Wall -Wno-unused -Wno-format #\u5176\u4ed6\u9009\u62e9: -Wno-deprecated -Wno-write-strings #macro define DEFS := -DOS_COMMON_EXT -DNDEBUG -D_FILE_OFFSET_BITS = 64 EXTRA_CFLAGS := -c -fvisibility = hidden -std = c++11 # \u8f93\u51fa\u8def\u5f84 OUT_DIR = ../lib/linux.x64 # \u591a\u4e2a\u8def\u5f84\uff0c\u4f7f\u7528 \u7a7a\u683c \u9694\u5f00 INC_DIR = . ../include ../../.. # \u591a\u4e2a\u8def\u5f84\uff0c\u4f7f\u7528 \u7a7a\u683c \u9694\u5f00 SRC_DIR = ./src1 . ./src2 ./src3 # \u9700\u8981\u94fe\u63a5\u7684\u52a8\u6001\u5e93\u7684\u8def\u5f84 LIB_DIR = -L../lib/linux.x64 -L../../../../lib/linux.x64 # \u5b58\u653eobject file\u7684\u8def\u5f84 OBJ_DIR = build EXTRA_SRC = EXCLUDE_FILES = # \u9700\u8981\u94fe\u63a5\u7684\u52a8\u6001\u5e93 EXTRA_LIBS := -llib1 -llib2 -Wl,--whole-archive -lssl -lcrypto -Wl,--no-whole-archive SUFFIX = c cpp cc cxx TARGET = $( OUT_DIR ) /libTest.so #TARGET_TYPE := ar #TARGET_TYPE := app TARGET_TYPE := so ##################################################################################### # Do not change any part of them unless you have understood this script very well # # This is a kind remind. # ##################################################################################### #FUNC# Add a new line to the input stream. define add_newline $1 endef #FUNC# set the variable `src-x' according to the input $1 define set_src_x src-$1 = $( filter-out $4 , $( foreach d, $2 , $( wildcard $d /*. $1 )) $( filter %. $1 , $3 )) endef #FUNC# set the variable `obj-x' according to the input $1 define set_obj_x obj-$1 = $( patsubst %. $1 , $3 %.o, $( notdir $2 )) endef #VAR# Get the uniform representation of the object directory path name ifneq ($(OBJ_DIR),) prefix_objdir = $( shell echo $( OBJ_DIR ) | sed 's:\\(\\./*\\)*::' ) prefix_objdir := $( filter-out /, $( prefix_objdir ) / ) endif GCC := $( CROSS_COMPILE ) gcc G++ : = $( CROSS_COMPILE ) g ++ SRC_DIR := $( sort . $( SRC_DIR )) inc_dir = $( foreach d, $( sort $( INC_DIR ) $( SRC_DIR )) ,-I $d ) #--# Do smart deduction automatically $( eval $( foreach i , $( SUFFIX ) , $( call set_src_x , $ i , $( SRC_DIR ) , $( EXTRA_SRC ) , $( EXCLUDE_FILES )))) $( eval $( foreach i , $( SUFFIX ) , $( call set_obj_x , $ i , $( src- $ i ) , $( prefix_objdir )))) $( eval $( foreach f , $( EXTRA_SRC ) , $( call add_newline , vpath $( notdir $ f ) $( dir $ f )))) $( eval $( foreach d , $( SRC_DIR ) , $( foreach i , $( SUFFIX ) , $( call add_newline , vpath % . $ i $ d )))) all_objs = $( foreach i, $( SUFFIX ) , $( obj- $i )) all_srcs = $( foreach i, $( SUFFIX ) , $( src- $i )) CFLAGS = $( EXTRA_CFLAGS ) $( WARNINGS ) $( OPTIMIZE ) $( DEFS ) TARGET_TYPE := $( strip $( TARGET_TYPE )) ifeq ($(filter $(TARGET_TYPE),so ar app),) $( error Unexpected TARGET_TYPE ` $( TARGET_TYPE ) ' ) endif ifeq ($(TARGET_TYPE),so) CFLAGS += -fpic -shared LDFLAGS += -shared endif PHONY = all .mkdir clean all : . mkdir $( TARGET ) define cmd_o $$ (obj-$1) : $2%. o : %.$1 $( MAKEFILE_LIST ) $( GCC ) $( inc_dir ) -Wp,-MT, $$ @ -Wp,-MMD, $$ @.d $( CFLAGS ) -c -o $$ @ $$ < endef $( eval $( foreach i , $( SUFFIX ) , $( call cmd_o , $ i , $( prefix_objdir )))) ifeq ($(TARGET_TYPE),ar) $(TARGET) : AR := $( CROSS_COMPILE ) ar $(TARGET) : $( all_objs ) rm -f $@ $( AR ) rcvs $@ $( all_objs ) else $(TARGET) : LD = $( if $( strip $( src-cpp ) $( src-cc ) $( src-cxx )) , $( G ++ ) , $( GCC )) $(TARGET) : $( all_objs ) $( LD ) $( LDFLAGS ) $( all_objs ) $( LIB_DIR ) $( EXTRA_LIBS ) -o $@ endif .mkdir : @if [ ! -d $( OBJ_DIR ) ] ; then mkdir -p $( OBJ_DIR ) ; fi clean : rm -f $( prefix_objdir ) *.o $( TARGET ) rm -f $( prefix_objdir ) *.o.d -include $(patsubst %.o,%.o.d,$(all_objs)) .PHONY : $( PHONY )","title":"GNU/Linux\u667a\u80fdMakefile\u6a21\u677f\uff08\u591a\u76ee\u5f55\uff0c\u591a\u6587\u4ef6\uff09"},{"location":"Shell-and-tools/Tools/Cron/","text":"cron \u7ef4\u57fa\u767e\u79d1 cron","title":"Introduction"},{"location":"Shell-and-tools/Tools/Cron/#cron","text":"","title":"cron"},{"location":"Shell-and-tools/Tools/Cron/#cron_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1cron"},{"location":"Shell-and-tools/Tools/Debug/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u662f\u6211\u5728\u9605\u8bfb\u672c\u4e66\u76844.2. Interrupts and Exceptions\u65f6\u6709\u611f\u800c\u5199\u7684\uff0c\u5176\u4e2d\u63d0\u53ca\u4e86\u4e00\u4e9b\u5b9e\u73b0 Debugger \u7684\u91cd\u8981\u5e95\u5c42\u6280\u672f\uff0c\u6240\u4ee5\u6211\u51b3\u5b9a\u5bf9Debugger\u7684\u5b9e\u73b0\u8fdb\u884c\u603b\u7ed3\u3002 TODO 3.2.1. Process State TASK_TRACED Say this five times fast: strace, ptrace, dtrace, dtruss \u7ef4\u57fa\u767e\u79d1 Category:Debugging","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/#_1","text":"\u672c\u7ae0\u662f\u6211\u5728\u9605\u8bfb\u672c\u4e66\u76844.2. Interrupts and Exceptions\u65f6\u6709\u611f\u800c\u5199\u7684\uff0c\u5176\u4e2d\u63d0\u53ca\u4e86\u4e00\u4e9b\u5b9e\u73b0 Debugger \u7684\u91cd\u8981\u5e95\u5c42\u6280\u672f\uff0c\u6240\u4ee5\u6211\u51b3\u5b9a\u5bf9Debugger\u7684\u5b9e\u73b0\u8fdb\u884c\u603b\u7ed3\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Tools/Debug/#todo","text":"3.2.1. Process State TASK_TRACED Say this five times fast: strace, ptrace, dtrace, dtruss \u7ef4\u57fa\u767e\u79d1 Category:Debugging","title":"TODO"},{"location":"Shell-and-tools/Tools/Debug/Debugger/","text":"Debugger","title":"Debugger"},{"location":"Shell-and-tools/Tools/Debug/Debugger/#debugger","text":"","title":"Debugger"},{"location":"Shell-and-tools/Tools/Debug/Trace/","text":"Trace trace\u662fdebug\u4e2d\u975e\u5e38\u5e38\u89c1\u7684\u4e00\u79cd\u5f62\u5f0f\u3002 What is trace? \"trace\"\u5373\u201c\u8ddf\u8e2a\u201d\u3002 wikipedia Tracing (software) wikipedia Trace Examples Stack trace wikipedia Stack trace Stack-trace: Shell-and-tools\\Tools\\Debug\\Stack-trace System call trace System-call-trace: Shell-and-tools\\Tools\\Debug\\System-call-trace Library call tracer Library-call-tracer: Shell-and-tools\\Tools\\Debug\\Library-call-tracer Trace point gdb Tracepoints linux tracepoint: Using the Linux Kernel Tracepoints tracepoint(3) \u2014 Linux manual page lwn Fun with tracepoints Signal trace wikipedia Signal trace Kernel tracing framework framework OS kernel ktrace - BSD Unix - Mac OS X ftrace - Linux kernel DTrace - Solaris wikipedia LTTng","title":"Trace"},{"location":"Shell-and-tools/Tools/Debug/Trace/#trace","text":"trace\u662fdebug\u4e2d\u975e\u5e38\u5e38\u89c1\u7684\u4e00\u79cd\u5f62\u5f0f\u3002","title":"Trace"},{"location":"Shell-and-tools/Tools/Debug/Trace/#what#is#trace","text":"\"trace\"\u5373\u201c\u8ddf\u8e2a\u201d\u3002","title":"What is trace?"},{"location":"Shell-and-tools/Tools/Debug/Trace/#wikipedia#tracing#software","text":"","title":"wikipedia Tracing (software)"},{"location":"Shell-and-tools/Tools/Debug/Trace/#wikipedia#trace","text":"","title":"wikipedia Trace"},{"location":"Shell-and-tools/Tools/Debug/Trace/#examples","text":"","title":"Examples"},{"location":"Shell-and-tools/Tools/Debug/Trace/#stack#trace","text":"wikipedia Stack trace Stack-trace: Shell-and-tools\\Tools\\Debug\\Stack-trace","title":"Stack trace"},{"location":"Shell-and-tools/Tools/Debug/Trace/#system#call#trace","text":"System-call-trace: Shell-and-tools\\Tools\\Debug\\System-call-trace","title":"System call trace"},{"location":"Shell-and-tools/Tools/Debug/Trace/#library#call#tracer","text":"Library-call-tracer: Shell-and-tools\\Tools\\Debug\\Library-call-tracer","title":"Library call tracer"},{"location":"Shell-and-tools/Tools/Debug/Trace/#trace#point","text":"gdb Tracepoints linux tracepoint: Using the Linux Kernel Tracepoints tracepoint(3) \u2014 Linux manual page lwn Fun with tracepoints","title":"Trace point"},{"location":"Shell-and-tools/Tools/Debug/Trace/#signal#trace","text":"wikipedia Signal trace","title":"Signal trace"},{"location":"Shell-and-tools/Tools/Debug/Trace/#kernel#tracing#framework","text":"framework OS kernel ktrace - BSD Unix - Mac OS X ftrace - Linux kernel DTrace - Solaris wikipedia LTTng","title":"Kernel tracing framework"},{"location":"Shell-and-tools/Tools/Debug/Trap/","text":"Trap \u672c\u4e66\u76844.2. Interrupts and Exceptions\u8282\u5bf9Trap\u7684\u5b9a\u4e49\u548c\u7ef4\u57fa\u767e\u79d1 Trap (computing) \u4e2d\u7684\u63cf\u8ff0\u6709\u5dee\u5f02\uff0c\u7ecf\u8fc7\u5bf9\u6bd4\uff0c\u672c\u4e66\u7684\u63cf\u8ff0\u662f\u66f4\u52a0\u51c6\u786e\u7684\u3002","title":"Trap"},{"location":"Shell-and-tools/Tools/Debug/Trap/#trap","text":"\u672c\u4e66\u76844.2. Interrupts and Exceptions\u8282\u5bf9Trap\u7684\u5b9a\u4e49\u548c\u7ef4\u57fa\u767e\u79d1 Trap (computing) \u4e2d\u7684\u63cf\u8ff0\u6709\u5dee\u5f02\uff0c\u7ecf\u8fc7\u5bf9\u6bd4\uff0c\u672c\u4e66\u7684\u63cf\u8ff0\u662f\u66f4\u52a0\u51c6\u786e\u7684\u3002","title":"Trap"},{"location":"Shell-and-tools/Tools/Debug/Application/Dead-lock/","text":"","title":"Dead-lock"},{"location":"Shell-and-tools/Tools/Debug/Application/Stuck-process/","text":"Check if a process is stuck in linux docstore 21.7. Hanging Processes: Detection and Diagnostics Sometimes an httpd process might hang\uff08\u88ab\u6302\u8d77\uff09 in the middle of processing a request. This may happen because of a bug in the code, such as being stuck in a while loop. Or it may be blocked in a system call, perhaps waiting indefinitely\uff08\u65e0\u671f\u9650\u7684\uff09 for an unavailable resource. To fix the problem, we need to learn in what circumstances the process hangs, so that we can reproduce the problem, which will allow us to uncover its cause. 21.7.1. Hanging Because of an Operating System Problem Sometimes you can find a process hanging because of some kind of system problem. For example, if the processes was doing some disk I/O operation, it might get stuck in uninterruptible sleep (' D ' disk wait in ps report, ' U ' in top ), which indicates either that something is broken in your kernel or that you're using NFS. Also, usually you find that you cannot kill -9 this process. NOTE: \u53c2\u89c1: NFS: Network File System ps : Programming\\Process\\Tools\\ps Another process that cannot be killed with kill -9 is a zombie process (' Z ' disk wait in ps report, <defunc> in top ), in which case the process is already dead and Apache didn't wait on it properly (of course, it can be some other process not related to Apache). In the case of disk wait , you can actually get the wait channel from ps and look it up in your kernel symbol table to find out what resource it was waiting on. This might point the way to what component of the system is misbehaving, if the problem occurs frequently. docstore.mik.ua/orelly/weblinux2/modperl/ch21_07.htm NOTE: \u5173\u4e8e wait channel \uff0c\u53c2\u89c1 Programming\\Process\\Tools\\ps\\Wait-channel.md \u5173\u4e8ekernel symbol table\uff0c\u5b83\u5176\u5b9e\u5c31\u662fSystem.map\uff0c\u53c2\u89c1 Kernel\\Guide\\Debug\\System.map","title":"Stuck-process"},{"location":"Shell-and-tools/Tools/Debug/Application/Stuck-process/#check#if#a#process#is#stuck#in#linux","text":"","title":"Check if a process is stuck in linux"},{"location":"Shell-and-tools/Tools/Debug/Application/Stuck-process/#docstore#217#hanging#processes#detection#and#diagnostics","text":"Sometimes an httpd process might hang\uff08\u88ab\u6302\u8d77\uff09 in the middle of processing a request. This may happen because of a bug in the code, such as being stuck in a while loop. Or it may be blocked in a system call, perhaps waiting indefinitely\uff08\u65e0\u671f\u9650\u7684\uff09 for an unavailable resource. To fix the problem, we need to learn in what circumstances the process hangs, so that we can reproduce the problem, which will allow us to uncover its cause.","title":"docstore 21.7. Hanging Processes: Detection and Diagnostics"},{"location":"Shell-and-tools/Tools/Debug/Application/Stuck-process/#2171#hanging#because#of#an#operating#system#problem","text":"Sometimes you can find a process hanging because of some kind of system problem. For example, if the processes was doing some disk I/O operation, it might get stuck in uninterruptible sleep (' D ' disk wait in ps report, ' U ' in top ), which indicates either that something is broken in your kernel or that you're using NFS. Also, usually you find that you cannot kill -9 this process. NOTE: \u53c2\u89c1: NFS: Network File System ps : Programming\\Process\\Tools\\ps Another process that cannot be killed with kill -9 is a zombie process (' Z ' disk wait in ps report, <defunc> in top ), in which case the process is already dead and Apache didn't wait on it properly (of course, it can be some other process not related to Apache). In the case of disk wait , you can actually get the wait channel from ps and look it up in your kernel symbol table to find out what resource it was waiting on. This might point the way to what component of the system is misbehaving, if the problem occurs frequently. docstore.mik.ua/orelly/weblinux2/modperl/ch21_07.htm NOTE: \u5173\u4e8e wait channel \uff0c\u53c2\u89c1 Programming\\Process\\Tools\\ps\\Wait-channel.md \u5173\u4e8ekernel symbol table\uff0c\u5b83\u5176\u5b9e\u5c31\u662fSystem.map\uff0c\u53c2\u89c1 Kernel\\Guide\\Debug\\System.map","title":"21.7.1. Hanging Because of an Operating System Problem"},{"location":"Shell-and-tools/Tools/Debug/GDB/","text":"\u5173\u4e8e\u672c\u7ae0 Official site: GDB: The GNU Project Debugger wikipedia GNU Debugger GDB Documentation","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/#_1","text":"","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Tools/Debug/GDB/#official#site#gdb#the#gnu#project#debugger","text":"","title":"Official site: GDB: The GNU Project Debugger"},{"location":"Shell-and-tools/Tools/Debug/GDB/#wikipedia#gnu#debugger","text":"","title":"wikipedia GNU Debugger"},{"location":"Shell-and-tools/Tools/Debug/GDB/#gdb#documentation","text":"","title":"GDB Documentation"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.11-Convenience-Variables/","text":"10.11 Convenience Variables $_exitsignal #include <signal.h> int main ( int argc , char * argv []) { raise ( SIGALRM ); return 0 ; } // gcc -g test.c $_exception $_inferior $_thread $_gthread","title":"10.11-Convenience-Variables"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.11-Convenience-Variables/#1011#convenience#variables","text":"","title":"10.11 Convenience Variables"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.11-Convenience-Variables/#_exitsignal","text":"#include <signal.h> int main ( int argc , char * argv []) { raise ( SIGALRM ); return 0 ; } // gcc -g test.c","title":"$_exitsignal"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.11-Convenience-Variables/#_exception","text":"","title":"$_exception"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.11-Convenience-Variables/#_inferior","text":"","title":"$_inferior"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.11-Convenience-Variables/#_thread","text":"","title":"$_thread"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.11-Convenience-Variables/#_gthread","text":"","title":"$_gthread"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.13-Registers/","text":"10.13 Registers info registers info all-registers GDB has four \u201cstandard\u201d register names that are available (in expressions) on most machines\u2014whenever they do not conflict with an architecture\u2019s canonical mnemonics(\u52a9\u8bb0\u7b26) for registers. Register name Register Reference $pc program counter register wikipedia Program counter $sp stack pointer wikipedia Stack register $fp register that contains a pointer to the current stack frame $ps register that contains the processor status NOTE:register\u7684\u7406\u8bba\u77e5\u8bc6\uff0c\u91cd\u8981\u5728\u5de5\u7a0bHardware\u4e2d\u8fdb\u884c\u7684\u8ba8\u8bba\u3002 For example, you could print the program counter in hex with p/x $pc or print the instruction to be executed next with x/i $pc or add four to the stack pointer 12 with set $sp + = 4","title":"10.13-Registers"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.13-Registers/#1013#registers","text":"","title":"10.13 Registers"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.13-Registers/#info#registers","text":"","title":"info registers"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.13-Registers/#info#all-registers","text":"GDB has four \u201cstandard\u201d register names that are available (in expressions) on most machines\u2014whenever they do not conflict with an architecture\u2019s canonical mnemonics(\u52a9\u8bb0\u7b26) for registers. Register name Register Reference $pc program counter register wikipedia Program counter $sp stack pointer wikipedia Stack register $fp register that contains a pointer to the current stack frame $ps register that contains the processor status NOTE:register\u7684\u7406\u8bba\u77e5\u8bc6\uff0c\u91cd\u8981\u5728\u5de5\u7a0bHardware\u4e2d\u8fdb\u884c\u7684\u8ba8\u8bba\u3002 For example, you could print the program counter in hex with p/x $pc or print the instruction to be executed next with x/i $pc or add four to the stack pointer 12 with set $sp + = 4","title":"info all-registers"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.19-Produce-a-Core-File-from-Your-Program/","text":"10.19 How to Produce a Core File from Your Program gcore(1) \u2014 Linux manual page Example: How to use pstack and gcore to gather additional data for Support","title":"10.19-Produce-a-Core-File-from-Your-Program"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.19-Produce-a-Core-File-from-Your-Program/#1019#how#to#produce#a#core#file#from#your#program","text":"","title":"10.19 How to Produce a Core File from Your Program"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/10-Examining-Data/10.19-Produce-a-Core-File-from-Your-Program/#gcore1#linux#manual#page","text":"Example: How to use pstack and gcore to gather additional data for Support","title":"gcore(1) \u2014 Linux manual page"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/11-Debugging-Optimized-Code/11-Debugging-Optimized-Code/","text":"Debugging Optimized Code \u5728\u4f7f\u7528gdb\u8c03\u8bd5\u4e00\u4e2aC++ member function\u7684\u65f6\u5019\uff0c\u6309\u7167 GDB\\Guide\\Cpp.md#Breakpoint for member functions \u4e2d\u63cf\u8ff0\u7684\u65b9\u6cd5\uff0c\u7adf\u7136\u65e0\u6cd5\u627e\u5230\u5bf9\u5e94\u7684member function\u3002\u8fd9\u8ba9\u6211\u611f\u5230\u5947\u602a\uff0c\u4e8e\u662fGoogle: why an existing member function can not be break in gdb\uff0c\u6587\u7ae0stackoverflow Set breakpoint for class member function not successful \u63cf\u8ff0\u7684\u60c5\u51b5\u4e0e\u6211\u4eec\u7684\u60c5\u51b5\u76f8\u540c\uff0c\u539f\u6765\u662fcompiler optimization\u7684\u7f18\u6545\uff0ccompiler inline\u4e86\u8fd9\u4e2a\u51fd\u6570\uff0c\u6240\u4ee5\u65e0\u6cd5\u627e\u5230\u5bf9\u5e94\u7684definition\uff0c\u540e\u6765\u6211\u6838\u5b9e\u4e86\u6211\u7684Makefile\uff1a EXTRA_CFLAGS := -g -pthread -c -fPIC -O2 \u786e\u5b9e\u5f00\u542f\u4e86 O2 \u4f18\u5316\uff0c\u540e\u6765\u6211\u5c06optimization\u5173\u95ed\uff0c\u518d\u6b21\u8fdb\u884c\u8c03\u8bd5\uff0c\u53ef\u4ee5\u80fd\u591f\u627e\u5230\u5bf9\u5e94\u7684function\u3002 gdb onlinedocs 11 Debugging Optimized Code 11.1 Inline Functions info frame TO READ: stackoverflow Set breakpoint for class member function not successful","title":"11-Debugging-Optimized-Code"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/11-Debugging-Optimized-Code/11-Debugging-Optimized-Code/#debugging#optimized#code","text":"\u5728\u4f7f\u7528gdb\u8c03\u8bd5\u4e00\u4e2aC++ member function\u7684\u65f6\u5019\uff0c\u6309\u7167 GDB\\Guide\\Cpp.md#Breakpoint for member functions \u4e2d\u63cf\u8ff0\u7684\u65b9\u6cd5\uff0c\u7adf\u7136\u65e0\u6cd5\u627e\u5230\u5bf9\u5e94\u7684member function\u3002\u8fd9\u8ba9\u6211\u611f\u5230\u5947\u602a\uff0c\u4e8e\u662fGoogle: why an existing member function can not be break in gdb\uff0c\u6587\u7ae0stackoverflow Set breakpoint for class member function not successful \u63cf\u8ff0\u7684\u60c5\u51b5\u4e0e\u6211\u4eec\u7684\u60c5\u51b5\u76f8\u540c\uff0c\u539f\u6765\u662fcompiler optimization\u7684\u7f18\u6545\uff0ccompiler inline\u4e86\u8fd9\u4e2a\u51fd\u6570\uff0c\u6240\u4ee5\u65e0\u6cd5\u627e\u5230\u5bf9\u5e94\u7684definition\uff0c\u540e\u6765\u6211\u6838\u5b9e\u4e86\u6211\u7684Makefile\uff1a EXTRA_CFLAGS := -g -pthread -c -fPIC -O2 \u786e\u5b9e\u5f00\u542f\u4e86 O2 \u4f18\u5316\uff0c\u540e\u6765\u6211\u5c06optimization\u5173\u95ed\uff0c\u518d\u6b21\u8fdb\u884c\u8c03\u8bd5\uff0c\u53ef\u4ee5\u80fd\u591f\u627e\u5230\u5bf9\u5e94\u7684function\u3002","title":"Debugging Optimized Code"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/11-Debugging-Optimized-Code/11-Debugging-Optimized-Code/#gdb#onlinedocs11#debugging#optimized#code","text":"","title":"gdb onlinedocs11 Debugging Optimized Code"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/11-Debugging-Optimized-Code/11-Debugging-Optimized-Code/#111#inline#functions","text":"info frame TO READ: stackoverflow Set breakpoint for class member function not successful","title":"11.1 Inline Functions"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/13-Tracepoints/Tracepoints/","text":"Tracepoints gdb onlinedocs 13 Tracepoints In some applications, it is not feasible for the debugger to interrupt the program\u2019s execution long enough for the developer to learn anything helpful about its behavior. If the program\u2019s correctness depends on its real-time behavior, delays introduced by a debugger might cause the program to change its behavior drastically, or perhaps fail, even when the code itself is correct. It is useful to be able to observe the program\u2019s behavior without interrupting it. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5df2\u7ecf\u8bf4\u660e\u4e86tracepointer\u548cbreakpoints\uff08breakpoint\u3001watchpoint\u3001catchpoint\uff09\u4e4b\u95f4\u7684\u5dee\u5f02\u6240\u5728 TO READ suchakra.wordpress Fast Tracing with GDB","title":"Tracepoints"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/13-Tracepoints/Tracepoints/#tracepoints","text":"","title":"Tracepoints"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/13-Tracepoints/Tracepoints/#gdb#onlinedocs#13#tracepoints","text":"In some applications, it is not feasible for the debugger to interrupt the program\u2019s execution long enough for the developer to learn anything helpful about its behavior. If the program\u2019s correctness depends on its real-time behavior, delays introduced by a debugger might cause the program to change its behavior drastically, or perhaps fail, even when the code itself is correct. It is useful to be able to observe the program\u2019s behavior without interrupting it. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u5df2\u7ecf\u8bf4\u660e\u4e86tracepointer\u548cbreakpoints\uff08breakpoint\u3001watchpoint\u3001catchpoint\uff09\u4e4b\u95f4\u7684\u5dee\u5f02\u6240\u5728 TO READ suchakra.wordpress Fast Tracing with GDB","title":"gdb onlinedocs 13 Tracepoints"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/","text":"15 Using GDB with Different Languages Language-specific information is built into GDB for some languages, allowing you to express operations like the above in your program\u2019s native language, and allowing GDB to output values in a manner consistent with the syntax of your program\u2019s native language. NOTE: gdb\u7684\u8fd9\u4e2a\u7279\u6027\u662f\u975e\u5e38\u6709\u4ef7\u503c\u7684\uff0c\u5b83\u8ba9\u6211\u4eec\u80fd\u591f\u5b9e\u73b0\u7c7b\u4f3c\u4e8epython\u7684interactively-programming\u7684\u6548\u679c\uff0c\u5373\u5728gdb\u4e2d\u8f93\u5165expression\uff0c\u7136\u540egdb\u80fd\u591fevaluate\u3001output\u3002","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/#15#using#gdb#with#different#languages","text":"Language-specific information is built into GDB for some languages, allowing you to express operations like the above in your program\u2019s native language, and allowing GDB to output values in a manner consistent with the syntax of your program\u2019s native language. NOTE: gdb\u7684\u8fd9\u4e2a\u7279\u6027\u662f\u975e\u5e38\u6709\u4ef7\u503c\u7684\uff0c\u5b83\u8ba9\u6211\u4eec\u80fd\u591f\u5b9e\u73b0\u7c7b\u4f3c\u4e8epython\u7684interactively-programming\u7684\u6548\u679c\uff0c\u5373\u5728gdb\u4e2d\u8f93\u5165expression\uff0c\u7136\u540egdb\u80fd\u591fevaluate\u3001output\u3002","title":"15 Using GDB with Different Languages"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/15.4-Supported-Languages/C-family-language/","text":"C family language Breakpoint for member functions stackoverflow breakpoint for member functions class BST { BST () ... private : int add (( BST * root , BST * src ); } A As Dark Falcon said, break BST::add should work if you don't have overloads. You can also type: ( gdb ) break ' BST :: add ( < TAB > (note the single quote). This should prompt GDB to perform tab-completion, and finish the line like so: ( gdb ) break ' BST :: add ( BST * , BST * ) and which point you can add the terminating ' ' and hit Enter to add the breakpoint. I can get a break point for the void display function Function return type is not part of its signature and has nothing to do with what's happening. Show all members of a class \u5982\u4f55\u5728gdb\u4e2d\uff0c\u5c55\u793a\u4e00\u4e2aclass\u7684\u6240\u6709\u7684member\uff1f\u53ef\u4ee5\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4\uff1a ptype \u53c2\u89c1 stackoverflow How to list class methods in gdb? # A GDB\\Debugging-with-gdb\\16-Examining-the-Symbol-Table struct \u4f7f\u7528\u5982\u4e0b\u547d\u4ee4: ptype /o How do I show what fields a struct has in GDB? GDB\\Debugging-with-gdb\\16-Examining-the-Symbol-Table sizeof gdb\u662f\u80fd\u591f\u7406\u89e3 sizeof \u7684\uff0c\u6240\u4ee5\u901a\u8fc7\u6b64\u53ef\u4ee5\u83b7\u77e5\u4e00\u4e2astruct\u7684size\uff0c\u4e0b\u9762\u662f\u4f8b\u5b50: ( gdb ) p sizeof ( CHSInsRspInfoField ) $1 = 264 ( gdb )","title":"C-family-language"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/15.4-Supported-Languages/C-family-language/#c#family#language","text":"","title":"C family language"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/15.4-Supported-Languages/C-family-language/#breakpoint#for#member#functions","text":"","title":"Breakpoint for member functions"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/15.4-Supported-Languages/C-family-language/#stackoverflow#breakpoint#for#member#functions","text":"class BST { BST () ... private : int add (( BST * root , BST * src ); } A As Dark Falcon said, break BST::add should work if you don't have overloads. You can also type: ( gdb ) break ' BST :: add ( < TAB > (note the single quote). This should prompt GDB to perform tab-completion, and finish the line like so: ( gdb ) break ' BST :: add ( BST * , BST * ) and which point you can add the terminating ' ' and hit Enter to add the breakpoint. I can get a break point for the void display function Function return type is not part of its signature and has nothing to do with what's happening.","title":"stackoverflow breakpoint for member functions"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/15.4-Supported-Languages/C-family-language/#show#all#members#of#a#class","text":"\u5982\u4f55\u5728gdb\u4e2d\uff0c\u5c55\u793a\u4e00\u4e2aclass\u7684\u6240\u6709\u7684member\uff1f\u53ef\u4ee5\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4\uff1a","title":"Show all members of a class"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/15.4-Supported-Languages/C-family-language/#ptype","text":"\u53c2\u89c1 stackoverflow How to list class methods in gdb? # A GDB\\Debugging-with-gdb\\16-Examining-the-Symbol-Table","title":"ptype"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/15.4-Supported-Languages/C-family-language/#struct","text":"\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4:","title":"struct"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/15.4-Supported-Languages/C-family-language/#ptype#o","text":"How do I show what fields a struct has in GDB? GDB\\Debugging-with-gdb\\16-Examining-the-Symbol-Table","title":"ptype /o"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/15-Using-GDB-with-Different-Languages/15.4-Supported-Languages/C-family-language/#sizeof","text":"gdb\u662f\u80fd\u591f\u7406\u89e3 sizeof \u7684\uff0c\u6240\u4ee5\u901a\u8fc7\u6b64\u53ef\u4ee5\u83b7\u77e5\u4e00\u4e2astruct\u7684size\uff0c\u4e0b\u9762\u662f\u4f8b\u5b50: ( gdb ) p sizeof ( CHSInsRspInfoField ) $1 = 264 ( gdb )","title":"sizeof"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/16-Examining-the-Symbol-Table/Symbol-table/","text":"Symbol table \u5728\u5de5\u7a0bcompiler-principle\u7684 Chapter-2-A-Simple-Syntax-Directed-Translator\\2.7-Symbol-Tables \u4e2d\u4ecb\u7ecd\u4e86symbol table\uff0c\u5176\u4e2d\u63d0\u53ca\u4e86\uff1a debug\u9636\u6bb5\uff1a\u5728debug\u7684\u65f6\u5019\uff0c\u53ea\u6709\u8bfb\u53d6\u4e86symbol table\u4e86\uff0c\u624d\u80fd\u591f\u7075\u6d3b\u5730\u8bbe\u7f6e\u3002 \u4e00\u4e2a\u5178\u578b\u7684\u4f8b\u5b50\u662f\uff1a \u5728debug dynamic library\u7684\u65f6\u5019\uff0c\u5982\u679c\u5bf9\u5e94\u7684dynamic library\u6ca1\u6709load\uff0c\u5219\u65e0\u6cd5dynamic library\u7684\u5b9e\u73b0\u4e2d\u7684symbol\u8fdb\u884cbreak\u3002 symbol table\u7684\u91cd\u8981\u4ef7\u503c \u5728\u5de5\u7a0bcompiler-principle\u7684 Chapter-2-A-Simple-Syntax-Directed-Translator\\2.7-Symbol-Tables \u4e2d\u5df2\u7ecf\u4ecb\u7ecd\u4e86symbol table\u7684\u91cd\u8981\u4ef7\u503c\uff0c\u73b0\u5728\u7ed3\u5408 gdb \u518d\u6b21\u6765\u8fdb\u884c\u8bf4\u660e\uff1a gdb\u4e2d\u5173\u4e8esource code\u7684\u547d\u4ee4\uff0c\u57fa\u672c\u4e0a\u662f\u57fa\u4e8esymbol table\u5b9e\u73b0\u7684\uff0c\u6bd4\u5982 info function gdb onlinedocs 16 Examining the Symbol Table whatis[/flags] [arg] ptype[/flags] [arg] application\uff1a Show all members of a class\uff08\u53c2\u89c1 Debug\\GDB\\Guide \uff09 struct \uff08\u53c2\u89c1 Debug\\GDB\\Guide \uff09 add-symbol-file command \u8fd9\u4e2a\u547d\u4ee4\u6709\u65f6\u662f\u975e\u5e38\u6709\u7528\u7684\u3002 gdb onlinedocs 18.1 Commands to Specify Files thegeekstuff Load Shared library Symbols Many a times, programmers will use shared libraries in their code. Sometimes, we might want to look into the shared library itself to understand what\u2019s going on. Here I\u2019ll show an example using GLib Library and how to obtains the debugging information for it. By default, all distributions will strip the libraries to some extent. The complete debugging information will be stored in a separate package which they name like \u201cpackage-1.0-dbg\u201d, and only if needed user can install. When you install the \u201cpackage-1.0-dbg\u201d, by default gdb will load all the debugging information, but to understand the concept here we will see how to manually load the symbol file. #include <stdio.h> #include <glib.h> struct a { int a ; int b ; }; void * print ( struct a * obj , int as ) { printf ( \"%d:%d \\n \" , obj -> a , obj -> b ); } int main () { struct a * obj ; obj = ( struct a * ) malloc ( sizeof ( struct a )); obj -> a = 3 ; obj -> b = 4 ; GList * list = NULL ; list = g_list_append ( list , obj ); g_list_foreach ( list ,( GFunc ) print , NULL ); } $ cc -g -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include/ -lglib-2.0 glib_test.c Note: You need to install the libglib2.0-0 to try out this example. Now we will start the debugging. ( gdb ) b 1 Breakpoint 1 at 0x4007db: file a.c, line 1 . ( gdb ) run ... ( gdb ) info sharedlibrary From To Syms Read Shared Object Library 0x00007ffff7dddaf0 0x00007ffff7df5c83 Yes ( * ) /lib64/ld-linux-x86-64.so.2 0x00007ffff7b016c0 0x00007ffff7b6e5cc Yes ( * ) /lib/x86_64-linux-gnu/libglib-2.0.so.0 0x00007ffff7779b80 0x00007ffff7890bcc Yes ( * ) /lib/x86_64-linux-gnu/libc.so.6 0x00007ffff751f9a0 0x00007ffff7546158 Yes ( * ) /lib/x86_64-linux-gnu/libpcre.so.3 0x00007ffff7307690 0x00007ffff7312c78 Yes ( * ) /lib/x86_64-linux-gnu/libpthread.so.0 0x00007ffff70fc190 0x00007ffff70ff4f8 Yes ( * ) /lib/x86_64-linux-gnu/librt.so.1 ( * ) : Shared library is missing debugging information. From the above information, note that the library libglib-2.0.so.0 is having symbols, but the debuuging information like file_name , line_no etc\u2026 are missing. Download the debug information for the package from respective distribution (libglib2.0-0-dbg in Debian \u2013 Wheezy). (gdb) add-symbol-file /home/lakshmanan/libglib-2.0.so.0.3200.4 0x00007ffff7b016c0 add symbol table from file \"/home/lakshmanan/libglib-2.0.so.0.3200.4\" at .text_addr = 0x7ffff7b016c0 (y or n) y Reading symbols from /home/lakshmanan/libglib-2.0.so.0.3200.4...done. The address given in the add-symbol-file command is, the \u201cFrom\u201d address printed by \u201c info sharedlibrary \u201d command. Now the debugging information is loaded. ... ... (gdb) n g_list_foreach (list=0x0, func=0x4007cc , user_data=0x0) at /tmp/buildd/glib2.0-2.33.12+really2.32.4/./glib/glist.c:897 Sometimes the shared libraries won\u2019t even have any symbols in it, and in those situations, the above method will be helpful.","title":"Symbol-table"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/16-Examining-the-Symbol-Table/Symbol-table/#symbol#table","text":"\u5728\u5de5\u7a0bcompiler-principle\u7684 Chapter-2-A-Simple-Syntax-Directed-Translator\\2.7-Symbol-Tables \u4e2d\u4ecb\u7ecd\u4e86symbol table\uff0c\u5176\u4e2d\u63d0\u53ca\u4e86\uff1a debug\u9636\u6bb5\uff1a\u5728debug\u7684\u65f6\u5019\uff0c\u53ea\u6709\u8bfb\u53d6\u4e86symbol table\u4e86\uff0c\u624d\u80fd\u591f\u7075\u6d3b\u5730\u8bbe\u7f6e\u3002 \u4e00\u4e2a\u5178\u578b\u7684\u4f8b\u5b50\u662f\uff1a \u5728debug dynamic library\u7684\u65f6\u5019\uff0c\u5982\u679c\u5bf9\u5e94\u7684dynamic library\u6ca1\u6709load\uff0c\u5219\u65e0\u6cd5dynamic library\u7684\u5b9e\u73b0\u4e2d\u7684symbol\u8fdb\u884cbreak\u3002","title":"Symbol table"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/16-Examining-the-Symbol-Table/Symbol-table/#symbol#table_1","text":"\u5728\u5de5\u7a0bcompiler-principle\u7684 Chapter-2-A-Simple-Syntax-Directed-Translator\\2.7-Symbol-Tables \u4e2d\u5df2\u7ecf\u4ecb\u7ecd\u4e86symbol table\u7684\u91cd\u8981\u4ef7\u503c\uff0c\u73b0\u5728\u7ed3\u5408 gdb \u518d\u6b21\u6765\u8fdb\u884c\u8bf4\u660e\uff1a gdb\u4e2d\u5173\u4e8esource code\u7684\u547d\u4ee4\uff0c\u57fa\u672c\u4e0a\u662f\u57fa\u4e8esymbol table\u5b9e\u73b0\u7684\uff0c\u6bd4\u5982 info function","title":"symbol table\u7684\u91cd\u8981\u4ef7\u503c"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/16-Examining-the-Symbol-Table/Symbol-table/#gdb#onlinedocs#16#examining#the#symbol#table","text":"","title":"gdb onlinedocs 16 Examining the Symbol Table"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/16-Examining-the-Symbol-Table/Symbol-table/#whatisflags#arg","text":"","title":"whatis[/flags] [arg]"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/16-Examining-the-Symbol-Table/Symbol-table/#ptypeflags#arg","text":"application\uff1a Show all members of a class\uff08\u53c2\u89c1 Debug\\GDB\\Guide \uff09 struct \uff08\u53c2\u89c1 Debug\\GDB\\Guide \uff09","title":"ptype[/flags] [arg]"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/16-Examining-the-Symbol-Table/Symbol-table/#add-symbol-file#command","text":"\u8fd9\u4e2a\u547d\u4ee4\u6709\u65f6\u662f\u975e\u5e38\u6709\u7528\u7684\u3002","title":"add-symbol-file command"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/16-Examining-the-Symbol-Table/Symbol-table/#gdb#onlinedocs#181#commands#to#specify#files","text":"","title":"gdb onlinedocs 18.1 Commands to Specify Files"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/16-Examining-the-Symbol-Table/Symbol-table/#thegeekstuff#load#shared#library#symbols","text":"Many a times, programmers will use shared libraries in their code. Sometimes, we might want to look into the shared library itself to understand what\u2019s going on. Here I\u2019ll show an example using GLib Library and how to obtains the debugging information for it. By default, all distributions will strip the libraries to some extent. The complete debugging information will be stored in a separate package which they name like \u201cpackage-1.0-dbg\u201d, and only if needed user can install. When you install the \u201cpackage-1.0-dbg\u201d, by default gdb will load all the debugging information, but to understand the concept here we will see how to manually load the symbol file. #include <stdio.h> #include <glib.h> struct a { int a ; int b ; }; void * print ( struct a * obj , int as ) { printf ( \"%d:%d \\n \" , obj -> a , obj -> b ); } int main () { struct a * obj ; obj = ( struct a * ) malloc ( sizeof ( struct a )); obj -> a = 3 ; obj -> b = 4 ; GList * list = NULL ; list = g_list_append ( list , obj ); g_list_foreach ( list ,( GFunc ) print , NULL ); } $ cc -g -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include/ -lglib-2.0 glib_test.c Note: You need to install the libglib2.0-0 to try out this example. Now we will start the debugging. ( gdb ) b 1 Breakpoint 1 at 0x4007db: file a.c, line 1 . ( gdb ) run ... ( gdb ) info sharedlibrary From To Syms Read Shared Object Library 0x00007ffff7dddaf0 0x00007ffff7df5c83 Yes ( * ) /lib64/ld-linux-x86-64.so.2 0x00007ffff7b016c0 0x00007ffff7b6e5cc Yes ( * ) /lib/x86_64-linux-gnu/libglib-2.0.so.0 0x00007ffff7779b80 0x00007ffff7890bcc Yes ( * ) /lib/x86_64-linux-gnu/libc.so.6 0x00007ffff751f9a0 0x00007ffff7546158 Yes ( * ) /lib/x86_64-linux-gnu/libpcre.so.3 0x00007ffff7307690 0x00007ffff7312c78 Yes ( * ) /lib/x86_64-linux-gnu/libpthread.so.0 0x00007ffff70fc190 0x00007ffff70ff4f8 Yes ( * ) /lib/x86_64-linux-gnu/librt.so.1 ( * ) : Shared library is missing debugging information. From the above information, note that the library libglib-2.0.so.0 is having symbols, but the debuuging information like file_name , line_no etc\u2026 are missing. Download the debug information for the package from respective distribution (libglib2.0-0-dbg in Debian \u2013 Wheezy). (gdb) add-symbol-file /home/lakshmanan/libglib-2.0.so.0.3200.4 0x00007ffff7b016c0 add symbol table from file \"/home/lakshmanan/libglib-2.0.so.0.3200.4\" at .text_addr = 0x7ffff7b016c0 (y or n) y Reading symbols from /home/lakshmanan/libglib-2.0.so.0.3200.4...done. The address given in the add-symbol-file command is, the \u201cFrom\u201d address printed by \u201c info sharedlibrary \u201d command. Now the debugging information is loaded. ... ... (gdb) n g_list_foreach (list=0x0, func=0x4007cc , user_data=0x0) at /tmp/buildd/glib2.0-2.33.12+really2.32.4/./glib/glist.c:897 Sometimes the shared libraries won\u2019t even have any symbols in it, and in those situations, the above method will be helpful.","title":"thegeekstuff Load Shared library Symbols"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/18-gdb-Files/18-gdb-Files/","text":"18 gdb Files 18.1 Commands to Specify Files exec-file [ filename ] symbol-file [ filename ] add-symbol-file filename address The add-symbol-file command reads additional symbol table information from the file filename . You would use this command when filename has been dynamically loaded (by some other means) into the program that is running. NOTE: \u662f\u5728\u9605\u8bfb Load Shared library Symbols \u65f6\uff0c\u53d1\u73b0\u7684\u8fd9\u4e2acommand\uff0c\u5b83\u8ba9\u6211\u60f3\u8d77\u6765\u4e86\u6709\u65f6\u5019 glibc \u629b\u51faexception\u5bfc\u81f4program core dump\u3002\u5728 Shell-and-tools\\Tools\\Debug\\GDB\\Debugging-with-gdb\\GDB-Command-Reference.md \u4e2d\u6536\u5f55\u4e86\u8fd9\u90e8\u5206\u5185\u5bb9\u3002","title":"18-gdb-Files"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/18-gdb-Files/18-gdb-Files/#18#gdb#files","text":"","title":"18 gdb Files"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/18-gdb-Files/18-gdb-Files/#181#commands#to#specify#files","text":"","title":"18.1 Commands to Specify Files"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/18-gdb-Files/18-gdb-Files/#exec-file#filename","text":"","title":"exec-file  [ filename ]"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/18-gdb-Files/18-gdb-Files/#symbol-file#filename","text":"","title":"symbol-file [ filename ]"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/18-gdb-Files/18-gdb-Files/#add-symbol-file#filename#address","text":"The add-symbol-file command reads additional symbol table information from the file filename . You would use this command when filename has been dynamically loaded (by some other means) into the program that is running. NOTE: \u662f\u5728\u9605\u8bfb Load Shared library Symbols \u65f6\uff0c\u53d1\u73b0\u7684\u8fd9\u4e2acommand\uff0c\u5b83\u8ba9\u6211\u60f3\u8d77\u6765\u4e86\u6709\u65f6\u5019 glibc \u629b\u51faexception\u5bfc\u81f4program core dump\u3002\u5728 Shell-and-tools\\Tools\\Debug\\GDB\\Debugging-with-gdb\\GDB-Command-Reference.md \u4e2d\u6536\u5f55\u4e86\u8fd9\u90e8\u5206\u5185\u5bb9\u3002","title":"add-symbol-file filename address"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/19-Specifying-a-Debugging-Target/19-Specifying-a-Debugging-Target/","text":"Specifying a Debugging Target \u663e\u7136\uff0c\u548cinferior\u7c7b\u4f3c\uff0ctarget\u4e5f\u662fGDB\u4e2d\u62bd\u8c61\u51fa\u6765\u7684\u4e00\u4e2a\u6982\u5ff5\u3002 gdb onlinedocs 19 Specifying a Debugging Target","title":"Specifying-a-Debugging-Target"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/19-Specifying-a-Debugging-Target/19-Specifying-a-Debugging-Target/#specifying#a#debugging#target","text":"\u663e\u7136\uff0c\u548cinferior\u7c7b\u4f3c\uff0ctarget\u4e5f\u662fGDB\u4e2d\u62bd\u8c61\u51fa\u6765\u7684\u4e00\u4e2a\u6982\u5ff5\u3002","title":"Specifying a Debugging Target"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/19-Specifying-a-Debugging-Target/19-Specifying-a-Debugging-Target/#gdb#onlinedocs#19#specifying#a#debugging#target","text":"","title":"gdb onlinedocs 19 Specifying a Debugging Target"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/2-Getting-In-and-Out-of-gdb/2-Getting-In-and-Out-of-gdb/","text":"2 Getting In and Out of gdb 2.1 Invoking gdb You can also run gdb with a variety of arguments and options, to specify more of your debugging environment at the outset\uff08\u5f00\u7aef\uff09. gdb program gdb program core You can, instead, specify a process ID as a second argument, if you want to debug a running process : gdb program 1234 You can optionally have gdb pass any arguments after the executable file to the inferior using --args . This option stops option processing. gdb --args gcc -O2 -c foo.c NOTE: \u5728linux OS\u4e2d\uff0c\u6211\u4eec\u5e38\u5e38\u4f7f\u7528script\u6765\u542f\u52a8application\uff0c\u8fd9\u662f\u56e0\u4e3a\u542f\u52a8\u5b83\u4eec\u7684\u65f6\u5019\u9700\u8981\u4f20\u5165\u4e00\u5806args\uff0c\u4e0a\u8ff0\u6307\u4ee4\u544a\u8bc9\u4e86\u6211\u4eec\u5982\u4f55\u6765\u8c03\u8bd5\u4f7f\u7528scrip\u542f\u52a8\u7684application\u3002 This will cause gdb to debug gcc , and to set gcc \u2019s command-line arguments (see Section 4.3 [Arguments], page 30) to \u2018 -O2 -c foo.c \u2019. gdb --silent gdb -q gdb --quite 2.1.1 Choosing Files 2.3 Shell Commands If you need to execute occasional shell commands during your debugging session, there is no need to leave or suspend gdb ; you can just use the shell command. shell command-string !command-string The utility make is often needed in development environments. You do not have to use the shell command for this purpose in gdb: make make-args 2.4 Logging Output You may want to save the output of gdb commands to a file. There are several commands to control gdb\u2019s logging. set logging on set logging off NOTE: \u5f00\u542f\u6216\u5173\u95ed logging Application: \u5c06\u7a0b\u5e8f\u8fd0\u884c\u8f93\u51fa\u91cd\u5b9a\u5411\u5230\u6307\u5b9a\u6587\u4ef6 run > outfile \u53c2\u8003: https://stackoverflow.com/a/19715092 set logging on \u5982\u4f55\u5b9e\u73b0\u81ea\u5b9a\u4e49\u6587\u4ef6\uff1f \u53c2\u8003: stackoverflow Gdb print to file instead of stdout # A tee Extending on @qubodup 's answer gdb core.3599 -ex bt -ex quit |& tee backtrace.log the -ex switch runs a gdb command. So the above loads the core file, runs bt command, then quit command. Output is written to backtrace.log and also on the screen. Another useful gdb invocation (giving stacktrace with local variables from all threads) is gdb core.3599 -ex 'thread apply all bt full' -ex quit \u53c2\u8003: https://stackoverflow.com/a/36821621","title":"2-Getting-In-and-Out-of-gdb"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/2-Getting-In-and-Out-of-gdb/2-Getting-In-and-Out-of-gdb/#2#getting#in#and#out#of#gdb","text":"","title":"2 Getting In and Out of gdb"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/2-Getting-In-and-Out-of-gdb/2-Getting-In-and-Out-of-gdb/#21#invoking#gdb","text":"You can also run gdb with a variety of arguments and options, to specify more of your debugging environment at the outset\uff08\u5f00\u7aef\uff09. gdb program gdb program core You can, instead, specify a process ID as a second argument, if you want to debug a running process : gdb program 1234 You can optionally have gdb pass any arguments after the executable file to the inferior using --args . This option stops option processing. gdb --args gcc -O2 -c foo.c NOTE: \u5728linux OS\u4e2d\uff0c\u6211\u4eec\u5e38\u5e38\u4f7f\u7528script\u6765\u542f\u52a8application\uff0c\u8fd9\u662f\u56e0\u4e3a\u542f\u52a8\u5b83\u4eec\u7684\u65f6\u5019\u9700\u8981\u4f20\u5165\u4e00\u5806args\uff0c\u4e0a\u8ff0\u6307\u4ee4\u544a\u8bc9\u4e86\u6211\u4eec\u5982\u4f55\u6765\u8c03\u8bd5\u4f7f\u7528scrip\u542f\u52a8\u7684application\u3002 This will cause gdb to debug gcc , and to set gcc \u2019s command-line arguments (see Section 4.3 [Arguments], page 30) to \u2018 -O2 -c foo.c \u2019. gdb --silent gdb -q gdb --quite","title":"2.1 Invoking gdb"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/2-Getting-In-and-Out-of-gdb/2-Getting-In-and-Out-of-gdb/#211#choosing#files","text":"","title":"2.1.1 Choosing Files"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/2-Getting-In-and-Out-of-gdb/2-Getting-In-and-Out-of-gdb/#23#shell#commands","text":"If you need to execute occasional shell commands during your debugging session, there is no need to leave or suspend gdb ; you can just use the shell command. shell command-string !command-string The utility make is often needed in development environments. You do not have to use the shell command for this purpose in gdb: make make-args","title":"2.3 Shell Commands"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/2-Getting-In-and-Out-of-gdb/2-Getting-In-and-Out-of-gdb/#24#logging#output","text":"You may want to save the output of gdb commands to a file. There are several commands to control gdb\u2019s logging. set logging on set logging off NOTE: \u5f00\u542f\u6216\u5173\u95ed logging","title":"2.4 Logging Output"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/2-Getting-In-and-Out-of-gdb/2-Getting-In-and-Out-of-gdb/#application","text":"run > outfile \u53c2\u8003: https://stackoverflow.com/a/19715092 set logging on \u5982\u4f55\u5b9e\u73b0\u81ea\u5b9a\u4e49\u6587\u4ef6\uff1f \u53c2\u8003: stackoverflow Gdb print to file instead of stdout # A tee Extending on @qubodup 's answer gdb core.3599 -ex bt -ex quit |& tee backtrace.log the -ex switch runs a gdb command. So the above loads the core file, runs bt command, then quit command. Output is written to backtrace.log and also on the screen. Another useful gdb invocation (giving stacktrace with local variables from all threads) is gdb core.3599 -ex 'thread apply all bt full' -ex quit \u53c2\u8003: https://stackoverflow.com/a/36821621","title":"Application: \u5c06\u7a0b\u5e8f\u8fd0\u884c\u8f93\u51fa\u91cd\u5b9a\u5411\u5230\u6307\u5b9a\u6587\u4ef6"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/23-Extending-GDB/","text":"23 Extending GDB","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/23-Extending-GDB/#23#extending#gdb","text":"","title":"23 Extending GDB"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/25-gdb-Text-User-Interface/25-gdb-Text-User-Interface/","text":"25 gdb Text User Interface NOTE: \u662f\u5728\u68c0\u7d22View both source and assembly\u53d1\u73b0\u7684TUI Application View both source and assembly stackoverflow View Both Assembly and C code A You can run gdb in Text User Interface (TUI) mode: gdb -tui <your-binary> (gdb) b main (gdb) r (gdb) layout split The layout split command divides the window into two parts - one of them displaying the source code, the other one the corresponding assembly. A few others tricks: set disassembly-flavor intel - if your prefer intel notation set print asm-demangle - demangles C++ names in assembly view ni - next instruction si - step instruction If you do not want to use the TUI mode (e.g. your terminal does not like it), you can always do: x /12i $pc which means print 12 instructions from current program counter address - this also works with the tricks above (demangling, stepping instructions, etc.). The \" x /12i $pc \" trick works in both gdb and cgdb, whereas \"layout split\" only works in gdb. Enjoy :)","title":"25-gdb-Text-User-Interface"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/25-gdb-Text-User-Interface/25-gdb-Text-User-Interface/#25#gdb#text#user#interface","text":"NOTE: \u662f\u5728\u68c0\u7d22View both source and assembly\u53d1\u73b0\u7684TUI","title":"25 gdb Text User Interface"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/25-gdb-Text-User-Interface/25-gdb-Text-User-Interface/#application","text":"","title":"Application"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/25-gdb-Text-User-Interface/25-gdb-Text-User-Interface/#view#both#source#and#assembly","text":"","title":"View both source and assembly"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/25-gdb-Text-User-Interface/25-gdb-Text-User-Interface/#stackoverflow#view#both#assembly#and#c#code","text":"A You can run gdb in Text User Interface (TUI) mode: gdb -tui <your-binary> (gdb) b main (gdb) r (gdb) layout split The layout split command divides the window into two parts - one of them displaying the source code, the other one the corresponding assembly. A few others tricks: set disassembly-flavor intel - if your prefer intel notation set print asm-demangle - demangles C++ names in assembly view ni - next instruction si - step instruction If you do not want to use the TUI mode (e.g. your terminal does not like it), you can always do: x /12i $pc which means print 12 instructions from current program counter address - this also works with the tricks above (demangling, stepping instructions, etc.). The \" x /12i $pc \" trick works in both gdb and cgdb, whereas \"layout split\" only works in gdb. Enjoy :)","title":"stackoverflow View Both Assembly and C code"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/","text":"4 Running Programs Under gdb 4.1 Compiling for Debugging gcc , the gnu C/C++ compiler, supports \u2018 -g \u2019 with or without \u2018 -O \u2019, making it possible to debug optimized code. We recommend that you always use \u2018 -g \u2019 whenever you compile a program. You may think your program is correct, but there is no sense in pushing your luck. For more information, see Chapter 11 [Optimized Code], page 159. gdb knows about preprocessor macros and can show you their expansion (see Chapter 12 [Macros], page 163). Most compilers do not include information about preprocessor macros in the debugging information if you specify the \u2018 -g \u2019 flag alone. Version 3.1 and later of gcc , the gnu C compiler, provides macro information if you are using the DWARF debugging format, and specify the option \u2018 -g3 \u2019. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a\u5728\u7f16\u8bd1\u671f\u7684option\u4e2d\u6dfb\u52a0\u4e0a -g3 -DWARF \u5c31\u53ef\u4ee5\u5305\u542bmacro\u7684\u8c03\u8bd5\u4fe1\u606f\uff0c\u6bd4\u5982\uff1a gcc -g3 -DWARF See Section \u201cOptions for Debugging Your Program or GCC\u201d in Using the gnu Compiler Collection (GCC), for more information on gcc options affecting debug information. You will have the best debugging experience if you use the latest version of the DWARF debugging format that your compiler supports. DWARF is currently the most expressive and best supported debugging format in gdb . NOTE: \u5173\u4e8e DWARF \u662f\u4e00\u79cddebugging format\u3002 4.2 Starting your Program run r 4.3 Your Program\u2019s Arguments 4.7 Debugging an Already-running Process attach process-id detach 4.9 Debugging Multiple Inferiors and Programs gdb lets you run and debug multiple programs in a single session. In addition, gdb on some systems may let you run several programs simultaneously (otherwise you have to exit from one before starting another). In the most general case, you can have multiple threads of execution in each of multiple processes, launched from multiple executables. inferior gdb represents the state of each program execution with an object called an inferior . An inferior typically corresponds to a process , but is more general and applies also to targets that do not have processes. Inferiors may be created before a process runs, and may be retained after a process exits. Inferiors have unique identifiers that are different from process ids. info inferiors info inferiors Print a list of all inferiors currently being managed by gdb. To switch focus between inferiors, use the inferior command: inferior infno inferior infno The debugger convenience variable \u2018 $_inferior \u2019 contains the number of the current inferior. You may find this useful in writing breakpoint conditional expressions , command scripts , and so forth. See Section 10.11 [Convenience Variables], page 139, for general information on convenience variables. add-inferior and clone-inferior You can get multiple executables into a debugging session via the add-inferior and clone-inferior commands. On some systems gdb can add inferiors to the debug session automatically by following calls to fork and exec . To remove inferiors from the debugging session use the remove-inferiors command. 4.10 Debugging Programs with Multiple Threads NOTE: \u5728\u4e0b\u5217\u7ae0\u8282\u4e2d\uff0c\u4e5f\u4ecb\u7ecd\u4e86thread\u76f8\u5173\u7684\u4e3b\u9898: 5.5 Stopping and Starting Multi-thread Programs 5.5.4 Thread-Specific Breakpoints current thread The gdb thread debugging facility allows you to observe all threads while your program runs\u2014but whenever gdb takes control, one thread in particular is always the focus of debugging. This thread is called the current thread . Debugging commands show program information from the perspective of the current thread. NOTE: \u4ece\u5b9e\u8df5\u7ed3\u679c\u6765\u770b\uff0c\u5982\u679c\u662fdebug an already running process\uff0c\u5219gdb\u9ed8\u8ba4\u662fattach\u5230main thread\uff0c\u5373\u9ed8\u8ba4\u60c5\u51b5\u4e0bcurrent \u4ed6head\u662fmain thread\u3002 systag NOTE: \u201csystag\u201d\u7684\u542b\u4e49\u662fsystem tag Whenever gdb detects a new thread in your program, it displays the target system\u2019s identification for the thread with a message in the form \u2018[New systag]\u2019, where systag is a thread identifier whose form varies depending on the particular system. GDB per-inferior thread ID For debugging purposes, gdb associates its own thread number \u2014always a single integer\u2014with each thread of an inferior. This number is unique between all threads of an inferior, but not unique between threads of different inferiors. Qualified thread ID You can refer to a given thread in an inferior using the qualified inferior-num.thread-num syntax, also known as qualified thread ID , with inferior-num being the inferior number and thread-num being the thread number of the given inferior. For example, thread 2.3 refers to thread number 3 of inferior 2. If you omit inferior-num (e.g., thread 3), then gdb infers you\u2019re referring to a thread of the current inferior . GDB Global thread ID In addition to a per-inferior number, each thread is also assigned a unique global number, also known as global thread ID , a single integer. $_thread and $_gthread See Convenience Variables , for general information on convenience variables. info threads NOTE: \u4e0b\u9762\u662f\u6211\u5728 GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7 \u4e0a\u4f7f\u7528\u6b64\u547d\u4ee4\u7684\u8f93\u51fa ( gdb ) info threads Id Target Id Frame 5 Thread 0x7f7775589700 ( LWP 81330 ) \"main\" 0x00007f777620ecf2 in pthread_cond_timedwait @@ GLIBC_2 .3.2 () from / lib64 / libpthread . so .0 4 Thread 0x7f7774d88700 ( LWP 81331 ) \"main\" 0x00007f77764de1ad in nanosleep () from / lib64 / libc . so .6 3 Thread 0x7f7774587700 ( LWP 81332 ) \"main\" 0x00007f7776517923 in epoll_wait () from / lib64 / libc . so .6 2 Thread 0x7f7773d86700 ( LWP 81333 ) \"main\" 0x00007f7776517923 in epoll_wait () from / lib64 / libc . so .6 * 1 Thread 0x7f77777cf780 ( LWP 81329 ) \"main\" 0x00007f77764de1ad in nanosleep () from / lib64 / libc . so .6 An asterisk \u2018 * \u2019 to the left of the GDB thread number indicates the current thread. thread apply Example stackoverflow How do I get the backtrace for all the threads in GDB? thread apply all bt drdobbs Multithreaded Debugging Techniques fayewilliams View A Backtrace For All Threads With GDB TO READ csdn \u7ebf\u7a0b\u7684\u67e5\u770b\u4ee5\u53ca\u5229\u7528gdb\u8c03\u8bd5\u591a\u7ebf\u7a0b 4.11 Debugging Forks On most systems, gdb has no special support for debugging programs which create additional processes using the fork function. When a program forks, gdb will continue to debug the parent process and the child process will run unimpeded\uff08\u672a\u53d7\u963b\u7684\uff09. If you have set a breakpoint in any code which the child then executes, the child will get a SIGTRAP signal which (unless it catches the signal) will cause it to terminate. NOTE: \u9ed8\u8ba4\u662f\u8c03\u8bd5parent process\uff0c\u5373\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cgdb\u662f attach parent process\u7684\u3002\u90a3\u5982\u4f55\u8ba9 gdb attach\u5230child process\u5462\uff1f\u4e0b\u9762\u5bf9\u6b64\u8fdb\u884c\u4e86\u4ecb\u7ecd\uff1a However, if you want to debug the child process there is a workaround which isn\u2019t too painful. Put a call to sleep in the code which the child process executes after the fork. It may be useful to sleep only if a certain environment variable is set, or a certain file exists, so that the delay need not occur when you don\u2019t want to run gdb on the child. While the child is sleeping, use the ps program to get its process ID . Then tell gdb (a new invocation of gdb if you are also debugging the parent process) to attach to the child process (see Section 4.7 [Attach], page 32). From that point on you can debug the child process just like any other process which you attached to. On some systems, gdb provides support for debugging programs that create additional processes using the fork or vfork functions. On gnu/Linux platforms, this feature is supported with kernel version 2.5.46 and later. By default, when a program forks, gdb will continue to debug the parent process and the child process will run unimpeded. set follow-fork-mode If you want to follow the child process instead of the parent process , use the command set follow-fork-mode set follow-fork-mode mode parent child show follow-fork-mode set detach-on-fork On Linux, if you want to debug both the parent and child processes, use the command set detach-on-fork . set detach-on-fork mode on off show detach-on-fork","title":"4-Running-Programs-Under-gdb"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#4#running#programs#under#gdb","text":"","title":"4 Running Programs Under gdb"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#41#compiling#for#debugging","text":"gcc , the gnu C/C++ compiler, supports \u2018 -g \u2019 with or without \u2018 -O \u2019, making it possible to debug optimized code. We recommend that you always use \u2018 -g \u2019 whenever you compile a program. You may think your program is correct, but there is no sense in pushing your luck. For more information, see Chapter 11 [Optimized Code], page 159. gdb knows about preprocessor macros and can show you their expansion (see Chapter 12 [Macros], page 163). Most compilers do not include information about preprocessor macros in the debugging information if you specify the \u2018 -g \u2019 flag alone. Version 3.1 and later of gcc , the gnu C compiler, provides macro information if you are using the DWARF debugging format, and specify the option \u2018 -g3 \u2019. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a\u5728\u7f16\u8bd1\u671f\u7684option\u4e2d\u6dfb\u52a0\u4e0a -g3 -DWARF \u5c31\u53ef\u4ee5\u5305\u542bmacro\u7684\u8c03\u8bd5\u4fe1\u606f\uff0c\u6bd4\u5982\uff1a gcc -g3 -DWARF See Section \u201cOptions for Debugging Your Program or GCC\u201d in Using the gnu Compiler Collection (GCC), for more information on gcc options affecting debug information. You will have the best debugging experience if you use the latest version of the DWARF debugging format that your compiler supports. DWARF is currently the most expressive and best supported debugging format in gdb . NOTE: \u5173\u4e8e DWARF \u662f\u4e00\u79cddebugging format\u3002","title":"4.1 Compiling for Debugging"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#42#starting#your#program","text":"","title":"4.2 Starting your Program"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#run","text":"r","title":"run"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#43#your#programs#arguments","text":"","title":"4.3 Your Program\u2019s Arguments"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#47#debugging#an#already-running#process","text":"","title":"4.7 Debugging an Already-running Process"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#attach#process-id","text":"","title":"attach process-id"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#detach","text":"","title":"detach"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#49#debugging#multiple#inferiors#and#programs","text":"gdb lets you run and debug multiple programs in a single session. In addition, gdb on some systems may let you run several programs simultaneously (otherwise you have to exit from one before starting another). In the most general case, you can have multiple threads of execution in each of multiple processes, launched from multiple executables.","title":"4.9 Debugging Multiple Inferiors and Programs"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#inferior","text":"gdb represents the state of each program execution with an object called an inferior . An inferior typically corresponds to a process , but is more general and applies also to targets that do not have processes. Inferiors may be created before a process runs, and may be retained after a process exits. Inferiors have unique identifiers that are different from process ids.","title":"inferior"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#info#inferiors","text":"info inferiors Print a list of all inferiors currently being managed by gdb. To switch focus between inferiors, use the inferior command:","title":"info inferiors"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#inferior#infno","text":"inferior infno The debugger convenience variable \u2018 $_inferior \u2019 contains the number of the current inferior. You may find this useful in writing breakpoint conditional expressions , command scripts , and so forth. See Section 10.11 [Convenience Variables], page 139, for general information on convenience variables.","title":"inferior infno"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#add-inferior#and#clone-inferior","text":"You can get multiple executables into a debugging session via the add-inferior and clone-inferior commands. On some systems gdb can add inferiors to the debug session automatically by following calls to fork and exec . To remove inferiors from the debugging session use the remove-inferiors command.","title":"add-inferior and clone-inferior"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#410#debugging#programs#with#multiple#threads","text":"NOTE: \u5728\u4e0b\u5217\u7ae0\u8282\u4e2d\uff0c\u4e5f\u4ecb\u7ecd\u4e86thread\u76f8\u5173\u7684\u4e3b\u9898: 5.5 Stopping and Starting Multi-thread Programs 5.5.4 Thread-Specific Breakpoints","title":"4.10 Debugging Programs with Multiple Threads"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#current#thread","text":"The gdb thread debugging facility allows you to observe all threads while your program runs\u2014but whenever gdb takes control, one thread in particular is always the focus of debugging. This thread is called the current thread . Debugging commands show program information from the perspective of the current thread. NOTE: \u4ece\u5b9e\u8df5\u7ed3\u679c\u6765\u770b\uff0c\u5982\u679c\u662fdebug an already running process\uff0c\u5219gdb\u9ed8\u8ba4\u662fattach\u5230main thread\uff0c\u5373\u9ed8\u8ba4\u60c5\u51b5\u4e0bcurrent \u4ed6head\u662fmain thread\u3002","title":"current thread"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#systag","text":"NOTE: \u201csystag\u201d\u7684\u542b\u4e49\u662fsystem tag Whenever gdb detects a new thread in your program, it displays the target system\u2019s identification for the thread with a message in the form \u2018[New systag]\u2019, where systag is a thread identifier whose form varies depending on the particular system.","title":"systag"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#gdb#per-inferior#thread#id","text":"For debugging purposes, gdb associates its own thread number \u2014always a single integer\u2014with each thread of an inferior. This number is unique between all threads of an inferior, but not unique between threads of different inferiors.","title":"GDB per-inferior thread ID"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#qualified#thread#id","text":"You can refer to a given thread in an inferior using the qualified inferior-num.thread-num syntax, also known as qualified thread ID , with inferior-num being the inferior number and thread-num being the thread number of the given inferior. For example, thread 2.3 refers to thread number 3 of inferior 2. If you omit inferior-num (e.g., thread 3), then gdb infers you\u2019re referring to a thread of the current inferior .","title":"Qualified thread ID"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#gdb#global#thread#id","text":"In addition to a per-inferior number, each thread is also assigned a unique global number, also known as global thread ID , a single integer.","title":"GDB Global thread ID"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#_thread#and#_gthread","text":"See Convenience Variables , for general information on convenience variables.","title":"$_thread and $_gthread"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#info#threads","text":"NOTE: \u4e0b\u9762\u662f\u6211\u5728 GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7 \u4e0a\u4f7f\u7528\u6b64\u547d\u4ee4\u7684\u8f93\u51fa ( gdb ) info threads Id Target Id Frame 5 Thread 0x7f7775589700 ( LWP 81330 ) \"main\" 0x00007f777620ecf2 in pthread_cond_timedwait @@ GLIBC_2 .3.2 () from / lib64 / libpthread . so .0 4 Thread 0x7f7774d88700 ( LWP 81331 ) \"main\" 0x00007f77764de1ad in nanosleep () from / lib64 / libc . so .6 3 Thread 0x7f7774587700 ( LWP 81332 ) \"main\" 0x00007f7776517923 in epoll_wait () from / lib64 / libc . so .6 2 Thread 0x7f7773d86700 ( LWP 81333 ) \"main\" 0x00007f7776517923 in epoll_wait () from / lib64 / libc . so .6 * 1 Thread 0x7f77777cf780 ( LWP 81329 ) \"main\" 0x00007f77764de1ad in nanosleep () from / lib64 / libc . so .6 An asterisk \u2018 * \u2019 to the left of the GDB thread number indicates the current thread.","title":"info threads"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#thread#apply","text":"","title":"thread apply"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#example","text":"stackoverflow How do I get the backtrace for all the threads in GDB? thread apply all bt drdobbs Multithreaded Debugging Techniques fayewilliams View A Backtrace For All Threads With GDB","title":"Example"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#to#read","text":"csdn \u7ebf\u7a0b\u7684\u67e5\u770b\u4ee5\u53ca\u5229\u7528gdb\u8c03\u8bd5\u591a\u7ebf\u7a0b","title":"TO READ"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#411#debugging#forks","text":"On most systems, gdb has no special support for debugging programs which create additional processes using the fork function. When a program forks, gdb will continue to debug the parent process and the child process will run unimpeded\uff08\u672a\u53d7\u963b\u7684\uff09. If you have set a breakpoint in any code which the child then executes, the child will get a SIGTRAP signal which (unless it catches the signal) will cause it to terminate. NOTE: \u9ed8\u8ba4\u662f\u8c03\u8bd5parent process\uff0c\u5373\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cgdb\u662f attach parent process\u7684\u3002\u90a3\u5982\u4f55\u8ba9 gdb attach\u5230child process\u5462\uff1f\u4e0b\u9762\u5bf9\u6b64\u8fdb\u884c\u4e86\u4ecb\u7ecd\uff1a However, if you want to debug the child process there is a workaround which isn\u2019t too painful. Put a call to sleep in the code which the child process executes after the fork. It may be useful to sleep only if a certain environment variable is set, or a certain file exists, so that the delay need not occur when you don\u2019t want to run gdb on the child. While the child is sleeping, use the ps program to get its process ID . Then tell gdb (a new invocation of gdb if you are also debugging the parent process) to attach to the child process (see Section 4.7 [Attach], page 32). From that point on you can debug the child process just like any other process which you attached to. On some systems, gdb provides support for debugging programs that create additional processes using the fork or vfork functions. On gnu/Linux platforms, this feature is supported with kernel version 2.5.46 and later. By default, when a program forks, gdb will continue to debug the parent process and the child process will run unimpeded.","title":"4.11 Debugging Forks"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#set#follow-fork-mode","text":"If you want to follow the child process instead of the parent process , use the command set follow-fork-mode set follow-fork-mode mode parent child show follow-fork-mode","title":"set follow-fork-mode"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/4-Running-Programs-Under-gdb/#set#detach-on-fork","text":"On Linux, if you want to debug both the parent and child processes, use the command set detach-on-fork . set detach-on-fork mode on off show detach-on-fork","title":"set detach-on-fork"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/Debug-multithreaded-application/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u63cf\u8ff0\u5728debug multithreaded application\u65f6\uff0c\u4f1a\u9047\u5230\u7684commonissue\uff0c\u4ee5\u53ca\u89e3\u51b3\u65b9\u6cd5\u3002 \u6b63\u5982\u5728 Debugging Common Issues in Multithreaded Applications \u4e2d\u6240\u8a00\uff1a This paper describes several challenges that are commonly encountered when debugging multithreaded applications in order to compare the open source GNU GDB debugger","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/Debug-multithreaded-application/#_1","text":"\u672c\u7ae0\u63cf\u8ff0\u5728debug multithreaded application\u65f6\uff0c\u4f1a\u9047\u5230\u7684commonissue\uff0c\u4ee5\u53ca\u89e3\u51b3\u65b9\u6cd5\u3002 \u6b63\u5982\u5728 Debugging Common Issues in Multithreaded Applications \u4e2d\u6240\u8a00\uff1a This paper describes several challenges that are commonly encountered when debugging multithreaded applications in order to compare the open source GNU GDB debugger","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/Debug-multithreaded-application/Race-condition/","text":"Race condition Debugging Common Issues in Multithreaded Applications The application is a simple tcp-server that creates a new thread ( super-thread ) for processing each incoming client request. Each super-thread spawns a set of sub-threads which approximate the value of pi using the trapezoidal rule. The server allows one to define the maximum number of super-threads and the number of sub-threads . Three implemented bugs can be switched on and off for demonstration purposes. This could be done through the use of global variables, or the use of ifdef s in the code and rebuilding the application for each scenario. int main ( int argc , char * argv []) /* All super-threads are created here */ void * processRequest ( void * sfd ) /* The sub-threads will be spawned in this function */ void * iterate ( void * ind ) /* Sub-threads are calculating PI */ void onError ( const char * errorMsg ) /* Error handling */ NOTE: supreme-thread\u7684\u7ebf\u7a0b\u6267\u884c\u51fd\u6570\u662f processRequest sub-thread\u7ebf\u7a0b\u6267\u884c\u51fd\u6570\u662f iterate Properties referring to each super-thread are stored in an array of structures which is globally visible. Whether a thread is still alive or has already been terminated, these structures will hold the thread id , the session id , and the results calculated by the super-thread\u2019s sub-threads. Introducing such an array ( threadInfo tID[MAXTHREADS]; ) allows one to provide thread functions with a pointer to an index of this array while creating a thread in order to hand over all relevant super-thread related properties. The following variables, which are used to store the index\u2019s integer value, will be mentioned in this document: int * pindex ; /* Pointer to an index of type integer, used in function main() as argument in pthread_create() */ void * sfd ; /* Void pointer to an index of type integer, used in function processRequest() */ int index ; /* Local integer variable used in function processRequest() */ void * ind ; /* Void pointer to an index of type integer, used in function iterate() */ int index ; /* Local integer variable used in function iterate() */ NOTE: \u9700\u8981\u7ed3\u5408\u524d\u9762\u7684\u51fd\u6570\u539f\u578b\u6765\u7406\u89e3\u8fd9\u4e9bvariable\u7684\u7528\u9014 Debugging a Simple, Multithreaded Application The first bug should be easy to find. The server calculates reasonable results when only one superthread is running, as seen in Figure 1. However, when additional super-threads are created the results become incorrect, as shown in Figure 2. It seems that there is a conflict between threads that occurs in cases where more than one super-thread is running. The popular (some would say ubiquitous) GDB debugger1 will be used to demonstrate this issue. We will also show how that same issue can be addressed using TotalView2. Debugging a Multithreaded Application with GDB The following steps outline a debug session using GDB: 1.) Start the server within GDB: gdb ./server . 2.) Set the breakpoints: As shown in Figure 3, it makes sense to place the first breakpoint in main() , in front of the function pthread_create() , where the super-threads are created. The GDB command list main <return> lists the source code with line numbers. The first breakpoint is set at line 266 by typing break 266 <return> . Additional breakpoints are placed at line 132 in the function processRequest() where the subthreads will be spawned, and before the calculation starts at line 34 in the function iterate() . These breakpoints will stop the process when they are encountered by the debugger. While GDB allows you to create thread-specific breakpoints, it does not prevent you from setting breakpoints on lines that are normally considered invalid, such as in front of comments or on blank lines. These incorrectly placed breakpoints will be recorded by the debugger but will not have the intended effect of stopping the program.","title":"Race-condition"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/Debug-multithreaded-application/Race-condition/#race#condition","text":"","title":"Race condition"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/Debug-multithreaded-application/Race-condition/#debugging#common#issues#in#multithreaded#applications","text":"The application is a simple tcp-server that creates a new thread ( super-thread ) for processing each incoming client request. Each super-thread spawns a set of sub-threads which approximate the value of pi using the trapezoidal rule. The server allows one to define the maximum number of super-threads and the number of sub-threads . Three implemented bugs can be switched on and off for demonstration purposes. This could be done through the use of global variables, or the use of ifdef s in the code and rebuilding the application for each scenario. int main ( int argc , char * argv []) /* All super-threads are created here */ void * processRequest ( void * sfd ) /* The sub-threads will be spawned in this function */ void * iterate ( void * ind ) /* Sub-threads are calculating PI */ void onError ( const char * errorMsg ) /* Error handling */ NOTE: supreme-thread\u7684\u7ebf\u7a0b\u6267\u884c\u51fd\u6570\u662f processRequest sub-thread\u7ebf\u7a0b\u6267\u884c\u51fd\u6570\u662f iterate Properties referring to each super-thread are stored in an array of structures which is globally visible. Whether a thread is still alive or has already been terminated, these structures will hold the thread id , the session id , and the results calculated by the super-thread\u2019s sub-threads. Introducing such an array ( threadInfo tID[MAXTHREADS]; ) allows one to provide thread functions with a pointer to an index of this array while creating a thread in order to hand over all relevant super-thread related properties. The following variables, which are used to store the index\u2019s integer value, will be mentioned in this document: int * pindex ; /* Pointer to an index of type integer, used in function main() as argument in pthread_create() */ void * sfd ; /* Void pointer to an index of type integer, used in function processRequest() */ int index ; /* Local integer variable used in function processRequest() */ void * ind ; /* Void pointer to an index of type integer, used in function iterate() */ int index ; /* Local integer variable used in function iterate() */ NOTE: \u9700\u8981\u7ed3\u5408\u524d\u9762\u7684\u51fd\u6570\u539f\u578b\u6765\u7406\u89e3\u8fd9\u4e9bvariable\u7684\u7528\u9014","title":"Debugging Common Issues in Multithreaded Applications"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/Debug-multithreaded-application/Race-condition/#debugging#a#simple#multithreaded#application","text":"The first bug should be easy to find. The server calculates reasonable results when only one superthread is running, as seen in Figure 1. However, when additional super-threads are created the results become incorrect, as shown in Figure 2. It seems that there is a conflict between threads that occurs in cases where more than one super-thread is running. The popular (some would say ubiquitous) GDB debugger1 will be used to demonstrate this issue. We will also show how that same issue can be addressed using TotalView2.","title":"Debugging a Simple, Multithreaded Application"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/Debug-multithreaded-application/Race-condition/#debugging#a#multithreaded#application#with#gdb","text":"The following steps outline a debug session using GDB: 1.) Start the server within GDB: gdb ./server . 2.) Set the breakpoints: As shown in Figure 3, it makes sense to place the first breakpoint in main() , in front of the function pthread_create() , where the super-threads are created. The GDB command list main <return> lists the source code with line numbers. The first breakpoint is set at line 266 by typing break 266 <return> . Additional breakpoints are placed at line 132 in the function processRequest() where the subthreads will be spawned, and before the calculation starts at line 34 in the function iterate() . These breakpoints will stop the process when they are encountered by the debugger. While GDB allows you to create thread-specific breakpoints, it does not prevent you from setting breakpoints on lines that are normally considered invalid, such as in front of comments or on blank lines. These incorrectly placed breakpoints will be recorded by the debugger but will not have the intended effect of stopping the program.","title":"Debugging a Multithreaded Application with GDB"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/Debug-multithreaded-application/Show-thread-start-rtn/","text":"Show thread start-rtn \u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662f\uff1a\u5982\u4f55\u67e5\u770b\u4e00\u4e2athread\u7684\u7ebf\u7a0b\u6267\u884c\u51fd\u6570\uff0c stackoverflow How to list the threads along with it's appropriate function in GDB.? A : You can use thread apply all bt command. It will print backtraces of all your threads. You will find thread function name inside each of these backtrace near the end and before clone system call. A : I press Ctrl+L to clear the screen buffer set height 0 thread apply all bt This will dump backtrace for all the threads but won't pause (because we set the window height to 0) if the list is long. I then copy/paste the output to a text editor for examination. \u4e0b\u9762\u662f\u6211\u4eec\u7684\u5b9e\u8df5: ( gdb ) info threads Id Target Id Frame 5 Thread 0x7f3a780ee700 ( LWP 142466 ) \"main\" 0x00007f3a78d73cf2 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0 4 Thread 0x7f3a778ed700 ( LWP 142467 ) \"main\" 0x00007f3a790431ad in nanosleep () from /lib64/libc.so.6 3 Thread 0x7f3a770ec700 ( LWP 142468 ) \"main\" 0x00007f3a7907c923 in epoll_wait () from /lib64/libc.so.6 2 Thread 0x7f3a768eb700 ( LWP 142469 ) \"main\" 0x00007f3a7907c923 in epoll_wait () from /lib64/libc.so.6 * 1 Thread 0x7f3a7a334780 ( LWP 142465 ) \"main\" 0x00007f3a790431ad in nanosleep () from /lib64/libc.so.6 ( gdb ) thread apply all bt Thread 5 ( Thread 0x7f3a780ee700 ( LWP 142466 )) : #0 0x00007f3a78d73cf2 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0 #1 0x00007f3a787495e2 in __gthread_cond_timedwait (__abs_timeout=0x7f3a780edd80, __mutex=<optimized out>, __cond=0x212a388) at /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/gthr-default.h:871 #2 __wait_until_impl<std::chrono::duration<long, std::ratio<1l, 1000000000l> > > (__atime=..., __lock=..., this=0x212a388) at /usr/include/c++/4.8.2/condition_variable:160 #3 wait_until<std::chrono::duration<long, std::ratio<1l, 1000000000l> > > (__atime=..., __lock=..., this=0x212a388) at /usr/include/c++/4.8.2/condition_variable:100 #4 wait_until<std::chrono::_V2::system_clock, std::chrono::duration<long int, std::ratio<1l, 1000000000l> >, CEvent::Wait(int64_t)::__lambda0> ( __p = ..., __atime = ..., __lock = ..., this = 0x212a388 ) at /usr/include/c++/4.8.2/condition_variable:123 #5 wait_for<long int, std::ratio<1l, 1000l>, CEvent::Wait(int64_t)::__lambda0> (__p=..., __rtime=..., __lock=..., this=0x212a388) at /usr/include/c++/4.8.2/condition_variable:139 #6 CEvent::Wait (this=0x212a360, dwMillsSecond=dwMillsSecond@entry=100) at ../../plugins/logproxy/event.cpp:44 #7 0x00007f3a787453da in Pop (iTimeOut=100, this=0x212a290) at ../../plugins/logproxy/log_queue.h:92 #8 CLogProxyImpl::Run (this=<optimized out>) at ../../plugins/logproxy/log_proxy_impl.cpp:367 #9 0x00007f3a799142b0 in ?? () from /lib64/libstdc++.so.6 #10 0x00007f3a78d6fe25 in start_thread () from /lib64/libpthread.so.0 #11 0x00007f3a7907c34d in clone () from /lib64/libc.so.6 Thread 4 ( Thread 0x7f3a778ed700 ( LWP 142467 )) : #0 0x00007f3a790431ad in nanosleep () from /lib64/libc.so.6 #1 0x00007f3a79073ec4 in usleep () from /lib64/libc.so.6 #2 0x00007f3a78740470 in sleep_for<long, std::ratio<1l, 1000l> > (__rtime=...) at /usr/include/c++/4.8.2/thread:281 #3 CCheckConnThread::Run (this=0x2161040) at ../../utilities/tcp/tcp_factory.cpp:608 #4 0x00007f3a799142b0 in ?? () from /lib64/libstdc++.so.6 #5 0x00007f3a78d6fe25 in start_thread () from /lib64/libpthread.so.0 #6 0x00007f3a7907c34d in clone () from /lib64/libc.so.6 Thread 3 ( Thread 0x7f3a770ec700 ( LWP 142468 )) : #0 0x00007f3a7907c923 in epoll_wait () from /lib64/libc.so.6 #1 0x00007f3a78740b4a in CTcpSendThread::Run (this=0x2160f48) at ../../utilities/tcp/tcp_factory.cpp:228 #2 0x00007f3a799142b0 in ?? () from /lib64/libstdc++.so.6 #3 0x00007f3a78d6fe25 in start_thread () from /lib64/libpthread.so.0 #4 0x00007f3a7907c34d in clone () from /lib64/libc.so.6 ---Type < return > to continue , or q < return > to quit--- Thread 2 ( Thread 0x7f3a768eb700 ( LWP 142469 )) : #0 0x00007f3a7907c923 in epoll_wait () from /lib64/libc.so.6 #1 0x00007f3a7874094a in CTcpRecvThread::Run (this=0x2160fc8) at ../../utilities/tcp/tcp_factory.cpp:261 #2 0x00007f3a799142b0 in ?? () from /lib64/libstdc++.so.6 #3 0x00007f3a78d6fe25 in start_thread () from /lib64/libpthread.so.0 #4 0x00007f3a7907c34d in clone () from /lib64/libc.so.6 Thread 1 ( Thread 0x7f3a7a334780 ( LWP 142465 )) : #0 0x00007f3a790431ad in nanosleep () from /lib64/libc.so.6 #1 0x00007f3a79073ec4 in usleep () from /lib64/libc.so.6 #2 0x0000000000406189 in sleep_for<long, std::ratio<1l, 1000l> > (__rtime=...) at /usr/include/c++/4.8.2/thread:281 #3 CMyApp::Run (this=this@entry=0x7ffcb3fa4b50) at ../HA-test-1/app.h:251 #4 0x00000000004032ac in main () at main.cpp:43 \u4ece\u4e0a\u9762\u7684\u8f93\u51fa\u53ef\u4ee5\u770b\u51fa\uff1a Thread 1\u662fmain thread\uff0c\u5b83\u4e0d\u662f\u7531clone system call\u521b\u5efa\u7684\uff0c\u5176\u4ed6thread\u90fd\u662f\u7531 clone system call \u521b\u5efa\u7684","title":"Show-thread-start-rtn"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/Debug-multithreaded-application/Show-thread-start-rtn/#show#thread#start-rtn","text":"\u672c\u8282\u6807\u9898\u7684\u542b\u4e49\u662f\uff1a\u5982\u4f55\u67e5\u770b\u4e00\u4e2athread\u7684\u7ebf\u7a0b\u6267\u884c\u51fd\u6570\uff0c","title":"Show thread start-rtn"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/4-Running-Programs-Under-gdb/Debug-multithreaded-application/Show-thread-start-rtn/#stackoverflow#how#to#list#the#threads#along#with#its#appropriate#function#in#gdb","text":"A : You can use thread apply all bt command. It will print backtraces of all your threads. You will find thread function name inside each of these backtrace near the end and before clone system call. A : I press Ctrl+L to clear the screen buffer set height 0 thread apply all bt This will dump backtrace for all the threads but won't pause (because we set the window height to 0) if the list is long. I then copy/paste the output to a text editor for examination. \u4e0b\u9762\u662f\u6211\u4eec\u7684\u5b9e\u8df5: ( gdb ) info threads Id Target Id Frame 5 Thread 0x7f3a780ee700 ( LWP 142466 ) \"main\" 0x00007f3a78d73cf2 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0 4 Thread 0x7f3a778ed700 ( LWP 142467 ) \"main\" 0x00007f3a790431ad in nanosleep () from /lib64/libc.so.6 3 Thread 0x7f3a770ec700 ( LWP 142468 ) \"main\" 0x00007f3a7907c923 in epoll_wait () from /lib64/libc.so.6 2 Thread 0x7f3a768eb700 ( LWP 142469 ) \"main\" 0x00007f3a7907c923 in epoll_wait () from /lib64/libc.so.6 * 1 Thread 0x7f3a7a334780 ( LWP 142465 ) \"main\" 0x00007f3a790431ad in nanosleep () from /lib64/libc.so.6 ( gdb ) thread apply all bt Thread 5 ( Thread 0x7f3a780ee700 ( LWP 142466 )) : #0 0x00007f3a78d73cf2 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0 #1 0x00007f3a787495e2 in __gthread_cond_timedwait (__abs_timeout=0x7f3a780edd80, __mutex=<optimized out>, __cond=0x212a388) at /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/gthr-default.h:871 #2 __wait_until_impl<std::chrono::duration<long, std::ratio<1l, 1000000000l> > > (__atime=..., __lock=..., this=0x212a388) at /usr/include/c++/4.8.2/condition_variable:160 #3 wait_until<std::chrono::duration<long, std::ratio<1l, 1000000000l> > > (__atime=..., __lock=..., this=0x212a388) at /usr/include/c++/4.8.2/condition_variable:100 #4 wait_until<std::chrono::_V2::system_clock, std::chrono::duration<long int, std::ratio<1l, 1000000000l> >, CEvent::Wait(int64_t)::__lambda0> ( __p = ..., __atime = ..., __lock = ..., this = 0x212a388 ) at /usr/include/c++/4.8.2/condition_variable:123 #5 wait_for<long int, std::ratio<1l, 1000l>, CEvent::Wait(int64_t)::__lambda0> (__p=..., __rtime=..., __lock=..., this=0x212a388) at /usr/include/c++/4.8.2/condition_variable:139 #6 CEvent::Wait (this=0x212a360, dwMillsSecond=dwMillsSecond@entry=100) at ../../plugins/logproxy/event.cpp:44 #7 0x00007f3a787453da in Pop (iTimeOut=100, this=0x212a290) at ../../plugins/logproxy/log_queue.h:92 #8 CLogProxyImpl::Run (this=<optimized out>) at ../../plugins/logproxy/log_proxy_impl.cpp:367 #9 0x00007f3a799142b0 in ?? () from /lib64/libstdc++.so.6 #10 0x00007f3a78d6fe25 in start_thread () from /lib64/libpthread.so.0 #11 0x00007f3a7907c34d in clone () from /lib64/libc.so.6 Thread 4 ( Thread 0x7f3a778ed700 ( LWP 142467 )) : #0 0x00007f3a790431ad in nanosleep () from /lib64/libc.so.6 #1 0x00007f3a79073ec4 in usleep () from /lib64/libc.so.6 #2 0x00007f3a78740470 in sleep_for<long, std::ratio<1l, 1000l> > (__rtime=...) at /usr/include/c++/4.8.2/thread:281 #3 CCheckConnThread::Run (this=0x2161040) at ../../utilities/tcp/tcp_factory.cpp:608 #4 0x00007f3a799142b0 in ?? () from /lib64/libstdc++.so.6 #5 0x00007f3a78d6fe25 in start_thread () from /lib64/libpthread.so.0 #6 0x00007f3a7907c34d in clone () from /lib64/libc.so.6 Thread 3 ( Thread 0x7f3a770ec700 ( LWP 142468 )) : #0 0x00007f3a7907c923 in epoll_wait () from /lib64/libc.so.6 #1 0x00007f3a78740b4a in CTcpSendThread::Run (this=0x2160f48) at ../../utilities/tcp/tcp_factory.cpp:228 #2 0x00007f3a799142b0 in ?? () from /lib64/libstdc++.so.6 #3 0x00007f3a78d6fe25 in start_thread () from /lib64/libpthread.so.0 #4 0x00007f3a7907c34d in clone () from /lib64/libc.so.6 ---Type < return > to continue , or q < return > to quit--- Thread 2 ( Thread 0x7f3a768eb700 ( LWP 142469 )) : #0 0x00007f3a7907c923 in epoll_wait () from /lib64/libc.so.6 #1 0x00007f3a7874094a in CTcpRecvThread::Run (this=0x2160fc8) at ../../utilities/tcp/tcp_factory.cpp:261 #2 0x00007f3a799142b0 in ?? () from /lib64/libstdc++.so.6 #3 0x00007f3a78d6fe25 in start_thread () from /lib64/libpthread.so.0 #4 0x00007f3a7907c34d in clone () from /lib64/libc.so.6 Thread 1 ( Thread 0x7f3a7a334780 ( LWP 142465 )) : #0 0x00007f3a790431ad in nanosleep () from /lib64/libc.so.6 #1 0x00007f3a79073ec4 in usleep () from /lib64/libc.so.6 #2 0x0000000000406189 in sleep_for<long, std::ratio<1l, 1000l> > (__rtime=...) at /usr/include/c++/4.8.2/thread:281 #3 CMyApp::Run (this=this@entry=0x7ffcb3fa4b50) at ../HA-test-1/app.h:251 #4 0x00000000004032ac in main () at main.cpp:43 \u4ece\u4e0a\u9762\u7684\u8f93\u51fa\u53ef\u4ee5\u770b\u51fa\uff1a Thread 1\u662fmain thread\uff0c\u5b83\u4e0d\u662f\u7531clone system call\u521b\u5efa\u7684\uff0c\u5176\u4ed6thread\u90fd\u662f\u7531 clone system call \u521b\u5efa\u7684","title":"stackoverflow How to list the threads along with it's appropriate function in GDB.?"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/","text":"5 Stopping and Continuing 5.1 Breakpoints, Watchpoints, and Catchpoints \u540d\u79f0 \u8bf4\u660e command breakpoint A breakpoint makes your program stop whenever a certain point(location) in the program is reached. break watchpoint A watchpoint is a special breakpoint that stops your program when the value of an expression changes. watch catchpoint A catchpoint is another special breakpoint that stops your program when a certain kind of event occurs, such as the throwing of a C++ exception or the loading of a library. catch \u67e5 info break \u5220 5.1.4 Deleting Breakpoints\u8282 5.1.1 Setting Breakpoints ccomand \u8bf4\u660e break location break When called without any arguments, break sets a breakpoint at the next instruction to be executed in the selected stack frame break ... if cond Set a breakpoint with condition cond ; \u5177\u4f53\u7528\u6cd5\u53c2\u89c1\u4e0b\u9762\u7684example tbreak args Set a breakpoint enabled only for one stop temporary breakpoint hbreak args Set a hardware-assisted breakpoint. thbreak args Set a hardware-assisted breakpoint enabled only for one stop. rbreak regex Set breakpoints on all functions matching the regular expression regex. rbreak file:regex If rbreak is called with a filename qualification, it limits the search for functions matching the given regular expression to the specified file. Example break ... if cond stackoverflow GDB: break if variable equal value \u7684 \u56de\u7b54 \u7ed9\u51fa\u4e86\u5b83\u7684\u7528\u6cd5\uff1a in addition to a watchpoint nested inside a breakpoint you can also set a single breakpoint on the 'filename:line_number' and use a condition. I find it sometimes easier. ( gdb ) break iter . c : 6 if i == 5 Breakpoint 2 at 0x4004dc : file iter . c , line 6. ( gdb ) c Continuing . 0 1 2 3 4 Breakpoint 2 , main () at iter . c : 6 6 printf ( \"%d \\n \" , i ); If like me you get tired of line numbers changing, you can add a label then set the breakpoint on the label like so: #include <stdio.h> main () { int i = 0 ; for ( i = 0 ; i < 7 ; ++ i ) { looping : printf ( \"%d \\n \" , i ); } return 0 ; } ( gdb ) break main : looping if i == 5 5.1.2 Setting Watchpoints Example stackoverflow GDB: break if variable equal value : #include <stdio.h> main () { int i = 0 ; for ( i = 0 ; i < 7 ; ++ i ) printf ( \"%d \\n \" , i ); return 0 ; } A You can use a watchpoint for this (A breakpoint on data instead of code). You can start by using watch i . Then set a condition for it using condition <breakpoint num> i == 5 You can get the breakpoint number by using info watch 5.1.3 Setting Catchpoints catch event event \u547d\u4ee4\u683c\u5f0f \u8bed\u8a00 \u8bf4\u660e throw\u3001rethrow\u3001catch cat event [regexp] C++ The throwing, re-throwing, or catching of a C++ exception exception Ada An Ada exception being raised exception unhandled Ada assert Ada exec syscall [name|number|group:groupname |g:groupname ] A call to or return from a system call, a.k.a. syscall. fork A call to fork. vfork A call to vfork. load [regexp] \u3001 unload [regexp] The loading or unloading of a shared library signal [signal... | all ] The delivery of a signal. Example \u627e\u51fa\u629b\u51fa\u5f02\u5e38\u7684\u8bed\u53e5 $ gdb a . out ( gdb ) catch throw Function \"__cxa_throw\" not defined . Catchpoint 1 ( throw ) ( gdb ) r [ New Thread 0x7ffff7ff0700 ( LWP 3121 )] [ New Thread 0x7ffff5f53700 ( LWP 3122 )] tcp : //127.0.0.1:8001 [ New Thread 0x7ffff5752700 ( LWP 3123 )] [ New Thread 0x7ffff4f51700 ( LWP 3124 )] [ New Thread 0x7ffff4daf700 ( LWP 3125 )] [ Switching to Thread 0x7ffff5752700 ( LWP 3123 )] Catchpoint 1 ( exception thrown ), 0x00007ffff6eb2920 in __cxa_throw () from / usr / lib64 / libstdc ++ . so .6 Missing separate debuginfos , use : debuginfo - install glibc -2.17-196. el7 . x86_64 libgcc -4.8.5-39. el7 . x86_64 libstdc ++ -4.8.5-39. el7 . x86_64 ( gdb ) bt #0 0x00007ffff6eb2920 in __cxa_throw () from /usr/lib64/libstdc++.so.6 #1 0x00007ffff72f060e in CppSQLite3DB::open (this=<optimized out>, szFile=<optimized out>) at ./cpp_sqlite3/CppSQLite3.cpp:1216 #2 0x00007ffff7297651 in CHSInsTradeApiCacheService_ust::ApiPushCacheInit (this=0x63a760, cacheFileName = cacheFileName @ entry = 0x7ffff573e400 \"./log/STOCKOPT_HSINSAPI_20200730_1082\" , svrMaxSerialno = 1998 ) at trade_api_cache . cpp : 250 \u901a\u8fc7 bt \u6765\u67e5\u770bstack frame\uff0cframe #1 \u6307\u793a\u4e86\u629b\u51faexception\u7684\u8bed\u53e5\uff1b catch syscall ( gdb ) catch syscall Catchpoint 1 ( syscall ) ( gdb ) r Starting program: /tmp/catch-syscall Catchpoint 1 ( call to syscall \u2019close\u2019 ) , \\ 0xffffe424 in __kernel_vsyscall () ( gdb ) c Continuing. Catchpoint 1 ( returned from syscall \u2019close\u2019 ) , \\ 0xffffe424 in __kernel_vsyscall () ( gdb ) catch syscall chroot (gdb) catch syscall chroot Catchpoint 1 (syscall \u2019chroot\u2019 [61]) (gdb) r Starting program: /tmp/catch-syscall Catchpoint 1 (call to syscall \u2019chroot\u2019), \\ 0xffffe424 in __kernel_vsyscall () (gdb) c Continuing. Catchpoint 1 (returned from syscall \u2019chroot\u2019), \\ 0xffffe424 in __kernel_vsyscall () (gdb) 5.1.4 Deleting Breakpoints clear 5.1.6 Break Conditions The simplest sort of breakpoint breaks every time your program reaches a specified place. You can also specify a condition for a breakpoint. A condition is just a Boolean expression in your programming language (see Section 10.1 [Expressions], page 117). A breakpoint with a condition evaluates the expression each time your program reaches it, and your program stops only if the condition is true . Break Condition VS assertion ... Break Condition VS watchpoint ... Break conditions can be specified when a breakpoint is set, by using \u2018if\u2019 in the arguments to the break command. See Section 5.1.1 [Setting Breakpoints], page 46. They can also be changed at any time with the condition command. You can also use the if keyword with the watch command. The catch command does not recognize the if keyword; condition is the only way to impose a further condition on a catchpoint. condition bnum expression Specify expression as the break condition for breakpoint, watchpoint, or catchpoint number bnum . condition bnum Remove the condition from breakpoint number bnum . Example: specify a condition on an existing breakpoint \u6587\u7ae0fayewilliams GDB Conditional Breakpoints \u4e2d\u7ed9\u51fa\u4e86\u4e00\u4e9b\u4f8b\u5b50\uff1a example: specify a condition on an existing breakpoint by using the breakpoint number as a reference You can also specify a condition on an existing breakpoint by using the breakpoint number as a reference: cond 3 i == 99 cond 3 Example: break if variable equal value GDB Conditional Breakpoints \u4e2d\u7ed9\u51fa\u7684\u4f8b\u5b50\uff1a b Message.cpp:112 if i == 99 \u6211\u7684\u5b9e\u8df5: b CHQImpl::DealMessage info locals cond 1 nFuncNo = 107 \u4e0a\u8ff0\u8868\u8fbe\u7684\u662f\uff1a\u5f53\u51fd\u6570 CHQImpl::DealMessage \u7684\u4e34\u65f6\u53d8\u91cf nFuncNo \u7684\u503c\u4e3a 107 \u65f6\uff0c\u5219break\u3002 GDB: break if variable equal value \u4e2d\u7ed9\u51fa\u7684\u4f8b\u5b50\uff1a I like to make GDB set a break point when a variable equal some value I set, I tried this example: #include <stdio.h> main () { int i = 0 ; for ( i = 0 ; i < 7 ; ++ i ) printf ( \"%d \\n \" , i ); return 0 ; } A : ( gdb ) break iter.c:6 if i == 5 Breakpoint 2 at 0x4004dc: file iter.c, line 6 . ( gdb ) c Continuing. 0 1 2 3 4 Breakpoint 2 , main () at iter.c:6 6 printf ( \"%d\\n\" , i ) ; If like me you get tired of line numbers changing, you can add a label then set the breakpoint on the label like so: #include <stdio.h> main () { int i = 0 ; for ( i = 0 ; i < 7 ; ++ i ) { looping : printf ( \"%d \\n \" , i ); } return 0 ; } ( gdb ) break main : looping if i == 5 Example: \u66f4\u52a0\u590d\u6742\u7684\u6761\u4ef6 GDB Conditional Breakpoints \u4e2d\u7ed9\u51fa\u7684\u4f8b\u5b50\uff1a Pretty much anything you like! Just write the condition exactly as if you were testing for it in your code, e.g.: ( gdb ) cond 1 strcmp ( message, \"earthquake\" ) == 0 //stop if the array message is equal to 'earthquake' ( gdb ) cond 2 *p == 'r' //stop if the char* pointer p points to the letter 'r' (gdb) cond 3 num < 0.75 //stop while the float num is less than 0.75 5.1.7 Breakpoint Command Lists NOTE: \u8fd9\u662fautomatic gdb debug\u7684\u57fa\u7840\u3002 You can give any breakpoint (or watchpoint or catchpoint ) a series of commands to execute when your program stops due to that breakpoint . For example, you might want to print the values of certain expressions, or enable other breakpoints. commands [range...] ... command-list ... end Example: print variable For example, here is how you could use breakpoint commands to print the value of x at entry to foo whenever x is positive. break foo if x>0 commands silent printf \"x is %d\\n\" ,x cont end Example: compensate for one bug One application for breakpoint commands is to compensate(\u507f\u8fd8) for one bug so you can test for another. Put a breakpoint just after the erroneous line of code, give it a condition to detect the case in which something erroneous has been done, and give it commands to assign correct values to any variables that need them. End with the continue command so that your program does not stop, and start with the silent command so that no output is produced. Here is an example: break 403 commands silent set x = y + 4 cont end 5.2 Continuing and Stepping step vs next \u5355\u6b65\u6267\u884c: step next step\u4f1a\u8fdb\u5165\u51fd\u6570 next\u4e0d\u8fdb\u5165\u51fd\u6570 \u9010\u8bed\u53e5 \u9010\u8fc7\u7a0b \u5355\u4f4d \u4ee5function\u4e3a\u5355\u4f4d next \u4ee5statement/source line\u4e3a\u5355\u4f4d step \u4ee5instruction\u4e3a\u5355\u4f4d stepi \u3001 nexti NOTE: \u4e3b\u8981\u7528\u4e8edebug assembly\uff0c\u5173\u4e8edebug assembly\uff0c\u53c2\u89c1 Shell-and-tools\\Tools\\Debug\\GDB\\Guide\\Debug-assembly.md","title":"5-Stopping-and-Continuing"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#5#stopping#and#continuing","text":"","title":"5 Stopping and Continuing"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#51#breakpoints#watchpoints#and#catchpoints","text":"\u540d\u79f0 \u8bf4\u660e command breakpoint A breakpoint makes your program stop whenever a certain point(location) in the program is reached. break watchpoint A watchpoint is a special breakpoint that stops your program when the value of an expression changes. watch catchpoint A catchpoint is another special breakpoint that stops your program when a certain kind of event occurs, such as the throwing of a C++ exception or the loading of a library. catch \u67e5 info break \u5220 5.1.4 Deleting Breakpoints\u8282","title":"5.1 Breakpoints, Watchpoints, and Catchpoints"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#511#setting#breakpoints","text":"ccomand \u8bf4\u660e break location break When called without any arguments, break sets a breakpoint at the next instruction to be executed in the selected stack frame break ... if cond Set a breakpoint with condition cond ; \u5177\u4f53\u7528\u6cd5\u53c2\u89c1\u4e0b\u9762\u7684example tbreak args Set a breakpoint enabled only for one stop temporary breakpoint hbreak args Set a hardware-assisted breakpoint. thbreak args Set a hardware-assisted breakpoint enabled only for one stop. rbreak regex Set breakpoints on all functions matching the regular expression regex. rbreak file:regex If rbreak is called with a filename qualification, it limits the search for functions matching the given regular expression to the specified file.","title":"5.1.1 Setting Breakpoints"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#example","text":"break ... if cond stackoverflow GDB: break if variable equal value \u7684 \u56de\u7b54 \u7ed9\u51fa\u4e86\u5b83\u7684\u7528\u6cd5\uff1a in addition to a watchpoint nested inside a breakpoint you can also set a single breakpoint on the 'filename:line_number' and use a condition. I find it sometimes easier. ( gdb ) break iter . c : 6 if i == 5 Breakpoint 2 at 0x4004dc : file iter . c , line 6. ( gdb ) c Continuing . 0 1 2 3 4 Breakpoint 2 , main () at iter . c : 6 6 printf ( \"%d \\n \" , i ); If like me you get tired of line numbers changing, you can add a label then set the breakpoint on the label like so: #include <stdio.h> main () { int i = 0 ; for ( i = 0 ; i < 7 ; ++ i ) { looping : printf ( \"%d \\n \" , i ); } return 0 ; } ( gdb ) break main : looping if i == 5","title":"Example"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#512#setting#watchpoints","text":"","title":"5.1.2 Setting Watchpoints"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#example_1","text":"stackoverflow GDB: break if variable equal value : #include <stdio.h> main () { int i = 0 ; for ( i = 0 ; i < 7 ; ++ i ) printf ( \"%d \\n \" , i ); return 0 ; } A You can use a watchpoint for this (A breakpoint on data instead of code). You can start by using watch i . Then set a condition for it using condition <breakpoint num> i == 5 You can get the breakpoint number by using info watch","title":"Example"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#513#setting#catchpoints","text":"catch event event \u547d\u4ee4\u683c\u5f0f \u8bed\u8a00 \u8bf4\u660e throw\u3001rethrow\u3001catch cat event [regexp] C++ The throwing, re-throwing, or catching of a C++ exception exception Ada An Ada exception being raised exception unhandled Ada assert Ada exec syscall [name|number|group:groupname |g:groupname ] A call to or return from a system call, a.k.a. syscall. fork A call to fork. vfork A call to vfork. load [regexp] \u3001 unload [regexp] The loading or unloading of a shared library signal [signal... | all ] The delivery of a signal.","title":"5.1.3 Setting Catchpoints"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#example_2","text":"","title":"Example"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#_1","text":"$ gdb a . out ( gdb ) catch throw Function \"__cxa_throw\" not defined . Catchpoint 1 ( throw ) ( gdb ) r [ New Thread 0x7ffff7ff0700 ( LWP 3121 )] [ New Thread 0x7ffff5f53700 ( LWP 3122 )] tcp : //127.0.0.1:8001 [ New Thread 0x7ffff5752700 ( LWP 3123 )] [ New Thread 0x7ffff4f51700 ( LWP 3124 )] [ New Thread 0x7ffff4daf700 ( LWP 3125 )] [ Switching to Thread 0x7ffff5752700 ( LWP 3123 )] Catchpoint 1 ( exception thrown ), 0x00007ffff6eb2920 in __cxa_throw () from / usr / lib64 / libstdc ++ . so .6 Missing separate debuginfos , use : debuginfo - install glibc -2.17-196. el7 . x86_64 libgcc -4.8.5-39. el7 . x86_64 libstdc ++ -4.8.5-39. el7 . x86_64 ( gdb ) bt #0 0x00007ffff6eb2920 in __cxa_throw () from /usr/lib64/libstdc++.so.6 #1 0x00007ffff72f060e in CppSQLite3DB::open (this=<optimized out>, szFile=<optimized out>) at ./cpp_sqlite3/CppSQLite3.cpp:1216 #2 0x00007ffff7297651 in CHSInsTradeApiCacheService_ust::ApiPushCacheInit (this=0x63a760, cacheFileName = cacheFileName @ entry = 0x7ffff573e400 \"./log/STOCKOPT_HSINSAPI_20200730_1082\" , svrMaxSerialno = 1998 ) at trade_api_cache . cpp : 250 \u901a\u8fc7 bt \u6765\u67e5\u770bstack frame\uff0cframe #1 \u6307\u793a\u4e86\u629b\u51faexception\u7684\u8bed\u53e5\uff1b","title":"\u627e\u51fa\u629b\u51fa\u5f02\u5e38\u7684\u8bed\u53e5"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#catch#syscall","text":"( gdb ) catch syscall Catchpoint 1 ( syscall ) ( gdb ) r Starting program: /tmp/catch-syscall Catchpoint 1 ( call to syscall \u2019close\u2019 ) , \\ 0xffffe424 in __kernel_vsyscall () ( gdb ) c Continuing. Catchpoint 1 ( returned from syscall \u2019close\u2019 ) , \\ 0xffffe424 in __kernel_vsyscall () ( gdb )","title":"catch syscall"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#catch#syscall#chroot","text":"(gdb) catch syscall chroot Catchpoint 1 (syscall \u2019chroot\u2019 [61]) (gdb) r Starting program: /tmp/catch-syscall Catchpoint 1 (call to syscall \u2019chroot\u2019), \\ 0xffffe424 in __kernel_vsyscall () (gdb) c Continuing. Catchpoint 1 (returned from syscall \u2019chroot\u2019), \\ 0xffffe424 in __kernel_vsyscall () (gdb)","title":"catch syscall chroot"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#514#deleting#breakpoints","text":"","title":"5.1.4 Deleting Breakpoints"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#clear","text":"","title":"clear"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#516#break#conditions","text":"The simplest sort of breakpoint breaks every time your program reaches a specified place. You can also specify a condition for a breakpoint. A condition is just a Boolean expression in your programming language (see Section 10.1 [Expressions], page 117). A breakpoint with a condition evaluates the expression each time your program reaches it, and your program stops only if the condition is true .","title":"5.1.6 Break Conditions"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#break#condition#vs#assertion","text":"...","title":"Break Condition VS assertion"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#break#condition#vs#watchpoint","text":"... Break conditions can be specified when a breakpoint is set, by using \u2018if\u2019 in the arguments to the break command. See Section 5.1.1 [Setting Breakpoints], page 46. They can also be changed at any time with the condition command. You can also use the if keyword with the watch command. The catch command does not recognize the if keyword; condition is the only way to impose a further condition on a catchpoint.","title":"Break Condition VS watchpoint"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#condition#bnum#expression","text":"Specify expression as the break condition for breakpoint, watchpoint, or catchpoint number bnum .","title":"condition bnum expression"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#condition#bnum","text":"Remove the condition from breakpoint number bnum .","title":"condition bnum"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#example#specify#a#condition#on#an#existing#breakpoint","text":"\u6587\u7ae0fayewilliams GDB Conditional Breakpoints \u4e2d\u7ed9\u51fa\u4e86\u4e00\u4e9b\u4f8b\u5b50\uff1a example: specify a condition on an existing breakpoint by using the breakpoint number as a reference You can also specify a condition on an existing breakpoint by using the breakpoint number as a reference: cond 3 i == 99 cond 3","title":"Example: specify a condition on an existing breakpoint"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#example#break#if#variable#equal#value","text":"GDB Conditional Breakpoints \u4e2d\u7ed9\u51fa\u7684\u4f8b\u5b50\uff1a b Message.cpp:112 if i == 99 \u6211\u7684\u5b9e\u8df5: b CHQImpl::DealMessage info locals cond 1 nFuncNo = 107 \u4e0a\u8ff0\u8868\u8fbe\u7684\u662f\uff1a\u5f53\u51fd\u6570 CHQImpl::DealMessage \u7684\u4e34\u65f6\u53d8\u91cf nFuncNo \u7684\u503c\u4e3a 107 \u65f6\uff0c\u5219break\u3002 GDB: break if variable equal value \u4e2d\u7ed9\u51fa\u7684\u4f8b\u5b50\uff1a I like to make GDB set a break point when a variable equal some value I set, I tried this example: #include <stdio.h> main () { int i = 0 ; for ( i = 0 ; i < 7 ; ++ i ) printf ( \"%d \\n \" , i ); return 0 ; } A : ( gdb ) break iter.c:6 if i == 5 Breakpoint 2 at 0x4004dc: file iter.c, line 6 . ( gdb ) c Continuing. 0 1 2 3 4 Breakpoint 2 , main () at iter.c:6 6 printf ( \"%d\\n\" , i ) ; If like me you get tired of line numbers changing, you can add a label then set the breakpoint on the label like so: #include <stdio.h> main () { int i = 0 ; for ( i = 0 ; i < 7 ; ++ i ) { looping : printf ( \"%d \\n \" , i ); } return 0 ; } ( gdb ) break main : looping if i == 5","title":"Example: break if variable equal value"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#example_3","text":"GDB Conditional Breakpoints \u4e2d\u7ed9\u51fa\u7684\u4f8b\u5b50\uff1a Pretty much anything you like! Just write the condition exactly as if you were testing for it in your code, e.g.: ( gdb ) cond 1 strcmp ( message, \"earthquake\" ) == 0 //stop if the array message is equal to 'earthquake' ( gdb ) cond 2 *p == 'r' //stop if the char* pointer p points to the letter 'r' (gdb) cond 3 num < 0.75 //stop while the float num is less than 0.75","title":"Example: \u66f4\u52a0\u590d\u6742\u7684\u6761\u4ef6"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#517#breakpoint#command#lists","text":"NOTE: \u8fd9\u662fautomatic gdb debug\u7684\u57fa\u7840\u3002 You can give any breakpoint (or watchpoint or catchpoint ) a series of commands to execute when your program stops due to that breakpoint . For example, you might want to print the values of certain expressions, or enable other breakpoints. commands [range...] ... command-list ... end","title":"5.1.7 Breakpoint Command Lists"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#example#print#variable","text":"For example, here is how you could use breakpoint commands to print the value of x at entry to foo whenever x is positive. break foo if x>0 commands silent printf \"x is %d\\n\" ,x cont end","title":"Example: print variable"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#example#compensate#for#one#bug","text":"One application for breakpoint commands is to compensate(\u507f\u8fd8) for one bug so you can test for another. Put a breakpoint just after the erroneous line of code, give it a condition to detect the case in which something erroneous has been done, and give it commands to assign correct values to any variables that need them. End with the continue command so that your program does not stop, and start with the silent command so that no output is produced. Here is an example: break 403 commands silent set x = y + 4 cont end","title":"Example:  compensate for one bug"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#52#continuing#and#stepping","text":"","title":"5.2 Continuing and Stepping"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#step#vs#next","text":"\u5355\u6b65\u6267\u884c: step next step\u4f1a\u8fdb\u5165\u51fd\u6570 next\u4e0d\u8fdb\u5165\u51fd\u6570 \u9010\u8bed\u53e5 \u9010\u8fc7\u7a0b","title":"step vs next"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5-Stopping-and-Continuing/#_2","text":"\u4ee5function\u4e3a\u5355\u4f4d next \u4ee5statement/source line\u4e3a\u5355\u4f4d step \u4ee5instruction\u4e3a\u5355\u4f4d stepi \u3001 nexti NOTE: \u4e3b\u8981\u7528\u4e8edebug assembly\uff0c\u5173\u4e8edebug assembly\uff0c\u53c2\u89c1 Shell-and-tools\\Tools\\Debug\\GDB\\Guide\\Debug-assembly.md","title":"\u5355\u4f4d"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5.5-Stopping-and-Starting-Multi-thread-Programs/","text":"5.5 Stopping and Starting Multi-thread Programs NOTE: \u662f\u5728\u9605\u8bfb csdn \u7ebf\u7a0b\u7684\u67e5\u770b\u4ee5\u53ca\u5229\u7528gdb\u8c03\u8bd5\u591a\u7ebf\u7a0b \u53d1\u73b0\u7684\u8fd9\u4e2atopic\u3002 There are two modes of controlling execution of your program within the debugger. Mode Explanation Is default all-stop When any thread in your program stops (for example, at a breakpoint or while being stepped), all other threads in the program are also stopped by gdb. yes non-stop Other threads can continue to run freely while you examine the stopped thread in the debugger. 5.5.1 All-Stop Mode Conversely, whenever you restart the program, all threads start executing. This is true even when single-stepping with commands like step or next. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a\u4e00\u65e6\u5f00\u59cbprogram\uff0c\u5219\u6240\u6709\u7684thread\u5f00\u59cb\u6267\u884c\uff0c\u5373\u4f7f\u662f\u4f60\u6b63\u5728\u5355\u6b65\u8c03\u8bd5\u4e00\u4e2athread\uff0c\u5176\u4ed6\u7684thread\u4f9d\u65e7\u5728\u6b63\u5e38\u6267\u884c\u3002 In particular, gdb cannot single-step all threads in lockstep. Since thread scheduling is up to your debugging target\u2019s operating system (not controlled by gdb), other threads may execute more than one statement while the current thread completes a single step. Moreover, in general other threads stop in the middle of a statement, rather than at a clean statement boundary, when the program stops. NOTE: gdb\u80fd\u591f\u5b9e\u73b0\u6240\u6709thread\u7684 \u540c\u65f6\u505c\u6b62\uff0c\u4f46\u662f\u6ca1\u6709\u529e\u6cd5\u4fdd\u8bc1\u6240\u6709\u7684thread\u7684execution\u8fdb\u884c\u63a7\u5236\uff0c\u8fd9\u662f\u56e0\u4e3a\u201cthread scheduling is up to your debugging target\u2019s operating system (not controlled by gdb)\u201d\uff0c\u6bd4\u5982gdb\u65e0\u6cd5\u5b9e\u73b0\u4e0b\u9762\u7684\u8fd9\u4e9b\u63a7\u5236: \u6240\u6709\u7684thread\u90fdsingle-step next\uff08\u53ef\u4ee5\u5b9e\u73b0single-step\u67d0\u4e2a\u6307\u5b9athread\uff0c\u4e0b\u9762\u4f1a\u8fdb\u884c\u4ecb\u7ecd\uff09 Scheduler-locking mode On some OSes, you can modify gdb\u2019s default behavior by locking the OS scheduler to allow only a single thread to run. NOTE: \u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4ec5\u4ec5\u5e0c\u671b\u4e00\u4e2athread\u8fd0\u884c\uff0c\u5176\u4ed6\u7684thread\u90fdstop\uff0cgdb\u4e5f\u4e3auser\u63d0\u4f9b\u4e86\u8fd9\u79cdpower\u3002 set scheduler-locking mode Set the scheduler locking mode. It applies to normal execution , record mode , and replay mode . If it is off, then there is no locking and any thread may run at any time. If on, then only the current thread may\uff08\u4e4b\u6240\u4ee5\u4f7f\u7528**may**\u4fee\u9970\u662f\u56e0\u4e3ascheduler\u662f\u7531OS\u6765\u5b9e\u73b0\u7684\uff09 run when the inferior is resumed. The step mode optimizes for single-stepping; it prevents other threads from preempting the current thread while you are stepping, so that the focus of debugging does not change unexpectedly. Other threads never get a chance to run when you step, and they are completely free to run when you use commands like \u2018 continue \u2019, \u2018 until \u2019, or \u2018 finish \u2019. However, unless another thread hits a breakpoint during its timeslice, gdb does not change the current thread away from the thread that you are debugging. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a\u5f53\u5f00\u542f scheduler-locking \u7684\u65f6\u5019\uff0c\u53ea\u6709current thread\u80fd\u591f\u88ab\u6267\u884c\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cuser\u53ef\u4ee5single-step current thread\uff0c\u56e0\u6b64\u5b9e\u73b0\u4e86\u201cthe focus of debugging does not change unexpectedly\u201d\uff1b\u5f53\u6267\u884c \u2018 continue \u2019, \u2018 until \u2019, or \u2018 finish \u2019\u7b49\u6307\u4ee4\u7684\u540e\uff0c\u5219\u5176\u4ed6thread\u90fd\u5f00\u59cb\u6267\u884c\u4e86\uff0c\u90a3\u8fd9\u662f\u5426\u76f8\u5f53\u4e8e\u5173\u95ed\u4e86 scheduler-locking \uff1f\u4e0d\u662f\u7684\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u6267\u884c \u2018 continue \u2019, \u2018 until \u2019, or \u2018 finish \u2019\u7b49\u6307\u4ee4\uff0c\u8868\u793a\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86current thread\u7684debug\uff0c\u53ef\u4ee5debug\u5176\u4ed6thread\u4e86\u3002\u5f53\u53e6\u5916thread hit breakpoint\u540e\uff0c\u6211\u4eec\u53ef\u4ee5single-step\u90a3\u4e2athread\u4e86\u3002\u663e\u7136\uff0c\u5f53\u5f00\u542fscheduler-locking mode\uff0c\u5219\u8fdb\u5165\u4e86\u4e0a\u8ff0\u6267\u884c\u6a21\u5f0f\u3002 \u603b\u7684\u6765\u8bf4\uff0c\u901a\u8fc7scheduler-locking\uff0c\u6211\u4eec\u53ef\u4ee5\u5b9e\u73b0single-step single thread\u3002 The replay mode behaves like off in record mode and like on in replay mode. NOTE: \u8fd9\u6bb5\u8bdd\u6ca1\u6709\u7406\u89e3 show scheduler-locking Display the current scheduler locking mode. Example csdn \u7ebf\u7a0b\u7684\u67e5\u770b\u4ee5\u53ca\u5229\u7528gdb\u8c03\u8bd5\u591a\u7ebf\u7a0b Schedule-multiple mode By default, when you issue one of the execution commands such as continue , next or step , gdb allows only threads of the current inferior to run. For example, if gdb is attached to two inferiors, each with two threads, the continue command resumes only the two threads of the current inferior . This is useful, for example, when you debug a program that forks and you want to hold the parent stopped (so that, for instance, it doesn\u2019t run to exit), while you debug the child. In other situations, you may not be interested in inspecting the current state of any of the processes gdb is attached to, and you may want to resume them all until some breakpoint is hit. In the latter case, you can instruct gdb to allow all threads of all the inferiors to run with the set schedule-multiple command. set schedule-multiple 5.5.2 Non-Stop Mode 5.5.3 Background Execution NOTE: \u975e\u5e38\u7c7b\u4f3c\u4e8eshell\u4e2d\u7684\u505a\u6cd5 gdb\u2019s execution commands have two variants: Mode Explanation Is default foreground (synchronous) gdb waits for the program to report that some thread has stopped before prompting for another command. yes background (asynchronous) gdb immediately gives a command prompt so that you can issue other commands while your program runs. To specify background execution, add a & to the command. 5.5.4 Thread-Specific Breakpoints break location thread thread-id break location thread thread-id if ... Example Multithreaded Debugging Techniques","title":"5.5-Stopping-and-Starting-Multi-thread-Programs"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5.5-Stopping-and-Starting-Multi-thread-Programs/#55#stopping#and#starting#multi-thread#programs","text":"NOTE: \u662f\u5728\u9605\u8bfb csdn \u7ebf\u7a0b\u7684\u67e5\u770b\u4ee5\u53ca\u5229\u7528gdb\u8c03\u8bd5\u591a\u7ebf\u7a0b \u53d1\u73b0\u7684\u8fd9\u4e2atopic\u3002 There are two modes of controlling execution of your program within the debugger. Mode Explanation Is default all-stop When any thread in your program stops (for example, at a breakpoint or while being stepped), all other threads in the program are also stopped by gdb. yes non-stop Other threads can continue to run freely while you examine the stopped thread in the debugger.","title":"5.5 Stopping and Starting Multi-thread Programs"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5.5-Stopping-and-Starting-Multi-thread-Programs/#551#all-stop#mode","text":"Conversely, whenever you restart the program, all threads start executing. This is true even when single-stepping with commands like step or next. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a\u4e00\u65e6\u5f00\u59cbprogram\uff0c\u5219\u6240\u6709\u7684thread\u5f00\u59cb\u6267\u884c\uff0c\u5373\u4f7f\u662f\u4f60\u6b63\u5728\u5355\u6b65\u8c03\u8bd5\u4e00\u4e2athread\uff0c\u5176\u4ed6\u7684thread\u4f9d\u65e7\u5728\u6b63\u5e38\u6267\u884c\u3002 In particular, gdb cannot single-step all threads in lockstep. Since thread scheduling is up to your debugging target\u2019s operating system (not controlled by gdb), other threads may execute more than one statement while the current thread completes a single step. Moreover, in general other threads stop in the middle of a statement, rather than at a clean statement boundary, when the program stops. NOTE: gdb\u80fd\u591f\u5b9e\u73b0\u6240\u6709thread\u7684 \u540c\u65f6\u505c\u6b62\uff0c\u4f46\u662f\u6ca1\u6709\u529e\u6cd5\u4fdd\u8bc1\u6240\u6709\u7684thread\u7684execution\u8fdb\u884c\u63a7\u5236\uff0c\u8fd9\u662f\u56e0\u4e3a\u201cthread scheduling is up to your debugging target\u2019s operating system (not controlled by gdb)\u201d\uff0c\u6bd4\u5982gdb\u65e0\u6cd5\u5b9e\u73b0\u4e0b\u9762\u7684\u8fd9\u4e9b\u63a7\u5236: \u6240\u6709\u7684thread\u90fdsingle-step next\uff08\u53ef\u4ee5\u5b9e\u73b0single-step\u67d0\u4e2a\u6307\u5b9athread\uff0c\u4e0b\u9762\u4f1a\u8fdb\u884c\u4ecb\u7ecd\uff09","title":"5.5.1 All-Stop Mode"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5.5-Stopping-and-Starting-Multi-thread-Programs/#scheduler-locking#mode","text":"On some OSes, you can modify gdb\u2019s default behavior by locking the OS scheduler to allow only a single thread to run. NOTE: \u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4ec5\u4ec5\u5e0c\u671b\u4e00\u4e2athread\u8fd0\u884c\uff0c\u5176\u4ed6\u7684thread\u90fdstop\uff0cgdb\u4e5f\u4e3auser\u63d0\u4f9b\u4e86\u8fd9\u79cdpower\u3002 set scheduler-locking mode Set the scheduler locking mode. It applies to normal execution , record mode , and replay mode . If it is off, then there is no locking and any thread may run at any time. If on, then only the current thread may\uff08\u4e4b\u6240\u4ee5\u4f7f\u7528**may**\u4fee\u9970\u662f\u56e0\u4e3ascheduler\u662f\u7531OS\u6765\u5b9e\u73b0\u7684\uff09 run when the inferior is resumed. The step mode optimizes for single-stepping; it prevents other threads from preempting the current thread while you are stepping, so that the focus of debugging does not change unexpectedly. Other threads never get a chance to run when you step, and they are completely free to run when you use commands like \u2018 continue \u2019, \u2018 until \u2019, or \u2018 finish \u2019. However, unless another thread hits a breakpoint during its timeslice, gdb does not change the current thread away from the thread that you are debugging. NOTE: \u4e0a\u9762\u8fd9\u6bb5\u8bdd\u7684\u610f\u601d\u662f\uff1a\u5f53\u5f00\u542f scheduler-locking \u7684\u65f6\u5019\uff0c\u53ea\u6709current thread\u80fd\u591f\u88ab\u6267\u884c\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cuser\u53ef\u4ee5single-step current thread\uff0c\u56e0\u6b64\u5b9e\u73b0\u4e86\u201cthe focus of debugging does not change unexpectedly\u201d\uff1b\u5f53\u6267\u884c \u2018 continue \u2019, \u2018 until \u2019, or \u2018 finish \u2019\u7b49\u6307\u4ee4\u7684\u540e\uff0c\u5219\u5176\u4ed6thread\u90fd\u5f00\u59cb\u6267\u884c\u4e86\uff0c\u90a3\u8fd9\u662f\u5426\u76f8\u5f53\u4e8e\u5173\u95ed\u4e86 scheduler-locking \uff1f\u4e0d\u662f\u7684\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u6267\u884c \u2018 continue \u2019, \u2018 until \u2019, or \u2018 finish \u2019\u7b49\u6307\u4ee4\uff0c\u8868\u793a\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86current thread\u7684debug\uff0c\u53ef\u4ee5debug\u5176\u4ed6thread\u4e86\u3002\u5f53\u53e6\u5916thread hit breakpoint\u540e\uff0c\u6211\u4eec\u53ef\u4ee5single-step\u90a3\u4e2athread\u4e86\u3002\u663e\u7136\uff0c\u5f53\u5f00\u542fscheduler-locking mode\uff0c\u5219\u8fdb\u5165\u4e86\u4e0a\u8ff0\u6267\u884c\u6a21\u5f0f\u3002 \u603b\u7684\u6765\u8bf4\uff0c\u901a\u8fc7scheduler-locking\uff0c\u6211\u4eec\u53ef\u4ee5\u5b9e\u73b0single-step single thread\u3002 The replay mode behaves like off in record mode and like on in replay mode. NOTE: \u8fd9\u6bb5\u8bdd\u6ca1\u6709\u7406\u89e3 show scheduler-locking Display the current scheduler locking mode. Example csdn \u7ebf\u7a0b\u7684\u67e5\u770b\u4ee5\u53ca\u5229\u7528gdb\u8c03\u8bd5\u591a\u7ebf\u7a0b","title":"Scheduler-locking mode"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5.5-Stopping-and-Starting-Multi-thread-Programs/#schedule-multiple#mode","text":"By default, when you issue one of the execution commands such as continue , next or step , gdb allows only threads of the current inferior to run. For example, if gdb is attached to two inferiors, each with two threads, the continue command resumes only the two threads of the current inferior . This is useful, for example, when you debug a program that forks and you want to hold the parent stopped (so that, for instance, it doesn\u2019t run to exit), while you debug the child. In other situations, you may not be interested in inspecting the current state of any of the processes gdb is attached to, and you may want to resume them all until some breakpoint is hit. In the latter case, you can instruct gdb to allow all threads of all the inferiors to run with the set schedule-multiple command. set schedule-multiple","title":"Schedule-multiple mode"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5.5-Stopping-and-Starting-Multi-thread-Programs/#552#non-stop#mode","text":"","title":"5.5.2 Non-Stop Mode"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5.5-Stopping-and-Starting-Multi-thread-Programs/#553#background#execution","text":"NOTE: \u975e\u5e38\u7c7b\u4f3c\u4e8eshell\u4e2d\u7684\u505a\u6cd5 gdb\u2019s execution commands have two variants: Mode Explanation Is default foreground (synchronous) gdb waits for the program to report that some thread has stopped before prompting for another command. yes background (asynchronous) gdb immediately gives a command prompt so that you can issue other commands while your program runs. To specify background execution, add a & to the command.","title":"5.5.3 Background Execution"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/5.5-Stopping-and-Starting-Multi-thread-Programs/#554#thread-specific#breakpoints","text":"break location thread thread-id break location thread thread-id if ... Example Multithreaded Debugging Techniques","title":"5.5.4 Thread-Specific Breakpoints"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/Breakpoint-conditional-expressions/","text":"Breakpoint conditional expressions \u5728\u9605\u8bfbDebugging with gdb chapter 4.9 Debugging Multiple Inferiors and Programs\u65f6\uff0c\u5176\u4e2d\u63cf\u8ff0\uff1a The debugger convenience variable \u2018$_inferior\u2019 contains the number of the current inferior. You may find this useful in writing breakpoint conditional expressions , command scripts, and so forth. \u9042\u51b3\u5b9a\u5bf9**breakpoint conditional expressions**\u8fdb\u884c\u4e13\u95e8\u603b\u7ed3\u3002","title":"Breakpoint-conditional-expressions"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/5-Stopping-and-Continuing/Breakpoint-conditional-expressions/#breakpoint#conditional#expressions","text":"\u5728\u9605\u8bfbDebugging with gdb chapter 4.9 Debugging Multiple Inferiors and Programs\u65f6\uff0c\u5176\u4e2d\u63cf\u8ff0\uff1a The debugger convenience variable \u2018$_inferior\u2019 contains the number of the current inferior. You may find this useful in writing breakpoint conditional expressions , command scripts, and so forth. \u9042\u51b3\u5b9a\u5bf9**breakpoint conditional expressions**\u8fdb\u884c\u4e13\u95e8\u603b\u7ed3\u3002","title":"Breakpoint conditional expressions"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/6-Running-programs-backward/6-Running-programs-backward/","text":"6 Running programs backward","title":"6-Running-programs-backward"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/6-Running-programs-backward/6-Running-programs-backward/#6#running#programs#backward","text":"","title":"6 Running programs backward"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/7-Recording-Inferior%27s-Execution-and-Replaying-It/","text":"7 Recording Inferior\u2019s Execution and Replaying It NOTE: \u53c2\u89c1: wikipedia Record and replay debugging \u8fd9\u79cdrecord log and replay\u7684\u505a\u6cd5\u5728\u5f88\u591a\u5730\u65b9\u90fd\u7528\u5230\u4e86\uff1a Redis: Append only file persistence wikipedia database transaction log The Log: What every software engineer should know about real-time data's unifying abstraction DistributedLog: A Technical Review of Kafka and DistributedLog","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/7-Recording-Inferior%27s-Execution-and-Replaying-It/#7#recording#inferiors#execution#and#replaying#it","text":"NOTE: \u53c2\u89c1: wikipedia Record and replay debugging \u8fd9\u79cdrecord log and replay\u7684\u505a\u6cd5\u5728\u5f88\u591a\u5730\u65b9\u90fd\u7528\u5230\u4e86\uff1a Redis: Append only file persistence wikipedia database transaction log The Log: What every software engineer should know about real-time data's unifying abstraction DistributedLog: A Technical Review of Kafka and DistributedLog","title":"7 Recording Inferior\u2019s Execution and Replaying It"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/","text":"8 Examining the Stack When your program has stopped, the first thing you need to know is where it stopped and how it got there. Each time your program performs a function call, information about the call is generated. That information includes the location of the call in your program, the arguments of the call, and the local variables of the function being called. The information is saved in a block of data called a stack frame . The stack frames are allocated in a region of memory called the call stack . One of the stack frames is selected by gdb and many gdb commands refer implicitly to the selected frame. In particular, whenever you ask gdb for the value of a variable in your program, the value is found in the selected frame. There are special gdb commands to select whichever frame you are interested in. See Section 8.3 [Selecting a Frame], page 98. NOTE: \u9ed8\u8ba4\u9009\u4e2d\u7684stack frame: current inferior\u7684current thread\u7684current frame\uff0c\u5373frame 0\u3002 \u5c24\u5176\u662f\u5728debug\u4e00\u4e2aalready running process\u7684\u65f6\u5019\uff0c\u5fc5\u987b\u5148select\u4e00\u4e2aframe\uff0c\u7136\u540e\u624d\u80fd\u591f\u67e5\u770b\u5176\u4e2d\u7684variable\u3002 8.1 Stack Frames The call stack is divided up into contiguous pieces called stack frames, or frames for short; each frame is the data associated with one call to one function. The frame contains the arguments given to the function, the function\u2019s local variables, and the address at which the function is executing. 8.2 Backtraces A backtrace is a summary of how your program got where it is. It shows one line per frame, for many frames, starting with the currently executing frame (frame zero), followed by its caller (frame one), and on up the stack. backtrace / bt 8.3 Selecting a Frame Most commands for examining the stack and other data in your program work on whichever stack frame is selected at the moment. Here are the commands for selecting a stack frame; all of them finish by printing a brief description of the stack frame just selected. frame n up n down n 8.4 Information About a Frame There are several other commands to print information about the selected stack frame. frame z info frame 8.5 Applying a Command to Several Frames. frame apply 8.6 Management of Frame Filters.","title":"8-Examining-the-Stack"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#8#examining#the#stack","text":"When your program has stopped, the first thing you need to know is where it stopped and how it got there. Each time your program performs a function call, information about the call is generated. That information includes the location of the call in your program, the arguments of the call, and the local variables of the function being called. The information is saved in a block of data called a stack frame . The stack frames are allocated in a region of memory called the call stack . One of the stack frames is selected by gdb and many gdb commands refer implicitly to the selected frame. In particular, whenever you ask gdb for the value of a variable in your program, the value is found in the selected frame. There are special gdb commands to select whichever frame you are interested in. See Section 8.3 [Selecting a Frame], page 98. NOTE: \u9ed8\u8ba4\u9009\u4e2d\u7684stack frame: current inferior\u7684current thread\u7684current frame\uff0c\u5373frame 0\u3002 \u5c24\u5176\u662f\u5728debug\u4e00\u4e2aalready running process\u7684\u65f6\u5019\uff0c\u5fc5\u987b\u5148select\u4e00\u4e2aframe\uff0c\u7136\u540e\u624d\u80fd\u591f\u67e5\u770b\u5176\u4e2d\u7684variable\u3002","title":"8 Examining the Stack"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#81#stack#frames","text":"The call stack is divided up into contiguous pieces called stack frames, or frames for short; each frame is the data associated with one call to one function. The frame contains the arguments given to the function, the function\u2019s local variables, and the address at which the function is executing.","title":"8.1 Stack Frames"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#82#backtraces","text":"A backtrace is a summary of how your program got where it is. It shows one line per frame, for many frames, starting with the currently executing frame (frame zero), followed by its caller (frame one), and on up the stack.","title":"8.2 Backtraces"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#backtrace#bt","text":"","title":"backtrace / bt"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#83#selecting#a#frame","text":"Most commands for examining the stack and other data in your program work on whichever stack frame is selected at the moment. Here are the commands for selecting a stack frame; all of them finish by printing a brief description of the stack frame just selected.","title":"8.3 Selecting a Frame"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#frame#n","text":"","title":"frame n"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#up#n","text":"","title":"up n"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#down#n","text":"","title":"down n"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#84#information#about#a#frame","text":"There are several other commands to print information about the selected stack frame.","title":"8.4 Information About a Frame"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#framez","text":"","title":"framez"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#info#frame","text":"","title":"info frame"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#85#applying#a#command#to#several#frames","text":"","title":"8.5 Applying a Command to Several Frames."},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#frame#apply","text":"","title":"frame apply"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/8-Examining-the-Stack/8-Examining-the-Stack/#86#management#of#frame#filters","text":"","title":"8.6 Management of Frame Filters."},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/9-Examining-Source-Files/9-Examining-Source-Files/","text":"9 Examining Source Files 9.1 Printing Source Lines 9.2 Specifying a Location 9.3 Editing Source Files 9.6 Source and Machine Code disassemble Example Few GDB Commands \u2013 Debug Core, Disassemble, Load Shared Library : (gdb) disassemble main Dump of assembler code for function main: 0x00000000004004ac : push %rbp 0x00000000004004ad : mov %rsp,%rbp 0x00000000004004b0 : mov $0x0,%eax 0x00000000004004b5 : pop %rbp 0x00000000004004b6 : retq End of assembler dump.","title":"9-Examining-Source-Files"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/9-Examining-Source-Files/9-Examining-Source-Files/#9#examining#source#files","text":"","title":"9 Examining Source Files"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/9-Examining-Source-Files/9-Examining-Source-Files/#91#printing#source#lines","text":"","title":"9.1 Printing Source Lines"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/9-Examining-Source-Files/9-Examining-Source-Files/#92#specifying#a#location","text":"","title":"9.2 Specifying a Location"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/9-Examining-Source-Files/9-Examining-Source-Files/#93#editing#source#files","text":"","title":"9.3 Editing Source Files"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/9-Examining-Source-Files/9-Examining-Source-Files/#96#source#and#machine#code","text":"","title":"9.6 Source and Machine Code"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/9-Examining-Source-Files/9-Examining-Source-Files/#disassemble","text":"","title":"disassemble"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/9-Examining-Source-Files/9-Examining-Source-Files/#example","text":"Few GDB Commands \u2013 Debug Core, Disassemble, Load Shared Library : (gdb) disassemble main Dump of assembler code for function main: 0x00000000004004ac : push %rbp 0x00000000004004ad : mov %rsp,%rbp 0x00000000004004b0 : mov $0x0,%eax 0x00000000004004b5 : pop %rbp 0x00000000004004b6 : retq End of assembler dump.","title":"Example"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/","text":"\u5173\u4e8e\u672c\u7ae0 gdb\u7684\u7528\u6237\u624b\u518c Debugging with GDB \u4e2d\u7684\u5185\u5bb9\u662f\u975e\u5e38\u5b8c\u5907\uff0c\u4f46\u662f\u5e9e\u6742\uff0c\u4e3a\u4e86\u66f4\u597d\u5730\u638c\u63e1\u5176\u4e2d\u7684\u5185\u5bb9\uff0c\u672c\u7ae0\u5bf9Debugging with gdb\u4e2d\u7684\u5185\u5bb9\u8fdb\u884c: \u68b3\u7406\uff0c\u4ece\u66f4\u9ad8\u7684\u89d2\u5ea6\u5bf9\u539f\u6587\u4e2d\u7684\u5185\u5bb9\u8fdb\u884c\u603b\u7ed3 \u4e13\u9898\u8ba8\u8bba \u53e6\u5916\u672c\u7ae0\u8fd8\u53c2\u8003\u4e86\uff1a visualgdb GDB Command Reference cnblogs gdb\u547d\u4ee4\u8c03\u8bd5\u6280\u5de7 Debugging with GDB \u5185\u5bb9\u6982\u8ff0 Debugging with GDB \u4e2d\u7684\u5185\u5bb9\u662f\u975e\u5e38\u5e9e\u6742\u7684\uff0c\u56e0\u6b64\u5bf9\u4e66\u4e2d\u5185\u5bb9\u5efa\u7acb\u4e00\u4e2a\u9ad8\u5c4b\u5efa\u74f4\u7684\u89c6\u89d2\u662f\u975e\u5e38\u6709\u5fc5\u8981\u7684\u3002\u672c\u8282\u91c7\u53d6\u7684\u662f\u201c\u57fa\u4e8e\u7279\u6027\u201d\u8fdb\u884c\u6982\u62ec\u7684\u601d\u8def\u3002 Control process \u5728 Shell-and-tools\\Tools\\Debug\\GDB\\Debugging-with-gdb\\Guide\\Guide-to-controlling-process.md \u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u8ba8\u8bba\u3002 Examine data \u5728 Shell-and-tools\\Tools\\Debug\\GDB\\Debugging-with-gdb\\Guide\\Guide-to-examining-data.md \u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u8ba8\u8bba\u3002","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/#_1","text":"gdb\u7684\u7528\u6237\u624b\u518c Debugging with GDB \u4e2d\u7684\u5185\u5bb9\u662f\u975e\u5e38\u5b8c\u5907\uff0c\u4f46\u662f\u5e9e\u6742\uff0c\u4e3a\u4e86\u66f4\u597d\u5730\u638c\u63e1\u5176\u4e2d\u7684\u5185\u5bb9\uff0c\u672c\u7ae0\u5bf9Debugging with gdb\u4e2d\u7684\u5185\u5bb9\u8fdb\u884c: \u68b3\u7406\uff0c\u4ece\u66f4\u9ad8\u7684\u89d2\u5ea6\u5bf9\u539f\u6587\u4e2d\u7684\u5185\u5bb9\u8fdb\u884c\u603b\u7ed3 \u4e13\u9898\u8ba8\u8bba \u53e6\u5916\u672c\u7ae0\u8fd8\u53c2\u8003\u4e86\uff1a visualgdb GDB Command Reference cnblogs gdb\u547d\u4ee4\u8c03\u8bd5\u6280\u5de7","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/#debugging#with#gdb","text":"Debugging with GDB \u4e2d\u7684\u5185\u5bb9\u662f\u975e\u5e38\u5e9e\u6742\u7684\uff0c\u56e0\u6b64\u5bf9\u4e66\u4e2d\u5185\u5bb9\u5efa\u7acb\u4e00\u4e2a\u9ad8\u5c4b\u5efa\u74f4\u7684\u89c6\u89d2\u662f\u975e\u5e38\u6709\u5fc5\u8981\u7684\u3002\u672c\u8282\u91c7\u53d6\u7684\u662f\u201c\u57fa\u4e8e\u7279\u6027\u201d\u8fdb\u884c\u6982\u62ec\u7684\u601d\u8def\u3002","title":"Debugging with GDB \u5185\u5bb9\u6982\u8ff0"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/#control#process","text":"\u5728 Shell-and-tools\\Tools\\Debug\\GDB\\Debugging-with-gdb\\Guide\\Guide-to-controlling-process.md \u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u8ba8\u8bba\u3002","title":"Control process"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/#examine#data","text":"\u5728 Shell-and-tools\\Tools\\Debug\\GDB\\Debugging-with-gdb\\Guide\\Guide-to-examining-data.md \u4e2d\u5bf9\u6b64\u8fdb\u884c\u4e86\u8ba8\u8bba\u3002","title":"Examine data"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Debug-assembly/","text":"Debug assembly \u662f\u5728\u9605\u8bfb View Both Assembly and C code \u7684 \u56de\u7b54 \u65f6\u60f3\u5230\u7684\u8fd9\u4e2a\u95ee\u9898\uff1a View Both Assembly and C code You can run gdb in Text User Interface (TUI) mode: gdb -tui <your-binary> (gdb) b main (gdb) r (gdb) layout split The layout split command divides the window into two parts - one of them displaying the source code, the other one the corresponding assembly. A few others tricks: set disassembly-flavor intel - if your prefer intel notation set print asm-demangle - demangles C++ names in assembly view ni - next instruction si - step instruction If you do not want to use the TUI mode (e.g. your terminal does not like it), you can always do: x /12i $pc which means print 12 instructions from current program counter address - this also works with the tricks above (demangling, stepping instructions, etc.). The \"x /12i $pc\" trick works in both gdb and cgdb, whereas \"layout split\" only works in gdb. Enjoy :)","title":"Debug-assembly"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Debug-assembly/#debug#assembly","text":"\u662f\u5728\u9605\u8bfb View Both Assembly and C code \u7684 \u56de\u7b54 \u65f6\u60f3\u5230\u7684\u8fd9\u4e2a\u95ee\u9898\uff1a","title":"Debug assembly"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Debug-assembly/#view#both#assembly#and#c#code","text":"You can run gdb in Text User Interface (TUI) mode: gdb -tui <your-binary> (gdb) b main (gdb) r (gdb) layout split The layout split command divides the window into two parts - one of them displaying the source code, the other one the corresponding assembly. A few others tricks: set disassembly-flavor intel - if your prefer intel notation set print asm-demangle - demangles C++ names in assembly view ni - next instruction si - step instruction If you do not want to use the TUI mode (e.g. your terminal does not like it), you can always do: x /12i $pc which means print 12 instructions from current program counter address - this also works with the tricks above (demangling, stepping instructions, etc.). The \"x /12i $pc\" trick works in both gdb and cgdb, whereas \"layout split\" only works in gdb. Enjoy :)","title":"View Both Assembly and C code"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Guide-to-controlling-process/","text":"Guide to controlling process \u672c\u6587\u4e3b\u8981\u8ba8\u8bba\u7684\u5185\u5bb9\u662f\uff1a\u5bf9process\u7684\u8fd0\u884c\u8fdb\u884c\u63a7\u5236\uff0c\u5b83\u662fgdb\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u7279\u6027\u3002 \u7ae0\u8282 run and kill\uff0c\u5373\u8fd0\u884c\u548c\u7ec8\u6b62\u7a0b\u5e8f\uff0c\u4e0b\u9762\u662f\u6d89\u53ca\u8fd9\u4e2a\u4e3b\u9898\u7684\u7ae0\u8282 4 Running Programs Under GDB 6 Running programs backward 7 Recording Inferior\u2019s Execution and Replaying It stop and continue\uff0c\u5373\u5728process\u8fd0\u884c\u8fc7\u7a0b\u4e2d\uff0cstop\u3001continue\uff0c\u4e0b\u9762\u662f\u6d89\u53ca\u8fd9\u4e2a\u4e3b\u9898\u7684\u7ae0\u8282\uff1a 5 Stopping and Continuing alter 17 Altering Execution Mode process execution \u662f\u975e\u5e38\u590d\u6742\u7684\uff0c\u5b83\u4e0d\u4ec5\u4ec5\u6d89\u53cagdb\uff0c\u8fd8\u6d89\u53caOS\uff1b\u5bf9\u4e8e\u5404\u79cd\u590d\u6742\u7684\u573a\u666f\uff0cgdb\u90fd\u6709\u7740\u8f83\u597d\u7684\u652f\u6301\uff0c\u56e0\u6b64\u53ef\u4ee5\u770b\u5230\uff0c\u5728gdb\u4e2d\uff0c\u6709\u7740\u975e\u5e38\u591a\u7684mode\uff0c\u672c\u8282\u5bf9gdb\u4e2d\u6d89\u53caprocess execution\u7684mode\u8fdb\u884c\u6c47\u603b\uff1a Mode \u7ae0\u8282 \u7b80\u4ecb All-Stop Mode and Non-Stop Mode 5.5 Stopping and Starting Multi-thread Programs Scheduler locking mode 5.5.1 All-Stop Mode Schedule-multiple mode 5.5.1 All-Stop Mode Normal execution\u3001record mode and replay mode 7 Recording Inferior\u2019s Execution and Replaying It Foreground (synchronous) and background (asynchronous) 5.5.3 Background Execution Command shortcut command chapter explanation run See Starting your Program . attach See Debugging an Already-running Process . step See step . stepi See stepi . next See next . nexti See nexti . continue See continue . finish See finish . until See until .","title":"Guide-to-controlling-process"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Guide-to-controlling-process/#guide#to#controlling#process","text":"\u672c\u6587\u4e3b\u8981\u8ba8\u8bba\u7684\u5185\u5bb9\u662f\uff1a\u5bf9process\u7684\u8fd0\u884c\u8fdb\u884c\u63a7\u5236\uff0c\u5b83\u662fgdb\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u7279\u6027\u3002","title":"Guide to controlling process"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Guide-to-controlling-process/#_1","text":"run and kill\uff0c\u5373\u8fd0\u884c\u548c\u7ec8\u6b62\u7a0b\u5e8f\uff0c\u4e0b\u9762\u662f\u6d89\u53ca\u8fd9\u4e2a\u4e3b\u9898\u7684\u7ae0\u8282 4 Running Programs Under GDB 6 Running programs backward 7 Recording Inferior\u2019s Execution and Replaying It stop and continue\uff0c\u5373\u5728process\u8fd0\u884c\u8fc7\u7a0b\u4e2d\uff0cstop\u3001continue\uff0c\u4e0b\u9762\u662f\u6d89\u53ca\u8fd9\u4e2a\u4e3b\u9898\u7684\u7ae0\u8282\uff1a 5 Stopping and Continuing alter 17 Altering Execution","title":"\u7ae0\u8282"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Guide-to-controlling-process/#mode","text":"process execution \u662f\u975e\u5e38\u590d\u6742\u7684\uff0c\u5b83\u4e0d\u4ec5\u4ec5\u6d89\u53cagdb\uff0c\u8fd8\u6d89\u53caOS\uff1b\u5bf9\u4e8e\u5404\u79cd\u590d\u6742\u7684\u573a\u666f\uff0cgdb\u90fd\u6709\u7740\u8f83\u597d\u7684\u652f\u6301\uff0c\u56e0\u6b64\u53ef\u4ee5\u770b\u5230\uff0c\u5728gdb\u4e2d\uff0c\u6709\u7740\u975e\u5e38\u591a\u7684mode\uff0c\u672c\u8282\u5bf9gdb\u4e2d\u6d89\u53caprocess execution\u7684mode\u8fdb\u884c\u6c47\u603b\uff1a Mode \u7ae0\u8282 \u7b80\u4ecb All-Stop Mode and Non-Stop Mode 5.5 Stopping and Starting Multi-thread Programs Scheduler locking mode 5.5.1 All-Stop Mode Schedule-multiple mode 5.5.1 All-Stop Mode Normal execution\u3001record mode and replay mode 7 Recording Inferior\u2019s Execution and Replaying It Foreground (synchronous) and background (asynchronous) 5.5.3 Background Execution","title":"Mode"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Guide-to-controlling-process/#command#shortcut","text":"command chapter explanation run See Starting your Program . attach See Debugging an Already-running Process . step See step . stepi See stepi . next See next . nexti See nexti . continue See continue . finish See finish . until See until .","title":"Command shortcut"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Guide-to-examining-data/","text":"Guide to examining data \u672c\u6587\u4e3b\u8981\u8ba8\u8bba\u7684\u5185\u5bb9\u662f\uff1a\u67e5\u770b\u6570\u636e\uff0c\u5b83\u662fgdb\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u7279\u6027\u3002 \u7ae0\u8282 \u4e0b\u9762\u662f\u6d89\u53ca\u8fd9\u4e2a\u4e3b\u9898\u7684\u7ae0\u8282\uff1a 8 Examining the Stack 9 Examining Source Files 10 Examining Data 16 Examining the Symbol Table Search gdb\u63d0\u4f9b\u4e86search\u529f\u80fd\uff0c\u4fbf\u4e8e\u7528\u6237\u5feb\u901f\u5b9a\u4f4d\u5230\u76ee\u6807\u3002 9.4 Searching Source Files 10.22 Search Memory","title":"Guide-to-examining-data"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Guide-to-examining-data/#guide#to#examining#data","text":"\u672c\u6587\u4e3b\u8981\u8ba8\u8bba\u7684\u5185\u5bb9\u662f\uff1a\u67e5\u770b\u6570\u636e\uff0c\u5b83\u662fgdb\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u7279\u6027\u3002","title":"Guide to examining data"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Guide-to-examining-data/#_1","text":"\u4e0b\u9762\u662f\u6d89\u53ca\u8fd9\u4e2a\u4e3b\u9898\u7684\u7ae0\u8282\uff1a 8 Examining the Stack 9 Examining Source Files 10 Examining Data 16 Examining the Symbol Table","title":"\u7ae0\u8282"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Guide-to-examining-data/#search","text":"gdb\u63d0\u4f9b\u4e86search\u529f\u80fd\uff0c\u4fbf\u4e8e\u7528\u6237\u5feb\u901f\u5b9a\u4f4d\u5230\u76ee\u6807\u3002 9.4 Searching Source Files 10.22 Search Memory","title":"Search"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Point-in-GDB/","text":"Point in GDB breakpoint\u3001watchpoint\u3001catchpoint: \u53c2\u89c1 5.1 Breakpoints, Watchpoints, and Catchpoints tracepoint: \u53c2\u89c1 13 Tracepoints","title":"Point-in-GDB"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Point-in-GDB/#point#in#gdb","text":"breakpoint\u3001watchpoint\u3001catchpoint: \u53c2\u89c1 5.1 Breakpoints, Watchpoints, and Catchpoints tracepoint: \u53c2\u89c1 13 Tracepoints","title":"Point in GDB"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Args/","text":"args \u4f7f\u7528gdb\u8c03\u8bd5\u7684\u65f6\u5019,\u5982\u4f55\u4f20\u9012\u53c2\u6570\u7684\u5e94\u7528\u7a0b\u5e8f?\u672c\u6587\u5bf9\u6b64\u8fdb\u884c\u603b\u7ed3. gdb --args \u5728 \u300aDebugging with gdb\u300b\u7684\"2 Getting In and Out of gdb\"\u4e2d\uff0c\u4ecb\u7ecd\u4e86\u8fd9\u79cd\u7528\u6cd5: gdb --args gcc -O2 -c foo.c stackoverflow How do I run a program with commandline arguments using GDB within a Bash script? A You can run gdb with --args parameter, gdb --args executablename arg1 arg2 arg3 If you want it to run automatically, place some commands in a file (e.g. 'run') and give it as argument: -x /tmp/cmds. Optionally you can run with -batch mode. gdb -batch -x /tmp/cmds --args executablename arg1 arg2 arg3 A Another way to do this, which I personally find slightly more convenient and intuitive (without having to remember the --args parameter), is to compile normally, and use r arg1 arg2 arg3 directly from within gdb , like so: $ gcc -g *.c *.h $ gdb ./a.out (gdb) r arg1 arg2 arg3 stackoverflow How to pass arguments and redirect stdin from a file to program run in gdb? A Pass the arguments to the run command from within gdb. $ gdb ./a.out ( gdb ) r < t Starting program: /dir/a.out < t A You can do this: gdb --args path/to/executable -every -arg you can = think < of The magic bit being --args . Just type run in the gdb command console to start debugging.","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Args/#args","text":"\u4f7f\u7528gdb\u8c03\u8bd5\u7684\u65f6\u5019,\u5982\u4f55\u4f20\u9012\u53c2\u6570\u7684\u5e94\u7528\u7a0b\u5e8f?\u672c\u6587\u5bf9\u6b64\u8fdb\u884c\u603b\u7ed3.","title":"args"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Args/#gdb#--args","text":"\u5728 \u300aDebugging with gdb\u300b\u7684\"2 Getting In and Out of gdb\"\u4e2d\uff0c\u4ecb\u7ecd\u4e86\u8fd9\u79cd\u7528\u6cd5: gdb --args gcc -O2 -c foo.c","title":"gdb --args"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Args/#stackoverflow#how#do#i#run#a#program#with#commandline#arguments#using#gdb#within#a#bash#script","text":"A You can run gdb with --args parameter, gdb --args executablename arg1 arg2 arg3 If you want it to run automatically, place some commands in a file (e.g. 'run') and give it as argument: -x /tmp/cmds. Optionally you can run with -batch mode. gdb -batch -x /tmp/cmds --args executablename arg1 arg2 arg3 A Another way to do this, which I personally find slightly more convenient and intuitive (without having to remember the --args parameter), is to compile normally, and use r arg1 arg2 arg3 directly from within gdb , like so: $ gcc -g *.c *.h $ gdb ./a.out (gdb) r arg1 arg2 arg3","title":"stackoverflow How do I run a program with commandline arguments using GDB within a Bash script?"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Args/#stackoverflow#how#to#pass#arguments#and#redirect#stdin#from#a#file#to#program#run#in#gdb","text":"A Pass the arguments to the run command from within gdb. $ gdb ./a.out ( gdb ) r < t Starting program: /dir/a.out < t A You can do this: gdb --args path/to/executable -every -arg you can = think < of The magic bit being --args . Just type run in the gdb command console to start debugging.","title":"stackoverflow How to pass arguments and redirect stdin from a file to program run in gdb?"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/","text":"Automate gdb debug \u53c2\u8003\uff1a What are the best ways to automate a GDB debugging session? How to print every executed line in GDB automatically until a given breakpoint is reached? gdb scripting: execute commands at selected breakpoint Automate gdb: show backtrace at every call to function puts \u6240\u8c13\u201cautomate gdb debug session\u201d\uff0c\u662f\u6307\u5145\u5206\u5229\u7528gdb\u7684scripting mechanism\uff0c\u800c\u4e0d\u4f7f\u7528interactive\u6a21\u5f0f\u6765\u8fdb\u884cdebug\u3002 What are the best ways to automate a GDB debugging session? \u7684\u63d0\u95ee\u8005\u51c6\u786e\u5730\u8868\u8fbe\u4e86\u8fd9\u79cd\u8bc9\u6c42\uff1a Does GDB have a built in scripting mechanism , should I code up an expect script, or is there an even better solution out there? I'll be sending the same sequence of commands every time and I'll be saving the output of each command to a file (most likely using GDB's built-in logging mechanism, unless someone has a better idea). --batch --command Example Basically, in this example I wanted to get some variable values in particular places of the code; and have them output until the program crashes. So here is first a little program which is guaranteed to crash in a few steps, test.c : #include <stdio.h> #include <stdlib.h> int icount = 1 ; // default value main ( int argc , char * argv []) { int i ; if ( argc == 2 ) { icount = atoi ( argv [ 1 ]); } i = icount ; while ( i > -1 ) { int b = 5 / i ; printf ( \" 5 / %d = %d \\n \" , i , b ); i = i - 1 ; } printf ( \"Finished \\n \" ); return 0 ; } The only reason the program accepts command-line arguments is to be able to choose the number of steps before crashing - and to show that gdb ignores --args in batch mode. This I compile with: gcc -g test.c -o test.exe Then, I prepare the following script - the main trick here is to assign a command to each breakpoint , which will eventually continue (see also Automate gdb: show backtrace at every call to function puts ). This script I call test.gdb : # http://sourceware.org/gdb/wiki/FAQ: to disable the # \"---Type <return> to continue, or q <return> to quit---\" # in batch mode: set width 0 set height 0 set verbose off # at entry point - cmd1 b main commands 1 print argc continue end # printf line - cmd2 b test.c:17 commands 2 p i p b continue end # int b = line - cmd3 b test.c:16 commands 3 p i p b continue end # show arguments for program show args printf \"Note, however: in batch mode, arguments will be ignored!\\n\" # note: even if arguments are shown; # must specify cmdline arg for \"run\" # when running in batch mode! (then they are ignored) # below, we specify command line argument \"2\": run 2 # run #start # alternative to run: runs to main, and stops #continue Note that, if you intend to use it in batch mode, you have to \"start up\" the script at the end, with run or start or something similar. With this script in place, I can call gdb in batch mode - which will generate the following output in the terminal: $ gdb --batch --command = test.gdb --args ./test.exe 5 Breakpoint 1 at 0x804844d: file test.c, line 10 . Breakpoint 2 at 0x8048485: file test.c, line 17 . Breakpoint 3 at 0x8048473: file test.c, line 16 . Argument list to give program being debugged when it is started is \"5\" . Note, however: in batch mode, arguments will be ignored! Breakpoint 1 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:10 10 if ( argc == 2 ) { $1 = 2 Breakpoint 3 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:16 16 int b = 5 / i ; $2 = 2 $3 = 134513899 Breakpoint 2 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:17 17 printf ( \" 5 / %d = %d \\n\" , i, b ) ; $4 = 2 $5 = 2 5 / 2 = 2 Breakpoint 3 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:16 16 int b = 5 / i ; $6 = 1 $7 = 2 Breakpoint 2 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:17 17 printf ( \" 5 / %d = %d \\n\" , i, b ) ; $8 = 1 $9 = 5 5 / 1 = 5 Breakpoint 3 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:16 16 int b = 5 / i ; $10 = 0 $11 = 5 Program received signal SIGFPE, Arithmetic exception. 0x0804847d in main ( argc = 2 , argv = 0xbffff424 ) at test.c:16 16 int b = 5 / i ; Note that while we specify command line argument 5, the loop still spins only two times (as is the specification of run in the gdb script); if run didn't have any arguments, it spins only once (the default value of the program) confirming that --args ./test.exe 5 is ignored. However, since now this is output in a single call, and without any user interaction, the command line output can easily be captured in a text file using bash redirection, say: gdb --batch --command=test.gdb --args ./test.exe 5 > out.txt There is also an example of using python for automating gdb in c - GDB auto stepping - automatic printout of lines, while free running? Hope this helps, Cheers! Example : break puts Try this instead: set width 0 set height 0 set verbose off start # runs to main, so shared libraries are loaded # after you reach main, GDB should have libc symbols, \"puts\" among them break puts commands 1 backtrace continue end If this doesn't work, please state operating system version. EDIT: as osgx correctly points out, the other alternative is to add set breakpoint pending on before break puts \u4f7f\u7528 .gdbinit Example gdb executes file .gdbinit after running. So you can add your commands to this file and see if it is OK for you. This is an example of .gdbinit in order to print backtrace for all f() calls: set pagination off set logging file gdb.txt set logging on file a.out b f commands bt continue end info breakpoints r set logging off quit \u4f7f\u7528 -ex Example If a -x with a file is too much for you, just use multiple -ex 's. This is an example to track a running program showing (and saving) the backtrace on crashes sudo gdb -p $( pidof my-app ) -batch \\ -ex \"set logging on\" \\ -ex continue \\ -ex \"bt full\" \\ -ex quit \u4f7f\u7528 source start Example GDB: Automatic 'Next'ing? # file: step_mult.gdb define step_mult set $step_mult_max = 1000 if $argc > = 1 set $step_mult_max = $arg0 end set $step_mult_count = 0 while ( $step_mult_count < $step_mult_max ) set $step_mult_count = $step_mult_count + 1 printf \"step #%d\\n\" , $step_mult_count step end end #include <stdio.h> int x [] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; int * p [ 11 ]; int main () { int i ; for ( i = 0 ; i < 11 ; ++ i ) { p [ i ] = & x [ i ]; } p [ 5 ] = 0 ; for ( i = 0 ; i < 11 ; ++ i ) { printf ( \"*p[%d] == %d \\n \" , i , * p [ i ]); } return 0 ; } C: \\t emp>gdb test.exe GNU gdb ( GDB ) 7 .2 ... Reading symbols from C: \\t emp/test.exe...done. ( gdb ) source c:/temp/step_mult.gdb ( gdb ) start Temporary breakpoint 1 at 0x401385: file C: \\t emp \\t est.c, line 23 . Starting program: C: \\t emp/test.exe [ New Thread 5396 .0x1638 ] Temporary breakpoint 1 , main () at C: \\t emp \\t est.c:23 23 for ( i = 0 ; i < 11 ; ++i ) { ( gdb ) step_mult 70 step #1 24 p [ i ] = & x [ i ] ; step #2 23 for ( i = 0 ; i < 11 ; ++i ) { ...... TO READ How to print every executed line in GDB automatically until a given breakpoint is reached?","title":"Gdb-automate-debug"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#automate#gdb#debug","text":"\u53c2\u8003\uff1a What are the best ways to automate a GDB debugging session? How to print every executed line in GDB automatically until a given breakpoint is reached? gdb scripting: execute commands at selected breakpoint Automate gdb: show backtrace at every call to function puts \u6240\u8c13\u201cautomate gdb debug session\u201d\uff0c\u662f\u6307\u5145\u5206\u5229\u7528gdb\u7684scripting mechanism\uff0c\u800c\u4e0d\u4f7f\u7528interactive\u6a21\u5f0f\u6765\u8fdb\u884cdebug\u3002 What are the best ways to automate a GDB debugging session? \u7684\u63d0\u95ee\u8005\u51c6\u786e\u5730\u8868\u8fbe\u4e86\u8fd9\u79cd\u8bc9\u6c42\uff1a Does GDB have a built in scripting mechanism , should I code up an expect script, or is there an even better solution out there? I'll be sending the same sequence of commands every time and I'll be saving the output of each command to a file (most likely using GDB's built-in logging mechanism, unless someone has a better idea).","title":"Automate gdb debug"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#--batch#--command","text":"","title":"--batch --command"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#example","text":"Basically, in this example I wanted to get some variable values in particular places of the code; and have them output until the program crashes. So here is first a little program which is guaranteed to crash in a few steps, test.c : #include <stdio.h> #include <stdlib.h> int icount = 1 ; // default value main ( int argc , char * argv []) { int i ; if ( argc == 2 ) { icount = atoi ( argv [ 1 ]); } i = icount ; while ( i > -1 ) { int b = 5 / i ; printf ( \" 5 / %d = %d \\n \" , i , b ); i = i - 1 ; } printf ( \"Finished \\n \" ); return 0 ; } The only reason the program accepts command-line arguments is to be able to choose the number of steps before crashing - and to show that gdb ignores --args in batch mode. This I compile with: gcc -g test.c -o test.exe Then, I prepare the following script - the main trick here is to assign a command to each breakpoint , which will eventually continue (see also Automate gdb: show backtrace at every call to function puts ). This script I call test.gdb : # http://sourceware.org/gdb/wiki/FAQ: to disable the # \"---Type <return> to continue, or q <return> to quit---\" # in batch mode: set width 0 set height 0 set verbose off # at entry point - cmd1 b main commands 1 print argc continue end # printf line - cmd2 b test.c:17 commands 2 p i p b continue end # int b = line - cmd3 b test.c:16 commands 3 p i p b continue end # show arguments for program show args printf \"Note, however: in batch mode, arguments will be ignored!\\n\" # note: even if arguments are shown; # must specify cmdline arg for \"run\" # when running in batch mode! (then they are ignored) # below, we specify command line argument \"2\": run 2 # run #start # alternative to run: runs to main, and stops #continue Note that, if you intend to use it in batch mode, you have to \"start up\" the script at the end, with run or start or something similar. With this script in place, I can call gdb in batch mode - which will generate the following output in the terminal: $ gdb --batch --command = test.gdb --args ./test.exe 5 Breakpoint 1 at 0x804844d: file test.c, line 10 . Breakpoint 2 at 0x8048485: file test.c, line 17 . Breakpoint 3 at 0x8048473: file test.c, line 16 . Argument list to give program being debugged when it is started is \"5\" . Note, however: in batch mode, arguments will be ignored! Breakpoint 1 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:10 10 if ( argc == 2 ) { $1 = 2 Breakpoint 3 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:16 16 int b = 5 / i ; $2 = 2 $3 = 134513899 Breakpoint 2 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:17 17 printf ( \" 5 / %d = %d \\n\" , i, b ) ; $4 = 2 $5 = 2 5 / 2 = 2 Breakpoint 3 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:16 16 int b = 5 / i ; $6 = 1 $7 = 2 Breakpoint 2 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:17 17 printf ( \" 5 / %d = %d \\n\" , i, b ) ; $8 = 1 $9 = 5 5 / 1 = 5 Breakpoint 3 , main ( argc = 2 , argv = 0xbffff424 ) at test.c:16 16 int b = 5 / i ; $10 = 0 $11 = 5 Program received signal SIGFPE, Arithmetic exception. 0x0804847d in main ( argc = 2 , argv = 0xbffff424 ) at test.c:16 16 int b = 5 / i ; Note that while we specify command line argument 5, the loop still spins only two times (as is the specification of run in the gdb script); if run didn't have any arguments, it spins only once (the default value of the program) confirming that --args ./test.exe 5 is ignored. However, since now this is output in a single call, and without any user interaction, the command line output can easily be captured in a text file using bash redirection, say: gdb --batch --command=test.gdb --args ./test.exe 5 > out.txt There is also an example of using python for automating gdb in c - GDB auto stepping - automatic printout of lines, while free running? Hope this helps, Cheers!","title":"Example"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#example#break#puts","text":"Try this instead: set width 0 set height 0 set verbose off start # runs to main, so shared libraries are loaded # after you reach main, GDB should have libc symbols, \"puts\" among them break puts commands 1 backtrace continue end If this doesn't work, please state operating system version. EDIT: as osgx correctly points out, the other alternative is to add set breakpoint pending on before break puts","title":"Example : break puts"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#gdbinit","text":"","title":"\u4f7f\u7528.gdbinit"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#example_1","text":"gdb executes file .gdbinit after running. So you can add your commands to this file and see if it is OK for you. This is an example of .gdbinit in order to print backtrace for all f() calls: set pagination off set logging file gdb.txt set logging on file a.out b f commands bt continue end info breakpoints r set logging off quit","title":"Example"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#-ex","text":"","title":"\u4f7f\u7528-ex"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#example_2","text":"If a -x with a file is too much for you, just use multiple -ex 's. This is an example to track a running program showing (and saving) the backtrace on crashes sudo gdb -p $( pidof my-app ) -batch \\ -ex \"set logging on\" \\ -ex continue \\ -ex \"bt full\" \\ -ex quit","title":"Example"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#source#start","text":"","title":"\u4f7f\u7528source start"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#example#gdb#automatic#nexting","text":"# file: step_mult.gdb define step_mult set $step_mult_max = 1000 if $argc > = 1 set $step_mult_max = $arg0 end set $step_mult_count = 0 while ( $step_mult_count < $step_mult_max ) set $step_mult_count = $step_mult_count + 1 printf \"step #%d\\n\" , $step_mult_count step end end #include <stdio.h> int x [] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; int * p [ 11 ]; int main () { int i ; for ( i = 0 ; i < 11 ; ++ i ) { p [ i ] = & x [ i ]; } p [ 5 ] = 0 ; for ( i = 0 ; i < 11 ; ++ i ) { printf ( \"*p[%d] == %d \\n \" , i , * p [ i ]); } return 0 ; } C: \\t emp>gdb test.exe GNU gdb ( GDB ) 7 .2 ... Reading symbols from C: \\t emp/test.exe...done. ( gdb ) source c:/temp/step_mult.gdb ( gdb ) start Temporary breakpoint 1 at 0x401385: file C: \\t emp \\t est.c, line 23 . Starting program: C: \\t emp/test.exe [ New Thread 5396 .0x1638 ] Temporary breakpoint 1 , main () at C: \\t emp \\t est.c:23 23 for ( i = 0 ; i < 11 ; ++i ) { ( gdb ) step_mult 70 step #1 24 p [ i ] = & x [ i ] ; step #2 23 for ( i = 0 ; i < 11 ; ++i ) { ......","title":"Example GDB: Automatic 'Next'ing?"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Automate/Gdb-automate-debug/#to#read","text":"How to print every executed line in GDB automatically until a given breakpoint is reached?","title":"TO READ"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Debug-HS-middleware/","text":"Debug HS middleware gdb --args xxx -s 0 start local_mode NOTE: XXX \u662f\u4e3b\u7a0b\u5e8f\u7684\u540d\u79f0 message-oriented middleware\u4e2d\uff0cruntime dynamical load Shared library\uff0c\u5b83\u7531start script\u6765\u542f\u52a8\uff0c\u5982\u4f55\u6765\u5bf9\u5b83\u8fdb\u884cdebug\uff1f gdb --args set follow-fork-mode child set stop-on-shard-lib 1 catch throw gdb --args xxx -s 0 start local_mode set follow-fork-mode child b main r catch throw","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Debug-HS-middleware/#debug#hs#middleware","text":"gdb --args xxx -s 0 start local_mode NOTE: XXX \u662f\u4e3b\u7a0b\u5e8f\u7684\u540d\u79f0 message-oriented middleware\u4e2d\uff0cruntime dynamical load Shared library\uff0c\u5b83\u7531start script\u6765\u542f\u52a8\uff0c\u5982\u4f55\u6765\u5bf9\u5b83\u8fdb\u884cdebug\uff1f gdb --args set follow-fork-mode child set stop-on-shard-lib 1","title":"Debug HS middleware"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Debug-HS-middleware/#catch#throw","text":"gdb --args xxx -s 0 start local_mode set follow-fork-mode child b main r catch throw","title":"catch throw"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u8ba8\u8bbagdb\u7684design\u76f8\u5173\u7684\u95ee\u9898\uff0c\u4ece\u4e00\u4e2a\u8f83\u9ad8\u7684\u89c6\u89d2\u6765\u6574\u4f53\u5730\u770b\u5f85gdb\u3002","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/#_1","text":"\u672c\u7ae0\u8ba8\u8bbagdb\u7684design\u76f8\u5173\u7684\u95ee\u9898\uff0c\u4ece\u4e00\u4e2a\u8f83\u9ad8\u7684\u89c6\u89d2\u6765\u6574\u4f53\u5730\u770b\u5f85gdb\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/Abstraction-in-GDB/","text":"Abstraction in GDB Target: \u53c2\u89c1 19 Specifying a Debugging Target Inferior: \u53c2\u89c1 4.9 Debugging Multiple Inferiors Connections and Programs","title":"Abstraction-in-GDB"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/Abstraction-in-GDB/#abstraction#in#gdb","text":"Target: \u53c2\u89c1 19 Specifying a Debugging Target Inferior: \u53c2\u89c1 4.9 Debugging Multiple Inferiors Connections and Programs","title":"Abstraction in GDB"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/Structure-in-GDB/","text":"Structure in GDB \u4f7f\u7528**\u7ed3\u6784\u5316\u601d\u7ef4**\u6765\u5206\u6790GDB\u3002 Contain\u5173\u7cfb \u4e00\u4e2agdb session\u53ef\u4ee5 contain \u591a\u4e2a inferior\uff1b \u4e00\u4e2ainferior\u53ef\u4ee5 contain \u591a\u4e2a thread\uff1b \u4e00\u4e2athread\u6709\u4e00\u4e2acall stack\uff0ccall stack contain \u591a\u4e2a stack frame\uff1b \u901a\u8fc7\u4e0a\u9762\u7684\u63cf\u8ff0\u53ef\u77e5\uff1a\u6574\u4f53\u5f62\u6210\u4e86\u4e00\u4e2atree structure thread1 inferior1 thread2 session inferior2 inferior3 \u4e00\u5bf9\u591a\u5173\u7cfb \u5728\u4f7f\u7528gdb\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ea\u6709\u4e00\u4e2asession\uff0c\u4f46\u662f\u53ef\u80fd\u6709\u591a\u4e2ainferior\u3001\u591a\u4e2athread\u3001\u591a\u4e2astack frame\uff0c\u663e\u7136\u8fd9\u662f\u4e00\u79cd \u4e00\u5bf9\u591a \u5173\u7cfb\uff1b \u7531\u4e8e\u53ea\u6709\u4e00\u4e2asession\uff0c\u6240\u4ee5\u5728\u4f7f\u7528gdb\u7684\u65f6\u5019\uff0c\u5c31\u9700\u8981\u6d89\u53ca\u5230current\u3001switch and select\u3001apply to all\u3002 Current Current inferior: 4.9 Debugging Multiple Inferiors Connections and Programs Current thread: 4.10 Debugging Programs with Multiple Threads Current stack frame: 8 Examining the Stack Switch and select Select a inferior: inferior infno Select a thread: thread thread-id Select a frame: 8.3 Selecting a Frame Apply to all Thread: thread apply Stack frame: 8.5 Applying a Command to Several Frames.","title":"Structure-in-GDB"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/Structure-in-GDB/#structure#in#gdb","text":"\u4f7f\u7528**\u7ed3\u6784\u5316\u601d\u7ef4**\u6765\u5206\u6790GDB\u3002","title":"Structure in GDB"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/Structure-in-GDB/#contain","text":"\u4e00\u4e2agdb session\u53ef\u4ee5 contain \u591a\u4e2a inferior\uff1b \u4e00\u4e2ainferior\u53ef\u4ee5 contain \u591a\u4e2a thread\uff1b \u4e00\u4e2athread\u6709\u4e00\u4e2acall stack\uff0ccall stack contain \u591a\u4e2a stack frame\uff1b \u901a\u8fc7\u4e0a\u9762\u7684\u63cf\u8ff0\u53ef\u77e5\uff1a\u6574\u4f53\u5f62\u6210\u4e86\u4e00\u4e2atree structure thread1 inferior1 thread2 session inferior2 inferior3","title":"Contain\u5173\u7cfb"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/Structure-in-GDB/#_1","text":"\u5728\u4f7f\u7528gdb\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ea\u6709\u4e00\u4e2asession\uff0c\u4f46\u662f\u53ef\u80fd\u6709\u591a\u4e2ainferior\u3001\u591a\u4e2athread\u3001\u591a\u4e2astack frame\uff0c\u663e\u7136\u8fd9\u662f\u4e00\u79cd \u4e00\u5bf9\u591a \u5173\u7cfb\uff1b \u7531\u4e8e\u53ea\u6709\u4e00\u4e2asession\uff0c\u6240\u4ee5\u5728\u4f7f\u7528gdb\u7684\u65f6\u5019\uff0c\u5c31\u9700\u8981\u6d89\u53ca\u5230current\u3001switch and select\u3001apply to all\u3002","title":"\u4e00\u5bf9\u591a\u5173\u7cfb"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/Structure-in-GDB/#current","text":"Current inferior: 4.9 Debugging Multiple Inferiors Connections and Programs Current thread: 4.10 Debugging Programs with Multiple Threads Current stack frame: 8 Examining the Stack","title":"Current"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/Structure-in-GDB/#switch#and#select","text":"Select a inferior: inferior infno Select a thread: thread thread-id Select a frame: 8.3 Selecting a Frame","title":"Switch and select"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Design-of-gdb/Structure-in-GDB/#apply#to#all","text":"Thread: thread apply Stack frame: 8.5 Applying a Command to Several Frames.","title":"Apply to all"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Function/","text":"Function cnblogs gdb\u547d\u4ee4\u8c03\u8bd5\u6280\u5de7 1\u3001\u5217\u51fa\u51fd\u6570\u7684\u540d\u5b57 (gdb) info functions 2\u3001\u662f\u5426\u8fdb\u5165\u5f85\u8c03\u8bd5\u4fe1\u606f\u7684\u51fd\u6570(gdb)step s 3\u3001\u8fdb\u5165\u4e0d\u5e26\u8c03\u8bd5\u4fe1\u606f\u7684\u51fd\u6570(gdb)set step-mode on 4\u3001\u9000\u51fa\u6b63\u5728\u8c03\u8bd5\u7684\u51fd\u6570(gdb)return expression \u6216\u8005 (gdb)finish 5\u3001\u76f4\u63a5\u6267\u884c\u51fd\u6570(gdb)start \u51fd\u6570\u540d call\u51fd\u6570\u540d 6\u3001\u6253\u5370\u51fd\u6570\u5806\u6808\u5e27\u4fe1\u606f(gdb)info frame or i frame 7\u3001\u67e5\u770b\u51fd\u6570\u5bc4\u5b58\u5668\u4fe1\u606f(gdb)i registers 8\u3001\u67e5\u770b\u51fd\u6570\u53cd\u6c47\u7f16\u4ee3\u7801(gdb)disassemble func 9\u3001\u6253\u5370\u5c3e\u8c03\u7528\u5806\u6808\u5e27\u4fe1\u606f(gdb)set debug entry-values 1 10\u3001\u9009\u62e9\u51fd\u6570\u5806\u6808\u5e27(gdb)frame n 11\u3001\u5411\u4e0a\u6216\u5411\u4e0b\u5207\u6362\u51fd\u6570\u5806\u6808\u5e27(gdb)up n down n gdb onlinedocs 17 Altering Execution Call function in gdb stackoverflow How to evaluate functions in GDB? aixxe Loading, unloading & reloading shared libraries. Using dynamic linker functions to load, unload and reload our code into a process. stackoverflow Step out of current function with GDB A You can use the finish command. finish : Continue running until just after function in the selected stack frame returns. Print the returned value (if any). This command can be abbreviated as fin . (see https://sourceware.org/gdb/current/onlinedocs/gdb/Continuing-and-Stepping.html#Continuing-and-Stepping )","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Function/#function","text":"","title":"Function"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Function/#cnblogs#gdb","text":"1\u3001\u5217\u51fa\u51fd\u6570\u7684\u540d\u5b57 (gdb) info functions 2\u3001\u662f\u5426\u8fdb\u5165\u5f85\u8c03\u8bd5\u4fe1\u606f\u7684\u51fd\u6570(gdb)step s 3\u3001\u8fdb\u5165\u4e0d\u5e26\u8c03\u8bd5\u4fe1\u606f\u7684\u51fd\u6570(gdb)set step-mode on 4\u3001\u9000\u51fa\u6b63\u5728\u8c03\u8bd5\u7684\u51fd\u6570(gdb)return expression \u6216\u8005 (gdb)finish 5\u3001\u76f4\u63a5\u6267\u884c\u51fd\u6570(gdb)start \u51fd\u6570\u540d call\u51fd\u6570\u540d 6\u3001\u6253\u5370\u51fd\u6570\u5806\u6808\u5e27\u4fe1\u606f(gdb)info frame or i frame 7\u3001\u67e5\u770b\u51fd\u6570\u5bc4\u5b58\u5668\u4fe1\u606f(gdb)i registers 8\u3001\u67e5\u770b\u51fd\u6570\u53cd\u6c47\u7f16\u4ee3\u7801(gdb)disassemble func 9\u3001\u6253\u5370\u5c3e\u8c03\u7528\u5806\u6808\u5e27\u4fe1\u606f(gdb)set debug entry-values 1 10\u3001\u9009\u62e9\u51fd\u6570\u5806\u6808\u5e27(gdb)frame n 11\u3001\u5411\u4e0a\u6216\u5411\u4e0b\u5207\u6362\u51fd\u6570\u5806\u6808\u5e27(gdb)up n down n","title":"cnblogs gdb\u547d\u4ee4\u8c03\u8bd5\u6280\u5de7"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Function/#gdb#onlinedocs#17#altering#execution","text":"","title":"gdb onlinedocs 17 Altering Execution"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Function/#call#function#in#gdb","text":"stackoverflow How to evaluate functions in GDB? aixxe Loading, unloading & reloading shared libraries. Using dynamic linker functions to load, unload and reload our code into a process.","title":"Call function in gdb"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Function/#stackoverflow#step#out#of#current#function#with#gdb","text":"A You can use the finish command. finish : Continue running until just after function in the selected stack frame returns. Print the returned value (if any). This command can be abbreviated as fin . (see https://sourceware.org/gdb/current/onlinedocs/gdb/Continuing-and-Stepping.html#Continuing-and-Stepping )","title":"stackoverflow Step out of current function with GDB"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/","text":"Shared library \u672c\u6587\u63cf\u8ff0gdb\u8c03\u8bd5shared library\u7684\u5185\u5bb9\u3002 Set breakpoint in shared library Linux OS\u662f\u652f\u6301\u591a\u79cd\u4f7f\u7528shared library\u7684\u65b9\u5f0f\u7684\uff0c\u65e0\u8bba\u662f\u54ea\u79cd\u65b9\u5f0f\uff0c\u8c03\u8bd5shared library\u7684\u4e00\u4e2a\u539f\u5219\u662f: \u53ea\u6709\u5f53shared library\u88ab\u52a0\u8f7d\u540e\uff0c\u624d\u80fd\u591f\u8bfb\u53d6\u5176\u4e2d\u7684symbol\uff0c\u7136\u540e\u624d\u80fd\u591f\u5bf9\u5176\u8fdb\u884c\u8c03\u8bd5\u3002 stackoverflow how to set breakpoint on function in a shared library which has not been loaded in gdb : Actually gdb should tell you that it's able to resolve the symbol in the future, when new libraries are loaded visualgdb Shared library commands NOTE: \u5bf9shared library\u76f8\u5173\u7684command\u8fdb\u884c\u4e86\u8f83\u597d\u7684\u603b\u7ed3 command \u7b80\u4ecb info sharedlibrary \u67e5\u770b\u5df2\u7ecf\u52a0\u8f7d\u7684shared library set auto-solib-add gdb break when a shared library load set solib-search-path set stop-on-solib-events set sysroot sharedlibrary set stop-on-solib-events command visualgdb set stop-on-solib-events Syntax set stop-on-solib-events 0 set stop-on-solib-events 1 show stop-on-solib-events NOTE: set stop-on-solib-events 1 \u5bf9\u4e8e\u901a\u8fc7 dlopen \u6765\u52a0\u8f7d\u7684shared library\u975e\u5e38\u6709\u7528\u3002 codeyarns How to set regex breakpoint for shared library in GDB I find it useful to configure GDB to stop whenever a shared library is loaded. This can be done by setting this option: set stop-on-solib-events 1 Now GDB stops every time at the point where one or more shared libraries need to be loaded. If I realize that the shared library I am interested in has now loaded, I run the regex breakpoint command at that point to set the breakpoints. Voila! Run-time load \u672c\u8282\u6807\u9898\u7684\u51fd\u6570\u662f\u201c\u8fd0\u884c\u65f6\u52a0\u8f7d\u201d\u3002dynamic library\u662frun-time\u624d\u4f1a\u7ee7\u7eed\u52a0\u8f7d\u7684\uff0c\u6240\u4ee5\u5728\u7a0b\u5e8f\u8fd0\u884c\u4e4b\u524d\uff0c\u65e0\u6cd5\u83b7\u53d6dynamic library\u7684\u4fe1\u606f\uff0c\u8fd9\u662f\u56e0\u4e3a\u6b64\u65f6gdb\u8fd8\u6ca1\u6709\u52a0\u8f7ddynamic library\uff0c\u6240\u4ee5\u6ca1\u6709\u8bfb\u53d6\u5176symbol table\uff0c\u6240\u4ee5\u65e0\u6cd5\u83b7\u5f97dynamic library\u7684\u5b9e\u73b0\u7684\u4fe1\u606f\u3002 \u53ea\u6709\u5f53\u7a0b\u5e8f\u5f00\u59cb\u8fd0\u884c\u540e\uff0c\u624d\u80fd\u591f\u5bf9dynamic library\u8fdb\u884cdebug\u3002 \u56e0\u6b64\uff0c\u5728\u8c03\u8bd5dynamic library\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4e00\u822c\u4f7f\u7528\u4e0b\u9762\u7684\u7b56\u7565: $ gdb a.out ( gdb ) b main Breakpoint 1 at 0x401a90: file main.cpp, line 17 . ( gdb ) r Starting program:a.out Breakpoint 1 , main () at main.cpp:17 ( gdb ) info sharedlibrary From To Syms Read Shared Object Library 0x00007ffff7ddbad0 0x00007ffff7df7080 Yes ( * ) /lib64/ld-linux-x86-64.so.2 0x00007ffff758e220 0x00007ffff75f537a Yes ( * ) /lib64/libstdc++.so.6 0x00007ffff7236310 0x00007ffff72a12d6 Yes ( * ) /lib64/libm.so.6 0x00007ffff701da90 0x00007ffff702d245 Yes ( * ) /lib64/libgcc_s.so.1 0x00007ffff6c6d8d0 0x00007ffff6dbd22f Yes ( * ) /lib64/libc.so.6 0x00007ffff6a378b0 0x00007ffff6a42e01 Yes ( * ) /lib64/libpthread.so.0 0x00007ffff61d7f80 0x00007ffff61e56c3 Yes ( * ) /lib64/libnsl.so.1 0x00007ffff5fd0d90 0x00007ffff5fd188e Yes ( * ) /lib64/libdl.so.2 0x00007ffff5dca1e0 0x00007ffff5dcd16c Yes ( * ) /lib64/librt.so.1 ( * ) : Shared library is missing debugging information. \u81f3\u6b64\uff0cdynamic library\u5c31\u5df2\u7ecf\u88c5\u8f7d\u4e86\uff0c\u6b64\u65f6\u53ef\u4ee5\u5bf9\u5176\u8fdb\u884c\u8c03\u8bd5\u3002 Load, unload and reload shared library aixxe Loading, unloading & reloading shared libraries Using dynamic linker functions to load, unload and reload our code into a process. stackoverflow make gdb load a shared library from a specific path Directly load shared library gdb\u80fd\u591f\u76f4\u63a5load shared library\uff0c\u5373\u4f7f\u6ca1\u6709\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u8fd9\u4e2a\u7279\u6027\u662f\u6709\u4e00\u5b9a\u4ef7\u503c\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u53ef\u4ee5\u76f4\u63a5\u8bfb\u53d6shared library\u4e2d\u7684\u4e00\u4e9b\u4fe1\u606f\u3002 TO READ https://sysprogs.com/w/resolving-library-symbol-load-errors-when-debugging-with-cross-toolchains/","title":"Introduction"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#shared#library","text":"\u672c\u6587\u63cf\u8ff0gdb\u8c03\u8bd5shared library\u7684\u5185\u5bb9\u3002","title":"Shared library"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#set#breakpoint#in#shared#library","text":"Linux OS\u662f\u652f\u6301\u591a\u79cd\u4f7f\u7528shared library\u7684\u65b9\u5f0f\u7684\uff0c\u65e0\u8bba\u662f\u54ea\u79cd\u65b9\u5f0f\uff0c\u8c03\u8bd5shared library\u7684\u4e00\u4e2a\u539f\u5219\u662f: \u53ea\u6709\u5f53shared library\u88ab\u52a0\u8f7d\u540e\uff0c\u624d\u80fd\u591f\u8bfb\u53d6\u5176\u4e2d\u7684symbol\uff0c\u7136\u540e\u624d\u80fd\u591f\u5bf9\u5176\u8fdb\u884c\u8c03\u8bd5\u3002 stackoverflow how to set breakpoint on function in a shared library which has not been loaded in gdb : Actually gdb should tell you that it's able to resolve the symbol in the future, when new libraries are loaded","title":"Set breakpoint in shared library"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#visualgdb#shared#library#commands","text":"NOTE: \u5bf9shared library\u76f8\u5173\u7684command\u8fdb\u884c\u4e86\u8f83\u597d\u7684\u603b\u7ed3 command \u7b80\u4ecb info sharedlibrary \u67e5\u770b\u5df2\u7ecf\u52a0\u8f7d\u7684shared library set auto-solib-add gdb break when a shared library load set solib-search-path set stop-on-solib-events set sysroot sharedlibrary","title":"visualgdb Shared library commands"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#set#stop-on-solib-events#command","text":"","title":"set stop-on-solib-events command"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#visualgdb#set#stop-on-solib-events","text":"","title":"visualgdb set stop-on-solib-events"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#syntax","text":"set stop-on-solib-events 0 set stop-on-solib-events 1 show stop-on-solib-events NOTE: set stop-on-solib-events 1 \u5bf9\u4e8e\u901a\u8fc7 dlopen \u6765\u52a0\u8f7d\u7684shared library\u975e\u5e38\u6709\u7528\u3002","title":"Syntax"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#codeyarns#how#to#set#regex#breakpoint#for#shared#library#in#gdb","text":"I find it useful to configure GDB to stop whenever a shared library is loaded. This can be done by setting this option: set stop-on-solib-events 1 Now GDB stops every time at the point where one or more shared libraries need to be loaded. If I realize that the shared library I am interested in has now loaded, I run the regex breakpoint command at that point to set the breakpoints. Voila!","title":"codeyarns How to set regex breakpoint for shared library in GDB"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#run-time#load","text":"\u672c\u8282\u6807\u9898\u7684\u51fd\u6570\u662f\u201c\u8fd0\u884c\u65f6\u52a0\u8f7d\u201d\u3002dynamic library\u662frun-time\u624d\u4f1a\u7ee7\u7eed\u52a0\u8f7d\u7684\uff0c\u6240\u4ee5\u5728\u7a0b\u5e8f\u8fd0\u884c\u4e4b\u524d\uff0c\u65e0\u6cd5\u83b7\u53d6dynamic library\u7684\u4fe1\u606f\uff0c\u8fd9\u662f\u56e0\u4e3a\u6b64\u65f6gdb\u8fd8\u6ca1\u6709\u52a0\u8f7ddynamic library\uff0c\u6240\u4ee5\u6ca1\u6709\u8bfb\u53d6\u5176symbol table\uff0c\u6240\u4ee5\u65e0\u6cd5\u83b7\u5f97dynamic library\u7684\u5b9e\u73b0\u7684\u4fe1\u606f\u3002 \u53ea\u6709\u5f53\u7a0b\u5e8f\u5f00\u59cb\u8fd0\u884c\u540e\uff0c\u624d\u80fd\u591f\u5bf9dynamic library\u8fdb\u884cdebug\u3002 \u56e0\u6b64\uff0c\u5728\u8c03\u8bd5dynamic library\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4e00\u822c\u4f7f\u7528\u4e0b\u9762\u7684\u7b56\u7565: $ gdb a.out ( gdb ) b main Breakpoint 1 at 0x401a90: file main.cpp, line 17 . ( gdb ) r Starting program:a.out Breakpoint 1 , main () at main.cpp:17 ( gdb ) info sharedlibrary From To Syms Read Shared Object Library 0x00007ffff7ddbad0 0x00007ffff7df7080 Yes ( * ) /lib64/ld-linux-x86-64.so.2 0x00007ffff758e220 0x00007ffff75f537a Yes ( * ) /lib64/libstdc++.so.6 0x00007ffff7236310 0x00007ffff72a12d6 Yes ( * ) /lib64/libm.so.6 0x00007ffff701da90 0x00007ffff702d245 Yes ( * ) /lib64/libgcc_s.so.1 0x00007ffff6c6d8d0 0x00007ffff6dbd22f Yes ( * ) /lib64/libc.so.6 0x00007ffff6a378b0 0x00007ffff6a42e01 Yes ( * ) /lib64/libpthread.so.0 0x00007ffff61d7f80 0x00007ffff61e56c3 Yes ( * ) /lib64/libnsl.so.1 0x00007ffff5fd0d90 0x00007ffff5fd188e Yes ( * ) /lib64/libdl.so.2 0x00007ffff5dca1e0 0x00007ffff5dcd16c Yes ( * ) /lib64/librt.so.1 ( * ) : Shared library is missing debugging information. \u81f3\u6b64\uff0cdynamic library\u5c31\u5df2\u7ecf\u88c5\u8f7d\u4e86\uff0c\u6b64\u65f6\u53ef\u4ee5\u5bf9\u5176\u8fdb\u884c\u8c03\u8bd5\u3002","title":"Run-time load"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#load#unload#and#reload#shared#library","text":"","title":"Load, unload and reload shared library"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#aixxe#loading#unloading#reloading#shared#libraries","text":"Using dynamic linker functions to load, unload and reload our code into a process.","title":"aixxe Loading, unloading &amp; reloading shared libraries"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#stackoverflow#make#gdb#load#a#shared#library#from#a#specific#path","text":"","title":"stackoverflow make gdb load a shared library from a specific path"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#directly#load#shared#library","text":"gdb\u80fd\u591f\u76f4\u63a5load shared library\uff0c\u5373\u4f7f\u6ca1\u6709\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c\u8fd9\u4e2a\u7279\u6027\u662f\u6709\u4e00\u5b9a\u4ef7\u503c\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u53ef\u4ee5\u76f4\u63a5\u8bfb\u53d6shared library\u4e2d\u7684\u4e00\u4e9b\u4fe1\u606f\u3002","title":"Directly load shared library"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/Shared-library/#to#read","text":"https://sysprogs.com/w/resolving-library-symbol-load-errors-when-debugging-with-cross-toolchains/","title":"TO READ"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/","text":"gdb primer \u9884\u5907\u77e5\u8bc6 GDB\u5de5\u4f5c\u793a\u610f\u56fe GDB \u5de5\u4f5c\u539f\u7406 GDB \u4f5c\u4e3a**\u7236\u8fdb\u7a0b**\uff0c\u88ab\u8c03\u8bd5\u7a0b\u5e8f\u4e3a**\u5b50\u8fdb\u7a0b**\uff0c\u901a\u8fc7**ptrace\u7cfb\u7edf\u8c03\u7528**\u548c\u4e00\u7cfb\u5217\u7684**\u4fe1\u53f7**\u4ea4\u4e92\u6765\u89c2\u5bdf\u548c\u63a7\u5236\u88ab\u8c03\u8bd5\u8fdb\u7a0b\u7684\u6267\u884c\uff0c\u68c0\u67e5\u548c\u4fee\u6539\u5176**\u5bc4\u5b58\u5668**\u548c**\u5185\u5b58\u73af\u5883**\u3002 \u8fd0\u884c\u7a0b\u5e8f\uff0c\u8bbe\u7f6e\u6240\u6709\u7684\u80fd\u5f71\u54cd\u7a0b\u5e8f\u8fd0\u884c\u7684\u4e1c\u897f\uff1b \u4fdd\u8bc1\u4f60\u7684\u7a0b\u5e8f\u5728\u6307\u5b9a\u7684\u6761\u4ef6\u4e0b\u505c\u6b62\uff1b \u5f53\u4f60\u7a0b\u5e8f\u505c\u6b62\u65f6\uff0c\u8ba9\u4f60\u68c0\u67e5\u53d1\u751f\u4e86\u4ec0\u4e48\uff1b \u6539\u53d8\u4f60\u7684\u7a0b\u5e8f\u8fd0\u884c\u884c\u4e3a\uff1b \u4e0a\u8ff0\u56db\u70b9\u6b63\u662fGDB\u5b98\u65b9\u6587\u6863\u7684\u201cSummary of gdb\u201d\u7ae0\u8282\u6240\u603b\u7ed3\u7684\u3002 \u7f16\u8bd1\u7a0b\u5e8f \u200b \u9884\u5904\u7406\u5668 \u7f16\u8bd1\u5668 \u6c47\u7f16\u5668 \u94fe\u63a5\u5668 \u9884\u5904\u7406\uff1a g++ \u2013E hello.cpp \u2013o hello.i \u7f16 \u8bd1\uff1a g++ -S hello.cpp \u2013o hello.s \u6c47 \u7f16\uff1a g++ -c hello.s \u2013o hello.o \u94fe \u63a5\uff1a g++ hello.c \u2013o hello \u7f16\u8bd1\u8c03\u8bd5\u7248\uff1a g++ -g hello.c \u2013o hello \u53ef\u6267\u884c\u7a0b\u5e8f\u683c\u5f0f(ELF) \u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u5e03\u5c40 \u7ecf\u517832\u4f4d AMD64 \u5e38\u7528\u5bc4\u5b58\u5668 \u5bc4\u5b58\u5668\u547d\u540d\uff1a32\u4f4d: %EAX , 64\u4f4d: %RAX \u901a\u7528\u5bc4\u5b58\u5668\uff1a %EAX % EBX %ECX %EDX %EAX \u51fd\u6570\u8fd4\u56de\u503c %ECX VC\uff08visual c++\uff09 \u7528\u6765\u5b58\u653e this \u6307\u9488 \u7279\u6b8a\u5bc4\u5b58\u5668\uff1a %ESI \u901a\u5e38\u5728\u5185\u5b58\u64cd\u4f5c\u6307\u4ee4\u4e2d\u4f5c\u4e3a\u201c\u6e90\u5730\u5740\u6307\u9488\u201d\u4f7f\u7528\u3002 %EDI \u901a\u5e38\u5728\u5185\u5b58\u64cd\u4f5c\u6307\u4ee4\u4e2d\u4f5c\u4e3a\u201c\u76ee\u7684\u5730\u5740\u6307\u9488\u201d\u4f7f\u7528\u3002 \u5806\u6808\u5bc4\u5b58\u5668\uff1a %EBP \u6808\u57fa\u5740\u5bc4\u5b58\u5668 %ESP \u6808\u9876\u5bc4\u5b58\u5668 \u6307\u4ee4\u5bc4\u5b58\u5668\uff1a %EIP \u6307\u5411\u5373\u5c06\u6267\u884c\u7684\u90a3\u6761\u6307\u4ee4\u7684\u5730\u5740 \u6807\u5fd7\u5bc4\u5b58\u5668\uff1a %EFR [CF/AF/PF/ZF/SF/OF] \u5e38\u7528\u6c47\u7f16\u6307\u4ee4 push %rbp - \u628a%rbp\u538b\u5165\u6808 mov %rsp,%rbp - \u628a%rsp\u8d4b\u503c\u7ed9%rbp sub $0x30,%rsp - \u79fb\u52a8\u6808\u9876\u6307\u9488\uff0c\u5206\u914d\u6808\u5185\u5b58 lea 0x26e43(%rip),%rsi - \u88c5\u5165\u6709\u6548\u5730\u5740 callq *0x30(%rax) - \u8c03\u7528\u865a\u51fd\u6570 cmp %rax,%r15 - \u6bd4\u8f83 je 0x7f982e65ce62 - \u7b49\u4e8e\u8df3\u8f6c \u51fd\u6570\u8c03\u7528\u7ea6\u5b9a __stdcall \uff1a\u53c2\u6570\u91c7\u7528\u4ece\u53f3\u5230\u5de6\u7684\u538b\u6808\u65b9\u5f0f\uff0c\u81ea\u5df1\u5728\u9000\u51fa\u65f6\u6e05\u7a7a\u5806\u6808 __cdecl \uff1ac\u8c03\u7528\u7ea6\u5b9a, \u6309\u4ece\u53f3\u81f3\u5de6\u7684\u987a\u5e8f\u538b\u53c2\u6570\u5165\u6808\uff0c\u7531\u8c03\u7528\u8005\u628a\u53c2\u6570\u5f39\u51fa\u6808\u3002\u5bf9\u4e8e\u4f20\u9001\u53c2\u6570\u7684\u5185\u5b58\u6808\u662f\u7531\u8c03\u7528\u8005\u6765\u7ef4\u62a4\u7684\uff08\u6b63\u56e0\u4e3a\u5982\u6b64\uff0c\u5b9e\u73b0\u53ef\u53d8\u53c2\u6570\u7684\u51fd\u6570\u53ea\u80fd\u4f7f\u7528\u8be5\u8c03\u7528\u7ea6\u5b9a\uff0c\u5982 printf \uff09 thiscall \uff1a\u4ec5\u4ec5\u5e94\u7528\u4e8e\"C++\"\u6210\u5458\u51fd\u6570\u3002this\u6307\u9488\u5b58\u653e\u4e8eCX\u5bc4\u5b58\u5668\uff0c\u53c2\u6570\u4ece\u53f3\u5230\u5de6\u538b\u3002thiscall\u4e0d\u662f\u5173\u952e\u8bcd\uff0c\u56e0\u6b64\u4e0d\u80fd\u88ab\u7a0b\u5e8f\u5458\u6307\u5b9a C++ \u5bf9\u8c61\u5185\u5b58\u6a21\u578b \u6ce8\u610f\uff1a 1\uff0c\u865a\u51fd\u6570\u8868\u3002\u907f\u514d\u591a\u7ee7\u627f\uff0c\u5404\u5e73\u53f0\u7f16\u8bd1\u5668\u884c\u4e3a\u4e0d\u4e00\u81f4\u3002 2\uff0c\u5185\u5b58\u5bf9\u9f50\u3002 glibc \u5185\u5b58\u7ba1\u7406 \u7528\u6237\u63a5\u53e3\uff1a malloc / free \u7cfb\u7edf\u8c03\u7528\uff1a brk / mmap / munmap \u5927\u5185\u5b58(>128k): \u76f4\u63a5\u8c03\u7528 mmap \u5c0f\u5185\u5b58: sbrk \uff0c\u94fe\u8868\u7ba1\u7406 \u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\uff0832\u4f4d\uff09 \u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\uff0864\u4f4d\uff09 %rax \u4f5c\u4e3a\u51fd\u6570\u8fd4\u56de\u503c\u4f7f\u7528\uff1b %rsp \u6808\u6307\u9488\u5bc4\u5b58\u5668\uff0c\u6307\u5411\u6808\u9876\uff1b %rdi \uff0c %rsi \uff0c %rdx \uff0c %rcx \uff0c %r8 \uff0c %r9 \u7528\u4f5c\u51fd\u6570\u524d6\u4e2a\u53c2\u6570\uff0c\u591a\u4f59\u7684\u53c2\u6570\u4f9d\u6b21\u4fdd\u5b58\u5728\u6808\u4e0a; %rbx \uff0c %rbp \uff0c %r12 \uff0c %r13 \uff0c %r14 \uff0c %r15 \u7528\u4f5c\u6570\u636e\u5b58\u50a8\uff0c\u9075\u5faa\u88ab\u8c03\u7528\u8005\u4f7f\u7528\u89c4\u5219\uff0c\u7b80\u5355\u8bf4\u5c31\u662f\u968f\u4fbf\u7528\uff0c\u8c03\u7528\u5b50\u51fd\u6570\u4e4b\u524d\u8981\u5907\u4efd\u5b83\uff0c\u4ee5\u9632\u88ab\u4fee\u6539\uff1b %r10 \uff0c %r11 \u7528\u4f5c\u6570\u636e\u5b58\u50a8\uff0c\u9075\u5faa\u8c03\u7528\u8005\u4f7f\u7528\u89c4\u5219\uff0c\u7b80\u5355\u8bf4\u5c31\u662f\u4f7f\u7528\u4e4b\u524d\u8981\u5148\u4fdd\u5b58\u539f\u503c\uff1b GDB\u547d\u4ee4 \u5e2e\u52a9\u547d\u4ee4\uff08help\uff09 GDB \u542f\u52a8 GDB \u6267\u884c GDB \u57fa\u672c\u547d\u4ee4 \u65ad\u70b9 \u4fe1\u53f7 \u81ea\u5b9a\u4e49\u547d\u4ee4 GDB\u5b9e\u6218 \u524d\u63d0 1\uff0c\u7a0b\u5e8f\u7f16\u8bd1\uff1a \u52a0\u4e0a -g \uff0c\u53bb\u6389\u4f18\u5316 -O2 2\uff0c\u751f\u6210core\u5927\u5c0f\u8bbe\u7f6e\uff1a ulimit \u2013c unlimited 3\uff0c\u8bbe\u7f6ecoredump \u751f\u6210\u8def\u5f84 echo '/tmp/cores/core.%e.%p.%t' > /proc/sys/kernel/core_pattern \u5206\u6790coredump\u6b65\u9aa4 1\uff0c gdb hsserver core.1234 \uff0c\u67e5\u770bcore\u6587\u4ef6 2\uff0c\u67e5\u770bgdb\u8f93\u51fa\uff0c\u786e\u8ba4\u7a0b\u5e8f\u548cso\u5e93\u5339\u914d\u3002 3\uff0c\u9996\u5148\u6839\u636eframe 0\u4fe1\u606f\uff0c\u786e\u8ba4\u7a0b\u5e8f\u5d29\u6e83\u7684\u76f4\u63a5\u539f\u56e0\u3002 4\uff0c bt \u67e5\u770b\u5806\u6808\u548c\u524d\u540e\u4ee3\u7801 5\uff0c\u67e5\u770b\u7ebf\u7a0b\u4fe1\u606f \u8fdb\u7a0b\u5185\u5b58\u5e03\u5c40 \u6839\u636e\u7a0b\u5e8f\u6253\u5370\uff0c\u5224\u65ad\u8fdb\u7a0b\u5185\u5b58\u5e03\u5c40\u3002 \u53c2\u89c1 address.cpp \u3002 \u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\u8ddf\u8e2a \u901a\u8fc7\u51fd\u6570\u8c03\u7528\uff0c\u8ddf\u8e2a\u5806\u6808\u53d8\u5316\u3002 \u67e5\u770b\u5165\u53c2\u4fe1\u606f\u548c\u672c\u5730\u53d8\u91cf\u4fe1\u606f\u7b49\u3002 \u53c2\u89c1 func.cpp coredump \u5b9a\u4f4d \u8c03\u8bd5\u5b9e\u9645\u7684coredump \u5b9a\u4f4d\u7a0b\u5e8f\u5d29\u6e83\u539f\u56e0 GDB \u6587\u6863 http://www.gnu.org/software/gdb/","title":"gdb-primer"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#gdb#primer","text":"","title":"gdb primer"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_1","text":"","title":"\u9884\u5907\u77e5\u8bc6"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#gdb","text":"","title":"GDB\u5de5\u4f5c\u793a\u610f\u56fe"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#gdb_1","text":"GDB \u4f5c\u4e3a**\u7236\u8fdb\u7a0b**\uff0c\u88ab\u8c03\u8bd5\u7a0b\u5e8f\u4e3a**\u5b50\u8fdb\u7a0b**\uff0c\u901a\u8fc7**ptrace\u7cfb\u7edf\u8c03\u7528**\u548c\u4e00\u7cfb\u5217\u7684**\u4fe1\u53f7**\u4ea4\u4e92\u6765\u89c2\u5bdf\u548c\u63a7\u5236\u88ab\u8c03\u8bd5\u8fdb\u7a0b\u7684\u6267\u884c\uff0c\u68c0\u67e5\u548c\u4fee\u6539\u5176**\u5bc4\u5b58\u5668**\u548c**\u5185\u5b58\u73af\u5883**\u3002 \u8fd0\u884c\u7a0b\u5e8f\uff0c\u8bbe\u7f6e\u6240\u6709\u7684\u80fd\u5f71\u54cd\u7a0b\u5e8f\u8fd0\u884c\u7684\u4e1c\u897f\uff1b \u4fdd\u8bc1\u4f60\u7684\u7a0b\u5e8f\u5728\u6307\u5b9a\u7684\u6761\u4ef6\u4e0b\u505c\u6b62\uff1b \u5f53\u4f60\u7a0b\u5e8f\u505c\u6b62\u65f6\uff0c\u8ba9\u4f60\u68c0\u67e5\u53d1\u751f\u4e86\u4ec0\u4e48\uff1b \u6539\u53d8\u4f60\u7684\u7a0b\u5e8f\u8fd0\u884c\u884c\u4e3a\uff1b \u4e0a\u8ff0\u56db\u70b9\u6b63\u662fGDB\u5b98\u65b9\u6587\u6863\u7684\u201cSummary of gdb\u201d\u7ae0\u8282\u6240\u603b\u7ed3\u7684\u3002","title":"GDB \u5de5\u4f5c\u539f\u7406"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_2","text":"\u200b \u9884\u5904\u7406\u5668 \u7f16\u8bd1\u5668 \u6c47\u7f16\u5668 \u94fe\u63a5\u5668 \u9884\u5904\u7406\uff1a g++ \u2013E hello.cpp \u2013o hello.i \u7f16 \u8bd1\uff1a g++ -S hello.cpp \u2013o hello.s \u6c47 \u7f16\uff1a g++ -c hello.s \u2013o hello.o \u94fe \u63a5\uff1a g++ hello.c \u2013o hello \u7f16\u8bd1\u8c03\u8bd5\u7248\uff1a g++ -g hello.c \u2013o hello","title":"\u7f16\u8bd1\u7a0b\u5e8f"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#elf","text":"","title":"\u53ef\u6267\u884c\u7a0b\u5e8f\u683c\u5f0f(ELF)"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_3","text":"","title":"\u8fdb\u7a0b\u5730\u5740\u7a7a\u95f4\u5e03\u5c40"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#32","text":"","title":"\u7ecf\u517832\u4f4d"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#amd64","text":"","title":"AMD64"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_4","text":"\u5bc4\u5b58\u5668\u547d\u540d\uff1a32\u4f4d: %EAX , 64\u4f4d: %RAX \u901a\u7528\u5bc4\u5b58\u5668\uff1a %EAX % EBX %ECX %EDX %EAX \u51fd\u6570\u8fd4\u56de\u503c %ECX VC\uff08visual c++\uff09 \u7528\u6765\u5b58\u653e this \u6307\u9488 \u7279\u6b8a\u5bc4\u5b58\u5668\uff1a %ESI \u901a\u5e38\u5728\u5185\u5b58\u64cd\u4f5c\u6307\u4ee4\u4e2d\u4f5c\u4e3a\u201c\u6e90\u5730\u5740\u6307\u9488\u201d\u4f7f\u7528\u3002 %EDI \u901a\u5e38\u5728\u5185\u5b58\u64cd\u4f5c\u6307\u4ee4\u4e2d\u4f5c\u4e3a\u201c\u76ee\u7684\u5730\u5740\u6307\u9488\u201d\u4f7f\u7528\u3002 \u5806\u6808\u5bc4\u5b58\u5668\uff1a %EBP \u6808\u57fa\u5740\u5bc4\u5b58\u5668 %ESP \u6808\u9876\u5bc4\u5b58\u5668 \u6307\u4ee4\u5bc4\u5b58\u5668\uff1a %EIP \u6307\u5411\u5373\u5c06\u6267\u884c\u7684\u90a3\u6761\u6307\u4ee4\u7684\u5730\u5740 \u6807\u5fd7\u5bc4\u5b58\u5668\uff1a %EFR [CF/AF/PF/ZF/SF/OF]","title":"\u5e38\u7528\u5bc4\u5b58\u5668"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_5","text":"push %rbp - \u628a%rbp\u538b\u5165\u6808 mov %rsp,%rbp - \u628a%rsp\u8d4b\u503c\u7ed9%rbp sub $0x30,%rsp - \u79fb\u52a8\u6808\u9876\u6307\u9488\uff0c\u5206\u914d\u6808\u5185\u5b58 lea 0x26e43(%rip),%rsi - \u88c5\u5165\u6709\u6548\u5730\u5740 callq *0x30(%rax) - \u8c03\u7528\u865a\u51fd\u6570 cmp %rax,%r15 - \u6bd4\u8f83 je 0x7f982e65ce62 - \u7b49\u4e8e\u8df3\u8f6c","title":"\u5e38\u7528\u6c47\u7f16\u6307\u4ee4"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_6","text":"__stdcall \uff1a\u53c2\u6570\u91c7\u7528\u4ece\u53f3\u5230\u5de6\u7684\u538b\u6808\u65b9\u5f0f\uff0c\u81ea\u5df1\u5728\u9000\u51fa\u65f6\u6e05\u7a7a\u5806\u6808 __cdecl \uff1ac\u8c03\u7528\u7ea6\u5b9a, \u6309\u4ece\u53f3\u81f3\u5de6\u7684\u987a\u5e8f\u538b\u53c2\u6570\u5165\u6808\uff0c\u7531\u8c03\u7528\u8005\u628a\u53c2\u6570\u5f39\u51fa\u6808\u3002\u5bf9\u4e8e\u4f20\u9001\u53c2\u6570\u7684\u5185\u5b58\u6808\u662f\u7531\u8c03\u7528\u8005\u6765\u7ef4\u62a4\u7684\uff08\u6b63\u56e0\u4e3a\u5982\u6b64\uff0c\u5b9e\u73b0\u53ef\u53d8\u53c2\u6570\u7684\u51fd\u6570\u53ea\u80fd\u4f7f\u7528\u8be5\u8c03\u7528\u7ea6\u5b9a\uff0c\u5982 printf \uff09 thiscall \uff1a\u4ec5\u4ec5\u5e94\u7528\u4e8e\"C++\"\u6210\u5458\u51fd\u6570\u3002this\u6307\u9488\u5b58\u653e\u4e8eCX\u5bc4\u5b58\u5668\uff0c\u53c2\u6570\u4ece\u53f3\u5230\u5de6\u538b\u3002thiscall\u4e0d\u662f\u5173\u952e\u8bcd\uff0c\u56e0\u6b64\u4e0d\u80fd\u88ab\u7a0b\u5e8f\u5458\u6307\u5b9a","title":"\u51fd\u6570\u8c03\u7528\u7ea6\u5b9a"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#c","text":"\u6ce8\u610f\uff1a 1\uff0c\u865a\u51fd\u6570\u8868\u3002\u907f\u514d\u591a\u7ee7\u627f\uff0c\u5404\u5e73\u53f0\u7f16\u8bd1\u5668\u884c\u4e3a\u4e0d\u4e00\u81f4\u3002 2\uff0c\u5185\u5b58\u5bf9\u9f50\u3002","title":"C++ \u5bf9\u8c61\u5185\u5b58\u6a21\u578b"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#glibc","text":"\u7528\u6237\u63a5\u53e3\uff1a malloc / free \u7cfb\u7edf\u8c03\u7528\uff1a brk / mmap / munmap \u5927\u5185\u5b58(>128k): \u76f4\u63a5\u8c03\u7528 mmap \u5c0f\u5185\u5b58: sbrk \uff0c\u94fe\u8868\u7ba1\u7406","title":"glibc \u5185\u5b58\u7ba1\u7406"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#32_1","text":"","title":"\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\uff0832\u4f4d\uff09"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#64","text":"%rax \u4f5c\u4e3a\u51fd\u6570\u8fd4\u56de\u503c\u4f7f\u7528\uff1b %rsp \u6808\u6307\u9488\u5bc4\u5b58\u5668\uff0c\u6307\u5411\u6808\u9876\uff1b %rdi \uff0c %rsi \uff0c %rdx \uff0c %rcx \uff0c %r8 \uff0c %r9 \u7528\u4f5c\u51fd\u6570\u524d6\u4e2a\u53c2\u6570\uff0c\u591a\u4f59\u7684\u53c2\u6570\u4f9d\u6b21\u4fdd\u5b58\u5728\u6808\u4e0a; %rbx \uff0c %rbp \uff0c %r12 \uff0c %r13 \uff0c %r14 \uff0c %r15 \u7528\u4f5c\u6570\u636e\u5b58\u50a8\uff0c\u9075\u5faa\u88ab\u8c03\u7528\u8005\u4f7f\u7528\u89c4\u5219\uff0c\u7b80\u5355\u8bf4\u5c31\u662f\u968f\u4fbf\u7528\uff0c\u8c03\u7528\u5b50\u51fd\u6570\u4e4b\u524d\u8981\u5907\u4efd\u5b83\uff0c\u4ee5\u9632\u88ab\u4fee\u6539\uff1b %r10 \uff0c %r11 \u7528\u4f5c\u6570\u636e\u5b58\u50a8\uff0c\u9075\u5faa\u8c03\u7528\u8005\u4f7f\u7528\u89c4\u5219\uff0c\u7b80\u5355\u8bf4\u5c31\u662f\u4f7f\u7528\u4e4b\u524d\u8981\u5148\u4fdd\u5b58\u539f\u503c\uff1b","title":"\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\uff0864\u4f4d\uff09"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#gdb_2","text":"","title":"GDB\u547d\u4ee4"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#help","text":"","title":"\u5e2e\u52a9\u547d\u4ee4\uff08help\uff09"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#gdb_3","text":"","title":"GDB \u542f\u52a8"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#gdb_4","text":"","title":"GDB \u6267\u884c"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#gdb_5","text":"","title":"GDB \u57fa\u672c\u547d\u4ee4"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_7","text":"","title":"\u65ad\u70b9"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_8","text":"","title":"\u4fe1\u53f7"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_9","text":"","title":"\u81ea\u5b9a\u4e49\u547d\u4ee4"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#gdb_6","text":"","title":"GDB\u5b9e\u6218"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_10","text":"1\uff0c\u7a0b\u5e8f\u7f16\u8bd1\uff1a \u52a0\u4e0a -g \uff0c\u53bb\u6389\u4f18\u5316 -O2 2\uff0c\u751f\u6210core\u5927\u5c0f\u8bbe\u7f6e\uff1a ulimit \u2013c unlimited 3\uff0c\u8bbe\u7f6ecoredump \u751f\u6210\u8def\u5f84 echo '/tmp/cores/core.%e.%p.%t' > /proc/sys/kernel/core_pattern","title":"\u524d\u63d0"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#coredump","text":"1\uff0c gdb hsserver core.1234 \uff0c\u67e5\u770bcore\u6587\u4ef6 2\uff0c\u67e5\u770bgdb\u8f93\u51fa\uff0c\u786e\u8ba4\u7a0b\u5e8f\u548cso\u5e93\u5339\u914d\u3002 3\uff0c\u9996\u5148\u6839\u636eframe 0\u4fe1\u606f\uff0c\u786e\u8ba4\u7a0b\u5e8f\u5d29\u6e83\u7684\u76f4\u63a5\u539f\u56e0\u3002 4\uff0c bt \u67e5\u770b\u5806\u6808\u548c\u524d\u540e\u4ee3\u7801 5\uff0c\u67e5\u770b\u7ebf\u7a0b\u4fe1\u606f","title":"\u5206\u6790coredump\u6b65\u9aa4"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_11","text":"\u6839\u636e\u7a0b\u5e8f\u6253\u5370\uff0c\u5224\u65ad\u8fdb\u7a0b\u5185\u5b58\u5e03\u5c40\u3002 \u53c2\u89c1 address.cpp \u3002","title":"\u8fdb\u7a0b\u5185\u5b58\u5e03\u5c40"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#_12","text":"\u901a\u8fc7\u51fd\u6570\u8c03\u7528\uff0c\u8ddf\u8e2a\u5806\u6808\u53d8\u5316\u3002 \u67e5\u770b\u5165\u53c2\u4fe1\u606f\u548c\u672c\u5730\u53d8\u91cf\u4fe1\u606f\u7b49\u3002 \u53c2\u89c1 func.cpp","title":"\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\u8ddf\u8e2a"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#coredump_1","text":"\u8c03\u8bd5\u5b9e\u9645\u7684coredump \u5b9a\u4f4d\u7a0b\u5e8f\u5d29\u6e83\u539f\u56e0","title":"coredump \u5b9a\u4f4d"},{"location":"Shell-and-tools/Tools/Debug/GDB/Debugging-with-gdb/Guide/gdb-primer/gdb-primer/#gdb_7","text":"http://www.gnu.org/software/gdb/","title":"GDB \u6587\u6863"},{"location":"Shell-and-tools/Tools/Debug/Library-call-tracer/ltrace/","text":"ltrace \u7ef4\u57fa\u767e\u79d1 ltrace ltrace(1) \u2014 Linux manual page","title":"ltrace"},{"location":"Shell-and-tools/Tools/Debug/Library-call-tracer/ltrace/#ltrace","text":"","title":"ltrace"},{"location":"Shell-and-tools/Tools/Debug/Library-call-tracer/ltrace/#ltrace_1","text":"","title":"\u7ef4\u57fa\u767e\u79d1 ltrace"},{"location":"Shell-and-tools/Tools/Debug/Library-call-tracer/ltrace/#ltrace1#linux#manual#page","text":"","title":"ltrace(1) \u2014 Linux manual page"},{"location":"Shell-and-tools/Tools/Debug/Stack-trace/Stack-trace/","text":"wikipedia Stack trace In computing , a stack trace (also called stack backtrace [ 1] or stack traceback [ 2] ) is a report of the active stack frames at a certain point in time during the execution of a program . When a program is run, memory is often dynamically allocated in two places\uff1athe stack and the heap . Memory is contiguously allocated on a stack but not on a heap, thus reflective of their names. Stack also refers to a programming construct, thus to differentiate it, this stack is referred to as the program's runtime stack . Technically, once a block of memory has been allocated on the stack, it cannot be easily removed as there can be other blocks of memory that were allocated before it. Each time a function is called in a program, a block of memory is allocated on top of the runtime stack called the activation record (or stack pointer.) At a high level, an activation record allocates memory for the function's parameters and local variables declared in the function. Programmers commonly use stack tracing during interactive and post-mortem debugging . End-users may see a stack trace displayed as part of an error message , which the user can then report to a programmer. A stack trace allows tracking the sequence of nested functions called - up to the point where the stack trace is generated. In a post-mortem scenario this extends up to the function where the failure occurred (but was not necessarily caused). Sibling calls do not appear in a stack trace. As an example, the following Python program contains an error.","title":"Stack-trace"},{"location":"Shell-and-tools/Tools/Debug/Stack-trace/Stack-trace/#wikipedia#stack#trace","text":"In computing , a stack trace (also called stack backtrace [ 1] or stack traceback [ 2] ) is a report of the active stack frames at a certain point in time during the execution of a program . When a program is run, memory is often dynamically allocated in two places\uff1athe stack and the heap . Memory is contiguously allocated on a stack but not on a heap, thus reflective of their names. Stack also refers to a programming construct, thus to differentiate it, this stack is referred to as the program's runtime stack . Technically, once a block of memory has been allocated on the stack, it cannot be easily removed as there can be other blocks of memory that were allocated before it. Each time a function is called in a program, a block of memory is allocated on top of the runtime stack called the activation record (or stack pointer.) At a high level, an activation record allocates memory for the function's parameters and local variables declared in the function. Programmers commonly use stack tracing during interactive and post-mortem debugging . End-users may see a stack trace displayed as part of an error message , which the user can then report to a programmer. A stack trace allows tracking the sequence of nested functions called - up to the point where the stack trace is generated. In a post-mortem scenario this extends up to the function where the failure occurred (but was not necessarily caused). Sibling calls do not appear in a stack trace. As an example, the following Python program contains an error.","title":"wikipedia Stack trace"},{"location":"Shell-and-tools/Tools/Debug/Stack-trace/pstack/pstack/","text":"pstack docs.oracle pstack Command pstack(1) - Linux man page Example: How to use pstack and gcore to gather additional data for Support","title":"pstack"},{"location":"Shell-and-tools/Tools/Debug/Stack-trace/pstack/pstack/#pstack","text":"","title":"pstack"},{"location":"Shell-and-tools/Tools/Debug/Stack-trace/pstack/pstack/#docsoracle#pstack#command","text":"","title":"docs.oracle pstack Command"},{"location":"Shell-and-tools/Tools/Debug/Stack-trace/pstack/pstack/#pstack1#-#linux#man#page","text":"Example: How to use pstack and gcore to gather additional data for Support","title":"pstack(1) - Linux man page"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/TODO/","text":"TODO how to trace system call of a process \u8fd9\u662f\u6211\u5728hustoj\u4e2d\u5df2\u7ecf\u78b0\u5230\u8fc7\u7684\u4e00\u79cd\u573a\u666f sandbox gdb gdb how to trace the system call in linux https://www.ibm.com/developerworks/aix/library/au-unix-strace.html https://stackoverflow.com/questions/29840213/how-do-i-trace-a-system-call-in-linux user space and kernel space https://www.tecmint.com/strace-commands-for-troubleshooting-and-debugging-linux/#:~:text= https://linux.die.net/man/1/strace https://stackoverflow.com/questions/29840213/how-do-i-trace-a-system-call-in-linux https://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/","title":"TODO"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/TODO/#todo","text":"","title":"TODO"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/TODO/#how#to#trace#system#call#of#a#process","text":"\u8fd9\u662f\u6211\u5728hustoj\u4e2d\u5df2\u7ecf\u78b0\u5230\u8fc7\u7684\u4e00\u79cd\u573a\u666f sandbox gdb gdb how to trace the system call in linux https://www.ibm.com/developerworks/aix/library/au-unix-strace.html https://stackoverflow.com/questions/29840213/how-do-i-trace-a-system-call-in-linux user space and kernel space https://www.tecmint.com/strace-commands-for-troubleshooting-and-debugging-linux/#:~:text= https://linux.die.net/man/1/strace https://stackoverflow.com/questions/29840213/how-do-i-trace-a-system-call-in-linux https://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/","title":"how to trace system call of a process"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/ptrace/","text":"ptrace wikipedia ptrace","title":"ptrace"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/ptrace/#ptrace","text":"","title":"ptrace"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/ptrace/#wikipedia#ptrace","text":"","title":"wikipedia ptrace"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/strace/strace/","text":"strace wikipedia strace strace(1) \u2014 Linux manual page TO READ geeksforgeeks Strace command in Linux with Examples thegeekstuff 7 Strace Examples to Debug the Execution of a Program in Linux https://stackoverflow.com/questions/29840213/how-do-i-trace-a-system-call-in-linux https://www.tecmint.com/strace-commands-for-troubleshooting-and-debugging-linux/","title":"strace"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/strace/strace/#strace","text":"","title":"strace"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/strace/strace/#wikipedia#strace","text":"","title":"wikipedia strace"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/strace/strace/#strace1#linux#manual#page","text":"","title":"strace(1) \u2014 Linux manual page"},{"location":"Shell-and-tools/Tools/Debug/System-call-trace/strace/strace/#to#read","text":"geeksforgeeks Strace command in Linux with Examples thegeekstuff 7 Strace Examples to Debug the Execution of a Program in Linux https://stackoverflow.com/questions/29840213/how-do-i-trace-a-system-call-in-linux https://www.tecmint.com/strace-commands-for-troubleshooting-and-debugging-linux/","title":"TO READ"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/","text":"How do I read the output of dmesg to determine how much memory a process is using when oom-killer is invoked? How to translate kernel's trap divide error rsp:2b6d2ea40450 to a source location? A How do you read a segfault kernel log message A When the report points to a program, not a shared library If it's a shared library What the error means A A How do I read the output of dmesg to determine how much memory a process is using when oom-killer is invoked? How to translate kernel's trap divide error rsp:2b6d2ea40450 to a source location? Customer reported an error in one of our programs caused by division by zero. We have only this VLM line: kernel: myprog[16122] trap divide error rip:79dd99 rsp:2b6d2ea40450 error:0 I do not believe there is core file for that. I searched through the Internet to find how I can tell the line of the program that caused this division by zero, but so far I am failing. I understand that 16122 is pid of the program, so that will not help me. I suspect that rsp:2b6d2ea40450 has something to do with the address of the line that caused the error ( 0x2b6d2ea40450 ) but is that true? If it is then how can I translate it to a physical approximate location in the source assuming I can load debug version of myprog into gdb, and then request to show the context around this address... Any, any help will be greatly appreciated! A ip is the instruction pointer , rsp is the stack pointer . The stack pointer is not too useful unless you have a core image or a running process. You can use either addr2line or the disassemble command in gdb to see the line that got the error, based on the ip . $ cat divtest . c main () { int a , b ; a = 1 ; b = a / 0 ; } $ . / divtest Floating point exception ( core dumped ) $ dmesg | tail -1 [ 6827.463256 ] traps : divtest [ 3255 ] trap divide error ip : 400504 sp : 7f ff54e81330 error : 0 in divtest [ 400000 + 1000 ] $ addr2line - e divtest 400504 . / divtest . c : 5 $ gdb divtest ( gdb ) disass / m 0x400504 Dump of assembler code for function main : 2 { 0x00000000004004f0 : push % rbp 0x00000000004004f1 : mov % rsp , % rbp 3 int a , b ; 4 5 a = 1 ; b = a / 0 ; 0x00000000004004f4 : movl $0x1 , -0x4 ( % rbp ) 0x00000000004004fb : mov -0x4 ( % rbp ), % eax 0x00000000004004fe : mov $0x0 , % ecx 0x0000000000400503 : cltd 0x0000000000400504 : idiv % ecx 0x0000000000400506 : mov % eax , -0x8 ( % rbp ) 6 } 0x0000000000400509 : pop % rbp 0x000000000040050a : retq End of assembler dump . How do you read a segfault kernel log message This can be a very simple question, I'm am attempting to debug an application which generates the following segfault error in the kern.log kernel: myapp[15514]: segfault at 794ef0 ip 080513b sp 794ef0 error 6 in myapp[8048000+24000] Here are my questions: Is there any documentation as to what are the diff error numbers on segfault, in this instance it is error 6, but i've seen error 4, 5 What is the meaning of the information at bf794ef0 ip 0805130b sp bf794ef0 and myapp[8048000+24000] ? So far i was able to compile with symbols, and when i do a x 0x8048000+24000 it returns a symbol, is that the correct way of doing it? My assumptions thus far are the following: sp = stack pointer? ip = instruction pointer at = ???? myapp[8048000+24000] = address of symbol? A When the report points to a program, not a shared library Run addr2line -e myapp 080513b (and repeat for the other instruction pointer values given) to see where the error is happening. Better, get a debug-instrumented build , and reproduce the problem under a debugger such as gdb. If it's a shared library In the libfoo.so[NNNNNN+YYYY] part, the NNNNNN is where the library was loaded. Subtract this from the instruction pointer ( ip ) and you'll get the offset into the .so of the offending instruction. Then you can use objdump -DCgl libfoo.so and search for the instruction at that offset. You should easily be able to figure out which function it is from the asm labels. If the .so doesn't have optimizations you can also try using addr2line -e libfoo.so <offset> . What the error means Here's the breakdown of the fields: address - the location in memory the code is trying to access (it's likely that 10 and 11 are offsets from a pointer we expect to be set to a valid value but which is instead pointing to 0 ) ip - instruction pointer, ie. where the code which is trying to do this lives sp - stack pointer error - Architecture-specific flags; see arch/*/mm/fault.c for your platform. COMMENTS : you gotta be wrong about error \u2013 Dima Tisnek Sep 12 '12 at 12:25 much better now \u2013 Dima Tisnek Sep 30 '12 at 9:07 Event for a shared lib, the \"[8048000+24000]\" part should give a hint where the crashing segment of the lib was mapped in memory. \"readelf --segments mylib.so\" lists these segments, and then you can calculate the EIP offset into the crashing segment and feed that to addr2line (or view it in \"objdump -dgS\"). \u2013 oliver Jun 13 '13 at 17:18 I believe 0x8048000 is (probably) the address where the text segment was mapped, so you will want to pass -j .text to the objdump command. (At least, that is what I needed when diagnosing one of these just now.) \u2013 Nemo Jun 5 '14 at 16:30 @Charles Duffy If I ever see you I will hug like I never hugged a living soul. \u2013 Baroudi Safwen Jan 11 '18 at 18:47 A Based on my limited knowledge, your assumptions are correct. sp = stack pointer ip = instruction pointer myapp[8048000+24000] = address If I were debugging the problem I would modify the code to produce a core dump or log a stack backtrace on the crash. You might also run the program under (or attach) GDB. The error code is just the architectural error code for page faults and seems to be architecture specific. They are often documented in arch/*/mm/fault.c in the kernel source. My copy of Linux/arch/i386/mm/fault.c has the following definition for error_code: bit 0 == 0 means no page found, 1 means protection fault bit 1 == 0 means read, 1 means write bit 2 == 0 means kernel, 1 means user-mode My copy of Linux/arch/x86_64/mm/fault.c adds the following: bit 3 == 1 means fault was an instruction fetch Beat me to it :) \u2013 David Titarenco Feb 1 '10 at 19:34 The issue i have is that: 1) The application is segfaulting in a production environment, where symbols are stripped, all i have is just the logs 2) I'm trying to find that memory location in the development env, so at least i can see where it is crashing. \u2013 Sullenx Feb 1 '10 at 19:42 1 If you have the pre-stripped binary, try running it through nm or objdump. \u2013 jschmier Feb 1 '10 at 19:52 nm is pretty helpful, at least I have an idea where the crash happened. One last thing, what is an error 6? ... is there any table out there? \u2013 Sullenx Feb 1 '10 at 20:07 I updated my answer to include the error code. \u2013 jschmier Feb 1 '10 at 20:47 3 segfault at 794ef0 ... sp 794ef0 - stack is obviously corrupted. \u2013 Nikolai Fetissov Feb 1 '10 at 20:54 Thank you, this is very helpful \u2013 Sullenx Feb 1 '10 at 20:56 A If it's a shared library You're hosed, unfortunately; it's not possible to know where the libraries were placed in memory by the dynamic linker after-the-fact . Well, there is still a possibility to retrieve the information, not from the binary, but from the object. But you need the base address of the object. And this information still is within the coredump, in the link_map structure. So first you want to import the struct link_map into GDB. So lets compile a program with it with debug symbol and add it to the GDB. link.c #include <link.h> toto (){ struct link_map * s = 0x400 ;} get_baseaddr_from_coredump.sh #!/bin/bash BINARY = $( which myapplication ) IsBinPIE () { readelf -h $1 | grep 'Type' | grep \"EXEC\" >/dev/null || return 0 return 1 } Hex2Decimal () { export number = \"`echo \" $1 \" | sed -e 's:^0[xX]::' | tr '[a-f]' '[A-F]'`\" export number = ` echo \"ibase=16; $number \" | bc ` } GetBinaryLength () { if [ $# ! = 1 ] ; then echo \"Error, no argument provided\" fi IsBinPIE $1 || ( echo \"ET_EXEC file, need a base_address\" ; exit 0 ) export totalsize = 0 # Get PT_LOAD's size segment out of Program Header Table (ELF format) export sizes = \" $( readelf -l $1 | grep LOAD | awk '{print $6}' | tr '\\n' ' ' ) \" for size in $sizes do Hex2Decimal \" $size \" ; export totalsize = $( expr $number + $totalsize ) ; export totalsize = $( expr $number + $totalsize ) done return $totalsize } if [ $# = 1 ] ; then echo \"Using binary $1 \" IsBinPIE $1 && ( echo \"NOT ET_EXEC, need a base_address...\" ; exit 0 ) BINARY = $1 fi gcc -g3 -fPIC -shared link.c -o link.so GOTADDR = $( readelf -S $BINARY | grep -E '\\.got.plt[ \\t]' | awk '{print $4}' ) echo \"First do the following command :\" echo file $BINARY echo add-symbol-file ./link.so 0x0 read echo \"Now copy/paste the following into your gdb session with attached coredump\" cat <<EOF set \\$ linkmapaddr = * ( 0x $GOTADDR + 4 ) set \\$ mylinkmap = ( struct link_map * ) \\$ linkmapaddr while ( \\$ mylinkmap ! = 0 ) if ( \\$ mylinkmap->l_addr ) printf \"add-symbol-file .%s %#.08x\\n\" , \\$ mylinkmap->l_name, \\$ mylinkmap->l_addr end set \\$ mylinkmap = \\$ mylinkmap->l_next end it will print you the whole link_map content, within a set of GDB command. It itself it might seems unnesseray but with the base_addr of the shared object we are about, you might get some more information out of an address by debuging directly the involved shared object in another GDB instance. Keep the first gdb to have an idee of the symbol. NOTE : the script is rather incomplete i suspect you may add to the second parameter of add-symbol-file printed the sum with this value : readelf -S $SO_PATH | grep -E '\\.text[ \\t]' | awk '{print $5}' where $SO_PATH is the first argument of the add-symbol-file Hope it helps","title":"Dmesg-format"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/#how#do#i#read#the#output#of#dmesg#to#determine#how#much#memory#a#process#is#using#when#oom-killer#is#invoked","text":"","title":"How do I read the output of dmesg to determine how much memory a process is using when oom-killer is invoked?"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/#how#to#translate#kernels#trap#divide#error#rsp2b6d2ea40450#to#a#source#location","text":"Customer reported an error in one of our programs caused by division by zero. We have only this VLM line: kernel: myprog[16122] trap divide error rip:79dd99 rsp:2b6d2ea40450 error:0 I do not believe there is core file for that. I searched through the Internet to find how I can tell the line of the program that caused this division by zero, but so far I am failing. I understand that 16122 is pid of the program, so that will not help me. I suspect that rsp:2b6d2ea40450 has something to do with the address of the line that caused the error ( 0x2b6d2ea40450 ) but is that true? If it is then how can I translate it to a physical approximate location in the source assuming I can load debug version of myprog into gdb, and then request to show the context around this address... Any, any help will be greatly appreciated!","title":"How to translate kernel's trap divide error rsp:2b6d2ea40450 to a source location?"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/#a","text":"ip is the instruction pointer , rsp is the stack pointer . The stack pointer is not too useful unless you have a core image or a running process. You can use either addr2line or the disassemble command in gdb to see the line that got the error, based on the ip . $ cat divtest . c main () { int a , b ; a = 1 ; b = a / 0 ; } $ . / divtest Floating point exception ( core dumped ) $ dmesg | tail -1 [ 6827.463256 ] traps : divtest [ 3255 ] trap divide error ip : 400504 sp : 7f ff54e81330 error : 0 in divtest [ 400000 + 1000 ] $ addr2line - e divtest 400504 . / divtest . c : 5 $ gdb divtest ( gdb ) disass / m 0x400504 Dump of assembler code for function main : 2 { 0x00000000004004f0 : push % rbp 0x00000000004004f1 : mov % rsp , % rbp 3 int a , b ; 4 5 a = 1 ; b = a / 0 ; 0x00000000004004f4 : movl $0x1 , -0x4 ( % rbp ) 0x00000000004004fb : mov -0x4 ( % rbp ), % eax 0x00000000004004fe : mov $0x0 , % ecx 0x0000000000400503 : cltd 0x0000000000400504 : idiv % ecx 0x0000000000400506 : mov % eax , -0x8 ( % rbp ) 6 } 0x0000000000400509 : pop % rbp 0x000000000040050a : retq End of assembler dump .","title":"A"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/#how#do#you#read#a#segfault#kernel#log#message","text":"This can be a very simple question, I'm am attempting to debug an application which generates the following segfault error in the kern.log kernel: myapp[15514]: segfault at 794ef0 ip 080513b sp 794ef0 error 6 in myapp[8048000+24000] Here are my questions: Is there any documentation as to what are the diff error numbers on segfault, in this instance it is error 6, but i've seen error 4, 5 What is the meaning of the information at bf794ef0 ip 0805130b sp bf794ef0 and myapp[8048000+24000] ? So far i was able to compile with symbols, and when i do a x 0x8048000+24000 it returns a symbol, is that the correct way of doing it? My assumptions thus far are the following: sp = stack pointer? ip = instruction pointer at = ???? myapp[8048000+24000] = address of symbol?","title":"How do you read a segfault kernel log message"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/#a_1","text":"","title":"A"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/#when#the#report#points#to#a#program#not#a#shared#library","text":"Run addr2line -e myapp 080513b (and repeat for the other instruction pointer values given) to see where the error is happening. Better, get a debug-instrumented build , and reproduce the problem under a debugger such as gdb.","title":"When the report points to a program, not a shared library"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/#if#its#a#shared#library","text":"In the libfoo.so[NNNNNN+YYYY] part, the NNNNNN is where the library was loaded. Subtract this from the instruction pointer ( ip ) and you'll get the offset into the .so of the offending instruction. Then you can use objdump -DCgl libfoo.so and search for the instruction at that offset. You should easily be able to figure out which function it is from the asm labels. If the .so doesn't have optimizations you can also try using addr2line -e libfoo.so <offset> .","title":"If it's a shared library"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/#what#the#error#means","text":"Here's the breakdown of the fields: address - the location in memory the code is trying to access (it's likely that 10 and 11 are offsets from a pointer we expect to be set to a valid value but which is instead pointing to 0 ) ip - instruction pointer, ie. where the code which is trying to do this lives sp - stack pointer error - Architecture-specific flags; see arch/*/mm/fault.c for your platform. COMMENTS : you gotta be wrong about error \u2013 Dima Tisnek Sep 12 '12 at 12:25 much better now \u2013 Dima Tisnek Sep 30 '12 at 9:07 Event for a shared lib, the \"[8048000+24000]\" part should give a hint where the crashing segment of the lib was mapped in memory. \"readelf --segments mylib.so\" lists these segments, and then you can calculate the EIP offset into the crashing segment and feed that to addr2line (or view it in \"objdump -dgS\"). \u2013 oliver Jun 13 '13 at 17:18 I believe 0x8048000 is (probably) the address where the text segment was mapped, so you will want to pass -j .text to the objdump command. (At least, that is what I needed when diagnosing one of these just now.) \u2013 Nemo Jun 5 '14 at 16:30 @Charles Duffy If I ever see you I will hug like I never hugged a living soul. \u2013 Baroudi Safwen Jan 11 '18 at 18:47","title":"What the error means"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/#a_2","text":"Based on my limited knowledge, your assumptions are correct. sp = stack pointer ip = instruction pointer myapp[8048000+24000] = address If I were debugging the problem I would modify the code to produce a core dump or log a stack backtrace on the crash. You might also run the program under (or attach) GDB. The error code is just the architectural error code for page faults and seems to be architecture specific. They are often documented in arch/*/mm/fault.c in the kernel source. My copy of Linux/arch/i386/mm/fault.c has the following definition for error_code: bit 0 == 0 means no page found, 1 means protection fault bit 1 == 0 means read, 1 means write bit 2 == 0 means kernel, 1 means user-mode My copy of Linux/arch/x86_64/mm/fault.c adds the following: bit 3 == 1 means fault was an instruction fetch Beat me to it :) \u2013 David Titarenco Feb 1 '10 at 19:34 The issue i have is that: 1) The application is segfaulting in a production environment, where symbols are stripped, all i have is just the logs 2) I'm trying to find that memory location in the development env, so at least i can see where it is crashing. \u2013 Sullenx Feb 1 '10 at 19:42 1 If you have the pre-stripped binary, try running it through nm or objdump. \u2013 jschmier Feb 1 '10 at 19:52 nm is pretty helpful, at least I have an idea where the crash happened. One last thing, what is an error 6? ... is there any table out there? \u2013 Sullenx Feb 1 '10 at 20:07 I updated my answer to include the error code. \u2013 jschmier Feb 1 '10 at 20:47 3 segfault at 794ef0 ... sp 794ef0 - stack is obviously corrupted. \u2013 Nikolai Fetissov Feb 1 '10 at 20:54 Thank you, this is very helpful \u2013 Sullenx Feb 1 '10 at 20:56","title":"A"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-format/#a_3","text":"If it's a shared library You're hosed, unfortunately; it's not possible to know where the libraries were placed in memory by the dynamic linker after-the-fact . Well, there is still a possibility to retrieve the information, not from the binary, but from the object. But you need the base address of the object. And this information still is within the coredump, in the link_map structure. So first you want to import the struct link_map into GDB. So lets compile a program with it with debug symbol and add it to the GDB. link.c #include <link.h> toto (){ struct link_map * s = 0x400 ;} get_baseaddr_from_coredump.sh #!/bin/bash BINARY = $( which myapplication ) IsBinPIE () { readelf -h $1 | grep 'Type' | grep \"EXEC\" >/dev/null || return 0 return 1 } Hex2Decimal () { export number = \"`echo \" $1 \" | sed -e 's:^0[xX]::' | tr '[a-f]' '[A-F]'`\" export number = ` echo \"ibase=16; $number \" | bc ` } GetBinaryLength () { if [ $# ! = 1 ] ; then echo \"Error, no argument provided\" fi IsBinPIE $1 || ( echo \"ET_EXEC file, need a base_address\" ; exit 0 ) export totalsize = 0 # Get PT_LOAD's size segment out of Program Header Table (ELF format) export sizes = \" $( readelf -l $1 | grep LOAD | awk '{print $6}' | tr '\\n' ' ' ) \" for size in $sizes do Hex2Decimal \" $size \" ; export totalsize = $( expr $number + $totalsize ) ; export totalsize = $( expr $number + $totalsize ) done return $totalsize } if [ $# = 1 ] ; then echo \"Using binary $1 \" IsBinPIE $1 && ( echo \"NOT ET_EXEC, need a base_address...\" ; exit 0 ) BINARY = $1 fi gcc -g3 -fPIC -shared link.c -o link.so GOTADDR = $( readelf -S $BINARY | grep -E '\\.got.plt[ \\t]' | awk '{print $4}' ) echo \"First do the following command :\" echo file $BINARY echo add-symbol-file ./link.so 0x0 read echo \"Now copy/paste the following into your gdb session with attached coredump\" cat <<EOF set \\$ linkmapaddr = * ( 0x $GOTADDR + 4 ) set \\$ mylinkmap = ( struct link_map * ) \\$ linkmapaddr while ( \\$ mylinkmap ! = 0 ) if ( \\$ mylinkmap->l_addr ) printf \"add-symbol-file .%s %#.08x\\n\" , \\$ mylinkmap->l_name, \\$ mylinkmap->l_addr end set \\$ mylinkmap = \\$ mylinkmap->l_next end it will print you the whole link_map content, within a set of GDB command. It itself it might seems unnesseray but with the base_addr of the shared object we are about, you might get some more information out of an address by debuging directly the involved shared object in another GDB instance. Keep the first gdb to have an idee of the symbol. NOTE : the script is rather incomplete i suspect you may add to the second parameter of add-symbol-file printed the sum with this value : readelf -S $SO_PATH | grep -E '\\.text[ \\t]' | awk '{print $5}' where $SO_PATH is the first argument of the add-symbol-file Hope it helps","title":"A"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-segfaulting/","text":"What the Linux kernel's messages about segfaulting programs mean on 64-bit x86 For quite a while the Linux kernel has had an option to log a kernel message about every faulting user program , and it probably defaults to on in your Linux distribution. I've seen these messages fly by for years, but for reasons beyond the scope of this entry I've recently wanted to understand what they mean in some moderate amount of detail. I'll start with a straightforward and typical example, one that I see every time I build and test Go (as this is a test case that is supposed to crash): testp[19288]: segfault at 0 ip 0000000000401271 sp 00007fff2ce4d210 error 4 in testp[400000+98000] The meaning of this is: ' testp[19288] ' is the faulting program and its PID ' segfault at 0 ' tells us the memory address (in hex) that caused the segfault when the program tried to access it. Here the address is 0, so we have a null dereference of some sort. ' ip 0000000000401271 ' is the value of the instruction pointer at the time of the fault. This should be the instruction that attempted to do the invalid memory access. In 64-bit x86, this will be register %rip (useful for inspecting things in GDB and elsewhere). ' sp 00007fff2ce4d210 ' is the value of the stack pointer. In 64-bit x86, this will be %rsp . ' error 4 ' is the page fault error code bits from traps.h in hex, as usual, and will almost always be at least 4 (which means 'user-mode access'). A value of 4 means it was a read of an unmapped area , such as address 0, while a value of 6 (4+2) means it was a write of an unmapped area . ' in testp[400000+98000] ' tells us the specific virtual memory area that the instruction pointer is in, specifying which file it is (here it's the executable), the starting address that VMA is mapped at ( 0x400000 ), and the size of the mapping ( 0x98000 ). With a faulting address of 0 and an error code of 4, we know this particular segfault is a read of a null pointer . Here's two more error messages: bash[12235]: segfault at 1054808 ip 000000000041d989 sp 00007ffec1f1cbd8 error 6 in bash[400000+f4000] 'Error 6' means a write to an unmapped user address , here 0x1054808 . bash[11909]: segfault at 0 ip 00007f83c03db746 sp 00007ffccbeda010 error 4 in libc-2.23.so[7f83c0350000+1c0000] Error 4 and address 0 is a null pointer read but this time it's in some libc function, not in bash's own code, since it's reported as 'in libc-2.23.so [...]'. Since I looked at the core dump, I can tell you that this was in strlen() . On 64-bit x86 Linux, you'll get a somewhat different message if the problem is actually with the instruction being executed, not the address it's referencing. For example: bash[2848] trap invalid opcode ip:48db90 sp:7ffddc8879e8 error:0 in bash[400000+f4000] There are a number of such trap types set up in traps.c . Two notable additional ones are 'divide error', which you get if you do an integer division by zero, and 'general protection', which you can get for certain extremely wild pointers (one case I know of is when your 64-bit x86 address is not in 'canonical form' ). Although these fields are formatted slightly differently, most of them mean the same thing as in segfaults. The exception is ' error:0 ', which is not a page fault error code. I don't understand the relevant kernel code enough to know what it means, but if I'm reading between the lines correctly in entry_64.txt , then it's either 0 (the usual case) or an error code from the CPU. Here is one possible list of exceptions that get error codes. Sometimes these messages can be a little bit unusual and surprising. Here is a silly sample program and the error it produces when run. The code: #include <stdio.h> int main(int argc, char **argv) { int (*p)(); p = 0x0; return printf(\"%d\\n\", (*p)()); } If compiled (without optimization is best) and run, this generates the kernel message: a.out[3714]: segfault at 0 ip (null) sp 00007ffe872aa418 error 14 in a.out[400000+1000] The ' (null) ' bit turns out to be expected; it's what the general kernel printf() function generates when asked to print something as a pointer and it's null (as seen here ). In our case the instruction pointer is 0 (null) because we've made a subroutine call through a null pointer and thus we're trying to execute code at address 0. I don't know why the 'in ...' portion says that we're in the executable (although in this case the call actually was there). The error code of 14 is in hex, which means that as bits it's 010100. This is a user mode read of an unmapped area (our usual '4' case), but it's an instruction fetch, not a normal data read or write. Any error 14s are a sign of some form of mangled function call or a return to a mangled address because the stack has been mashed. (These bits turn out to come straight from the CPU's page fault IDT .) For 64-bit x86 Linux kernels (and possibly for 32-bit x86 ones as well), the code you want to look at is show_signal_msg in fault.c , which prints the general 'segfault at ..' message, do_trap and do_general_protection in traps.c , which print the 'trap ...' messages, and print_vma_addr in memory.c , which prints the 'in ...' portion for all of these messages. Sidebar: The various error code bits as numbers +1 protection fault in a mapped area (eg writing to a read-only mapping) +2 write (instead of a read) +4 user mode access (instead of kernel mode access) +8 use of reserved bits in the page table entry detected (the kernel will panic if this happens) +16 (+0x10) fault was an instruction fetch, not data read or write +32 (+0x20) 'protection keys block access' (don't ask me) Hex 0x14 is 0x10 + 4; (hex) 6 is 4 + 2. Error code 7 (0x7) is 4 + 2 + 1, a user-mode write to a read-only mapping, and is what you get if you attempt to write to a string constant in C: char *ex = \"example\"; int main(int argc, char **argv) { *ex = 'E'; } Compile and run this and you will get: a.out[8832]: segfault at 400540 ip 0000000000400499 sp 00007ffce6831490 error 7 in a.out[400000+1000] It appears that the program code always gets loaded at 0x400000 for ordinary programs, although I believe that shared libraries can have their location randomized. PS: Per a comment in the kernel source, all accesses to addresses above the end of user space will be labeled as 'protection fault in a mapped area' whether or not there are actual page table entries there. The kernel does this so you can't work out where its memory pages are by looking at the error code. (I believe that user space normally ends around 0x07fffffffffff, per mm.txt , although see the comments about TASK_SIZE_MAX in processor.h and also page_64_types.h .)","title":"Dmesg-segfaulting"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-segfaulting/#what#the#linux#kernels#messages#about#segfaulting#programs#mean#on#64-bit#x86","text":"For quite a while the Linux kernel has had an option to log a kernel message about every faulting user program , and it probably defaults to on in your Linux distribution. I've seen these messages fly by for years, but for reasons beyond the scope of this entry I've recently wanted to understand what they mean in some moderate amount of detail. I'll start with a straightforward and typical example, one that I see every time I build and test Go (as this is a test case that is supposed to crash): testp[19288]: segfault at 0 ip 0000000000401271 sp 00007fff2ce4d210 error 4 in testp[400000+98000] The meaning of this is: ' testp[19288] ' is the faulting program and its PID ' segfault at 0 ' tells us the memory address (in hex) that caused the segfault when the program tried to access it. Here the address is 0, so we have a null dereference of some sort. ' ip 0000000000401271 ' is the value of the instruction pointer at the time of the fault. This should be the instruction that attempted to do the invalid memory access. In 64-bit x86, this will be register %rip (useful for inspecting things in GDB and elsewhere). ' sp 00007fff2ce4d210 ' is the value of the stack pointer. In 64-bit x86, this will be %rsp . ' error 4 ' is the page fault error code bits from traps.h in hex, as usual, and will almost always be at least 4 (which means 'user-mode access'). A value of 4 means it was a read of an unmapped area , such as address 0, while a value of 6 (4+2) means it was a write of an unmapped area . ' in testp[400000+98000] ' tells us the specific virtual memory area that the instruction pointer is in, specifying which file it is (here it's the executable), the starting address that VMA is mapped at ( 0x400000 ), and the size of the mapping ( 0x98000 ). With a faulting address of 0 and an error code of 4, we know this particular segfault is a read of a null pointer . Here's two more error messages: bash[12235]: segfault at 1054808 ip 000000000041d989 sp 00007ffec1f1cbd8 error 6 in bash[400000+f4000] 'Error 6' means a write to an unmapped user address , here 0x1054808 . bash[11909]: segfault at 0 ip 00007f83c03db746 sp 00007ffccbeda010 error 4 in libc-2.23.so[7f83c0350000+1c0000] Error 4 and address 0 is a null pointer read but this time it's in some libc function, not in bash's own code, since it's reported as 'in libc-2.23.so [...]'. Since I looked at the core dump, I can tell you that this was in strlen() . On 64-bit x86 Linux, you'll get a somewhat different message if the problem is actually with the instruction being executed, not the address it's referencing. For example: bash[2848] trap invalid opcode ip:48db90 sp:7ffddc8879e8 error:0 in bash[400000+f4000] There are a number of such trap types set up in traps.c . Two notable additional ones are 'divide error', which you get if you do an integer division by zero, and 'general protection', which you can get for certain extremely wild pointers (one case I know of is when your 64-bit x86 address is not in 'canonical form' ). Although these fields are formatted slightly differently, most of them mean the same thing as in segfaults. The exception is ' error:0 ', which is not a page fault error code. I don't understand the relevant kernel code enough to know what it means, but if I'm reading between the lines correctly in entry_64.txt , then it's either 0 (the usual case) or an error code from the CPU. Here is one possible list of exceptions that get error codes. Sometimes these messages can be a little bit unusual and surprising. Here is a silly sample program and the error it produces when run. The code: #include <stdio.h> int main(int argc, char **argv) { int (*p)(); p = 0x0; return printf(\"%d\\n\", (*p)()); } If compiled (without optimization is best) and run, this generates the kernel message: a.out[3714]: segfault at 0 ip (null) sp 00007ffe872aa418 error 14 in a.out[400000+1000] The ' (null) ' bit turns out to be expected; it's what the general kernel printf() function generates when asked to print something as a pointer and it's null (as seen here ). In our case the instruction pointer is 0 (null) because we've made a subroutine call through a null pointer and thus we're trying to execute code at address 0. I don't know why the 'in ...' portion says that we're in the executable (although in this case the call actually was there). The error code of 14 is in hex, which means that as bits it's 010100. This is a user mode read of an unmapped area (our usual '4' case), but it's an instruction fetch, not a normal data read or write. Any error 14s are a sign of some form of mangled function call or a return to a mangled address because the stack has been mashed. (These bits turn out to come straight from the CPU's page fault IDT .) For 64-bit x86 Linux kernels (and possibly for 32-bit x86 ones as well), the code you want to look at is show_signal_msg in fault.c , which prints the general 'segfault at ..' message, do_trap and do_general_protection in traps.c , which print the 'trap ...' messages, and print_vma_addr in memory.c , which prints the 'in ...' portion for all of these messages.","title":"What the Linux kernel's messages about segfaulting programs mean on 64-bit x86"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg-segfaulting/#sidebar#the#various#error#code#bits#as#numbers","text":"+1 protection fault in a mapped area (eg writing to a read-only mapping) +2 write (instead of a read) +4 user mode access (instead of kernel mode access) +8 use of reserved bits in the page table entry detected (the kernel will panic if this happens) +16 (+0x10) fault was an instruction fetch, not data read or write +32 (+0x20) 'protection keys block access' (don't ask me) Hex 0x14 is 0x10 + 4; (hex) 6 is 4 + 2. Error code 7 (0x7) is 4 + 2 + 1, a user-mode write to a read-only mapping, and is what you get if you attempt to write to a string constant in C: char *ex = \"example\"; int main(int argc, char **argv) { *ex = 'E'; } Compile and run this and you will get: a.out[8832]: segfault at 400540 ip 0000000000400499 sp 00007ffce6831490 error 7 in a.out[400000+1000] It appears that the program code always gets loaded at 0x400000 for ordinary programs, although I believe that shared libraries can have their location randomized. PS: Per a comment in the kernel source, all accesses to addresses above the end of user space will be labeled as 'protection fault in a mapped area' whether or not there are actual page table entries there. The kernel does this so you can't work out where its memory pages are by looking at the error code. (I believe that user space normally ends around 0x07fffffffffff, per mm.txt , although see the comments about TASK_SIZE_MAX in processor.h and also page_64_types.h .)","title":"Sidebar: The various error code bits as numbers"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg/","text":"dmesg dmesg(1) \u2014 Linux manual page https://blog.quarkslab.com/unaligned-accesses-in-cc-what-why-and-solutions-to-do-it-properly.html#id20 How to find out why process was killed on server QuotePredict [8\u6708 1 09:20] traps: hsserver[194024] trap divide error ip:7f9090ab8885 sp:7f8e67ffe8c8 error:0 [ +0.000007] traps: hsserver[194014] trap divide error ip:7f9090ab8885 sp:7f8e83ffe8c8 error:0 [8\u6708 2 09:19] traps: hsserver[106631] trap divide error ip:7f94437d4885 sp:7f925e7fb8c8 error:0 in libfsc_quote_predict.so[7f9443771000+8a000]","title":"Dmesg"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg/#dmesg","text":"","title":"dmesg"},{"location":"Shell-and-tools/Tools/Dmesg/Dmesg/#dmesg1#linux#manual#page","text":"https://blog.quarkslab.com/unaligned-accesses-in-cc-what-why-and-solutions-to-do-it-properly.html#id20 How to find out why process was killed on server QuotePredict [8\u6708 1 09:20] traps: hsserver[194024] trap divide error ip:7f9090ab8885 sp:7f8e67ffe8c8 error:0 [ +0.000007] traps: hsserver[194014] trap divide error ip:7f9090ab8885 sp:7f8e83ffe8c8 error:0 [8\u6708 2 09:19] traps: hsserver[106631] trap divide error ip:7f94437d4885 sp:7f925e7fb8c8 error:0 in libfsc_quote_predict.so[7f9443771000+8a000]","title":"dmesg(1) \u2014 Linux manual page"},{"location":"Shell-and-tools/Tools/GNU-toolchain/","text":"\u524d\u8a00 \u5728Unix-like OS\u4e2d\u8fdb\u884cprogramming\uff0c\u5c31\u4e0d\u5f97\u4e0d\u638c\u63e1 GNU Project \u6240\u63d0\u4f9b\u7684\u4e00\u7cfb\u5217\u5de5\u5177\u4e86\u3002 GNU\u5b98\u7f51\uff1a GNU Operating System \u5206\u7c7b GNU\u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u7684\uff08\u5f88\u591a\uff09software\uff0c\u6709\u5fc5\u8981\u5bf9\u8fd9\u4e9bsoftware\u8fdb\u884c\u5206\u7c7b\uff0c\u5728\u5176\u5b98\u7f51\u7684 GNU Manuals Online \u9875\u9762\u4e2d\u7ed9\u51fa\u4e86\u4e00\u4e2a\u5927\u5206\u7c7b\uff1a Archiving Audio Business and productivity Database Dictionaries Documentation translation Editors Education Email Fonts GNU organization Games Graphics Health Interface Internet applications Live communications Localization Mathematics Music Printing Science Security Software development Software libraries Spreadsheets System administration Telephony Text creation and manipulation Version control Video Web authoring Software development \u53ef\u4ee5\u770b\u5230\uff0c\u5b83\u8986\u76d6\u4e86\u975e\u5e38\u591a\u7684\u9886\u57df\u3002 \u5bf9\u4e8e\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u800c\u8a00\uff0c\u9700\u8981\u91cd\u70b9\u5173\u6ce8\u7684\u662f Software development \u8fd9\u4e00\u5927\u7c7b\u3002\u5176\u4e2d\u7684\u5de5\u5177\u5f88\u591a\u662f\u6211\u4eec\u5728\u65e5\u5e38\u5de5\u4f5c\u4e2d\u662f\u79bb\u4e0d\u5f00\u7684\u3002 GNU Build System \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0cgnu build system\u7684\u53e6\u5916\u4e00\u79cd\u8bf4\u6cd5\u662fautotools\uff1a \u5b98\u65b9\u4ecb\u7ecd\uff1a An Introduction to the Autotools \u7ec4\u6210 GNU Autoconf \u5b98\u7f51\uff1a Autoconf \u6587\u6863\uff1a GNU Autoconf - Creating Automatic Configuration Scripts \u529f\u80fd\uff1a\u521b\u5efa configure \u6587\u4ef6 \u5173\u4e8econfigure\u6587\u4ef6\uff0c\u53c2\u89c1 configure script \u4f7f\u7528configure\u6587\u4ef6\u6765\u521b\u5efamakefile\u6587\u4ef6 GNU Automake \u5b98\u7f51\uff1a Automake \u6587\u6863\uff1a automake GNU Libtool Gnulib \u5b66\u4e60\u8d44\u6e90 Autotools Mythbuster GNU toolchain","title":"Introduction"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#_1","text":"\u5728Unix-like OS\u4e2d\u8fdb\u884cprogramming\uff0c\u5c31\u4e0d\u5f97\u4e0d\u638c\u63e1 GNU Project \u6240\u63d0\u4f9b\u7684\u4e00\u7cfb\u5217\u5de5\u5177\u4e86\u3002 GNU\u5b98\u7f51\uff1a GNU Operating System","title":"\u524d\u8a00"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#_2","text":"GNU\u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u7684\uff08\u5f88\u591a\uff09software\uff0c\u6709\u5fc5\u8981\u5bf9\u8fd9\u4e9bsoftware\u8fdb\u884c\u5206\u7c7b\uff0c\u5728\u5176\u5b98\u7f51\u7684 GNU Manuals Online \u9875\u9762\u4e2d\u7ed9\u51fa\u4e86\u4e00\u4e2a\u5927\u5206\u7c7b\uff1a Archiving Audio Business and productivity Database Dictionaries Documentation translation Editors Education Email Fonts GNU organization Games Graphics Health Interface Internet applications Live communications Localization Mathematics Music Printing Science Security Software development Software libraries Spreadsheets System administration Telephony Text creation and manipulation Version control Video Web authoring","title":"\u5206\u7c7b"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#software#development","text":"\u53ef\u4ee5\u770b\u5230\uff0c\u5b83\u8986\u76d6\u4e86\u975e\u5e38\u591a\u7684\u9886\u57df\u3002 \u5bf9\u4e8e\u8f6f\u4ef6\u5de5\u7a0b\u5e08\u800c\u8a00\uff0c\u9700\u8981\u91cd\u70b9\u5173\u6ce8\u7684\u662f Software development \u8fd9\u4e00\u5927\u7c7b\u3002\u5176\u4e2d\u7684\u5de5\u5177\u5f88\u591a\u662f\u6211\u4eec\u5728\u65e5\u5e38\u5de5\u4f5c\u4e2d\u662f\u79bb\u4e0d\u5f00\u7684\u3002","title":"Software development"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#gnu#build#system","text":"\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0cgnu build system\u7684\u53e6\u5916\u4e00\u79cd\u8bf4\u6cd5\u662fautotools\uff1a \u5b98\u65b9\u4ecb\u7ecd\uff1a An Introduction to the Autotools","title":"GNU Build System"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#_3","text":"","title":"\u7ec4\u6210"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#gnu#autoconf","text":"\u5b98\u7f51\uff1a Autoconf \u6587\u6863\uff1a GNU Autoconf - Creating Automatic Configuration Scripts \u529f\u80fd\uff1a\u521b\u5efa configure \u6587\u4ef6 \u5173\u4e8econfigure\u6587\u4ef6\uff0c\u53c2\u89c1 configure script \u4f7f\u7528configure\u6587\u4ef6\u6765\u521b\u5efamakefile\u6587\u4ef6","title":"GNU Autoconf"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#gnu#automake","text":"\u5b98\u7f51\uff1a Automake \u6587\u6863\uff1a automake","title":"GNU Automake"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#gnu#libtool","text":"","title":"GNU Libtool"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#gnulib","text":"","title":"Gnulib"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#_4","text":"Autotools Mythbuster","title":"\u5b66\u4e60\u8d44\u6e90"},{"location":"Shell-and-tools/Tools/GNU-toolchain/#gnu#toolchain","text":"","title":"GNU toolchain"},{"location":"Shell-and-tools/Tools/Hardware/lshw/","text":"lshw \u662f\u5728\u9605\u8bfbhowtoforge Linux lscpu Command Tutorial for Beginners (5 Examples) \u65f6\uff0c\u53d1\u73b0\u7684\u8fd9\u4e2a\u547d\u4ee4\u3002 lshw(1) - Linux man page","title":"lshw"},{"location":"Shell-and-tools/Tools/Hardware/lshw/#lshw","text":"\u662f\u5728\u9605\u8bfbhowtoforge Linux lscpu Command Tutorial for Beginners (5 Examples) \u65f6\uff0c\u53d1\u73b0\u7684\u8fd9\u4e2a\u547d\u4ee4\u3002","title":"lshw"},{"location":"Shell-and-tools/Tools/Hardware/lshw/#lshw1#-#linux#man#page","text":"","title":"lshw(1) - Linux man page"},{"location":"Shell-and-tools/Tools/Hardware/CPU/lscpu/","text":"lscpu lscpu(1) \u2014 Linux manual page COLUMNS column explanation CPU The logical CPU number of a CPU as used by the Linux kernel. stackexchange Understanding output of lscpu \u4e2d\u89e3\u91ca\u4e86\u5b83\u7684\u7b97\u6cd5 CORE The logical core number. A core can contain several CPUs. SOCKET The logical socket number. A socket can contain several cores. \u6b64\u5904\u7684socket\uff0c\u4e0d\u662f\u6211\u4eec\u5e73\u65f6\u6240\u8bf4\u7684network socket\uff0c\u5b83\u662f\u6307wikipedia CPU socket \uff0c\u6839\u636e https://unix.stackexchange.com/a/145249 \u4e2d\u7684\u8bf4\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\uff0c\u6bcf\u4e2asocket\u5bf9\u5e94\u4e86\u4e00\u4e2aphysical processor NOTE: SOCKET\u3001CORE \u3001CPU \u5b58\u5728\u7740containing\u5173\u7cfb\uff0c\u539f\u6587\u5df2\u7ecf\u7ed9\u51fa\u4e86\u8bf4\u660e: A socket can contain several cores. A core can contain several CPUs. \u5b9e\u9645\u4f7f\u7528 lscpu \u548c\u539f\u6587\u4e2d\u7684\u63cf\u8ff0\u662f\u4e0d\u540c\u7684\u3002 Understanding output of lscpu stackexchange Understanding output of lscpu \u201cCPU(s): 56\u201d represents the number of logical cores , which equals \u201cThread(s) per core\u201d \u00d7 \u201cCore(s) per socket\u201d \u00d7 \u201cSocket(s)\u201d. One socket is one physical CPU package (which occupies one socket on the motherboard ); each socket hosts a number of physical cores , and each core can run one or more threads. In your case, you have two sockets, each containing a 14-core Xeon E5-2690 v4 CPU, and since that supports hyper-threading with two threads, each core can run two threads. NOTE: \u4e0a\u8ff0**host**\uff0c\u5176\u5b9e\u5c31\u662fcontain\uff1b \u6839\u636e https://unix.stackexchange.com/a/145249 \u4e2d\u7684\u8bf4\u6cd5: You have 2 physical sockets ( Socket(s) ), each contains 1 physical processor. \u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\uff0c\u6bcf\u4e2asocket\u5bf9\u5e94\u4e86\u4e00\u4e2aphysical processor \u201cNUMA node\u201d represents the memory architecture; \u201cNUMA\u201d stands for \u201cnon-uniform memory architecture\u201d . In your system, each socket is attached to certain DIMM slots, and each physical CPU package contains a memory controller which handles part of the total RAM. As a result, not all physical memory is equally accessible from all CPUs: one physical CPU can directly access the memory it controls, but has to go through the other physical CPU to access the rest of memory. In your system, logical cores 0\u201313 and 28\u201341 are in one NUMA node, the rest in the other. So yes, one NUMA node equals one socket, at least in typical multi-socket Xeon systems. https://unix.stackexchange.com/a/145249 To answer your question about how many cores and virtual cores you have: According to your lscpu output: You have 32 cores ( CPU(s) ) in total. You have 2 physical sockets ( Socket(s) ), each contains 1 physical processor. NOTE: \u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\uff0c\u6bcf\u4e2asocket\u5bf9\u5e94\u4e86\u4e00\u4e2aphysical processor Each processor of yours has 8 physical cores ( Core(s) per socket ) inside, which means you have 8 * 2 = 16 real cores. Each real core can have 2 threads ( Thread(s) per core ), which means you have real cores * threads = 16 * 2 = 32 cores in total. So you have 32 virtual cores from 16 real cores. Also see this , this and this link. Logical and physical \u901a\u8fc7 lscpu(1) \u2014 Linux manual page \u548c stackexchange Understanding output of lscpu \uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230logical\u548cphysical\uff0c\u90a3\u5982\u4f55\u6765\u7406\u89e3\u4e24\u8005\u5462\uff1f","title":"lscpu"},{"location":"Shell-and-tools/Tools/Hardware/CPU/lscpu/#lscpu","text":"","title":"lscpu"},{"location":"Shell-and-tools/Tools/Hardware/CPU/lscpu/#lscpu1#linux#manual#page","text":"","title":"lscpu(1) \u2014 Linux manual page"},{"location":"Shell-and-tools/Tools/Hardware/CPU/lscpu/#columns","text":"column explanation CPU The logical CPU number of a CPU as used by the Linux kernel. stackexchange Understanding output of lscpu \u4e2d\u89e3\u91ca\u4e86\u5b83\u7684\u7b97\u6cd5 CORE The logical core number. A core can contain several CPUs. SOCKET The logical socket number. A socket can contain several cores. \u6b64\u5904\u7684socket\uff0c\u4e0d\u662f\u6211\u4eec\u5e73\u65f6\u6240\u8bf4\u7684network socket\uff0c\u5b83\u662f\u6307wikipedia CPU socket \uff0c\u6839\u636e https://unix.stackexchange.com/a/145249 \u4e2d\u7684\u8bf4\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\uff0c\u6bcf\u4e2asocket\u5bf9\u5e94\u4e86\u4e00\u4e2aphysical processor NOTE: SOCKET\u3001CORE \u3001CPU \u5b58\u5728\u7740containing\u5173\u7cfb\uff0c\u539f\u6587\u5df2\u7ecf\u7ed9\u51fa\u4e86\u8bf4\u660e: A socket can contain several cores. A core can contain several CPUs. \u5b9e\u9645\u4f7f\u7528 lscpu \u548c\u539f\u6587\u4e2d\u7684\u63cf\u8ff0\u662f\u4e0d\u540c\u7684\u3002","title":"COLUMNS"},{"location":"Shell-and-tools/Tools/Hardware/CPU/lscpu/#understanding#output#of#lscpu","text":"","title":"Understanding output of lscpu"},{"location":"Shell-and-tools/Tools/Hardware/CPU/lscpu/#stackexchange#understanding#output#of#lscpu","text":"\u201cCPU(s): 56\u201d represents the number of logical cores , which equals \u201cThread(s) per core\u201d \u00d7 \u201cCore(s) per socket\u201d \u00d7 \u201cSocket(s)\u201d. One socket is one physical CPU package (which occupies one socket on the motherboard ); each socket hosts a number of physical cores , and each core can run one or more threads. In your case, you have two sockets, each containing a 14-core Xeon E5-2690 v4 CPU, and since that supports hyper-threading with two threads, each core can run two threads. NOTE: \u4e0a\u8ff0**host**\uff0c\u5176\u5b9e\u5c31\u662fcontain\uff1b \u6839\u636e https://unix.stackexchange.com/a/145249 \u4e2d\u7684\u8bf4\u6cd5: You have 2 physical sockets ( Socket(s) ), each contains 1 physical processor. \u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\uff0c\u6bcf\u4e2asocket\u5bf9\u5e94\u4e86\u4e00\u4e2aphysical processor \u201cNUMA node\u201d represents the memory architecture; \u201cNUMA\u201d stands for \u201cnon-uniform memory architecture\u201d . In your system, each socket is attached to certain DIMM slots, and each physical CPU package contains a memory controller which handles part of the total RAM. As a result, not all physical memory is equally accessible from all CPUs: one physical CPU can directly access the memory it controls, but has to go through the other physical CPU to access the rest of memory. In your system, logical cores 0\u201313 and 28\u201341 are in one NUMA node, the rest in the other. So yes, one NUMA node equals one socket, at least in typical multi-socket Xeon systems.","title":"stackexchange Understanding output of lscpu"},{"location":"Shell-and-tools/Tools/Hardware/CPU/lscpu/#httpsunixstackexchangecoma145249","text":"To answer your question about how many cores and virtual cores you have: According to your lscpu output: You have 32 cores ( CPU(s) ) in total. You have 2 physical sockets ( Socket(s) ), each contains 1 physical processor. NOTE: \u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\uff0c\u6bcf\u4e2asocket\u5bf9\u5e94\u4e86\u4e00\u4e2aphysical processor Each processor of yours has 8 physical cores ( Core(s) per socket ) inside, which means you have 8 * 2 = 16 real cores. Each real core can have 2 threads ( Thread(s) per core ), which means you have real cores * threads = 16 * 2 = 32 cores in total. So you have 32 virtual cores from 16 real cores. Also see this , this and this link.","title":"https://unix.stackexchange.com/a/145249"},{"location":"Shell-and-tools/Tools/Hardware/CPU/lscpu/#logical#and#physical","text":"\u901a\u8fc7 lscpu(1) \u2014 Linux manual page \u548c stackexchange Understanding output of lscpu \uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230logical\u548cphysical\uff0c\u90a3\u5982\u4f55\u6765\u7406\u89e3\u4e24\u8005\u5462\uff1f","title":"Logical and physical"},{"location":"Shell-and-tools/Tools/Misc/","text":"\u5173\u4e8e\u672c\u7ae0 \u672c\u7ae0\u603b\u7ed3\u4e00\u4e9b\u96c6\u6210\u4e86\u591a\u79cd\u529f\u80fd\u7684\u5de5\u5177\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Tools/Misc/#_1","text":"\u672c\u7ae0\u603b\u7ed3\u4e00\u4e9b\u96c6\u6210\u4e86\u591a\u79cd\u529f\u80fd\u7684\u5de5\u5177\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Tools/Misc/Valgrind/","text":"Valgrind wikipedia Valgrind Valgrind ( /\u02c8v\u00e6l\u0261r\u026and/ ) is a programming tool for memory debugging , memory leak detection, and profiling . NOTE: \u96c6\u6210\u4e86\u591a\u79cd\u529f\u80fd Valgrind was originally designed to be a free memory debugging tool for Linux on x86 , but has since evolved to become a generic framework for creating dynamic analysis tools such as checkers and profilers. NOTE: \u5173\u4e8e\u4e0a\u8ff0\"generic framework\"\uff0c\u9700\u8981\u7ed3\u5408\"wikipedia Valgrind # Overview\"\u7ae0\u8282\u5185\u5bb9\u548c \u5b98\u7f51 Valgrind \u4e2d\"Valgrind is an instrumentation framework for building dynamic analysis tools\"\u4e2d\u7684\u5185\u5bb9\u6765\u8fdb\u884c\u7406\u89e3\u3002 Overview Valgrind is in essence a virtual machine using just-in-time (JIT) compilation techniques, including dynamic recompilation . Nothing from the original program ever gets run directly on the host processor . Instead, Valgrind first translates the program into a temporary, simpler form called Intermediate Representation (IR) , which is a processor-neutral, SSA -based form. After the conversion, a tool (see below) is free to do whatever transformations it would like on the IR, before Valgrind translates the IR back into machine code and lets the host processor run it. Valgrind recompiles binary code to run on host and target (or simulated) CPUs of the same architecture. NOTE: \u5404\u79cdIR\u7684\u8f6c\u6362 It also includes a GDB stub to allow debugging of the target program as it runs in Valgrind, with \"monitor commands\" that allow querying the Valgrind tool for various information. A considerable amount of performance is lost in these transformations (and usually, the code the tool inserts); usually, code run with Valgrind and the \"none\" tool (which does nothing to the IR) runs at 20% to 25% of the speed of the normal program.[ 4] [ 5] Tools See also: Memory debugger and Profiling (computer programming) Memcheck \u5b98\u7f51 Valgrind Valgrind is an instrumentation framework for building dynamic analysis tools","title":"Valgrind"},{"location":"Shell-and-tools/Tools/Misc/Valgrind/#valgrind","text":"","title":"Valgrind"},{"location":"Shell-and-tools/Tools/Misc/Valgrind/#wikipedia#valgrind","text":"Valgrind ( /\u02c8v\u00e6l\u0261r\u026and/ ) is a programming tool for memory debugging , memory leak detection, and profiling . NOTE: \u96c6\u6210\u4e86\u591a\u79cd\u529f\u80fd Valgrind was originally designed to be a free memory debugging tool for Linux on x86 , but has since evolved to become a generic framework for creating dynamic analysis tools such as checkers and profilers. NOTE: \u5173\u4e8e\u4e0a\u8ff0\"generic framework\"\uff0c\u9700\u8981\u7ed3\u5408\"wikipedia Valgrind # Overview\"\u7ae0\u8282\u5185\u5bb9\u548c \u5b98\u7f51 Valgrind \u4e2d\"Valgrind is an instrumentation framework for building dynamic analysis tools\"\u4e2d\u7684\u5185\u5bb9\u6765\u8fdb\u884c\u7406\u89e3\u3002","title":"wikipedia Valgrind"},{"location":"Shell-and-tools/Tools/Misc/Valgrind/#overview","text":"Valgrind is in essence a virtual machine using just-in-time (JIT) compilation techniques, including dynamic recompilation . Nothing from the original program ever gets run directly on the host processor . Instead, Valgrind first translates the program into a temporary, simpler form called Intermediate Representation (IR) , which is a processor-neutral, SSA -based form. After the conversion, a tool (see below) is free to do whatever transformations it would like on the IR, before Valgrind translates the IR back into machine code and lets the host processor run it. Valgrind recompiles binary code to run on host and target (or simulated) CPUs of the same architecture. NOTE: \u5404\u79cdIR\u7684\u8f6c\u6362 It also includes a GDB stub to allow debugging of the target program as it runs in Valgrind, with \"monitor commands\" that allow querying the Valgrind tool for various information. A considerable amount of performance is lost in these transformations (and usually, the code the tool inserts); usually, code run with Valgrind and the \"none\" tool (which does nothing to the IR) runs at 20% to 25% of the speed of the normal program.[ 4] [ 5]","title":"Overview"},{"location":"Shell-and-tools/Tools/Misc/Valgrind/#tools","text":"See also: Memory debugger and Profiling (computer programming)","title":"Tools"},{"location":"Shell-and-tools/Tools/Misc/Valgrind/#memcheck","text":"","title":"Memcheck"},{"location":"Shell-and-tools/Tools/Misc/Valgrind/#valgrind_1","text":"Valgrind is an instrumentation framework for building dynamic analysis tools","title":"\u5b98\u7f51 Valgrind"},{"location":"Shell-and-tools/Tools/Misc/gperftools/","text":"gperftools github gperftools / gperftools OVERVIEW gperftools is a collection of a high-performance multi-threaded malloc() implementation, plus some pretty nifty performance analysis tools. TCMALLOC HEAP PROFILER HEAP CHECKER CPU PROFILER TODO cloud.tencent \u5185\u5b58\u6cc4\u6f0f\u5206\u6790\u7684\u5229\u5668\u2014\u2014gperftools\u7684Heap Checker","title":"gperftools"},{"location":"Shell-and-tools/Tools/Misc/gperftools/#gperftools","text":"","title":"gperftools"},{"location":"Shell-and-tools/Tools/Misc/gperftools/#github#gperftoolsgperftools","text":"","title":"github gperftools/gperftools"},{"location":"Shell-and-tools/Tools/Misc/gperftools/#overview","text":"gperftools is a collection of a high-performance multi-threaded malloc() implementation, plus some pretty nifty performance analysis tools.","title":"OVERVIEW"},{"location":"Shell-and-tools/Tools/Misc/gperftools/#tcmalloc","text":"","title":"TCMALLOC"},{"location":"Shell-and-tools/Tools/Misc/gperftools/#heap#profiler","text":"","title":"HEAP PROFILER"},{"location":"Shell-and-tools/Tools/Misc/gperftools/#heap#checker","text":"","title":"HEAP CHECKER"},{"location":"Shell-and-tools/Tools/Misc/gperftools/#cpu#profiler","text":"","title":"CPU PROFILER"},{"location":"Shell-and-tools/Tools/Misc/gperftools/#todo","text":"cloud.tencent \u5185\u5b58\u6cc4\u6f0f\u5206\u6790\u7684\u5229\u5668\u2014\u2014gperftools\u7684Heap Checker","title":"TODO"},{"location":"Shell-and-tools/Tools/Misc/gperftools/Heap-checker/","text":"Heap checker gperftools#heap checker","title":"Heap checker"},{"location":"Shell-and-tools/Tools/Misc/gperftools/Heap-checker/#heap#checker","text":"","title":"Heap checker"},{"location":"Shell-and-tools/Tools/Misc/gperftools/Heap-checker/#gperftoolsheap#checker","text":"","title":"gperftools#heap checker"},{"location":"Shell-and-tools/Tools/Performance/","text":"\u5173\u4e8e\u672c\u7ae0 \u5982\u4f55\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u6027\u80fd\u5206\u6790\uff1f\u5982\u4f55\u627e\u5230bottleneck\uff1f\u8fd9\u662f\u672c\u7ae0\u63a2\u8ba8\u7684\u95ee\u9898\uff0c\u672c\u7ae0\u603b\u7ed3Linux OS\u63d0\u4f9b\u7684\u5404\u79cd\u8fdb\u884c\u6027\u80fd\u7edf\u8ba1\u7684\u5de5\u5177\u3002","title":"Introduction"},{"location":"Shell-and-tools/Tools/Performance/#_1","text":"\u5982\u4f55\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u6027\u80fd\u5206\u6790\uff1f\u5982\u4f55\u627e\u5230bottleneck\uff1f\u8fd9\u662f\u672c\u7ae0\u63a2\u8ba8\u7684\u95ee\u9898\uff0c\u672c\u7ae0\u603b\u7ed3Linux OS\u63d0\u4f9b\u7684\u5404\u79cd\u8fdb\u884c\u6027\u80fd\u7edf\u8ba1\u7684\u5de5\u5177\u3002","title":"\u5173\u4e8e\u672c\u7ae0"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/","text":"System Load \u5982\u4f55\u67e5\u770bsystem load\uff0c\u5373\u201c\u7cfb\u7edf\u8d1f\u8f7d\u201d\uff0c\u8fd9\u662f\u672c\u6587\u8ba8\u8bba\u7684\u95ee\u9898\u3002 linuxjournal Hack and / - Linux Troubleshooting, Part I: High Load Although it's true that there are about as many different reasons for downtime as there are Linux text editors, and just as many approaches to troubleshooting, over the years, I've found I perform the same sorts of steps to isolate a problem. Because my column is generally aimed more at tips and tricks and less on philosophy and design , I'm not going to talk much about overall approaches to problem solving. Instead, in this series I describe some general classes of problems you might find on a Linux system, and then I discuss how to use common tools, most of which probably are already on your system, to isolate and resolve each class of problem. NOTE: \u4f5c\u8005\u5bf9\u77e5\u8bc6\u7684\u5212\u5206\uff1a tips and tricks philosophy and design \u662f\u975e\u5e38\u503c\u5f97\u5de5\u7a0b\u5e08\u501f\u9274\u7684\uff0c\u5728\u6587\u7ae0Thought\u4e2d\uff0c\u5f15\u7528\u4e86\u8fd9\u4e2a\u89c2\u70b9\u3002 For this first column, I start with one of the most common problems you will run into on a Linux system. No, it's not getting printing to work. I'm talking about a sluggish\uff08\u8fdf\u949d\u7684\uff09 server that might have high load . Before I explain how to diagnose and fix high load though, let's take a step back and discuss what load means on a Linux machine and how to know when it's high . Uptime and Load When administrators mention high load, generally they are talking about the load average . When I diagnose why a server is slow, the first command I run when I log in to the system is uptime : $ uptime 18 :30:35 up 365 days, 5 :29, 2 users, load average: 1 .37, 10 .15, 8 .10 NOTE: \u5173\u4e8e uptime \uff0c\u53c2\u89c1 Shell-and-tools\\Tools\\uptime.md How High Is High? NOTE: \u591a\u9ad8\u624d\u80fd\u7b97\u662f\u9ad8\uff1f After you understand what load average means, the next logical question is \u201cWhat load average is good and what is bad?\u201d The answer to that is \u201cIt depends.\u201d You see, a lot of different things can cause load to be high, each of which affects performance differently. One server might have a load of 50 and still be pretty responsive, while another server might have a load of 10 and take forever to log in to. What really matters when you troubleshoot a system with high load is why the load is high. When you start to diagnose high load , you find that most load seems to fall into three categories: Category CPU-bound load load caused by out of memory issues I/O-bound load I explain each of these categories in detail below and how to use tools like top and iostat to isolate the root cause. top If the first tool I use when I log in to a sluggish system is uptime , the second tool I use is top . The great thing about top is that it's available for all major Linux systems, and it provides a lot of useful information in a single screen. For this column, I stick to how to interpret its output to diagnose high load. To use top , simply type top on the command line. By default, top will run in interactive mode and update its output every few seconds. Listing 1 shows sample top output from a terminal. Listing 1. Sample top Output top - 14 :08:25 up 38 days, 8 :02, 1 user, load average: 1 .70, 1 .77, 1 .68 Tasks: 107 total, 3 running, 104 sleeping, 0 stopped, 0 zombie Cpu ( s ) : 11 .4%us, 29 .6%sy, 0 .0%ni, 58 .3%id, .7%wa, 0 .0%hi, 0 .0%si, 0 .0%st Mem: 1024176k total, 997408k used, 26768k free, 85520k buffers Swap: 1004052k total, 4360k used, 999692k free, 286040k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 9463 mysql 16 0 686m 111m 3328 S 53 5 .5 569 :17.64 mysqld 18749 nagios 16 0 140m 134m 1868 S 12 6 .6 1345 :01 nagios2db_status 24636 nagios 17 0 34660 10m 712 S 8 0 .5 1195 :15 nagios 22442 nagios 24 0 6048 2024 1452 S 8 0 .1 0 :00.04 check_time.pl As you can see, there's a lot of information in only a few lines. The first line mirrors the information you would get from the uptime command and will update every few seconds with the latest load averages . In this case, you can see my system is busy, but not what I would call heavily loaded. All the same, this output breaks down well into our different load categories . When I troubleshoot a sluggish system, I generally will rule out CPU-bound load , then RAM issues , then finally I/O issues in that order, so let's start with CPU-bound load . NOTE: \u6700\u540e\u4e00\u53e5\u8bdd\u662f\u4f5c\u8005\u7ed9\u51fa\u7684troubleshoot\u7684\u6b21\u5e8f\uff0c\u8fd9\u4e2a\u6b21\u5e8f\u975e\u5e38\u8fd9\u6837\uff0c\u540e\u9762\u7684\u5185\u5bb9\u5c31\u662f\u6cbf\u7740\u8fd9\u4e2a\u6b21\u5e8f\u5c55\u5f00\u7684\uff0c\u5e76\u4e14\u540e\u9762\u4f5c\u8005\u8fd8\u4f1a\u4ecb\u7ecd\u4f7f\u7528\u8fd9\u4e2a\u6b21\u5e8f\u7684\u539f\u56e0\u3002 CPU-Bound Load CPU-bound load is load caused when you have too many CPU-intensive processes running at once. Because each process needs CPU resources, they all must wait their turn. To check whether load is CPU-bound , check the CPU line in the top output: Cpu ( s ) : 11 .4%us, 29 .6%sy, 0 .0%ni, 58 .3%id, .7%wa, 0 .0%hi, 0 .0%si, 0 .0%st Each of these percentages are a percentage of the CPU time tied up doing a particular task. Again, you could spend an entire column on all of the output from top , so here's a few of these values and how to read them: Category \u7b80\u4ecb \u8be6\u7ec6\u8bf4\u660e us user CPU time More often than not, when you have CPU-bound load, it's due to a process run by a user on the system, such as Apache, MySQL or maybe a shell script. If this percentage is high, a user process such as those is a likely cause of the load. sy system CPU time The system CPU time is the percentage of the CPU tied up by kernel and other system processes. CPU-bound load should manifest either as a high percentage of user or high system CPU time. id CPU idle time This is the percentage of the time that the CPU spends idle. The higher the number here the better! In fact, if you see really high CPU idle time, it's a good indication that any high load is not CPU-bound . wa I/O wait The I/O wait value tells the percentage of time the CPU is spending waiting on I/O (typically disk I/O). If you have high load and this value is high, it's likely the load is not CPU-bound but is due to either RAM issues or high disk I/O . Track Down CPU-Bound Load If you do see a high percentage in the user or system columns, there's a good chance your load is CPU-bound . To track down the root cause, skip down a few lines to where top displays a list of current processes running on the system. By default, top will sort these based on the percentage of CPU used with the processes using the most on top (Listing 2). Listing 2. Current Processes Example PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 9463 mysql 16 0 686m 111m 3328 S 53 5 .5 569 :17.64 mysqld 18749 nagios 16 0 140m 134m 1868 S 12 6 .6 1345 :01 nagios2db_status 24636 nagios 17 0 34660 10m 712 S 8 0 .5 1195 :15 nagios 22442 nagios 24 0 6048 2024 1452 S 8 0 .1 0 :00.04 check_time.pl The %CPU column tells you just how much CPU each process is taking up. In this case, you can see that MySQL is taking up 53% of my CPU. As you look at this output during CPU-bound load , you probably will see one of two things: either you will have a single process tying up 99% of your CPU, or you will see a number of smaller processes all fighting for a percentage of CPU time. In either case, it's relatively simple to see the processes that are causing the problem. There's one final note I want to add on CPU-bound load : I've seen systems get incredibly high load simply because a multithreaded program spawned a huge number of threads on a system without many CPUs. If you spawn 20 threads on a single-CPU system, you might see a high load average , even though there are no particular processes that seem to tie up CPU time. NOTE: \u5bf9\u4e8e**CPU-bound load**\uff0c\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u90fd\u662f\u5982\u4e0b\u4e24\u79cd\u60c5\u51b5: \u95ee\u9898 \u89e3\u91ca a single process tying up 99% of your CPU \u8fdb\u7a0b\u5360\u7528\u592a\u9ad8 a number of smaller processes all fighting for a percentage of CPU time \u8fdb\u7a0b\u592a\u591a Out of RAM Issues The next cause for high load is a system that has run out of available RAM and has started to go into swap . Because swap space is usually on a hard drive that is much slower than RAM , when you use up available RAM and go into swap , each process slows down dramatically as the disk gets used. Usually this causes a downward spiral as processes that have been swapped run slower, take longer to respond and cause more processes to stack up until the system either runs out of RAM or slows down to an absolute crawl. \u901a\u5e38\u8fd9\u4f1a\u5bfc\u81f4\u87ba\u65cb\u5f0f\u4e0b\u964d\uff0c\u56e0\u4e3a\u4ea4\u6362\u8fc7\u7684\u8fdb\u7a0b\u8fd0\u884c\u5f97\u66f4\u6162\uff0c\u54cd\u5e94\u65f6\u95f4\u66f4\u957f\uff0c\u5e76\u5bfc\u81f4\u66f4\u591a\u8fdb\u7a0b\u5806\u79ef\u5728\u4e00\u8d77\uff0c\u76f4\u5230\u7cfb\u7edf\u8017\u5c3dRAM\u6216\u6162\u5230\u5b8c\u5168\u722c\u884c\u3002 What's tricky about swap issues is that because they hit the disk so hard, it's easy to misdiagnose them as I/O-bound load . After all, if your disk is being used as RAM, any processes that actually want to access files on the disk are going to have to wait in line. So, if I see high I/O wait in the CPU row in top , I check RAM next and rule it out before I troubleshoot any other I/O issues. NOTE: \u5f53\u201ca system that has run out of available RAM and has started to go into swap \u201d\u65f6\uff0c\u7531\u4e8edisk is being used as RAM, any processes that actually want to access files on the disk are going to have to wait in line\uff0c\u6240\u4ee5\u6211\u4eec\u5c31\u770b\u5230\u4e86high I/O wait in the CPU row in top When I want to diagnose out of memory issues , the first place I look is the next couple of lines in the top output: Mem: 1024176k total, 997408k used, 26768k free, 85520k buffers Swap: 1004052k total, 4360k used, 999692k free, 286040k cached These lines tell you the total amount of RAM and swap along with how much is used and free; however, look carefully, as these numbers can be misleading. I've seen many new and even experienced administrators who would look at the above output and conclude the system was almost out of RAM because there was only 26768k free. Although that does show how much RAM is currently unused, it doesn't tell the full story. NOTE: \u5728\u201cThe Linux File Cache\u201d\u4e2d\u4f1a\u5bf9\u6b64\u8fdb\u884c\u89e3\u91ca The Linux File Cache When you access a file and the Linux kernel loads it into RAM, the kernel doesn't necessarily unload the file when you no longer need it. If there is enough free RAM available, the kernel tries to cache as many files as it can into RAM. That way, if you access the file a second time, the kernel can retrieve it from RAM instead of the disk and give much better performance. As a system stays running, you will find the free RAM actually will appear to get rather small. If a process needs more RAM though, the kernel simply uses some of its file cache . In fact, I see a lot of the overclocking crowd who want to improve performance and create a ramdisk to store their files. What they don't realize is that more often than not, if they just let the kernel do the work for them, they'd probably see much better results and make more efficient use of their RAM. \u4e8b\u5b9e\u4e0a\uff0c\u6211\u770b\u5230\u8bb8\u591a\u8d85\u9891\u7528\u6237\u5e0c\u671b\u63d0\u9ad8\u6027\u80fd\u5e76\u521b\u5efa\u4e00\u4e2aramdisk\u6765\u5b58\u50a8\u4ed6\u4eec\u7684\u6587\u4ef6\u3002\u4ed6\u4eec\u6ca1\u6709\u610f\u8bc6\u5230\u7684\u662f\uff0c\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u8ba9\u5185\u6838\u4e3a\u4ed6\u4eec\u505a\u8fd9\u4e9b\u5de5\u4f5c\uff0c\u4ed6\u4eec\u53ef\u80fd\u4f1a\u770b\u5230\u66f4\u597d\u7684\u7ed3\u679c\uff0c\u5e76\u66f4\u6709\u6548\u5730\u4f7f\u7528\u4ed6\u4eec\u7684RAM\u3002 To get a more accurate amount of free RAM , you need to combine the values from the free column with the cached column . In my example, I would have 26768k + 286040k, or over 300Mb of free RAM. In this case, I could safely assume my system was not experiencing an out of RAM issue. Of course, even a system that has very little free RAM may not have gone into swap. That's why you also must check the Swap: line and see if a high proportion of your swap is being used. NOTE: \u6700\u540e\u4e00\u53e5\u8bdd\u4f5c\u8005\u5e76\u6ca1\u6709\u7ed9\u51fa\u7ed3\u8bba\uff0c\u6211\u89c9\u5f97\u7ed3\u8bba\u662f\uff1a\u5982\u679cswap\u7684\u4f7f\u7528\u6bd4\u4f8b\u8f83\u9ad8\uff0c\u5219\u8bf4\u660eout of RAM\u7684\u53ef\u80fd\u6027\u5c31\u6bd4\u8f83\u5927\u4e86 Track Down High RAM Usage If you do find you are low on free RAM, go back to the same process output from top , only this time, look in the %MEM column. By default, top will sort by the %CPU column, so simply type M and it will re-sort to show you which processes are using the highest percentage of RAM. In the output in Listing 3, I sorted the same processes by RAM, and you can see that the nagios2db_status process is using the most at 6.6%. Listing 3. Processes Sorted by RAM PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 18749 nagios 16 0 140m 134m 1868 S 12 6.6 1345:01 nagios2db_status 9463 mysql 16 0 686m 111m 3328 S 53 5.5 569:17.64 mysqld 24636 nagios 17 0 34660 10m 712 S 8 0.5 1195:15 nagios 22442 nagios 24 0 6048 2024 1452 S 8 0.1 0:00.04 check_time.pl I/O-Bound Load I/O-bound load can be tricky to track down sometimes. As I mentioned earlier, if your system is swapping, it can make the load appear to be I/O-bound. Once you rule out swapping though, if you do have a high I/O wait, the next step is to attempt to track down which disk and partition is getting the bulk of the I/O traffic. To do this, you need a tool like iostat . The iostat tool, like top , is a complicated and full-featured tool that could fill up its own article. Unlike top , although it should be available for your distribution, it may not be installed on your system by default, so you need to track down which package provides it. Under Red Hat and Debian-based systems, you can get it in the sysstat package. Once it's installed, simply run iostat with no arguments to get a good overall view of your disk I/O statistics: Linux 2 .6.24-19-server ( hostname ) 01 /31/2009 avg-cpu: %user %nice %system %iowait %steal %idle 5 .73 0 .07 2 .03 0 .53 0 .00 91 .64 Device: tps Blk_read/s Blk_wrtn/s Blk_read Blk_wrtn sda 9 .82 417 .96 27 .53 30227262 1990625 sda1 6 .55 219 .10 7 .12 15845129 515216 sda2 0 .04 0 .74 3 .31 53506 239328 sda3 3 .24 198 .12 17 .09 14328323 1236081 Like with top , iostat gives you the CPU percentage output. Below that, it provides a breakdown of each drive and partition on your system and statistics for each: column explanation tps transactions per second. Blk_read/s blocks read per second. Blk_wrtn/s blocks written per second. Blk_read total blocks read. Blk_wrtn total blocks written. By looking at these different values and comparing them to each other, ideally you will be able to find out first, which partition (or partitions) is getting the bulk of the I/O traffic, and second, whether the majority of that traffic is reads ( Blk_read/s ) or writes ( Blk_wrtn/s ). As I said, tracking down the cause of I/O issues can be tricky, but hopefully, those values will help you isolate what processes might be causing the load. For instance, if you have an I/O-bound load and you suspect that your remote backup job might be the culprit\uff08\u5143\u51f6\uff09, compare the read and write statistics. Because you know that a remote backup job is primarily going to read from your disk, if you see that the majority of the disk I/O is writes, you reasonably can assume it's not from the backup job. If, on the other hand, you do see a heavy amount of read I/O on a particular partition, you might run the lsof command and grep for that backup process and see whether it does in fact have some open file handles on that partition. As you can see, tracking down I/O issues with iostat is not straightforward. Even with no arguments, it can take some time and experience to make sense of the output. That said, iostat does have a number of arguments you can use to get more information about different types of I/O, including modes to find details about NFS shares. Check out the man page for iostat if you want to know more. Up until recently, tools like iostat were about the limit systems administrators had in their toolboxes for tracking down I/O issues, but due to recent developments in the kernel, it has become easier to find the causes of I/O on a per-process level. If you have a relatively new system, check out the iotop tool. Like with iostat , it may not be installed by default, but as the name implies, it essentially acts like top , only for disk I/O. In Listing 4, you can see that an rsync process on this machine is using the most I/O (in this case, read I/O). Listing 4. Example iotop Tool Output Total DISK READ: 189 .52 K/s | Total DISK WRITE: 0 .00 B/s TID PRIO USER DISK READ DISK WRITE SWAPIN IO> COMMAND 8169 be/4 root 189 .52 K/s 0 .00 B/s 0 .00 % 0 .00 % rsync --server --se 4243 be/4 kyle 0 .00 B/s 3 .79 K/s 0 .00 % 0 .00 % cli /usr/lib/gnome- 4244 be/4 kyle 0 .00 B/s 3 .79 K/s 0 .00 % 0 .00 % cli /usr/lib/gnome- 1 be/4 root 0 .00 B/s 0 .00 B/s 0 .00 % 0 .00 % init Once You Track Down the Culprit How you deal with these load-causing processes is up to you and depends on a lot of factors. In some cases, you might have a script that has gone out of control and is something you can easily kill. In other situations, such as in the case of a database process, it might not be safe simply to kill the process, because it could leave corrupted data behind. Plus, it could just be that your service is running out of capacity, and the real solution is either to add more resources to your current server or add more servers to share the load. It might even be load from a one-time job that is running on the machine and shouldn't impact load in the future, so you just can let the process complete. Because so many different things can cause processes to tie up\uff08\u5360\u7528\uff09 server resources, it's hard to list them all here, but hopefully, being able to identify the causes of your high load will put you on the right track the next time you get an alert that a machine is slow. Kyle Rankin is a Systems Architect in the San Francisco Bay Area and the author of a number of books, including The Official Ubuntu Server Book , Knoppix Hacks and Ubuntu Hacks . He is currently the president of the North Bay Linux Users' Group. redhat Troubleshooting slow servers: How to check CPU, RAM, and Disk I/O If you been doing sysadmin work long enough, you\u2019ve seen the dreaded \"Server is slow\" incidents. For a long time, these types of incidents would give me a pit in my stomach. How the heck do you troubleshoot something so subjective\uff08\u4f60\u600e\u4e48\u80fd\u89e3\u51b3\u8fd9\u4e48\u4e3b\u89c2\u7684\u95ee\u9898\u5462\uff09? An everyday user\u2019s \"slow\" might just be caused by other processes (scheduled or not) running and consuming more resources than usual, or something could actually be wrong with the server. The \"Big 3\" (aka CPU, RAM, and Disk I/O) Now, let\u2019s look at the three biggest causes of server slowdown: CPU, RAM, and disk I/O. CPU usage can cause overall slowness on the host, and difficulty completing tasks in a timely fashion. Some tools I use when looking at CPU are top and sar . Checking CPU usage with top The top utility gives you a real-time look at what\u2019s going on with the server. By default, when top starts, it shows activity for all CPUs: Image This view can be changed by pressing the numeric 1 key, which adds more detail regarding the usage values for each CPU: Image Some things to look for in this view would be the load average (displayed on the right side of the top row), and the value of the following for each CPU: us : This percentage represents the amount of CPU consumed by user processes. sy : This percentage represents the amount of CPU consumed by system processes. id : This percentage represents how idle each CPU is. Each of these three values can give you a fairly good, real-time idea of whether CPUs are bound by user processes or system processes. Note: For more information about load average and why some people think it\u2019s a silly number, check out Brendan Gregg\u2019s in-depth research . Checking all of the \"Big 3\" with sar For historical CPU performance data I rely on the sar command, which is provided by the sysstat package. On most server versions of Linux, sysstat is installed by default, but if it\u2019s not, you can add it with your distro\u2019s package manager. The sar utility collects system data every 10 minutes via a cron job located in /etc/cron.d/sysstat (CentOS 7.6). Here\u2019s how to check all of the \"Big 3\" using sar .","title":"System-Load"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#system#load","text":"\u5982\u4f55\u67e5\u770bsystem load\uff0c\u5373\u201c\u7cfb\u7edf\u8d1f\u8f7d\u201d\uff0c\u8fd9\u662f\u672c\u6587\u8ba8\u8bba\u7684\u95ee\u9898\u3002","title":"System Load"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#linuxjournal#hack#and#-#linux#troubleshooting#part#i#high#load","text":"Although it's true that there are about as many different reasons for downtime as there are Linux text editors, and just as many approaches to troubleshooting, over the years, I've found I perform the same sorts of steps to isolate a problem. Because my column is generally aimed more at tips and tricks and less on philosophy and design , I'm not going to talk much about overall approaches to problem solving. Instead, in this series I describe some general classes of problems you might find on a Linux system, and then I discuss how to use common tools, most of which probably are already on your system, to isolate and resolve each class of problem. NOTE: \u4f5c\u8005\u5bf9\u77e5\u8bc6\u7684\u5212\u5206\uff1a tips and tricks philosophy and design \u662f\u975e\u5e38\u503c\u5f97\u5de5\u7a0b\u5e08\u501f\u9274\u7684\uff0c\u5728\u6587\u7ae0Thought\u4e2d\uff0c\u5f15\u7528\u4e86\u8fd9\u4e2a\u89c2\u70b9\u3002 For this first column, I start with one of the most common problems you will run into on a Linux system. No, it's not getting printing to work. I'm talking about a sluggish\uff08\u8fdf\u949d\u7684\uff09 server that might have high load . Before I explain how to diagnose and fix high load though, let's take a step back and discuss what load means on a Linux machine and how to know when it's high .","title":"linuxjournal Hack and / - Linux Troubleshooting, Part I: High Load"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#uptime#and#load","text":"When administrators mention high load, generally they are talking about the load average . When I diagnose why a server is slow, the first command I run when I log in to the system is uptime : $ uptime 18 :30:35 up 365 days, 5 :29, 2 users, load average: 1 .37, 10 .15, 8 .10 NOTE: \u5173\u4e8e uptime \uff0c\u53c2\u89c1 Shell-and-tools\\Tools\\uptime.md","title":"Uptime and Load"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#how#high#is#high","text":"NOTE: \u591a\u9ad8\u624d\u80fd\u7b97\u662f\u9ad8\uff1f After you understand what load average means, the next logical question is \u201cWhat load average is good and what is bad?\u201d The answer to that is \u201cIt depends.\u201d You see, a lot of different things can cause load to be high, each of which affects performance differently. One server might have a load of 50 and still be pretty responsive, while another server might have a load of 10 and take forever to log in to. What really matters when you troubleshoot a system with high load is why the load is high. When you start to diagnose high load , you find that most load seems to fall into three categories: Category CPU-bound load load caused by out of memory issues I/O-bound load I explain each of these categories in detail below and how to use tools like top and iostat to isolate the root cause.","title":"How High Is High?"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#top","text":"If the first tool I use when I log in to a sluggish system is uptime , the second tool I use is top . The great thing about top is that it's available for all major Linux systems, and it provides a lot of useful information in a single screen. For this column, I stick to how to interpret its output to diagnose high load. To use top , simply type top on the command line. By default, top will run in interactive mode and update its output every few seconds. Listing 1 shows sample top output from a terminal. Listing 1. Sample top Output top - 14 :08:25 up 38 days, 8 :02, 1 user, load average: 1 .70, 1 .77, 1 .68 Tasks: 107 total, 3 running, 104 sleeping, 0 stopped, 0 zombie Cpu ( s ) : 11 .4%us, 29 .6%sy, 0 .0%ni, 58 .3%id, .7%wa, 0 .0%hi, 0 .0%si, 0 .0%st Mem: 1024176k total, 997408k used, 26768k free, 85520k buffers Swap: 1004052k total, 4360k used, 999692k free, 286040k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 9463 mysql 16 0 686m 111m 3328 S 53 5 .5 569 :17.64 mysqld 18749 nagios 16 0 140m 134m 1868 S 12 6 .6 1345 :01 nagios2db_status 24636 nagios 17 0 34660 10m 712 S 8 0 .5 1195 :15 nagios 22442 nagios 24 0 6048 2024 1452 S 8 0 .1 0 :00.04 check_time.pl As you can see, there's a lot of information in only a few lines. The first line mirrors the information you would get from the uptime command and will update every few seconds with the latest load averages . In this case, you can see my system is busy, but not what I would call heavily loaded. All the same, this output breaks down well into our different load categories . When I troubleshoot a sluggish system, I generally will rule out CPU-bound load , then RAM issues , then finally I/O issues in that order, so let's start with CPU-bound load . NOTE: \u6700\u540e\u4e00\u53e5\u8bdd\u662f\u4f5c\u8005\u7ed9\u51fa\u7684troubleshoot\u7684\u6b21\u5e8f\uff0c\u8fd9\u4e2a\u6b21\u5e8f\u975e\u5e38\u8fd9\u6837\uff0c\u540e\u9762\u7684\u5185\u5bb9\u5c31\u662f\u6cbf\u7740\u8fd9\u4e2a\u6b21\u5e8f\u5c55\u5f00\u7684\uff0c\u5e76\u4e14\u540e\u9762\u4f5c\u8005\u8fd8\u4f1a\u4ecb\u7ecd\u4f7f\u7528\u8fd9\u4e2a\u6b21\u5e8f\u7684\u539f\u56e0\u3002","title":"top"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#cpu-bound#load","text":"CPU-bound load is load caused when you have too many CPU-intensive processes running at once. Because each process needs CPU resources, they all must wait their turn. To check whether load is CPU-bound , check the CPU line in the top output: Cpu ( s ) : 11 .4%us, 29 .6%sy, 0 .0%ni, 58 .3%id, .7%wa, 0 .0%hi, 0 .0%si, 0 .0%st Each of these percentages are a percentage of the CPU time tied up doing a particular task. Again, you could spend an entire column on all of the output from top , so here's a few of these values and how to read them: Category \u7b80\u4ecb \u8be6\u7ec6\u8bf4\u660e us user CPU time More often than not, when you have CPU-bound load, it's due to a process run by a user on the system, such as Apache, MySQL or maybe a shell script. If this percentage is high, a user process such as those is a likely cause of the load. sy system CPU time The system CPU time is the percentage of the CPU tied up by kernel and other system processes. CPU-bound load should manifest either as a high percentage of user or high system CPU time. id CPU idle time This is the percentage of the time that the CPU spends idle. The higher the number here the better! In fact, if you see really high CPU idle time, it's a good indication that any high load is not CPU-bound . wa I/O wait The I/O wait value tells the percentage of time the CPU is spending waiting on I/O (typically disk I/O). If you have high load and this value is high, it's likely the load is not CPU-bound but is due to either RAM issues or high disk I/O .","title":"CPU-Bound Load"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#track#down#cpu-bound#load","text":"If you do see a high percentage in the user or system columns, there's a good chance your load is CPU-bound . To track down the root cause, skip down a few lines to where top displays a list of current processes running on the system. By default, top will sort these based on the percentage of CPU used with the processes using the most on top (Listing 2). Listing 2. Current Processes Example PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 9463 mysql 16 0 686m 111m 3328 S 53 5 .5 569 :17.64 mysqld 18749 nagios 16 0 140m 134m 1868 S 12 6 .6 1345 :01 nagios2db_status 24636 nagios 17 0 34660 10m 712 S 8 0 .5 1195 :15 nagios 22442 nagios 24 0 6048 2024 1452 S 8 0 .1 0 :00.04 check_time.pl The %CPU column tells you just how much CPU each process is taking up. In this case, you can see that MySQL is taking up 53% of my CPU. As you look at this output during CPU-bound load , you probably will see one of two things: either you will have a single process tying up 99% of your CPU, or you will see a number of smaller processes all fighting for a percentage of CPU time. In either case, it's relatively simple to see the processes that are causing the problem. There's one final note I want to add on CPU-bound load : I've seen systems get incredibly high load simply because a multithreaded program spawned a huge number of threads on a system without many CPUs. If you spawn 20 threads on a single-CPU system, you might see a high load average , even though there are no particular processes that seem to tie up CPU time. NOTE: \u5bf9\u4e8e**CPU-bound load**\uff0c\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u90fd\u662f\u5982\u4e0b\u4e24\u79cd\u60c5\u51b5: \u95ee\u9898 \u89e3\u91ca a single process tying up 99% of your CPU \u8fdb\u7a0b\u5360\u7528\u592a\u9ad8 a number of smaller processes all fighting for a percentage of CPU time \u8fdb\u7a0b\u592a\u591a","title":"Track Down CPU-Bound Load"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#out#of#ram#issues","text":"The next cause for high load is a system that has run out of available RAM and has started to go into swap . Because swap space is usually on a hard drive that is much slower than RAM , when you use up available RAM and go into swap , each process slows down dramatically as the disk gets used. Usually this causes a downward spiral as processes that have been swapped run slower, take longer to respond and cause more processes to stack up until the system either runs out of RAM or slows down to an absolute crawl. \u901a\u5e38\u8fd9\u4f1a\u5bfc\u81f4\u87ba\u65cb\u5f0f\u4e0b\u964d\uff0c\u56e0\u4e3a\u4ea4\u6362\u8fc7\u7684\u8fdb\u7a0b\u8fd0\u884c\u5f97\u66f4\u6162\uff0c\u54cd\u5e94\u65f6\u95f4\u66f4\u957f\uff0c\u5e76\u5bfc\u81f4\u66f4\u591a\u8fdb\u7a0b\u5806\u79ef\u5728\u4e00\u8d77\uff0c\u76f4\u5230\u7cfb\u7edf\u8017\u5c3dRAM\u6216\u6162\u5230\u5b8c\u5168\u722c\u884c\u3002 What's tricky about swap issues is that because they hit the disk so hard, it's easy to misdiagnose them as I/O-bound load . After all, if your disk is being used as RAM, any processes that actually want to access files on the disk are going to have to wait in line. So, if I see high I/O wait in the CPU row in top , I check RAM next and rule it out before I troubleshoot any other I/O issues. NOTE: \u5f53\u201ca system that has run out of available RAM and has started to go into swap \u201d\u65f6\uff0c\u7531\u4e8edisk is being used as RAM, any processes that actually want to access files on the disk are going to have to wait in line\uff0c\u6240\u4ee5\u6211\u4eec\u5c31\u770b\u5230\u4e86high I/O wait in the CPU row in top When I want to diagnose out of memory issues , the first place I look is the next couple of lines in the top output: Mem: 1024176k total, 997408k used, 26768k free, 85520k buffers Swap: 1004052k total, 4360k used, 999692k free, 286040k cached These lines tell you the total amount of RAM and swap along with how much is used and free; however, look carefully, as these numbers can be misleading. I've seen many new and even experienced administrators who would look at the above output and conclude the system was almost out of RAM because there was only 26768k free. Although that does show how much RAM is currently unused, it doesn't tell the full story. NOTE: \u5728\u201cThe Linux File Cache\u201d\u4e2d\u4f1a\u5bf9\u6b64\u8fdb\u884c\u89e3\u91ca","title":"Out of RAM Issues"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#the#linux#file#cache","text":"When you access a file and the Linux kernel loads it into RAM, the kernel doesn't necessarily unload the file when you no longer need it. If there is enough free RAM available, the kernel tries to cache as many files as it can into RAM. That way, if you access the file a second time, the kernel can retrieve it from RAM instead of the disk and give much better performance. As a system stays running, you will find the free RAM actually will appear to get rather small. If a process needs more RAM though, the kernel simply uses some of its file cache . In fact, I see a lot of the overclocking crowd who want to improve performance and create a ramdisk to store their files. What they don't realize is that more often than not, if they just let the kernel do the work for them, they'd probably see much better results and make more efficient use of their RAM. \u4e8b\u5b9e\u4e0a\uff0c\u6211\u770b\u5230\u8bb8\u591a\u8d85\u9891\u7528\u6237\u5e0c\u671b\u63d0\u9ad8\u6027\u80fd\u5e76\u521b\u5efa\u4e00\u4e2aramdisk\u6765\u5b58\u50a8\u4ed6\u4eec\u7684\u6587\u4ef6\u3002\u4ed6\u4eec\u6ca1\u6709\u610f\u8bc6\u5230\u7684\u662f\uff0c\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u8ba9\u5185\u6838\u4e3a\u4ed6\u4eec\u505a\u8fd9\u4e9b\u5de5\u4f5c\uff0c\u4ed6\u4eec\u53ef\u80fd\u4f1a\u770b\u5230\u66f4\u597d\u7684\u7ed3\u679c\uff0c\u5e76\u66f4\u6709\u6548\u5730\u4f7f\u7528\u4ed6\u4eec\u7684RAM\u3002 To get a more accurate amount of free RAM , you need to combine the values from the free column with the cached column . In my example, I would have 26768k + 286040k, or over 300Mb of free RAM. In this case, I could safely assume my system was not experiencing an out of RAM issue. Of course, even a system that has very little free RAM may not have gone into swap. That's why you also must check the Swap: line and see if a high proportion of your swap is being used. NOTE: \u6700\u540e\u4e00\u53e5\u8bdd\u4f5c\u8005\u5e76\u6ca1\u6709\u7ed9\u51fa\u7ed3\u8bba\uff0c\u6211\u89c9\u5f97\u7ed3\u8bba\u662f\uff1a\u5982\u679cswap\u7684\u4f7f\u7528\u6bd4\u4f8b\u8f83\u9ad8\uff0c\u5219\u8bf4\u660eout of RAM\u7684\u53ef\u80fd\u6027\u5c31\u6bd4\u8f83\u5927\u4e86","title":"The Linux File Cache"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#track#down#high#ram#usage","text":"If you do find you are low on free RAM, go back to the same process output from top , only this time, look in the %MEM column. By default, top will sort by the %CPU column, so simply type M and it will re-sort to show you which processes are using the highest percentage of RAM. In the output in Listing 3, I sorted the same processes by RAM, and you can see that the nagios2db_status process is using the most at 6.6%. Listing 3. Processes Sorted by RAM PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 18749 nagios 16 0 140m 134m 1868 S 12 6.6 1345:01 nagios2db_status 9463 mysql 16 0 686m 111m 3328 S 53 5.5 569:17.64 mysqld 24636 nagios 17 0 34660 10m 712 S 8 0.5 1195:15 nagios 22442 nagios 24 0 6048 2024 1452 S 8 0.1 0:00.04 check_time.pl","title":"Track Down High RAM Usage"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#io-bound#load","text":"I/O-bound load can be tricky to track down sometimes. As I mentioned earlier, if your system is swapping, it can make the load appear to be I/O-bound. Once you rule out swapping though, if you do have a high I/O wait, the next step is to attempt to track down which disk and partition is getting the bulk of the I/O traffic. To do this, you need a tool like iostat . The iostat tool, like top , is a complicated and full-featured tool that could fill up its own article. Unlike top , although it should be available for your distribution, it may not be installed on your system by default, so you need to track down which package provides it. Under Red Hat and Debian-based systems, you can get it in the sysstat package. Once it's installed, simply run iostat with no arguments to get a good overall view of your disk I/O statistics: Linux 2 .6.24-19-server ( hostname ) 01 /31/2009 avg-cpu: %user %nice %system %iowait %steal %idle 5 .73 0 .07 2 .03 0 .53 0 .00 91 .64 Device: tps Blk_read/s Blk_wrtn/s Blk_read Blk_wrtn sda 9 .82 417 .96 27 .53 30227262 1990625 sda1 6 .55 219 .10 7 .12 15845129 515216 sda2 0 .04 0 .74 3 .31 53506 239328 sda3 3 .24 198 .12 17 .09 14328323 1236081 Like with top , iostat gives you the CPU percentage output. Below that, it provides a breakdown of each drive and partition on your system and statistics for each: column explanation tps transactions per second. Blk_read/s blocks read per second. Blk_wrtn/s blocks written per second. Blk_read total blocks read. Blk_wrtn total blocks written. By looking at these different values and comparing them to each other, ideally you will be able to find out first, which partition (or partitions) is getting the bulk of the I/O traffic, and second, whether the majority of that traffic is reads ( Blk_read/s ) or writes ( Blk_wrtn/s ). As I said, tracking down the cause of I/O issues can be tricky, but hopefully, those values will help you isolate what processes might be causing the load. For instance, if you have an I/O-bound load and you suspect that your remote backup job might be the culprit\uff08\u5143\u51f6\uff09, compare the read and write statistics. Because you know that a remote backup job is primarily going to read from your disk, if you see that the majority of the disk I/O is writes, you reasonably can assume it's not from the backup job. If, on the other hand, you do see a heavy amount of read I/O on a particular partition, you might run the lsof command and grep for that backup process and see whether it does in fact have some open file handles on that partition. As you can see, tracking down I/O issues with iostat is not straightforward. Even with no arguments, it can take some time and experience to make sense of the output. That said, iostat does have a number of arguments you can use to get more information about different types of I/O, including modes to find details about NFS shares. Check out the man page for iostat if you want to know more. Up until recently, tools like iostat were about the limit systems administrators had in their toolboxes for tracking down I/O issues, but due to recent developments in the kernel, it has become easier to find the causes of I/O on a per-process level. If you have a relatively new system, check out the iotop tool. Like with iostat , it may not be installed by default, but as the name implies, it essentially acts like top , only for disk I/O. In Listing 4, you can see that an rsync process on this machine is using the most I/O (in this case, read I/O). Listing 4. Example iotop Tool Output Total DISK READ: 189 .52 K/s | Total DISK WRITE: 0 .00 B/s TID PRIO USER DISK READ DISK WRITE SWAPIN IO> COMMAND 8169 be/4 root 189 .52 K/s 0 .00 B/s 0 .00 % 0 .00 % rsync --server --se 4243 be/4 kyle 0 .00 B/s 3 .79 K/s 0 .00 % 0 .00 % cli /usr/lib/gnome- 4244 be/4 kyle 0 .00 B/s 3 .79 K/s 0 .00 % 0 .00 % cli /usr/lib/gnome- 1 be/4 root 0 .00 B/s 0 .00 B/s 0 .00 % 0 .00 % init","title":"I/O-Bound Load"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#once#you#track#down#the#culprit","text":"How you deal with these load-causing processes is up to you and depends on a lot of factors. In some cases, you might have a script that has gone out of control and is something you can easily kill. In other situations, such as in the case of a database process, it might not be safe simply to kill the process, because it could leave corrupted data behind. Plus, it could just be that your service is running out of capacity, and the real solution is either to add more resources to your current server or add more servers to share the load. It might even be load from a one-time job that is running on the machine and shouldn't impact load in the future, so you just can let the process complete. Because so many different things can cause processes to tie up\uff08\u5360\u7528\uff09 server resources, it's hard to list them all here, but hopefully, being able to identify the causes of your high load will put you on the right track the next time you get an alert that a machine is slow. Kyle Rankin is a Systems Architect in the San Francisco Bay Area and the author of a number of books, including The Official Ubuntu Server Book , Knoppix Hacks and Ubuntu Hacks . He is currently the president of the North Bay Linux Users' Group.","title":"Once You Track Down the Culprit"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#redhat#troubleshooting#slow#servers#how#to#check#cpu#ram#and#disk#io","text":"If you been doing sysadmin work long enough, you\u2019ve seen the dreaded \"Server is slow\" incidents. For a long time, these types of incidents would give me a pit in my stomach. How the heck do you troubleshoot something so subjective\uff08\u4f60\u600e\u4e48\u80fd\u89e3\u51b3\u8fd9\u4e48\u4e3b\u89c2\u7684\u95ee\u9898\u5462\uff09? An everyday user\u2019s \"slow\" might just be caused by other processes (scheduled or not) running and consuming more resources than usual, or something could actually be wrong with the server.","title":"redhat Troubleshooting slow servers: How to check CPU, RAM, and Disk I/O"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#the#big#3#aka#cpu#ram#and#disk#io","text":"Now, let\u2019s look at the three biggest causes of server slowdown: CPU, RAM, and disk I/O. CPU usage can cause overall slowness on the host, and difficulty completing tasks in a timely fashion. Some tools I use when looking at CPU are top and sar .","title":"The \"Big 3\" (aka CPU, RAM, and Disk I/O)"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#checking#cpu#usage#with#top","text":"The top utility gives you a real-time look at what\u2019s going on with the server. By default, when top starts, it shows activity for all CPUs: Image This view can be changed by pressing the numeric 1 key, which adds more detail regarding the usage values for each CPU: Image Some things to look for in this view would be the load average (displayed on the right side of the top row), and the value of the following for each CPU: us : This percentage represents the amount of CPU consumed by user processes. sy : This percentage represents the amount of CPU consumed by system processes. id : This percentage represents how idle each CPU is. Each of these three values can give you a fairly good, real-time idea of whether CPUs are bound by user processes or system processes. Note: For more information about load average and why some people think it\u2019s a silly number, check out Brendan Gregg\u2019s in-depth research .","title":"Checking CPU usage with top"},{"location":"Shell-and-tools/Tools/Performance/System-load/System-Load/#checking#all#of#the#big#3#with#sar","text":"For historical CPU performance data I rely on the sar command, which is provided by the sysstat package. On most server versions of Linux, sysstat is installed by default, but if it\u2019s not, you can add it with your distro\u2019s package manager. The sar utility collects system data every 10 minutes via a cron job located in /etc/cron.d/sysstat (CentOS 7.6). Here\u2019s how to check all of the \"Big 3\" using sar .","title":"Checking all of the \"Big 3\" with sar"},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-CPU-bound-bottleneck/","text":"Troubleshoot CPU bound bottleneck stackexchange How to find which Process is causing High CPU usage A top will display what is using your CPU. If you have it installed, htop allows you more fine-grained control, including filtering by\u2014in your case\u2014CPU A ps -eo pcpu,pid,user,args | sort -k1 -r -n | head -10 Works for me, show the top 10 cpu using threads, sorted numerically","title":"Troubleshoot-CPU-bound-bottleneck"},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-CPU-bound-bottleneck/#troubleshoot#cpu#bound#bottleneck","text":"","title":"Troubleshoot CPU bound bottleneck"},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-CPU-bound-bottleneck/#stackexchange#how#to#find#which#process#is#causing#high#cpu#usage","text":"A top will display what is using your CPU. If you have it installed, htop allows you more fine-grained control, including filtering by\u2014in your case\u2014CPU A ps -eo pcpu,pid,user,args | sort -k1 -r -n | head -10 Works for me, show the top 10 cpu using threads, sorted numerically","title":"stackexchange How to find which Process is causing High CPU usage"},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-disk-IO-bottleneck/","text":"Troubleshoot disk IO bottleneck \u672c\u6587\u6807\u9898\u7684\u542b\u4e49\u662f\uff1a\u6392\u67e5disk IO\u74f6\u9888\u3002 haydenjames Linux server performance: Is disk I/O slowing your application? If your Linux server is bogged down, your first step is often to use the TOP command in terminal to check load averages and wisely so. However, there are times when TOP shows very high load averages even with low cpu \u2018us\u2019 (user) and high cpu \u2018id\u2019 (idle) percentages. This is the case in the video below, load averages are above 30 on a server with 24 cores but CPU shows around 70 percent idle. One of the common causes of this condition is disk I/O bottleneck. Disk I/O is input/output (write/read) operations on a physical disk (or other storage). Requests which involve disk I/O can be slowed greatly if CPUs need to wait on the disk to read or write data. I/O Wait, (more about that below) is the percentage of time the CPU has to wait on disk. To begin, let\u2019s look at how we can confirm if disk I/O is slowing down application performance by using a few terminal command-line tools ( top , atop and iotop ) on a LEMP installed dedicated server. Using TOP command \u2013 load averages and wa (wait time) As per the video above, when you enter top , you\u2019ll first glance to the top-right to check load averages. Which in this case, are VERY high and thus indicate a pileup\uff08\u5806\u79ef\uff09 of requests. Next, we most likely will glance at the cpu and mem horizontal lines near the top, followed by the %CPU and %MEM columns to get an idea of which processes are using most resources. While in top, you will also want to look at \u2018wa\u2019 (see video above) it should be 0.0% almost all the time. Values consistently above 1% may indicate that your storage device is too slow to keep up with incoming requests. Notice in the video the initial value averages around 6% wait time. However, this is averaged across 24 cores, some of which are not activated because the CPU cores are not nearing capacity on their own. So we should expand the view by pressing \u20181\u2019 on your keyboard to view wa time for each cpu core when in use. As per the screenshot above, there are 24 cores when expanded, from 0 to 23. Once we\u2019ve done this, we see that \u2018 %wa \u2019 time is as high as 60% for some cpu cores! So we know there\u2019s a bottleneck, a major one. Next, let\u2019s confirm this disk bottleneck . Using ATOP command to monitor DSK (disk) I/O stats Using atop , next, we see that the storage device is 90 to 100 percent busy. This is a serious bottleneck. The effect is that requests are blocked until disk I/O can catch up. While in atop press \u2018 d \u201d to view the processes and PIDs which are using disk I/O. Here we see MySQL, Nginx, and PHP-FPM which are necessary processes and I would have to write another article about reducing disk I/O on high traffic L*MP servers. In short, be careful that Nginx (or Apache), MySQL, and PHP-FPM\u2019s access and error logs are not set up to write too frequently to disk and you want to also avoid storing cache (eg. Nginx cache) to disk in very high concurrent traffic environments. In addition to LEMP services, notice also \u2018flush-8:0\u2019 (traced to be PHP cache issue) and jbd2/sda5-8 (traced to access/kernel logs) along with their PIDs. On this server, I was able to perform a quick benchmark of the SSD after stopping services and noticed that disk performance was extremely poor. The results: 1073741824 bytes (1.1 GB) copied, 46.0156 s, 23.3 MB/s. So although reads/writes could be reduced, the real problem here is extremely slow disk I/O. This client\u2019s web host provider denied this and instead stated that MySQL was the problem because it often grows in size and suffers OOM kill . To the contrary, MySQL growing in memory usage was a symptom\uff08\u75c7\u72b6\uff09 of disk I/O blocking the timely return of MySQL queries and with MySQL\u2019s my.cnf max_connections setting on this server being way too high (2000), it also meant that MySQL\u2019s connections and queries would pile up\uff08\u5806\u79ef\uff09 and grow way beyond the available server RAM for all services . Growing to the point where the Linux Kernel would OOM kill MySQL. Considering MySQL\u2019s max allocated memory equals the size of per-thread buffers multiplied by that \u2018max_connections=2000\u2019 setting, this also left PHP-FPM with little free memory as it also piled up connections waiting on MySQL < disk. But with MySQL being the largest process, the Linux kernel opts to kill MySQL first. Using IOTOP command for real-time insight on disk read/writes iotop watches I/O usage information output by the Linux kernel and displays a table of current I/O usage by processes or threads on the system. I used the command: iotop -oPa . Here\u2019s an explanation of those options. -o , \u2013only (Only show processes or threads actually doing I/O, instead of showing all processes or threads. This can be dynamically toggled by pressing o.) -P , \u2013processes (Only show processes. Normally iotop shows all threads.) -a , **\u2013accumulated (**Show accumulated I/O instead of bandwidth. In this mode, iotop shows the amount of I/O processes have done since iotop started.) Look at the \u2018DISK WRITE\u2019 column, these are not very large figures. At the rate they increment, a fairly average speed storage device would not be busy with some kernel logging and disk cache. But at < 25 MB/s write speed (and over-committing memory) disk IO is maxed out by regular disk use from Nginx cache, kernel logs, access logs, etc. The fix here was to replace the storage with a better performing device, something with faster write speeds than an SD card. Of course, MySQL should never be allowed to make more connections than the server is capable of serving. Also, the workaround of throttling incoming traffic by lowering PHP-FPM\u2019s pm.max_children should be avoided or only temporary because this means refusing web traffic (basically moving the location of the bottleneck). Thankfully, the above case of a storage device being this slow is not common with most hosting providers. If you have a disk with average I/O, then you could also use Varnish cache or other caching methods, but these will only work as a shield when fully primed. If you have enough server memory, always opt to store everything there first. I hope this short article was useful. Feel free to leave tips, feedback, and/or tools below or contact me directly. Also, have a look at this list of top 50 APM tools . Here are some additional command line tools used: iostat , dstat , lsof , vmstat , nmon , sar , iptraf iftop , netstat , lsof , pvdisplay , lspci , ps . scoutapm Understanding Disk I/O - when should you be worried?","title":"Troubleshoot-disk-IO-bottleneck"},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-disk-IO-bottleneck/#troubleshoot#disk#io#bottleneck","text":"\u672c\u6587\u6807\u9898\u7684\u542b\u4e49\u662f\uff1a\u6392\u67e5disk IO\u74f6\u9888\u3002","title":"Troubleshoot disk IO bottleneck"},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-disk-IO-bottleneck/#haydenjames#linux#server#performance#is#disk#io#slowing#your#application","text":"If your Linux server is bogged down, your first step is often to use the TOP command in terminal to check load averages and wisely so. However, there are times when TOP shows very high load averages even with low cpu \u2018us\u2019 (user) and high cpu \u2018id\u2019 (idle) percentages. This is the case in the video below, load averages are above 30 on a server with 24 cores but CPU shows around 70 percent idle. One of the common causes of this condition is disk I/O bottleneck. Disk I/O is input/output (write/read) operations on a physical disk (or other storage). Requests which involve disk I/O can be slowed greatly if CPUs need to wait on the disk to read or write data. I/O Wait, (more about that below) is the percentage of time the CPU has to wait on disk. To begin, let\u2019s look at how we can confirm if disk I/O is slowing down application performance by using a few terminal command-line tools ( top , atop and iotop ) on a LEMP installed dedicated server.","title":"haydenjames Linux server performance: Is disk I/O slowing your application?"},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-disk-IO-bottleneck/#using#top#command#load#averages#and#wa#wait#time","text":"","title":"Using TOP command \u2013 load averages and wa (wait time)"},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-disk-IO-bottleneck/#_1","text":"As per the video above, when you enter top , you\u2019ll first glance to the top-right to check load averages. Which in this case, are VERY high and thus indicate a pileup\uff08\u5806\u79ef\uff09 of requests. Next, we most likely will glance at the cpu and mem horizontal lines near the top, followed by the %CPU and %MEM columns to get an idea of which processes are using most resources. While in top, you will also want to look at \u2018wa\u2019 (see video above) it should be 0.0% almost all the time. Values consistently above 1% may indicate that your storage device is too slow to keep up with incoming requests. Notice in the video the initial value averages around 6% wait time. However, this is averaged across 24 cores, some of which are not activated because the CPU cores are not nearing capacity on their own. So we should expand the view by pressing \u20181\u2019 on your keyboard to view wa time for each cpu core when in use. As per the screenshot above, there are 24 cores when expanded, from 0 to 23. Once we\u2019ve done this, we see that \u2018 %wa \u2019 time is as high as 60% for some cpu cores! So we know there\u2019s a bottleneck, a major one. Next, let\u2019s confirm this disk bottleneck .","title":""},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-disk-IO-bottleneck/#using#atop#command#to#monitor#dsk#disk#io#stats","text":"","title":"Using ATOP command to monitor DSK (disk) I/O stats"},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-disk-IO-bottleneck/#_2","text":"Using atop , next, we see that the storage device is 90 to 100 percent busy. This is a serious bottleneck. The effect is that requests are blocked until disk I/O can catch up. While in atop press \u2018 d \u201d to view the processes and PIDs which are using disk I/O. Here we see MySQL, Nginx, and PHP-FPM which are necessary processes and I would have to write another article about reducing disk I/O on high traffic L*MP servers. In short, be careful that Nginx (or Apache), MySQL, and PHP-FPM\u2019s access and error logs are not set up to write too frequently to disk and you want to also avoid storing cache (eg. Nginx cache) to disk in very high concurrent traffic environments. In addition to LEMP services, notice also \u2018flush-8:0\u2019 (traced to be PHP cache issue) and jbd2/sda5-8 (traced to access/kernel logs) along with their PIDs. On this server, I was able to perform a quick benchmark of the SSD after stopping services and noticed that disk performance was extremely poor. The results: 1073741824 bytes (1.1 GB) copied, 46.0156 s, 23.3 MB/s. So although reads/writes could be reduced, the real problem here is extremely slow disk I/O. This client\u2019s web host provider denied this and instead stated that MySQL was the problem because it often grows in size and suffers OOM kill . To the contrary, MySQL growing in memory usage was a symptom\uff08\u75c7\u72b6\uff09 of disk I/O blocking the timely return of MySQL queries and with MySQL\u2019s my.cnf max_connections setting on this server being way too high (2000), it also meant that MySQL\u2019s connections and queries would pile up\uff08\u5806\u79ef\uff09 and grow way beyond the available server RAM for all services . Growing to the point where the Linux Kernel would OOM kill MySQL. Considering MySQL\u2019s max allocated memory equals the size of per-thread buffers multiplied by that \u2018max_connections=2000\u2019 setting, this also left PHP-FPM with little free memory as it also piled up connections waiting on MySQL < disk. But with MySQL being the largest process, the Linux kernel opts to kill MySQL first.","title":""},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-disk-IO-bottleneck/#using#iotop#command#for#real-time#insight#on#disk#readwrites","text":"","title":"Using IOTOP command for real-time insight on disk read/writes"},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-disk-IO-bottleneck/#_3","text":"iotop watches I/O usage information output by the Linux kernel and displays a table of current I/O usage by processes or threads on the system. I used the command: iotop -oPa . Here\u2019s an explanation of those options. -o , \u2013only (Only show processes or threads actually doing I/O, instead of showing all processes or threads. This can be dynamically toggled by pressing o.) -P , \u2013processes (Only show processes. Normally iotop shows all threads.) -a , **\u2013accumulated (**Show accumulated I/O instead of bandwidth. In this mode, iotop shows the amount of I/O processes have done since iotop started.) Look at the \u2018DISK WRITE\u2019 column, these are not very large figures. At the rate they increment, a fairly average speed storage device would not be busy with some kernel logging and disk cache. But at < 25 MB/s write speed (and over-committing memory) disk IO is maxed out by regular disk use from Nginx cache, kernel logs, access logs, etc. The fix here was to replace the storage with a better performing device, something with faster write speeds than an SD card. Of course, MySQL should never be allowed to make more connections than the server is capable of serving. Also, the workaround of throttling incoming traffic by lowering PHP-FPM\u2019s pm.max_children should be avoided or only temporary because this means refusing web traffic (basically moving the location of the bottleneck). Thankfully, the above case of a storage device being this slow is not common with most hosting providers. If you have a disk with average I/O, then you could also use Varnish cache or other caching methods, but these will only work as a shield when fully primed. If you have enough server memory, always opt to store everything there first. I hope this short article was useful. Feel free to leave tips, feedback, and/or tools below or contact me directly. Also, have a look at this list of top 50 APM tools . Here are some additional command line tools used: iostat , dstat , lsof , vmstat , nmon , sar , iptraf iftop , netstat , lsof , pvdisplay , lspci , ps .","title":""},{"location":"Shell-and-tools/Tools/Performance/System-load/Troubleshoot-disk-IO-bottleneck/#scoutapm#understanding#disk#io#-#when#should#you#be#worried","text":"","title":"scoutapm Understanding Disk I/O - when should you be worried?"},{"location":"Shell-and-tools/Tools/Performance/System-load/uptime/","text":"uptime \u662f\u5728\u9605\u8bfblinuxjournal Hack and / - Linux Troubleshooting, Part I: High Load \u65f6\uff0c\u53d1\u73b0\u7684\u8fd9\u4e2a\u547d\u4ee4\u3002 uptime(1) - Linux man page System load averages is the average number of processes that are either in a runnable or uninterruptable state . A process in a runnable state is either using the CPU or waiting to use the CPU. A process in uninterruptable state is waiting for some I/O access, eg waiting for disk. The averages are taken over the three time intervals. Load averages are not normalized for the number of CPUs in a system, so a load average of 1 means a single CPU system is loaded all the time while on a 4 CPU system it means it was idle 75% of the time. NOTE: \u7406\u89e3load average\u662f\u5173\u952e\u6240\u5728\uff0c\u800c\u7406\u89e3load average\u7684\u5173\u952e\u5728\u4e8e\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684**normalized**\uff0c\u5b83\u7684\u610f\u601d\u662f\uff1auptime\u8f93\u51fa\u4e2d\u7684load average\u6307\u7684\u662fprocess\u4e2a\u6570\uff0c\u5b83\u5e76\u6ca1\u6709\u9664\u4ee5 CPU \u4e2a\u6570\uff0c\u8fd9\u5c31\u662f normalized \u7684\u542b\u4e49\u6240\u5728\u3002\u5173\u4e8e\u6b64\uff0c\u5728 Hack and / - Linux Troubleshooting, Part I: High Load \u4e2d\u4e5f\u5bf9\u5b83\u8fdb\u884c\u4e86\u8be6\u7ec6\u4ecb\u7ecd\uff0c\u4f5c\u8005\u5c06\u5b83\u4f5c\u4e3a\u67e5\u770b\u7cfb\u7edf load average \u7684\u7b2c\u4e00\u547d\u4ee4\u3002","title":"uptime"},{"location":"Shell-and-tools/Tools/Performance/System-load/uptime/#uptime","text":"\u662f\u5728\u9605\u8bfblinuxjournal Hack and / - Linux Troubleshooting, Part I: High Load \u65f6\uff0c\u53d1\u73b0\u7684\u8fd9\u4e2a\u547d\u4ee4\u3002","title":"uptime"},{"location":"Shell-and-tools/Tools/Performance/System-load/uptime/#uptime1#-#linux#man#page","text":"System load averages is the average number of processes that are either in a runnable or uninterruptable state . A process in a runnable state is either using the CPU or waiting to use the CPU. A process in uninterruptable state is waiting for some I/O access, eg waiting for disk. The averages are taken over the three time intervals. Load averages are not normalized for the number of CPUs in a system, so a load average of 1 means a single CPU system is loaded all the time while on a 4 CPU system it means it was idle 75% of the time. NOTE: \u7406\u89e3load average\u662f\u5173\u952e\u6240\u5728\uff0c\u800c\u7406\u89e3load average\u7684\u5173\u952e\u5728\u4e8e\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u4e2d\u7684**normalized**\uff0c\u5b83\u7684\u610f\u601d\u662f\uff1auptime\u8f93\u51fa\u4e2d\u7684load average\u6307\u7684\u662fprocess\u4e2a\u6570\uff0c\u5b83\u5e76\u6ca1\u6709\u9664\u4ee5 CPU \u4e2a\u6570\uff0c\u8fd9\u5c31\u662f normalized \u7684\u542b\u4e49\u6240\u5728\u3002\u5173\u4e8e\u6b64\uff0c\u5728 Hack and / - Linux Troubleshooting, Part I: High Load \u4e2d\u4e5f\u5bf9\u5b83\u8fdb\u884c\u4e86\u8be6\u7ec6\u4ecb\u7ecd\uff0c\u4f5c\u8005\u5c06\u5b83\u4f5c\u4e3a\u67e5\u770b\u7cfb\u7edf load average \u7684\u7b2c\u4e00\u547d\u4ee4\u3002","title":"uptime(1) - Linux man page"},{"location":"Shell-and-tools/Tools/Performance/perf/Linux-kernel-profiling-with-perf/","text":"perf.wiki.kernel Linux kernel profiling with perf","title":"Linux-kernel-profiling-with-perf"},{"location":"Shell-and-tools/Tools/Performance/perf/brendangregg-perf-Examples/","text":"perf Examples","title":"[perf Examples](http://www.brendangregg.com/perf.html)"},{"location":"Shell-and-tools/Tools/Performance/perf/brendangregg-perf-Examples/#perf#examples","text":"","title":"perf Examples"},{"location":"Shell-and-tools/Tools/Performance/perf/perf/","text":"perf wikipedia perf (Linux) perf(1) \u2014 Linux manual page PERF-TRACE(1) \u2014 Linux manual page PERF-TRACE(1) PERF-SCRIPT(1) PERF-RECORD(1)","title":"perf"},{"location":"Shell-and-tools/Tools/Performance/perf/perf/#perf","text":"","title":"perf"},{"location":"Shell-and-tools/Tools/Performance/perf/perf/#wikipedia#perf#linux","text":"","title":"wikipedia perf (Linux)"},{"location":"Shell-and-tools/Tools/Performance/perf/perf/#perf1#linux#manual#page","text":"","title":"perf(1) \u2014 Linux manual page"},{"location":"Shell-and-tools/Tools/Performance/perf/perf/#perf-trace1#linux#manual#page","text":"PERF-TRACE(1) PERF-SCRIPT(1) PERF-RECORD(1)","title":"PERF-TRACE(1) \u2014 Linux manual page"},{"location":"Shell-and-tools/Tools/Performance/perf/expert-Brendan-D-Gregg/","text":"Brendan D. Gregg \u5728performance\u65b9\u9762\u6709\u975e\u5e38\u597d\u7684\u603b\u7ed3\u3002 \u4e2a\u4eba\u7f51\u7ad9: Brendan D. Gregg","title":"Introduction"},{"location":"Shell-and-tools/Tools/Performance/perf/expert-Brendan-D-Gregg/#brendan#d#gregg","text":"\u5728performance\u65b9\u9762\u6709\u975e\u5e38\u597d\u7684\u603b\u7ed3\u3002 \u4e2a\u4eba\u7f51\u7ad9: Brendan D. Gregg","title":"Brendan D. Gregg"},{"location":"Shell-and-tools/Tools/Performance/sysstat/","text":"Sysstat \u5728\u5b66\u4e60 iostat \u7684\u65f6\u5019\uff0c\u53d1\u73b0\u5b83\u5c5e\u4e8e sysstat package\u3002 wikipedia Sysstat sysstat (***sys***tem ***stat***istics) is a collection of performance monitoring tools for Linux. It is available on Unix and Unix-like operating systems . command introduction \u8865\u5145\u8bf4\u660e sar [6] Collect, report, or save system activity information iostat (1) reports basic CPU statistics and input/output statistics for devices, partitions and network filesystems. \u5173\u4e8eIO\uff0c\u53c2\u89c1 Programming\\IO \u7ae0\u8282 mpstat (1) reports individual or combined processor related statistics. pidstat (1) reports statistics for Linux tasks (processes) : I/O, CPU, memory, etc. nfsiostat (1) reports input/output statistics for network filesystems (NFS). cifsiostat (1) reports I/O statistics for CIFS resources.","title":"Introduction"},{"location":"Shell-and-tools/Tools/Performance/sysstat/#sysstat","text":"\u5728\u5b66\u4e60 iostat \u7684\u65f6\u5019\uff0c\u53d1\u73b0\u5b83\u5c5e\u4e8e sysstat package\u3002","title":"Sysstat"},{"location":"Shell-and-tools/Tools/Performance/sysstat/#wikipedia#sysstat","text":"sysstat (***sys***tem ***stat***istics) is a collection of performance monitoring tools for Linux. It is available on Unix and Unix-like operating systems . command introduction \u8865\u5145\u8bf4\u660e sar [6] Collect, report, or save system activity information iostat (1) reports basic CPU statistics and input/output statistics for devices, partitions and network filesystems. \u5173\u4e8eIO\uff0c\u53c2\u89c1 Programming\\IO \u7ae0\u8282 mpstat (1) reports individual or combined processor related statistics. pidstat (1) reports statistics for Linux tasks (processes) : I/O, CPU, memory, etc. nfsiostat (1) reports input/output statistics for network filesystems (NFS). cifsiostat (1) reports I/O statistics for CIFS resources.","title":"wikipedia Sysstat"},{"location":"Shell-and-tools/Tools/Performance/sysstat/iostat/","text":"iostat wikipedia iostat iostat(1) - Linux man page","title":"Introduction"},{"location":"Shell-and-tools/Tools/Performance/sysstat/iostat/#iostat","text":"","title":"iostat"},{"location":"Shell-and-tools/Tools/Performance/sysstat/iostat/#wikipedia#iostat","text":"","title":"wikipedia iostat"},{"location":"Shell-and-tools/Tools/Performance/sysstat/iostat/#iostat1#-#linux#man#page","text":"","title":"iostat(1) - Linux man page"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/","text":"rsync \u540c\u6b65\u6587\u4ef6\u547d\u4ee4\u3002 \u5feb\u901f\u5165\u95e8 \u4e24\u79cd\u5de5\u4f5c\u65b9\u5f0f \u7b2c\u4e00\u79cd\u65b9\u5f0f:\u670d\u52a1\u5668\u2013\u5ba2\u6237\u7aef\u65b9\u5f0f \u5728\u8fd9\u79cd\u65b9\u5f0f\u4e0b\uff0c \u670d\u52a1\u7aef\u542f\u52a8daemon \u5b88\u62a4\u8fdb\u7a0b\uff0c \u76d1\u542c\u5728\u7aef\u53e3 873\uff0c \u5e76\u914d\u7f6e\u9700\u8981\u540c\u6b65\u7684\u6a21\u5757\u3002 \u7136\u540e\u5ba2\u6237\u7aef\u76f4\u63a5\u94fe\u63a5\u5230873\u7aef\u53e3\uff0c\u901a\u8fc7\u8ba4\u8bc1\uff0c\u5e76\u540c\u6b65\u3002\u5176\u4e2d\uff0c\u540c\u6b65\u7528\u7684\u8d26\u53f7\u548c\u5bc6\u7801\u90fd\u662f rsync \u4e13\u7528\u7684\uff0c\u5728 rsync \u914d\u7f6e\u6587\u4ef6\u4e2d\u72ec\u7acb\u914d\u7f6e\u3002 \u4e8e\u7cfb\u7edf\u8d26\u53f7\u65e0\u5173\u3002\u670d\u52a1\u7aef\u8fd0\u884c rsync \u8fdb\u7a0b\u5728daemon\u6a21\u5f0f\u4e0b\uff0c \u5ba2\u6237\u7aef\u662f\u666e\u901a\u7684 rsync \u8fdb\u7a0b\u3002\u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u5ba2\u6237\u7aef\u53ea\u80fd\u540c\u6b65\u670d\u52a1\u7aef\u4e8b\u5148\u914d\u7f6e\u7684\u6a21\u5757\uff08\u76ee\u5f55\uff09\u3002 \u4e0d\u80fd\u8bbf\u95ee\u5176\u4ed6\u8def\u5f84\u3002 \u7b2c\u4e8c\u79cd\u65b9\u5f0f:\u901a\u8fc7ssh\u94fe\u63a5 \u8fd9\u79cd\u65b9\u5f0f\u4e0b\uff0c \u65e0\u9700\u4e8b\u5148\u914d\u7f6e\u8fdc\u7a0b\u670d\u52a1\u7aef\u3002\u672c\u673a rsync \u8fdb\u7a0b \u76f4\u63a5\u901a\u8fc7 ssh \u901a\u9053\u8fde\u63a5\u5230\u8fdc\u7a0b\uff0c \u5e76\u5728\u8fdc\u7a0bssh\u901a\u9053\u6267\u884c\u547d\u4ee4\uff1a rsync \u2013****** \u3002 \u672c\u5730 rsync \u8fdb\u7a0b\u548c\u8fdc\u7a0b rsync \u8fdb\u7a0b\u901a\u8fc7\u81ea\u5df1\u7684**\u6807\u51c6\u8f93\u5165**\u548c**\u6807\u51c6\u8f93\u51fa**\u4e92\u76f8\u901a\u4fe1\u3002 \u5177\u4f53\u7684\u8bf4\u5c31\u662f\uff0c\u672c\u5730\u8fdb\u7a0b\u76d1\u542cssh\u901a\u9053\u7684\u8fdc\u7a0b\u56de\u663e\u5f53\u505a\u8f93\u5165\uff0c \u628a\u81ea\u5df1\u7684\u7684\u8f93\u51fa\u901a\u8fc7ssh\u901a\u9053\u53d1\u9001\u7ed9\u8fdc\u7a0b\u3002 \u800c\u8fdc\u7a0b\u7684 rsync \u8fdb\u7a0b\u5c31\u4e00\u6837\uff0c \u4e5f\u4f1a\u76d1\u542cssh\u901a\u9053\u7684\u8f93\u5165\uff0c\u5f53\u505a\u81ea\u5df1\u7684\u8f93\u5165\uff0c\u7136\u540e\u628a\u81ea\u5df1\u7684\u8f93\u51fa\u5199\u5165\u5230ssh\u901a\u9053\u3002\u4e8e\u662f\uff0c \u8fdc\u7a0brsync\u8fdb\u7a0b\u548c\u672c\u5730rsync\u8fdb\u7a0b\u5c31\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u540c\u6b65\u6587\u4ef6\u3002 \u8fd9\u79cd\u60c5\u51b5\uff0c\u65e0\u9700\u4e8b\u5148\u914d\u7f6e\u8fdc\u7a0b\u670d\u52a1\u7aef\uff0c \u53ea\u8981\u4f60\u6709ssh\u6743\u9650\u767b\u5f55\uff0c\u5c31\u80fd\u540c\u6b65\u3002 \u540c\u6b65\u7684\u8def\u5f84\u65e0\u9650\u5236\u3002 \u5f53\u7136\u53ea\u80fd\u8bbf\u95ee\u4f60\u7684ssh\u8d26\u53f7\u6240\u80fd\u8bbf\u95ee\u7684\u76ee\u5f55\u3002 \u5982\u679c\u4f60\u662froot\u90a3\u5c31\u662f\u65e0\u9650\u5236\u4e86\u3002 \u4e24\u79cd\u65b9\u5f0f\u5bf9\u6bd4 \u8fd9\u4e24\u79cd\u5de5\u4f5c\u65b9\u5f0f\u4e0b\uff0c\u53ea\u662f\u4f20\u8f93\u7684\u901a\u9053\u4e0d\u4e00\u6837\uff0c\u7b2c\u4e00\u79cd\u662f\u76f4\u63a5\u8d70socket\u901a\u9053\u3002 \u7b2c\u4e8c\u79cd\u662f\u8d70\u7684ssh\u901a\u9053\u3002\u5b89\u5168\u6027\u663e\u800c\u6613\u89c1\u3002 \u4e24\u79cd\u65b9\u5f0f\u4e0b\uff0c rsync \u90fd\u4f7f\u7528\u81ea\u6709\u534f\u8bae\u8fdb\u884c\u540c\u6b65\uff0c\u6240\u4ee5\u53ef\u4ee5\u643a\u5e26\u7684\u53c2\u6570\u90fd\u662f\u6ca1\u6709\u533a\u522b\u7684\u3002 \u7528\u6cd5 rsync \u7684\u4e00\u822c\u5f62\u5f0f\uff1a rsync -options SRC DEST \u6ce8\u610f \uff0c\u540c\u6b65\u4e5f\u662f\u6709\u65b9\u5411\u7684\uff0c\u56e0\u6b64\u9700\u8981\u660e\u767d\u4ece\u54ea\u91cc\u540c\u6b65\u5230\u54ea\u91cc\u3002 rsync \u547d\u4ee4\u80af\u5b9a\u662f\u5c06 SRC \u590d\u5236\u5230 DEST \u3002\u56e0\u4e3a SRC \uff0c DEST \u5373\u6709\u53ef\u80fd\u5728\u672c\u5730\uff0c\u4e5f\u6709\u53ef\u80fd\u5728\u8fdc\u7a0b\u4e3b\u673a\u3002 \u5f53\u901a\u8fc7ssh\u94fe\u63a5\u65f6\uff0c \u6709\u65f6\u9700\u8981\u6307\u5b9assh\u7aef\u53e3\uff0c \u8bf7\u4f7f\u7528\u8fd9\u4e2a\u65b9\u5f0f\uff1a rsync -options -e \"ssh -p 10000\" SRC DEST \u6ce8\u610f \uff0c\u662f\u5426\u4f7f\u7528ssh\u901a\u9053\uff0c\u4e0e\u4e0a\u9762\u8fd9\u4e2a\u53c2\u6570\u6ca1\u6709\u5fc5\u7136\u8054\u7cfb\u3002\u6211\u8fd9\u91cc\u6307\u5b9a\u4e8610000\u7aef\u53e3 \u547d\u4ee4 \u8bf4\u660e rsync [OPTION]... SRC DEST \u540c\u6b65\u672c\u5730\u6587\u4ef6\u3002\u5f53 SRC \u548c DEST \u8def\u5f84\u4fe1\u606f\u90fd\u4e0d\u5305\u542b\u6709\u5355\u4e2a\u5192\u53f7\" : \"\u5206\u9694\u7b26\u65f6\u5c31\u542f\u52a8\u8fd9\u79cd\u5de5\u4f5c\u6a21\u5f0f\u3002\u5982\uff1a rsync -a /data /backup rsync [OPTION]... SRC [USER@]HOST:DEST \u4f7f\u7528\u4e00\u4e2a**\u8fdc\u7a0bshell\u7a0b\u5e8f**(\u5982 rsh \u3001 ssh )\u6765\u5b9e\u73b0\u5c06\u672c\u5730\u673a\u5668\u7684\u5185\u5bb9\u62f7\u8d1d\u5230\u8fdc\u7a0b\u673a\u5668\u3002\u5f53 DSTT \u8def\u5f84\u5730\u5740\u5305\u542b\u5355\u4e2a\u5192\u53f7\" : \"\u5206\u9694\u7b26\u65f6\u542f\u52a8\u8be5\u6a21\u5f0f\u3002\u5982\uff1a rsync -avz *.c foo:src rsync [OPTION]... [USER@]HOST:SRC DEST \u4f7f\u7528\u4e00\u4e2a**\u8fdc\u7a0bshell\u7a0b\u5e8f**(\u5982 rsh \u3001 ssh )\u6765\u5b9e\u73b0\u5c06\u8fdc\u7a0b\u673a\u5668\u7684\u5185\u5bb9\u62f7\u8d1d\u5230\u672c\u5730\u673a\u5668\u3002\u5f53 SRC \u5730\u5740\u8def\u5f84\u5305\u542b\u5355\u4e2a\u5192\u53f7\" : \"\u5206\u9694\u7b26\u65f6\u542f\u52a8\u8be5\u6a21\u5f0f\u3002\u5982\uff1a rsync -avz foo:src/bar /data rsync [OPTION]... [USER@]HOST::SRC DEST \u4ece**\u8fdc\u7a0b rsync \u670d\u52a1\u5668**\u4e2d\u62f7\u8d1d\u6587\u4ef6\u5230\u672c\u5730\u673a\u3002\u5f53 SRC \u8def\u5f84\u4fe1\u606f\u5305\u542b\" :: \"\u5206\u9694\u7b26\u65f6\u542f\u52a8\u8be5\u6a21\u5f0f\u3002\u5982\uff1a rsync -av root@172.16.78.192::www /databack rsync [OPTION]... SRC [USER@]HOST::DEST \u4ece\u672c\u5730\u673a\u5668\u62f7\u8d1d\u6587\u4ef6\u5230**\u8fdc\u7a0b rsync \u670d\u52a1\u5668**\u4e2d\u3002\u5f53DST\u8def\u5f84\u4fe1\u606f\u5305\u542b\" :: \"\u5206\u9694\u7b26\u65f6\u542f\u52a8\u8be5\u6a21\u5f0f\u3002\u5982\uff1a rsync -av /databack root@172.16.78.192::www rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] \u5217\u8fdc\u7a0b\u673a\u7684\u6587\u4ef6\u5217\u8868\u3002\u8fd9\u7c7b\u4f3c\u4e8e rsync \u4f20\u8f93\uff0c\u4e0d\u8fc7\u53ea\u8981\u5728\u547d\u4ee4\u4e2d\u7701\u7565\u6389\u672c\u5730\u673a\u4fe1\u606f\u5373\u53ef\u3002\u5982\uff1a rsync -v rsync://172.16.78.192/www rsync \u5982\u4f55\u533a\u5206\u8fd9\u4e24\u79cd\u5de5\u4f5c\u65b9\u5f0f \u547d\u4ee4\u683c\u5f0f \u8bf4\u660e [USER@]HOST:FOLDER \u6ce8\u610f\u8fd9\u91cc HOST \u548cFOLDER\u4e4b\u95f4\u7528\u7684\u662f\u4e00\u4e2a\u5192\u53f7\uff0c rsync \u7531\u6b64\u5224\u65ad\u4f7f\u7528ssh\u901a\u9053\uff1b\u8fd9\u91cc\uff0c\u540e\u9762\u8ddf\u7684\u76f4\u63a5\u662fFOLDER\u7684\u5b8c\u6574\u8def\u5f84\uff0c\u9700\u8981\u662f USER \u6240\u80fd\u8bbf\u95ee\u7684\u5730\u65b9\u3002 [USER@]HOST::MODE HOST\u4e8eMODE\u4e4b\u95f4\u6709\u4e24\u4e2a\u5192\u53f7\uff0c rsync \u7531\u6b64\u5224\u65ad\u4f7f\u7528\u670d\u52a1\u5668\u2013\u5ba2\u6237\u7aef\u65b9\u5f0f\uff1b MODE \u662f\u8fdc\u7a0bdaemon\u4e8b\u5148\u914d\u7f6e\u597d\u7684 \u6a21\u5757\u540d\u5b57\u3002\u8fd9\u91cc\u53ea\u80fd\u4f7f\u7528\u5df2\u7ecf\u914d\u597d\u7684\u6a21\u5757\u540d\u5b57\uff0c\u4e0d\u80fd\u4f7f\u7528\u8def\u5f84\u3002 Example \u4ecelocal\u5411remote\u540c\u6b65 rsync local-file user@remote-host:remote-file \u6765\u6e90\uff1a\u7ef4\u57fa\u767e\u79d1 rsync \uff1b\u8fd9\u662f\u5c06\u672c\u5730\u63a8\u9001\u5230\u8fdc\u7a0b\u7684\u4f8b\u5b50\u3002 rsync -vzacu /home/wwwroot root@198.***.***.***:/home/ --exclude \"wwwroot/index\" -e \"ssh -p 22\" \u8fd9\u662f\u4e00\u4e2a\u901a\u8fc7ssh\u901a\u9053\u4ece\u672c\u5730\u63a8\u9001\u5230\u8fdc\u7a0b\u7684\u4f8b\u5b50\u3002 \u628a\u672c\u5730\u7684 /home/wwwroot \u63a8\u9001\u5230\u8fdc\u7a0b\u7684 /home \u4e0b\u9762\u3002\u53c2\u6570\u8bf4\u660e\uff1a \u53c2\u6570 \u8bf4\u660e -z \u8868\u793a\u4f20\u8f93\u8fc7\u7a0b\u538b\u7f29 -a \u8868\u793a\u91c7\u7528**\u5f52\u6863\u6a21\u5f0f**\uff0c \u62f7\u8d1d\u6587\u4ef6\u65f6\uff0c\u4fdd\u7559\u6587\u4ef6\u7684**\u5c5e\u4e3b**\uff0c \u7528\u6237\u7ec4 \uff0c**\u6743\u9650**\u7b49\u7b49\u4fe1\u606f\u3002 -c \u8868\u793a\u6821\u9a8c\u6587\u4ef6checksum -u \u8868\u793aupdate\uff0c\u53ea\u4f20\u9001\u66f4\u65b0\u7684\u6587\u4ef6\u3002 rsync \u4f1a\u6bd4\u8f83\u6587\u4ef6\u7684\u4fee\u6539\u65f6\u95f4\u3002\u53ea\u6709\u8f83\u65b0\u7684\u6587\u4ef6\u624d\u4f1a\u88ab\u540c\u6b65\u3002 \u7b26\u53f7\u94fe\u63a5 Perform rsync while following sym links rsync and symbolic links Permission Rsync command issues, owner and group permissions doesn\u00b4t change Copy only folders not files? FYI use rsync to copy the directory structure AND retain the permissions and attributes]( stackoverflow.com/a/9242883/52074 ). Using plain mkdir -p does not preserve permissions and attributes . \u2013 Trevor Boyd Smith Jun 1 '17 at 20:24 Rsync how to include directories but not files? A1 rsync -a -f \"+ */\" -f \"- *\" source/ destination/ rsync -a --include = '*/' --exclude = '*' source/ destination/ \u6b64\u5904\u4f7f\u7528\u4e86rsync\uff0c\u770b\u6765\u662f\u9700\u8981\u5b66\u4e60\u4e00\u4e0b\u7684\uff0c\u5df2\u7ecf\u521b\u5efa\u4e86rsync\u76ee\u5f55\u3002 \u62d3\u5c55 copy directory\u548c *.h \u6587\u4ef6: rsync -av -f \"+ */\" -f \"+ *.h\" -f \"- *\" $bazel_tensorflow /tensorflow $base_dir \u5b98\u7f51 rsync rsync is an open source utility that provides fast incremental file transfer. rsync is freely available under the GNU General Public License and is currently being maintained by Wayne Davison . Documentation","title":"Rsync"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#rsync","text":"\u540c\u6b65\u6587\u4ef6\u547d\u4ee4\u3002","title":"rsync"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#_1","text":"","title":"\u5feb\u901f\u5165\u95e8"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#_2","text":"","title":"\u4e24\u79cd\u5de5\u4f5c\u65b9\u5f0f"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#_3","text":"\u5728\u8fd9\u79cd\u65b9\u5f0f\u4e0b\uff0c \u670d\u52a1\u7aef\u542f\u52a8daemon \u5b88\u62a4\u8fdb\u7a0b\uff0c \u76d1\u542c\u5728\u7aef\u53e3 873\uff0c \u5e76\u914d\u7f6e\u9700\u8981\u540c\u6b65\u7684\u6a21\u5757\u3002 \u7136\u540e\u5ba2\u6237\u7aef\u76f4\u63a5\u94fe\u63a5\u5230873\u7aef\u53e3\uff0c\u901a\u8fc7\u8ba4\u8bc1\uff0c\u5e76\u540c\u6b65\u3002\u5176\u4e2d\uff0c\u540c\u6b65\u7528\u7684\u8d26\u53f7\u548c\u5bc6\u7801\u90fd\u662f rsync \u4e13\u7528\u7684\uff0c\u5728 rsync \u914d\u7f6e\u6587\u4ef6\u4e2d\u72ec\u7acb\u914d\u7f6e\u3002 \u4e8e\u7cfb\u7edf\u8d26\u53f7\u65e0\u5173\u3002\u670d\u52a1\u7aef\u8fd0\u884c rsync \u8fdb\u7a0b\u5728daemon\u6a21\u5f0f\u4e0b\uff0c \u5ba2\u6237\u7aef\u662f\u666e\u901a\u7684 rsync \u8fdb\u7a0b\u3002\u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u5ba2\u6237\u7aef\u53ea\u80fd\u540c\u6b65\u670d\u52a1\u7aef\u4e8b\u5148\u914d\u7f6e\u7684\u6a21\u5757\uff08\u76ee\u5f55\uff09\u3002 \u4e0d\u80fd\u8bbf\u95ee\u5176\u4ed6\u8def\u5f84\u3002","title":"\u7b2c\u4e00\u79cd\u65b9\u5f0f:\u670d\u52a1\u5668\u2013\u5ba2\u6237\u7aef\u65b9\u5f0f"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#ssh","text":"\u8fd9\u79cd\u65b9\u5f0f\u4e0b\uff0c \u65e0\u9700\u4e8b\u5148\u914d\u7f6e\u8fdc\u7a0b\u670d\u52a1\u7aef\u3002\u672c\u673a rsync \u8fdb\u7a0b \u76f4\u63a5\u901a\u8fc7 ssh \u901a\u9053\u8fde\u63a5\u5230\u8fdc\u7a0b\uff0c \u5e76\u5728\u8fdc\u7a0bssh\u901a\u9053\u6267\u884c\u547d\u4ee4\uff1a rsync \u2013****** \u3002 \u672c\u5730 rsync \u8fdb\u7a0b\u548c\u8fdc\u7a0b rsync \u8fdb\u7a0b\u901a\u8fc7\u81ea\u5df1\u7684**\u6807\u51c6\u8f93\u5165**\u548c**\u6807\u51c6\u8f93\u51fa**\u4e92\u76f8\u901a\u4fe1\u3002 \u5177\u4f53\u7684\u8bf4\u5c31\u662f\uff0c\u672c\u5730\u8fdb\u7a0b\u76d1\u542cssh\u901a\u9053\u7684\u8fdc\u7a0b\u56de\u663e\u5f53\u505a\u8f93\u5165\uff0c \u628a\u81ea\u5df1\u7684\u7684\u8f93\u51fa\u901a\u8fc7ssh\u901a\u9053\u53d1\u9001\u7ed9\u8fdc\u7a0b\u3002 \u800c\u8fdc\u7a0b\u7684 rsync \u8fdb\u7a0b\u5c31\u4e00\u6837\uff0c \u4e5f\u4f1a\u76d1\u542cssh\u901a\u9053\u7684\u8f93\u5165\uff0c\u5f53\u505a\u81ea\u5df1\u7684\u8f93\u5165\uff0c\u7136\u540e\u628a\u81ea\u5df1\u7684\u8f93\u51fa\u5199\u5165\u5230ssh\u901a\u9053\u3002\u4e8e\u662f\uff0c \u8fdc\u7a0brsync\u8fdb\u7a0b\u548c\u672c\u5730rsync\u8fdb\u7a0b\u5c31\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u540c\u6b65\u6587\u4ef6\u3002 \u8fd9\u79cd\u60c5\u51b5\uff0c\u65e0\u9700\u4e8b\u5148\u914d\u7f6e\u8fdc\u7a0b\u670d\u52a1\u7aef\uff0c \u53ea\u8981\u4f60\u6709ssh\u6743\u9650\u767b\u5f55\uff0c\u5c31\u80fd\u540c\u6b65\u3002 \u540c\u6b65\u7684\u8def\u5f84\u65e0\u9650\u5236\u3002 \u5f53\u7136\u53ea\u80fd\u8bbf\u95ee\u4f60\u7684ssh\u8d26\u53f7\u6240\u80fd\u8bbf\u95ee\u7684\u76ee\u5f55\u3002 \u5982\u679c\u4f60\u662froot\u90a3\u5c31\u662f\u65e0\u9650\u5236\u4e86\u3002","title":"\u7b2c\u4e8c\u79cd\u65b9\u5f0f:\u901a\u8fc7ssh\u94fe\u63a5"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#_4","text":"\u8fd9\u4e24\u79cd\u5de5\u4f5c\u65b9\u5f0f\u4e0b\uff0c\u53ea\u662f\u4f20\u8f93\u7684\u901a\u9053\u4e0d\u4e00\u6837\uff0c\u7b2c\u4e00\u79cd\u662f\u76f4\u63a5\u8d70socket\u901a\u9053\u3002 \u7b2c\u4e8c\u79cd\u662f\u8d70\u7684ssh\u901a\u9053\u3002\u5b89\u5168\u6027\u663e\u800c\u6613\u89c1\u3002 \u4e24\u79cd\u65b9\u5f0f\u4e0b\uff0c rsync \u90fd\u4f7f\u7528\u81ea\u6709\u534f\u8bae\u8fdb\u884c\u540c\u6b65\uff0c\u6240\u4ee5\u53ef\u4ee5\u643a\u5e26\u7684\u53c2\u6570\u90fd\u662f\u6ca1\u6709\u533a\u522b\u7684\u3002","title":"\u4e24\u79cd\u65b9\u5f0f\u5bf9\u6bd4"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#_5","text":"rsync \u7684\u4e00\u822c\u5f62\u5f0f\uff1a rsync -options SRC DEST \u6ce8\u610f \uff0c\u540c\u6b65\u4e5f\u662f\u6709\u65b9\u5411\u7684\uff0c\u56e0\u6b64\u9700\u8981\u660e\u767d\u4ece\u54ea\u91cc\u540c\u6b65\u5230\u54ea\u91cc\u3002 rsync \u547d\u4ee4\u80af\u5b9a\u662f\u5c06 SRC \u590d\u5236\u5230 DEST \u3002\u56e0\u4e3a SRC \uff0c DEST \u5373\u6709\u53ef\u80fd\u5728\u672c\u5730\uff0c\u4e5f\u6709\u53ef\u80fd\u5728\u8fdc\u7a0b\u4e3b\u673a\u3002 \u5f53\u901a\u8fc7ssh\u94fe\u63a5\u65f6\uff0c \u6709\u65f6\u9700\u8981\u6307\u5b9assh\u7aef\u53e3\uff0c \u8bf7\u4f7f\u7528\u8fd9\u4e2a\u65b9\u5f0f\uff1a rsync -options -e \"ssh -p 10000\" SRC DEST \u6ce8\u610f \uff0c\u662f\u5426\u4f7f\u7528ssh\u901a\u9053\uff0c\u4e0e\u4e0a\u9762\u8fd9\u4e2a\u53c2\u6570\u6ca1\u6709\u5fc5\u7136\u8054\u7cfb\u3002\u6211\u8fd9\u91cc\u6307\u5b9a\u4e8610000\u7aef\u53e3 \u547d\u4ee4 \u8bf4\u660e rsync [OPTION]... SRC DEST \u540c\u6b65\u672c\u5730\u6587\u4ef6\u3002\u5f53 SRC \u548c DEST \u8def\u5f84\u4fe1\u606f\u90fd\u4e0d\u5305\u542b\u6709\u5355\u4e2a\u5192\u53f7\" : \"\u5206\u9694\u7b26\u65f6\u5c31\u542f\u52a8\u8fd9\u79cd\u5de5\u4f5c\u6a21\u5f0f\u3002\u5982\uff1a rsync -a /data /backup rsync [OPTION]... SRC [USER@]HOST:DEST \u4f7f\u7528\u4e00\u4e2a**\u8fdc\u7a0bshell\u7a0b\u5e8f**(\u5982 rsh \u3001 ssh )\u6765\u5b9e\u73b0\u5c06\u672c\u5730\u673a\u5668\u7684\u5185\u5bb9\u62f7\u8d1d\u5230\u8fdc\u7a0b\u673a\u5668\u3002\u5f53 DSTT \u8def\u5f84\u5730\u5740\u5305\u542b\u5355\u4e2a\u5192\u53f7\" : \"\u5206\u9694\u7b26\u65f6\u542f\u52a8\u8be5\u6a21\u5f0f\u3002\u5982\uff1a rsync -avz *.c foo:src rsync [OPTION]... [USER@]HOST:SRC DEST \u4f7f\u7528\u4e00\u4e2a**\u8fdc\u7a0bshell\u7a0b\u5e8f**(\u5982 rsh \u3001 ssh )\u6765\u5b9e\u73b0\u5c06\u8fdc\u7a0b\u673a\u5668\u7684\u5185\u5bb9\u62f7\u8d1d\u5230\u672c\u5730\u673a\u5668\u3002\u5f53 SRC \u5730\u5740\u8def\u5f84\u5305\u542b\u5355\u4e2a\u5192\u53f7\" : \"\u5206\u9694\u7b26\u65f6\u542f\u52a8\u8be5\u6a21\u5f0f\u3002\u5982\uff1a rsync -avz foo:src/bar /data rsync [OPTION]... [USER@]HOST::SRC DEST \u4ece**\u8fdc\u7a0b rsync \u670d\u52a1\u5668**\u4e2d\u62f7\u8d1d\u6587\u4ef6\u5230\u672c\u5730\u673a\u3002\u5f53 SRC \u8def\u5f84\u4fe1\u606f\u5305\u542b\" :: \"\u5206\u9694\u7b26\u65f6\u542f\u52a8\u8be5\u6a21\u5f0f\u3002\u5982\uff1a rsync -av root@172.16.78.192::www /databack rsync [OPTION]... SRC [USER@]HOST::DEST \u4ece\u672c\u5730\u673a\u5668\u62f7\u8d1d\u6587\u4ef6\u5230**\u8fdc\u7a0b rsync \u670d\u52a1\u5668**\u4e2d\u3002\u5f53DST\u8def\u5f84\u4fe1\u606f\u5305\u542b\" :: \"\u5206\u9694\u7b26\u65f6\u542f\u52a8\u8be5\u6a21\u5f0f\u3002\u5982\uff1a rsync -av /databack root@172.16.78.192::www rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] \u5217\u8fdc\u7a0b\u673a\u7684\u6587\u4ef6\u5217\u8868\u3002\u8fd9\u7c7b\u4f3c\u4e8e rsync \u4f20\u8f93\uff0c\u4e0d\u8fc7\u53ea\u8981\u5728\u547d\u4ee4\u4e2d\u7701\u7565\u6389\u672c\u5730\u673a\u4fe1\u606f\u5373\u53ef\u3002\u5982\uff1a rsync -v rsync://172.16.78.192/www","title":"\u7528\u6cd5"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#rsync_1","text":"\u547d\u4ee4\u683c\u5f0f \u8bf4\u660e [USER@]HOST:FOLDER \u6ce8\u610f\u8fd9\u91cc HOST \u548cFOLDER\u4e4b\u95f4\u7528\u7684\u662f\u4e00\u4e2a\u5192\u53f7\uff0c rsync \u7531\u6b64\u5224\u65ad\u4f7f\u7528ssh\u901a\u9053\uff1b\u8fd9\u91cc\uff0c\u540e\u9762\u8ddf\u7684\u76f4\u63a5\u662fFOLDER\u7684\u5b8c\u6574\u8def\u5f84\uff0c\u9700\u8981\u662f USER \u6240\u80fd\u8bbf\u95ee\u7684\u5730\u65b9\u3002 [USER@]HOST::MODE HOST\u4e8eMODE\u4e4b\u95f4\u6709\u4e24\u4e2a\u5192\u53f7\uff0c rsync \u7531\u6b64\u5224\u65ad\u4f7f\u7528\u670d\u52a1\u5668\u2013\u5ba2\u6237\u7aef\u65b9\u5f0f\uff1b MODE \u662f\u8fdc\u7a0bdaemon\u4e8b\u5148\u914d\u7f6e\u597d\u7684 \u6a21\u5757\u540d\u5b57\u3002\u8fd9\u91cc\u53ea\u80fd\u4f7f\u7528\u5df2\u7ecf\u914d\u597d\u7684\u6a21\u5757\u540d\u5b57\uff0c\u4e0d\u80fd\u4f7f\u7528\u8def\u5f84\u3002","title":"rsync\u5982\u4f55\u533a\u5206\u8fd9\u4e24\u79cd\u5de5\u4f5c\u65b9\u5f0f"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#example","text":"","title":"Example"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#localremote","text":"rsync local-file user@remote-host:remote-file \u6765\u6e90\uff1a\u7ef4\u57fa\u767e\u79d1 rsync \uff1b\u8fd9\u662f\u5c06\u672c\u5730\u63a8\u9001\u5230\u8fdc\u7a0b\u7684\u4f8b\u5b50\u3002 rsync -vzacu /home/wwwroot root@198.***.***.***:/home/ --exclude \"wwwroot/index\" -e \"ssh -p 22\" \u8fd9\u662f\u4e00\u4e2a\u901a\u8fc7ssh\u901a\u9053\u4ece\u672c\u5730\u63a8\u9001\u5230\u8fdc\u7a0b\u7684\u4f8b\u5b50\u3002 \u628a\u672c\u5730\u7684 /home/wwwroot \u63a8\u9001\u5230\u8fdc\u7a0b\u7684 /home \u4e0b\u9762\u3002\u53c2\u6570\u8bf4\u660e\uff1a \u53c2\u6570 \u8bf4\u660e -z \u8868\u793a\u4f20\u8f93\u8fc7\u7a0b\u538b\u7f29 -a \u8868\u793a\u91c7\u7528**\u5f52\u6863\u6a21\u5f0f**\uff0c \u62f7\u8d1d\u6587\u4ef6\u65f6\uff0c\u4fdd\u7559\u6587\u4ef6\u7684**\u5c5e\u4e3b**\uff0c \u7528\u6237\u7ec4 \uff0c**\u6743\u9650**\u7b49\u7b49\u4fe1\u606f\u3002 -c \u8868\u793a\u6821\u9a8c\u6587\u4ef6checksum -u \u8868\u793aupdate\uff0c\u53ea\u4f20\u9001\u66f4\u65b0\u7684\u6587\u4ef6\u3002 rsync \u4f1a\u6bd4\u8f83\u6587\u4ef6\u7684\u4fee\u6539\u65f6\u95f4\u3002\u53ea\u6709\u8f83\u65b0\u7684\u6587\u4ef6\u624d\u4f1a\u88ab\u540c\u6b65\u3002","title":"\u4ecelocal\u5411remote\u540c\u6b65"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#_6","text":"Perform rsync while following sym links rsync and symbolic links","title":"\u7b26\u53f7\u94fe\u63a5"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#permission","text":"Rsync command issues, owner and group permissions doesn\u00b4t change","title":"Permission"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#copy#only#folders#not#files","text":"FYI use rsync to copy the directory structure AND retain the permissions and attributes]( stackoverflow.com/a/9242883/52074 ). Using plain mkdir -p does not preserve permissions and attributes . \u2013 Trevor Boyd Smith Jun 1 '17 at 20:24","title":"Copy only folders not files?"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#rsync#how#to#include#directories#but#not#files","text":"","title":"Rsync how to include directories but not files?"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#a1","text":"rsync -a -f \"+ */\" -f \"- *\" source/ destination/ rsync -a --include = '*/' --exclude = '*' source/ destination/ \u6b64\u5904\u4f7f\u7528\u4e86rsync\uff0c\u770b\u6765\u662f\u9700\u8981\u5b66\u4e60\u4e00\u4e0b\u7684\uff0c\u5df2\u7ecf\u521b\u5efa\u4e86rsync\u76ee\u5f55\u3002","title":"A1"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#_7","text":"copy directory\u548c *.h \u6587\u4ef6: rsync -av -f \"+ */\" -f \"+ *.h\" -f \"- *\" $bazel_tensorflow /tensorflow $base_dir","title":"\u62d3\u5c55"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#rsync_2","text":"rsync is an open source utility that provides fast incremental file transfer. rsync is freely available under the GNU General Public License and is currently being maintained by Wayne Davison .","title":"\u5b98\u7f51rsync"},{"location":"Shell-and-tools/Tools/Rsync/Rsync/#documentation","text":"","title":"Documentation"},{"location":"Shell-and-tools/Tools/Script/Linux%E6%9F%A5%E7%9C%8B%E7%89%A9%E7%90%86CPU%E4%B8%AA%E6%95%B0%E3%80%81%E6%A0%B8%E6%95%B0%E3%80%81%E9%80%BB%E8%BE%91CPU%E4%B8%AA%E6%95%B0/","text":"# \u603b\u6838\u6570 = \u7269\u7406CPU\u4e2a\u6570 X \u6bcf\u9897\u7269\u7406CPU\u7684\u6838\u6570 # \u603b\u903b\u8f91CPU\u6570 = \u7269\u7406CPU\u4e2a\u6570 X \u6bcf\u9897\u7269\u7406CPU\u7684\u6838\u6570 X \u8d85\u7ebf\u7a0b\u6570 # \u67e5\u770b\u7269\u7406CPU\u4e2a\u6570 cat /proc/cpuinfo| grep \"physical id\"| sort| uniq| wc -l # \u67e5\u770b\u6bcf\u4e2a\u7269\u7406CPU\u4e2dcore\u7684\u4e2a\u6570(\u5373\u6838\u6570) cat /proc/cpuinfo| grep \"cpu cores\"| uniq # \u67e5\u770b\u903b\u8f91CPU\u7684\u4e2a\u6570 cat /proc/cpuinfo| grep \"processor\"| wc -l","title":"Linux\u67e5\u770b\u7269\u7406CPU\u4e2a\u6570\u3001\u6838\u6570\u3001\u903b\u8f91CPU\u4e2a\u6570"},{"location":"TODO/20201105-gdb%E8%B0%83%E8%AF%95%E6%8C%87%E5%AE%9Athread/","text":"\u5bf9\u4e8e\u591a\u7ebf\u7a0bapplication\uff0cgdb\u4f1a\u4e3a\u6bcf\u4e2athread\u90fd\u6307\u5b9a\u4e00\u4e2athread ID\uff0c\u5982\u679c\u8fdb\u884cautomate debug\uff0c\u7528\u6237\u65e0\u6cd5\u63d0\u524d\u83b7\u77e5thread ID\uff0c\u90a3\u5982\u4f55\u6765\u67e5\u8be2\u5f97\u5230\u6307\u5b9athread\u7684thread ID\u5462\uff1f","title":"20201105 gdb\u8c03\u8bd5\u6307\u5b9athread"},{"location":"TODO/TODO/","text":"20190817 \u4eca\u5929\u5728\u9605\u8bfb\u300a Understanding.The.Linux.kernel.3rd.Edition \u300b\u76846.2.1.2. The jiffies variable\u7ae0\u8282\u7684\u65f6\u5019\uff0c\u5176\u4e2d\u7684\u4e00\u6bb5\u8bdd\u5f15\u8d77\u4e86\u6211\u5bf9\u539f\u5b50\u6027\u7684\u601d\u8003\uff1a You might wonder why jiffies has not been directly declared as a 64-bit unsigned long long integer on the 80 x 86 architecture. The answer is that accesses to 64-bit variables in 32-bit architectures cannot be done atomically . Therefore, every read operation on the whole 64 bits requires some synchronization technique to ensure that the counter is not updated while the two 32-bit half-counters are read; as a consequence, every 64-bit read operation is significantly slower than a 32-bit read operation. \u572832\u4f4d\u7684\u673a\u5668\u4e2d\uff0c\u4e00\u6b21\u80fd\u591f\u8bfb\u53d6\u7684\u6570\u636e\u7684\u957f\u5ea6\u4e3a32\u4f4d\uff0c\u6240\u4ee5\u8bfb\u53d6\u8d85\u8fc732\u7684\u6570\u636e\u5c31\u9700\u8981\u591a\u6761\u6307\u4ee4\uff0c\u663e\u7136\uff0c\u8fd9\u5c31\u4e0d\u662f\u539f\u5b50\u6027\u7684\u4e86\uff1b \u8054\u60f3\u5230\u4eca\u5929\u5728\u9605\u8bfb\u300a\u8ba1\u7b97\u673a\u7ec4\u6210\u539f\u7406\u300b\u76841.2.4 \u8ba1\u7b97\u673a\u7684\u6027\u80fd\u6307\u6807\uff0c\u6211\u6240\u505a\u7684\u7b14\u8bb0\u5982\u4e0b\uff1a \u6307\u5904\u7406\u673a**\u8fd0\u7b97\u5668**\u4e2d\u4e00\u6b21\u80fd\u591f\u5b8c\u6210\u4e8c\u8fdb\u5236\u6570\u8fd0\u7b97\u7684**\u4f4d\u6570**\uff0c\u598232\u4f4d\uff0c64\u4f4d\uff1b SUMMARY : \u8fd9\u5e94\u8be5\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u6240\u8bf4\u768432\u4f4d\uff0c\u621664\u4f4d\uff1b\u4e00\u6b21\u80fd\u591f\u5b8c\u6210\u4e8c\u8fdb\u5236\u6570\u7684\u8fd0\u7b97\uff0c\u5176\u5b9e\u8574\u542b\u4e2d\uff0cCPU\u4e00\u6b21CPU\u4e00\u6b21\u6027\u80fd\u8bfb\u53d6\u6570\u636e\u7684\u4e8c\u8fdb\u5236\u4f4d\u6570\u3002\u53c2\u89c1 Redis\u5185\u5b58\u7ba1\u7406\u7684\u57fa\u77f3zmallc.c\u6e90\u7801\u89e3\u8bfb\uff08\u4e00\uff09 \uff1b Data alignment: Straighten up and fly right SUMMARY : \u4e0a\u8ff0\u4e00\u6b21\u7684\u542b\u4e49\u662f\u4ec0\u4e48\uff1f\u662f\u6307\u4e00\u4e2a\u6307\u4ee4\u5468\u671f\uff1f \u73b0\u5728\u8054\u7cfb\u5230\u539f\u5b50\u6027\uff0c\u663e\u7136\uff0c\u4e0a\u8ff0\u8fd9\u6bb5\u8bdd\u4e2d\u7684**\u4e00\u6b21**\u7684\u542b\u4e49\u662f\u975e\u5e38\u6df1\u523b\u7684\uff1a\u5b83\u8574\u542b\u7740\u539f\u5b50\u6027\u7684\u4fdd\u8bc1\uff1b \u5176\u5b9e\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u5728\u4e4b\u524d\u5c31\u5df2\u7ecf\u9047\u5230\u8fc7\u7684\uff0c\u8bb0\u5f97\u5f53\u65f6\u9605\u8bfb\u7684\u6587\u7ae0\u662f\uff1a Atomic vs. Non-Atomic Operations \uff0c\u8fd9\u7bc7\u6587\u7ae0\u6211\u5df2\u7ecf\u6536\u5f55\u4e86\uff1b \u7efc\u4e0a\u6240\u8ff0\uff0c\u5176\u5b9e\u6211\u7684\u95ee\u9898\u53ef\u4ee5\u5f52\u7eb3\u4e3a\uff1awhy read 64 bit data in 32 bit is not atomic Google\u4e86\u4e00\u4e0b\uff0c\u53d1\u73b0\u4e86\u4e00\u4e9b\u6709\u4ef7\u503c\u7684\u5185\u5bb9\uff1a How to Customize Serialization in Java Using the Externalizable Interface Are 64 bit operations atomic for a 32 bit app on 64 bit Windows 20190829 epoll_wait \u3001 epoll_pwait \u548c\u4fe1\u53f7\u4e4b\u95f4\u7684\u5173\u7cfb http://man7.org/linux/man-pages/man2/epoll_wait.2.html epoll and nonblocking \u4f7f\u7528epoll\u7684\u65f6\u5019\uff0c\u662f\u5426\u4e00\u5b9a\u8981\u4f7f\u7528nonblocking IO\uff1f 20190905 passing file descriptor between process https://docs.python.org/3.5/library/multiprocessing.html \u5728python\u7684multiprocessing\u6587\u6863\u4e2d\u770b\u5230\u4e86\u5b83\u63d0\u51fa\u7684\u8fd9\u4e2a\u95ee\u9898\uff1a forkserver When the program starts and selects the forkserver start method, a server process is started. From then on, whenever a new process is needed, the parent process connects to the server and requests that it fork a new process. The fork server process is single threaded so it is safe for it to use os.fork(). No unnecessary resources are inherited. Available on Unix platforms which support passing file descriptors over Unix pipes. http://poincare.matf.bg.ac.rs/~ivana/courses/ps/sistemi_knjige/pomocno/apue/APUE/0201433079/ch17lev1sec4.html https://openforums.wordpress.com/2016/08/07/open-file-descriptor-passing-over-unix-domain-sockets/ semaphore tracker process https://docs.python.org/3.5/library/multiprocessing.html Synchronization between processes https://stackoverflow.com/questions/248911/how-do-i-synchronize-two-processes https://en.wikipedia.org/wiki/Semaphore_%28programming%29 http://sce2.umkc.edu/csee/cotterr/cs431_sp13/CS431_Linux_Process_Sync_12_bw.ppt 20190906 https://stackoverflow.com/questions/11129212/tcp-can-two-different-sockets-share-a-port https://lwn.net/Articles/542629/ https://stackoverflow.com/questions/1694144/can-two-applications-listen-to-the-same-port/25033226 20190909 TCP backlog https://stackoverflow.com/questions/36594400/what-is-backlog-in-tcp-connections http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/023/2333/2333s2.html https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html 20190913 atomic & race condition & lock & consistent model \u4e13\u9898 \u4eca\u5929\u5728\u9605\u8bfbredis source code\u7684\u65f6\u5019\uff0c\u603b\u7ed3\u4e86redis\u4e2dsocket file descriptor\u90fd\u662fnon blocking\u7684\uff0c\u7136\u540e\u6211\u5c31\u67e5\u9605APUE\u4e2d\u5173\u4e8e\u6587\u4ef6\u63cf\u8ff0\u7b26\u6807\u5fd7\uff0c\u6587\u4ef6\u6807\u5fd7\u7684\u5185\u5bb9\uff1b\u53c8\u91cd\u65b0\u770b\u4e86\u4e00\u904dAPUE 3.3\u8282\u4e2d\u5173\u4e8eTOCTTOU\u7684\u63cf\u8ff0\uff0c\u4ee5\u53caAPUE 3.11 \u539f\u5b50\u64cd\u4f5c\u7684\u63cf\u8ff0\uff0c\u6211\u624d\u610f\u8bc6\u5230\u539f\u7406linux\u7684system call\u4e5f\u662f\u80fd\u591f\u4fdd\u8bc1atomic\u7684\uff08\u4ece\u5e95\u5c42\u5b9e\u73b0\u6765\u770b\uff0c\u662f\u56e0\u4e3abig kernel lock \uff09\uff1b\u539f\u6765\u6211\u4ec5\u4ec5\u8ba4\u77e5\u5230\u4e00\u4e2ainstruction\u662fatomic\uff0c\u5176\u5b9e\u8fd9\u79cd\u8ba4\u77e5\u662f\u6bd4\u8f83\u5c40\u9650\u7684\uff1b\u8054\u60f3\u5230\u6211\u4e4b\u524d\u603b\u7ed3\u8fc7\u5173\u4e8eatomic\u7684\u5185\u5bb9\uff0c\u5982\u4e0b\uff1a everything\u4e2d\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4\u67e5\u627e\u6240\u6709atomic\u76f8\u5173\u7684\u5185\u5bb9\uff1a nowholeword:c:\\users\\dengkai17334\\appdata\\local\\ynote\\data\\ content:atomic \u73b0\u5728\u662f\u6709\u5fc5\u8981\u6574\u7406\u4e00\u756a\u4e86\u3002 linux system call atomic network data integrity in network \u5728 2.1. Two Types of Internet Sockets \u4e2d\u63d0\u53caTCP\u80fd\u591f\u4fdd\u8bc1 data integrity \uff0c\u53ef\u89c1 data integrity \u5e76\u4e0d\u4ec5\u4ec5\u5c40\u9650\u4e8e\u4e00\u65b9\u9762\uff1b What's the difference between 127.0.0.1 and 0.0.0.0? What's the difference between 127.0.0.1 and 0.0.0.0? interface address \u5728\u5f88\u591a\u5730\u65b9\u90fd\u89c1\u5230\u4e86\u8fd9\u4e2a\u8bcd\uff1a - getaddrinfo(3) - Linux man page \u5b83\u5230\u5e95\u662f\u4ec0\u4e48\u542b\u4e49 stream of bytes and bitstream Bitstream \u5df2\u7ecf\u9605\u8bfb Maximum segment lifetime https://en.wikipedia.org/wiki/Maximum_segment_lifetime 20190909 epoll\u4e2d\u7684file descripor\u662f\u5426\u4e00\u5b9a\u8981\u8bbe\u7f6e\u4e3anon blocking SO_RCVLOWAT and SO_SNDLOWAT \u7684\u503c\u90fd\u662f1\uff0c\u90a3\u4e48\u5982\u4f55\u786e\u5b9amessage boundary\uff1f shell getconf echo \"2^12\" | bc How to check if port is in use on Linux or Unix https://unix.stackexchange.com/a/185767 how to get all threads of a process process https://www.cyberciti.biz/faq/show-all-running-processes-in-linux/ https://unix.stackexchange.com/questions/2107/how-to-suspend-and-resume-processes How to print out a variable in makefile https://stackoverflow.com/questions/16467718/how-to-print-out-a-variable-in-makefile Process control block https://www.tldp.org/LDP/lki/lki-2.html \u4e0a\u9762\u8fd9\u7bc7\u6587\u7ae0\u4e3b\u8981\u8bb2\u8ff0\u7684\u662flinux kernel\u7684\u5b9e\u73b0 How to Find Out Which Windows Process is Using a File user the software:Process Explorer How find out which process is using a file in Linux? fuser file_name what will happen if a process exceed its resource limits \u8bb0\u5f97\u5728redis in action\u8fd9\u672c\u4e66\u4e2d\u6709\u63d0\u53ca\u8fc7\u7c7b\u4f3c\u7684\u95ee\u9898\uff1b C POSIX library https://en.wikipedia.org/wiki/C_POSIX_library http://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html C standard library https://en.wikipedia.org/wiki/C_standard_library process id APUE 4.4 Set-User-ID and Set-Group-ID https://en.wikipedia.org/wiki/User_identifier Time of check to time of use https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use User identifier https://en.wikipedia.org/wiki/User_identifier Secure Programming HOWTO https://dwheeler.com/secure-programs/Secure-Programs-HOWTO/index.html thread-local thread-local\u548creentry\u4e4b\u95f4\u7684\u5173\u7cfb hole in file hole\u5bf9\u6587\u4ef6\u5927\u5c0f\u7684\u5f71\u54cd\uff1b\u4e0a\u5468\u5728\u67e5\u770bhttps://liftoff.github.io/pyminifier/\u6587\u6863\u7684\u65f6\u5019\uff0c\u5176\u4e2d\u6709minifying\u529f\u80fd\uff0c\u662f\u548chole in file\u6709\u5173\u7684\uff1b \u540c\u65f6binary mode\u6765\u4fdd\u5b58\u6587\u4ef6\u4e5f\u80fd\u591f\u964d\u4f4e\u6587\u4ef6\u5927\u5c0f\uff1b linux memory memory usage memory available virtual process space https://www.tutorialspoint.com/where-are-static-variables-stored-in-c-cplusplus https://cs61.seas.harvard.edu/wiki/2016/Kernel2X \u8fd9\u7bc7\u6587\u7ae0\u975e\u5e38\u597d https://www.cs.utexas.edu/~lorenzo/corsi/cs372/06F/hw/3sol.html https://cs.stackexchange.com/questions/56825/how-to-calculate-virtual-address-space-from-page-size-virtual-address-size-and process environment 7.12\u4e0d\u540c\u8bed\u8a00\u7684environment\u662f\u5426\u4e0d\u540c file IO\uff1apython VS linux Python\u4e0eLinux\u7c7b\u4f3c\uff0c\u4e0e\u6587\u4ef6\u76f8\u5173\u7684\u64cd\u4f5c\u90fd\u662f\u4eceopen\u51fd\u6570\u5f00\u59cb\u7684 Fragmentation (computing) https://en.wikipedia.org/wiki/Fragmentation_(computing) page table size https://www.cs.cornell.edu/courses/cs4410/2015su/lectures/lec14-pagetables.html http://www.cs.cornell.edu/courses/cs4410/2016su/slides/lecture11.pdf http://www.cs.cornell.edu/courses/cs4410/2016su/schedule.html Data segment https://en.wikipedia.org/wiki/Data_segment ENOENT Why does ENOENT mean \u201cNo such file or directory\u201d? EACCES cron https://en.wikipedia.org/wiki/Cron https://www.adminschoice.com/crontab-quick-reference \u5728shell\u4e2d\u5220\u9664\u6389\u8fdb\u7a0b\u4f7f\u7528\u7684\u6587\u4ef6 \u4eca\u5929\u5728\u6d4b\u8bd5\u7684\u65f6\u5019\u53d1\u73b0\u4e86\u4e00\u4e2a\u6709\u8da3\u7684\u95ee\u9898\uff1a\u8fdb\u7a0b\u8fd0\u884c\u4e2d\uff0c\u8fd9\u4e2a\u8fdb\u7a0b\u4f1a\u4e0d\u65ad\u5730\u5411\u5176\u65e5\u5fd7\u6587\u4ef6\u4e2d\u5199\u5165\u65e5\u5fd7\uff1b\u7136\u540e\u6211\u5728shell\u4e2d\u5c06\u8fd9\u4e2a\u65e5\u5fd7\u6587\u4ef6\u7ed9\u5220\u9664\u4e86\uff0c\u53d1\u73b0\u8fdb\u7a0b\u5e76\u6ca1\u6709\u53d1\u73b0\u5b83\u7684\u65e5\u5fd7\u6587\u4ef6\u88ab\u5220\u4e86\uff0c\u4e5f\u6ca1\u6709\u51fa\u73b0\u521b\u5efa\u8fd9\u4e2a\u65e5\u5fd7\u6587\u4ef6\uff0c\u7a0b\u5e8f\u4e5f\u6ca1\u6709\u505c\u6b62\u4e0b\u6765\uff1b \u78c1\u76d8\u7a7a\u95f4\u6ee1\u540e\uff0c\u4e5f\u4f1a\u5bfc\u81f4process\u65e0\u6cd5\u5199\u5165\u5230\u6587\u4ef6\u4e2d\uff1b\u4f46\u662f\u5f53\u91ca\u653e\u4e00\u90e8\u5206\u7a7a\u95f4\u540e\uff0c\u53d1\u73b0process\u4ecd\u7136\u4e0d\u4f1a\u5199\u5165\uff0c\u5c31\u50cf\u662f\u653e\u5f03\u4e86\u4e00\u6837\uff1b Segmentation fault hiredis\u4e0d\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\uff0c\u4eca\u5929\u5728\u591a\u7ebf\u7a0b\u73af\u5883\u4e0b\u6d4b\u8bd5\u51fa\u5b83\u4f1a\u5bfc\u81f4process core dump\uff0cdump\u7684\u539f\u56e0\u662f Program terminated with signal 11, Segmentation fault. https://kb.iu.edu/d/aqsj https://en.wikipedia.org/wiki/Segmentation_fault thread unsafe and core dump how to test \u5982\u679c\u662f\u652f\u6301\u7f51\u7edc\uff0c\u9700\u8981\u6d4b\u8bd5\u591a\u4e2aclient\u8fde\u63a5\uff1b \u9700\u8981\u8fdb\u884c\u538b\u529b\u6d4b\u8bd5 \u9700\u8981\u8fdb\u884c\u5e76\u53d1\u6d4b\u8bd5 process and its thread Is there a way to see details of all the threads that a process has in Linux? google:how to get all threads of a process https://www.unix.com/aix/154772-how-list-all-threads-running-process.html http://ask.xmodulo.com/view-threads-process-linux.html how OS know process use a illegal memory location https://en.wikipedia.org/wiki/Memory_protection https://stackoverflow.com/questions/41172563/how-os-catches-illegal-memory-references-at-paging-scheme https://unix.stackexchange.com/questions/511963/how-linux-finds-out-about-illegal-memory-access-error https://www.kernel.org/ https://www.kernel.org/doc/gorman/html/understand/index.html https://www.kernel.org/doc/gorman/ https://www.kernel.org/doc/ dev file https://unix.stackexchange.com/questions/93531/what-is-stored-in-dev-pts-files-and-can-we-open-them Unix memory usage https://utcc.utoronto.ca/~cks/space/blog/linux/LinuxMemoryStats https://utcc.utoronto.ca/~cks/space/blog/unix/UnderstandingRSS https://stackoverflow.com/questions/131303/how-to-measure-actual-memory-usage-of-an-application-or-process https://unix.stackexchange.com/questions/554/how-to-monitor-cpu-memory-usage-of-a-single-process How can I kill a process by name instead of PID? https://stackoverflow.com/questions/160924/how-can-i-kill-a-process-by-name-instead-of-pid http://osxdaily.com/2017/01/12/kill-process-by-name-command-line/ APUE\u7684\u300aUnix-interruption-and-atom\u300b\u8fd8\u6ca1\u6709wanch \u5176\u4e2d\u4e3b\u8981\u8ba8\u8bba\u4e86Atomicity Consistency models \u5728parallel computing\u4e2d\u7684Consistency models\u8fd8\u6ca1\u6709\u5b8c\u6210 https://en.wikipedia.org/wiki/Category:Consistency_models epoll https://en.wikipedia.org/wiki/Epoll youdao Unix-abort init of linux init\u8fdb\u7a0b ch8.2\u4e2d\u6709\u5bf9init\u8fdb\u7a0b\u7684\u4e00\u4e2a\u4ecb\u7ecd ch9.2\u4ecb\u7ecd\u5230\uff0cinit\u4f1a\u8bfb\u53d6\u6587\u4ef6 /etc/ttys how to know what init system linux use https://unix.stackexchange.com/questions/18209/detect-init-system-using-the-shell https://fedoramagazine.org/what-is-an-init-system/ https://en.wikipedia.org/wiki/Init https://en.wikipedia.org/wiki/Systemd Convert between Unix and Windows text files https://kb.iu.edu/d/acux https://stackoverflow.com/questions/16239551/eol-conversion-in-notepad Memory management algorithms https://en.wikipedia.org/wiki/Category:Memory_management_algorithms Slab allocation interrupt in Unix interrupt vector table http://www.cis.upenn.edu/~lee/03cse380/lectures/ln2-process-v4.pdf \u5728 Context switch \u4e2d\u4e5f\u5bf9interrupt\u8fdb\u884c\u4e86\u4ecb\u7ecd signal signal\u4e5f\u662f\u4e00\u79cdinterrupt\uff0c\u6545\u5c06\u5b83\u653e\u5728interrupt\u4e4b\u4e0b Google unix signals and threads https://stackoverflow.com/questions/2575106/posix-threads-and-signals https://en.wikipedia.org/wiki/Signal_(IPC ) Scheduling (computing) https://en.wikipedia.org/wiki/Scheduling_(computing ) thread join and detach wait https://linux.die.net/man/2/waitpid","title":"20190817"},{"location":"TODO/TODO/#20190817","text":"\u4eca\u5929\u5728\u9605\u8bfb\u300a Understanding.The.Linux.kernel.3rd.Edition \u300b\u76846.2.1.2. The jiffies variable\u7ae0\u8282\u7684\u65f6\u5019\uff0c\u5176\u4e2d\u7684\u4e00\u6bb5\u8bdd\u5f15\u8d77\u4e86\u6211\u5bf9\u539f\u5b50\u6027\u7684\u601d\u8003\uff1a You might wonder why jiffies has not been directly declared as a 64-bit unsigned long long integer on the 80 x 86 architecture. The answer is that accesses to 64-bit variables in 32-bit architectures cannot be done atomically . Therefore, every read operation on the whole 64 bits requires some synchronization technique to ensure that the counter is not updated while the two 32-bit half-counters are read; as a consequence, every 64-bit read operation is significantly slower than a 32-bit read operation. \u572832\u4f4d\u7684\u673a\u5668\u4e2d\uff0c\u4e00\u6b21\u80fd\u591f\u8bfb\u53d6\u7684\u6570\u636e\u7684\u957f\u5ea6\u4e3a32\u4f4d\uff0c\u6240\u4ee5\u8bfb\u53d6\u8d85\u8fc732\u7684\u6570\u636e\u5c31\u9700\u8981\u591a\u6761\u6307\u4ee4\uff0c\u663e\u7136\uff0c\u8fd9\u5c31\u4e0d\u662f\u539f\u5b50\u6027\u7684\u4e86\uff1b \u8054\u60f3\u5230\u4eca\u5929\u5728\u9605\u8bfb\u300a\u8ba1\u7b97\u673a\u7ec4\u6210\u539f\u7406\u300b\u76841.2.4 \u8ba1\u7b97\u673a\u7684\u6027\u80fd\u6307\u6807\uff0c\u6211\u6240\u505a\u7684\u7b14\u8bb0\u5982\u4e0b\uff1a \u6307\u5904\u7406\u673a**\u8fd0\u7b97\u5668**\u4e2d\u4e00\u6b21\u80fd\u591f\u5b8c\u6210\u4e8c\u8fdb\u5236\u6570\u8fd0\u7b97\u7684**\u4f4d\u6570**\uff0c\u598232\u4f4d\uff0c64\u4f4d\uff1b SUMMARY : \u8fd9\u5e94\u8be5\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u6240\u8bf4\u768432\u4f4d\uff0c\u621664\u4f4d\uff1b\u4e00\u6b21\u80fd\u591f\u5b8c\u6210\u4e8c\u8fdb\u5236\u6570\u7684\u8fd0\u7b97\uff0c\u5176\u5b9e\u8574\u542b\u4e2d\uff0cCPU\u4e00\u6b21CPU\u4e00\u6b21\u6027\u80fd\u8bfb\u53d6\u6570\u636e\u7684\u4e8c\u8fdb\u5236\u4f4d\u6570\u3002\u53c2\u89c1 Redis\u5185\u5b58\u7ba1\u7406\u7684\u57fa\u77f3zmallc.c\u6e90\u7801\u89e3\u8bfb\uff08\u4e00\uff09 \uff1b Data alignment: Straighten up and fly right SUMMARY : \u4e0a\u8ff0\u4e00\u6b21\u7684\u542b\u4e49\u662f\u4ec0\u4e48\uff1f\u662f\u6307\u4e00\u4e2a\u6307\u4ee4\u5468\u671f\uff1f \u73b0\u5728\u8054\u7cfb\u5230\u539f\u5b50\u6027\uff0c\u663e\u7136\uff0c\u4e0a\u8ff0\u8fd9\u6bb5\u8bdd\u4e2d\u7684**\u4e00\u6b21**\u7684\u542b\u4e49\u662f\u975e\u5e38\u6df1\u523b\u7684\uff1a\u5b83\u8574\u542b\u7740\u539f\u5b50\u6027\u7684\u4fdd\u8bc1\uff1b \u5176\u5b9e\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u5728\u4e4b\u524d\u5c31\u5df2\u7ecf\u9047\u5230\u8fc7\u7684\uff0c\u8bb0\u5f97\u5f53\u65f6\u9605\u8bfb\u7684\u6587\u7ae0\u662f\uff1a Atomic vs. Non-Atomic Operations \uff0c\u8fd9\u7bc7\u6587\u7ae0\u6211\u5df2\u7ecf\u6536\u5f55\u4e86\uff1b \u7efc\u4e0a\u6240\u8ff0\uff0c\u5176\u5b9e\u6211\u7684\u95ee\u9898\u53ef\u4ee5\u5f52\u7eb3\u4e3a\uff1awhy read 64 bit data in 32 bit is not atomic Google\u4e86\u4e00\u4e0b\uff0c\u53d1\u73b0\u4e86\u4e00\u4e9b\u6709\u4ef7\u503c\u7684\u5185\u5bb9\uff1a How to Customize Serialization in Java Using the Externalizable Interface Are 64 bit operations atomic for a 32 bit app on 64 bit Windows","title":"20190817"},{"location":"TODO/TODO/#20190829","text":"","title":"20190829"},{"location":"TODO/TODO/#epoll_wait#epoll_pwait","text":"http://man7.org/linux/man-pages/man2/epoll_wait.2.html","title":"epoll_wait \u3001 epoll_pwait\u548c\u4fe1\u53f7\u4e4b\u95f4\u7684\u5173\u7cfb"},{"location":"TODO/TODO/#epoll#and#nonblocking","text":"\u4f7f\u7528epoll\u7684\u65f6\u5019\uff0c\u662f\u5426\u4e00\u5b9a\u8981\u4f7f\u7528nonblocking IO\uff1f","title":"epoll and nonblocking"},{"location":"TODO/TODO/#20190905","text":"","title":"20190905"},{"location":"TODO/TODO/#passing#file#descriptor#between#process","text":"https://docs.python.org/3.5/library/multiprocessing.html \u5728python\u7684multiprocessing\u6587\u6863\u4e2d\u770b\u5230\u4e86\u5b83\u63d0\u51fa\u7684\u8fd9\u4e2a\u95ee\u9898\uff1a forkserver When the program starts and selects the forkserver start method, a server process is started. From then on, whenever a new process is needed, the parent process connects to the server and requests that it fork a new process. The fork server process is single threaded so it is safe for it to use os.fork(). No unnecessary resources are inherited. Available on Unix platforms which support passing file descriptors over Unix pipes. http://poincare.matf.bg.ac.rs/~ivana/courses/ps/sistemi_knjige/pomocno/apue/APUE/0201433079/ch17lev1sec4.html https://openforums.wordpress.com/2016/08/07/open-file-descriptor-passing-over-unix-domain-sockets/","title":"passing file descriptor between process"},{"location":"TODO/TODO/#semaphore#tracker#process","text":"https://docs.python.org/3.5/library/multiprocessing.html","title":"semaphore tracker process"},{"location":"TODO/TODO/#synchronization#between#processes","text":"https://stackoverflow.com/questions/248911/how-do-i-synchronize-two-processes https://en.wikipedia.org/wiki/Semaphore_%28programming%29 http://sce2.umkc.edu/csee/cotterr/cs431_sp13/CS431_Linux_Process_Sync_12_bw.ppt","title":"Synchronization between processes"},{"location":"TODO/TODO/#20190906","text":"https://stackoverflow.com/questions/11129212/tcp-can-two-different-sockets-share-a-port https://lwn.net/Articles/542629/ https://stackoverflow.com/questions/1694144/can-two-applications-listen-to-the-same-port/25033226","title":"20190906"},{"location":"TODO/TODO/#20190909","text":"","title":"20190909"},{"location":"TODO/TODO/#tcp#backlog","text":"https://stackoverflow.com/questions/36594400/what-is-backlog-in-tcp-connections http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/023/2333/2333s2.html https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html","title":"TCP backlog"},{"location":"TODO/TODO/#20190913","text":"","title":"20190913"},{"location":"TODO/TODO/#atomic#race#condition#lock#consistent#model","text":"\u4eca\u5929\u5728\u9605\u8bfbredis source code\u7684\u65f6\u5019\uff0c\u603b\u7ed3\u4e86redis\u4e2dsocket file descriptor\u90fd\u662fnon blocking\u7684\uff0c\u7136\u540e\u6211\u5c31\u67e5\u9605APUE\u4e2d\u5173\u4e8e\u6587\u4ef6\u63cf\u8ff0\u7b26\u6807\u5fd7\uff0c\u6587\u4ef6\u6807\u5fd7\u7684\u5185\u5bb9\uff1b\u53c8\u91cd\u65b0\u770b\u4e86\u4e00\u904dAPUE 3.3\u8282\u4e2d\u5173\u4e8eTOCTTOU\u7684\u63cf\u8ff0\uff0c\u4ee5\u53caAPUE 3.11 \u539f\u5b50\u64cd\u4f5c\u7684\u63cf\u8ff0\uff0c\u6211\u624d\u610f\u8bc6\u5230\u539f\u7406linux\u7684system call\u4e5f\u662f\u80fd\u591f\u4fdd\u8bc1atomic\u7684\uff08\u4ece\u5e95\u5c42\u5b9e\u73b0\u6765\u770b\uff0c\u662f\u56e0\u4e3abig kernel lock \uff09\uff1b\u539f\u6765\u6211\u4ec5\u4ec5\u8ba4\u77e5\u5230\u4e00\u4e2ainstruction\u662fatomic\uff0c\u5176\u5b9e\u8fd9\u79cd\u8ba4\u77e5\u662f\u6bd4\u8f83\u5c40\u9650\u7684\uff1b\u8054\u60f3\u5230\u6211\u4e4b\u524d\u603b\u7ed3\u8fc7\u5173\u4e8eatomic\u7684\u5185\u5bb9\uff0c\u5982\u4e0b\uff1a everything\u4e2d\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4\u67e5\u627e\u6240\u6709atomic\u76f8\u5173\u7684\u5185\u5bb9\uff1a nowholeword:c:\\users\\dengkai17334\\appdata\\local\\ynote\\data\\ content:atomic \u73b0\u5728\u662f\u6709\u5fc5\u8981\u6574\u7406\u4e00\u756a\u4e86\u3002","title":"atomic &amp; race condition &amp; lock &amp; consistent model \u4e13\u9898"},{"location":"TODO/TODO/#linux#system#call#atomic","text":"","title":"linux system call atomic"},{"location":"TODO/TODO/#network","text":"","title":"network"},{"location":"TODO/TODO/#data#integrity#in#network","text":"\u5728 2.1. Two Types of Internet Sockets \u4e2d\u63d0\u53caTCP\u80fd\u591f\u4fdd\u8bc1 data integrity \uff0c\u53ef\u89c1 data integrity \u5e76\u4e0d\u4ec5\u4ec5\u5c40\u9650\u4e8e\u4e00\u65b9\u9762\uff1b","title":"data integrity in network"},{"location":"TODO/TODO/#whats#the#difference#between#127001#and#0000","text":"What's the difference between 127.0.0.1 and 0.0.0.0?","title":"What's the difference between 127.0.0.1 and 0.0.0.0?"},{"location":"TODO/TODO/#interface#address","text":"\u5728\u5f88\u591a\u5730\u65b9\u90fd\u89c1\u5230\u4e86\u8fd9\u4e2a\u8bcd\uff1a","title":"interface address"},{"location":"TODO/TODO/#-#getaddrinfo3#-#linux#man#page","text":"\u5b83\u5230\u5e95\u662f\u4ec0\u4e48\u542b\u4e49","title":"- getaddrinfo(3) - Linux man page"},{"location":"TODO/TODO/#stream#of#bytes#and#bitstream","text":"Bitstream \u5df2\u7ecf\u9605\u8bfb","title":"stream of bytes and bitstream"},{"location":"TODO/TODO/#maximum#segment#lifetime","text":"https://en.wikipedia.org/wiki/Maximum_segment_lifetime","title":"Maximum segment lifetime"},{"location":"TODO/TODO/#20190909_1","text":"epoll\u4e2d\u7684file descripor\u662f\u5426\u4e00\u5b9a\u8981\u8bbe\u7f6e\u4e3anon blocking SO_RCVLOWAT and SO_SNDLOWAT \u7684\u503c\u90fd\u662f1\uff0c\u90a3\u4e48\u5982\u4f55\u786e\u5b9amessage boundary\uff1f","title":"20190909"},{"location":"TODO/TODO/#shell","text":"getconf echo \"2^12\" | bc How to check if port is in use on Linux or Unix https://unix.stackexchange.com/a/185767 how to get all threads of a process","title":"shell"},{"location":"TODO/TODO/#process","text":"https://www.cyberciti.biz/faq/show-all-running-processes-in-linux/ https://unix.stackexchange.com/questions/2107/how-to-suspend-and-resume-processes","title":"process"},{"location":"TODO/TODO/#how#to#print#out#a#variable#in#makefile","text":"https://stackoverflow.com/questions/16467718/how-to-print-out-a-variable-in-makefile","title":"How to print out a variable in makefile"},{"location":"TODO/TODO/#process#control#block","text":"https://www.tldp.org/LDP/lki/lki-2.html \u4e0a\u9762\u8fd9\u7bc7\u6587\u7ae0\u4e3b\u8981\u8bb2\u8ff0\u7684\u662flinux kernel\u7684\u5b9e\u73b0","title":"Process control block"},{"location":"TODO/TODO/#how#to#find#out#which#windows#process#is#using#a#file","text":"user the software:Process Explorer","title":"How to Find Out Which Windows Process is Using a File"},{"location":"TODO/TODO/#how#find#out#which#process#is#using#a#file#in#linux","text":"fuser file_name","title":"How find out which process is using a file in Linux?"},{"location":"TODO/TODO/#what#will#happen#if#a#process#exceed#its#resource#limits","text":"\u8bb0\u5f97\u5728redis in action\u8fd9\u672c\u4e66\u4e2d\u6709\u63d0\u53ca\u8fc7\u7c7b\u4f3c\u7684\u95ee\u9898\uff1b","title":"what will happen if a process exceed its resource limits"},{"location":"TODO/TODO/#c#posix#library","text":"https://en.wikipedia.org/wiki/C_POSIX_library http://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html","title":"C POSIX library"},{"location":"TODO/TODO/#c#standard#library","text":"https://en.wikipedia.org/wiki/C_standard_library","title":"C standard library"},{"location":"TODO/TODO/#process#id","text":"APUE 4.4 Set-User-ID and Set-Group-ID https://en.wikipedia.org/wiki/User_identifier","title":"process id"},{"location":"TODO/TODO/#time#of#check#to#time#of#use","text":"https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use","title":"Time of check to time of use"},{"location":"TODO/TODO/#user#identifier","text":"https://en.wikipedia.org/wiki/User_identifier","title":"User identifier"},{"location":"TODO/TODO/#secure#programming#howto","text":"https://dwheeler.com/secure-programs/Secure-Programs-HOWTO/index.html","title":"Secure Programming HOWTO"},{"location":"TODO/TODO/#thread-local","text":"thread-local\u548creentry\u4e4b\u95f4\u7684\u5173\u7cfb","title":"thread-local"},{"location":"TODO/TODO/#hole#in#file","text":"hole\u5bf9\u6587\u4ef6\u5927\u5c0f\u7684\u5f71\u54cd\uff1b\u4e0a\u5468\u5728\u67e5\u770bhttps://liftoff.github.io/pyminifier/\u6587\u6863\u7684\u65f6\u5019\uff0c\u5176\u4e2d\u6709minifying\u529f\u80fd\uff0c\u662f\u548chole in file\u6709\u5173\u7684\uff1b \u540c\u65f6binary mode\u6765\u4fdd\u5b58\u6587\u4ef6\u4e5f\u80fd\u591f\u964d\u4f4e\u6587\u4ef6\u5927\u5c0f\uff1b","title":"hole in file"},{"location":"TODO/TODO/#linux#memory","text":"memory usage memory available","title":"linux memory"},{"location":"TODO/TODO/#virtual#process#space","text":"https://www.tutorialspoint.com/where-are-static-variables-stored-in-c-cplusplus https://cs61.seas.harvard.edu/wiki/2016/Kernel2X \u8fd9\u7bc7\u6587\u7ae0\u975e\u5e38\u597d https://www.cs.utexas.edu/~lorenzo/corsi/cs372/06F/hw/3sol.html https://cs.stackexchange.com/questions/56825/how-to-calculate-virtual-address-space-from-page-size-virtual-address-size-and","title":"virtual process space"},{"location":"TODO/TODO/#process#environment","text":"7.12\u4e0d\u540c\u8bed\u8a00\u7684environment\u662f\u5426\u4e0d\u540c","title":"process environment"},{"location":"TODO/TODO/#file#iopython#vs#linux","text":"Python\u4e0eLinux\u7c7b\u4f3c\uff0c\u4e0e\u6587\u4ef6\u76f8\u5173\u7684\u64cd\u4f5c\u90fd\u662f\u4eceopen\u51fd\u6570\u5f00\u59cb\u7684","title":"file IO\uff1apython VS linux"},{"location":"TODO/TODO/#fragmentation#computing","text":"https://en.wikipedia.org/wiki/Fragmentation_(computing)","title":"Fragmentation (computing)"},{"location":"TODO/TODO/#page#table#size","text":"https://www.cs.cornell.edu/courses/cs4410/2015su/lectures/lec14-pagetables.html http://www.cs.cornell.edu/courses/cs4410/2016su/slides/lecture11.pdf http://www.cs.cornell.edu/courses/cs4410/2016su/schedule.html","title":"page table size"},{"location":"TODO/TODO/#data#segment","text":"https://en.wikipedia.org/wiki/Data_segment","title":"Data segment"},{"location":"TODO/TODO/#enoent","text":"Why does ENOENT mean \u201cNo such file or directory\u201d?","title":"ENOENT"},{"location":"TODO/TODO/#eacces","text":"","title":"EACCES"},{"location":"TODO/TODO/#cron","text":"https://en.wikipedia.org/wiki/Cron https://www.adminschoice.com/crontab-quick-reference","title":"cron"},{"location":"TODO/TODO/#shell_1","text":"\u4eca\u5929\u5728\u6d4b\u8bd5\u7684\u65f6\u5019\u53d1\u73b0\u4e86\u4e00\u4e2a\u6709\u8da3\u7684\u95ee\u9898\uff1a\u8fdb\u7a0b\u8fd0\u884c\u4e2d\uff0c\u8fd9\u4e2a\u8fdb\u7a0b\u4f1a\u4e0d\u65ad\u5730\u5411\u5176\u65e5\u5fd7\u6587\u4ef6\u4e2d\u5199\u5165\u65e5\u5fd7\uff1b\u7136\u540e\u6211\u5728shell\u4e2d\u5c06\u8fd9\u4e2a\u65e5\u5fd7\u6587\u4ef6\u7ed9\u5220\u9664\u4e86\uff0c\u53d1\u73b0\u8fdb\u7a0b\u5e76\u6ca1\u6709\u53d1\u73b0\u5b83\u7684\u65e5\u5fd7\u6587\u4ef6\u88ab\u5220\u4e86\uff0c\u4e5f\u6ca1\u6709\u51fa\u73b0\u521b\u5efa\u8fd9\u4e2a\u65e5\u5fd7\u6587\u4ef6\uff0c\u7a0b\u5e8f\u4e5f\u6ca1\u6709\u505c\u6b62\u4e0b\u6765\uff1b \u78c1\u76d8\u7a7a\u95f4\u6ee1\u540e\uff0c\u4e5f\u4f1a\u5bfc\u81f4process\u65e0\u6cd5\u5199\u5165\u5230\u6587\u4ef6\u4e2d\uff1b\u4f46\u662f\u5f53\u91ca\u653e\u4e00\u90e8\u5206\u7a7a\u95f4\u540e\uff0c\u53d1\u73b0process\u4ecd\u7136\u4e0d\u4f1a\u5199\u5165\uff0c\u5c31\u50cf\u662f\u653e\u5f03\u4e86\u4e00\u6837\uff1b","title":"\u5728shell\u4e2d\u5220\u9664\u6389\u8fdb\u7a0b\u4f7f\u7528\u7684\u6587\u4ef6"},{"location":"TODO/TODO/#segmentation#fault","text":"hiredis\u4e0d\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\uff0c\u4eca\u5929\u5728\u591a\u7ebf\u7a0b\u73af\u5883\u4e0b\u6d4b\u8bd5\u51fa\u5b83\u4f1a\u5bfc\u81f4process core dump\uff0cdump\u7684\u539f\u56e0\u662f Program terminated with signal 11, Segmentation fault. https://kb.iu.edu/d/aqsj https://en.wikipedia.org/wiki/Segmentation_fault","title":"Segmentation fault"},{"location":"TODO/TODO/#thread#unsafe#and#core#dump","text":"","title":"thread unsafe and core dump"},{"location":"TODO/TODO/#how#to#test","text":"\u5982\u679c\u662f\u652f\u6301\u7f51\u7edc\uff0c\u9700\u8981\u6d4b\u8bd5\u591a\u4e2aclient\u8fde\u63a5\uff1b \u9700\u8981\u8fdb\u884c\u538b\u529b\u6d4b\u8bd5 \u9700\u8981\u8fdb\u884c\u5e76\u53d1\u6d4b\u8bd5","title":"how to test"},{"location":"TODO/TODO/#process#and#its#thread","text":"Is there a way to see details of all the threads that a process has in Linux? google:how to get all threads of a process https://www.unix.com/aix/154772-how-list-all-threads-running-process.html http://ask.xmodulo.com/view-threads-process-linux.html","title":"process and its thread"},{"location":"TODO/TODO/#how#os#know#process#use#a#illegal#memory#location","text":"https://en.wikipedia.org/wiki/Memory_protection https://stackoverflow.com/questions/41172563/how-os-catches-illegal-memory-references-at-paging-scheme https://unix.stackexchange.com/questions/511963/how-linux-finds-out-about-illegal-memory-access-error https://www.kernel.org/ https://www.kernel.org/doc/gorman/html/understand/index.html https://www.kernel.org/doc/gorman/ https://www.kernel.org/doc/","title":"how OS know process use a illegal memory location"},{"location":"TODO/TODO/#dev#file","text":"https://unix.stackexchange.com/questions/93531/what-is-stored-in-dev-pts-files-and-can-we-open-them","title":"dev file"},{"location":"TODO/TODO/#unix#memory#usage","text":"https://utcc.utoronto.ca/~cks/space/blog/linux/LinuxMemoryStats https://utcc.utoronto.ca/~cks/space/blog/unix/UnderstandingRSS https://stackoverflow.com/questions/131303/how-to-measure-actual-memory-usage-of-an-application-or-process https://unix.stackexchange.com/questions/554/how-to-monitor-cpu-memory-usage-of-a-single-process","title":"Unix memory usage"},{"location":"TODO/TODO/#how#can#i#kill#a#process#by#name#instead#of#pid","text":"https://stackoverflow.com/questions/160924/how-can-i-kill-a-process-by-name-instead-of-pid http://osxdaily.com/2017/01/12/kill-process-by-name-command-line/","title":"How can I kill a process by name instead of PID?"},{"location":"TODO/TODO/#apueunix-interruption-and-atomwanch","text":"\u5176\u4e2d\u4e3b\u8981\u8ba8\u8bba\u4e86Atomicity","title":"APUE\u7684\u300aUnix-interruption-and-atom\u300b\u8fd8\u6ca1\u6709wanch"},{"location":"TODO/TODO/#consistency#models","text":"\u5728parallel computing\u4e2d\u7684Consistency models\u8fd8\u6ca1\u6709\u5b8c\u6210 https://en.wikipedia.org/wiki/Category:Consistency_models","title":"Consistency models"},{"location":"TODO/TODO/#epoll","text":"https://en.wikipedia.org/wiki/Epoll","title":"epoll"},{"location":"TODO/TODO/#youdao#unix-abort","text":"","title":"youdao Unix-abort"},{"location":"TODO/TODO/#init#of#linux","text":"","title":"init of linux"},{"location":"TODO/TODO/#init","text":"ch8.2\u4e2d\u6709\u5bf9init\u8fdb\u7a0b\u7684\u4e00\u4e2a\u4ecb\u7ecd ch9.2\u4ecb\u7ecd\u5230\uff0cinit\u4f1a\u8bfb\u53d6\u6587\u4ef6 /etc/ttys how to know what init system linux use https://unix.stackexchange.com/questions/18209/detect-init-system-using-the-shell https://fedoramagazine.org/what-is-an-init-system/ https://en.wikipedia.org/wiki/Init https://en.wikipedia.org/wiki/Systemd","title":"init\u8fdb\u7a0b"},{"location":"TODO/TODO/#convert#between#unix#and#windows#text#files","text":"https://kb.iu.edu/d/acux https://stackoverflow.com/questions/16239551/eol-conversion-in-notepad","title":"Convert between Unix and Windows text files"},{"location":"TODO/TODO/#memory#management#algorithms","text":"https://en.wikipedia.org/wiki/Category:Memory_management_algorithms Slab allocation","title":"Memory management algorithms"},{"location":"TODO/TODO/#interrupt#in#unix","text":"interrupt vector table http://www.cis.upenn.edu/~lee/03cse380/lectures/ln2-process-v4.pdf \u5728 Context switch \u4e2d\u4e5f\u5bf9interrupt\u8fdb\u884c\u4e86\u4ecb\u7ecd","title":"interrupt in Unix"},{"location":"TODO/TODO/#signal","text":"signal\u4e5f\u662f\u4e00\u79cdinterrupt\uff0c\u6545\u5c06\u5b83\u653e\u5728interrupt\u4e4b\u4e0b","title":"signal"},{"location":"TODO/TODO/#google#unix#signals#and#threads","text":"https://stackoverflow.com/questions/2575106/posix-threads-and-signals https://en.wikipedia.org/wiki/Signal_(IPC )","title":"Google unix signals and threads"},{"location":"TODO/TODO/#scheduling#computing","text":"https://en.wikipedia.org/wiki/Scheduling_(computing )","title":"Scheduling (computing)"},{"location":"TODO/TODO/#thread#join#and#detach","text":"","title":"thread join and detach"},{"location":"TODO/TODO/#wait","text":"https://linux.die.net/man/2/waitpid","title":"wait"},{"location":"Unix-like-OS-mind-map/","text":"Unix-like-OS-mind-map Inspired by this post ,I decide to use mind map to organize the knowledge of Unix-like operating system .What I use is XMind 8 Update 8","title":"Unix-like-OS-mind-map"},{"location":"Unix-like-OS-mind-map/#unix-like-os-mind-map","text":"Inspired by this post ,I decide to use mind map to organize the knowledge of Unix-like operating system .What I use is XMind 8 Update 8","title":"Unix-like-OS-mind-map"},{"location":"Unix-standardization-and-implementation/The-open-group/","text":"The open group \u5b98\u65b9\u7ad9\u70b9\uff1a the open group http://pubs.opengroup.org/onlinepubs/9699919799/n","title":"The-open-group"},{"location":"Unix-standardization-and-implementation/The-open-group/#the#open#group","text":"\u5b98\u65b9\u7ad9\u70b9\uff1a the open group http://pubs.opengroup.org/onlinepubs/9699919799/n","title":"The open group"},{"location":"Unix-standardization-and-implementation/Unix-%26-Unix-like-%26-Linux/","text":"Unix & Unix like & Linux \u672c\u8282\u533a\u5206\u8fd9\u51e0\u4e2a\u6982\u5ff5\uff0c\u5e76\u8bb0\u5f55\u4e00\u4e9b\u6709\u7528\u8d44\u6e90\uff1a Unix wikipedia Unix Unix-like wikipedia Unix-like Linux \u5982\u4e0b\u662f\u5173\u4e8elinux OS\u7684\u4e00\u4e9b\u8d44\u6e90\uff1a wikipedia Linux NOTE: linux\u662fUnix-like wikipedia Linux kernel The Linux Kernel Archives The Linux Kernel documentation The Linux man-pages project LWN.net","title":"Unix-&-Unix-like-&-Linux"},{"location":"Unix-standardization-and-implementation/Unix-%26-Unix-like-%26-Linux/#unix#unix#like#linux","text":"\u672c\u8282\u533a\u5206\u8fd9\u51e0\u4e2a\u6982\u5ff5\uff0c\u5e76\u8bb0\u5f55\u4e00\u4e9b\u6709\u7528\u8d44\u6e90\uff1a","title":"Unix &amp; Unix like &amp; Linux"},{"location":"Unix-standardization-and-implementation/Unix-%26-Unix-like-%26-Linux/#unix","text":"wikipedia Unix","title":"Unix"},{"location":"Unix-standardization-and-implementation/Unix-%26-Unix-like-%26-Linux/#unix-like","text":"wikipedia Unix-like","title":"Unix-like"},{"location":"Unix-standardization-and-implementation/Unix-%26-Unix-like-%26-Linux/#linux","text":"\u5982\u4e0b\u662f\u5173\u4e8elinux OS\u7684\u4e00\u4e9b\u8d44\u6e90\uff1a wikipedia Linux NOTE: linux\u662fUnix-like wikipedia Linux kernel The Linux Kernel Archives The Linux Kernel documentation The Linux man-pages project LWN.net","title":"Linux"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/","text":"UNIX standardization and implementations \u672c\u8282\u68b3\u7406 Unix operating system \u548c Unix-like operating system \u4e4b\u95f4\u7684\u6807\u51c6\u3001\u6f14\u8fdb\u3001\u5173\u7cfb\u7b49\u3002\u5bf9\u4e8e\u8fd9\u4e9b\u6807\u51c6\u6709\u5fc5\u8981\u4e86\u89e3\u4e00\u4e0b\uff0c\u56e0\u4e3a\u5728\u5f88\u591a\u4e66\u7c4d\uff0c\u6587\u7ae0\u4e2d\u90fd\u4f1a\u89c1\u5230\u8fd9\u4e9b\u6807\u51c6\u3002\u672c\u8282\u7684\u5185\u5bb9\u4e3b\u8981\u6e90\u81ea\u4e8e Advanced Programming in the UNIX\u00ae Environment, Third Edition \u7684chapter 2 UNIX Standardization and Implementations Introduction Much work has gone into standardizing the UNIX programming environment and the C programming language. In this chapter we first look at the various standardization efforts that have been under way over the past two and a half decades. We then discuss the effects of these UNIX programming standards on the operating system implementations that are described in this book. An important part of all the standardization efforts is the specification of various limits that each implementation must define, so we look at these limits and the various ways to determine their values. UNIX Standardization ISO C NOTE: \u672c\u8282\u4ecb\u7ecd\u4e86ISO C standard\u7684\u6f14\u8fdb\u8fc7\u7a0b\uff0c\u8fd9\u4e9b\u5386\u53f2\u53ef\u4ee5pass\u6389\u3002\u4e0b\u9762\u5173\u4e8eISO C standard\u7684\u4e00\u4e9b\u7f51\u7ad9\u94fe\u63a5\uff1a wikipedia C (programming language) The Standard wikipedia ANSI C This standard defines not only the syntax and semantics of the programming language but also a standard library . The ISO C library can be divided into 24 areas, based on the headers defined by the standard (see Figure 2.1). The POSIX.1 standard includes these headers, as well as others. As Figure 2.1 shows, all of these headers are supported by the four implementations (FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10) that are described later in this chapter. NOTE: **POSIX.1 standard**\u662fISO C standard\u7684\u8d85\u96c6\u3002 The ISO C headers depend on which version of the C compiler is used with the operating system. FreeBSD 8.0 ships with version 4.2.1 of gcc, Solaris 10 ships with version 3.4.3 of gcc (in addition to its own C compiler in Sun Studio), Ubuntu 12.04 (Linux 3.2.0) ships with version 4.6.3 of gcc, and Mac OS X 10.6.8 ships with both versions 4.0.1 and 4.2.1 of gcc. Headers defined by the ISO C standard C standard library IEEE POSIX NOTE: \u672c\u8282\u4ecb\u7ecd\u4e86IEEE POSIX standard\u7684\u6f14\u8fdb\u8fc7\u7a0b\uff0c\u8fd9\u4e9b\u5386\u53f2\u53ef\u4ee5pass\u6389\u3002\u4e0b\u9762\u5173\u4e8eIEEE POSIX\u7684\u4e00\u4e9b\u7f51\u7ad9\u94fe\u63a5\uff1a wikipedia POSIX POSIX official site POSIX is a family of standards initially developed by the IEEE (Institute of Electrical and Electronics Engineers). POSIX stands for Portable Operating System Interface. It originally referred only to the IEEE Standard 1003.1-1988 \u2014 the operating system interface \u2014 but was later extended to include many of the standards and draft standards with the 1003 designation, including the shell and utilities (1003.2). Because the 1003.1 standard specifies an interface and not an implementation , no distinction is made between system calls and library functions . All the routines in the standard are called functions . POSIX Threads POSIX Threads The Open Group Base Specifications Issue 7, IEEE Std 1003.1 C POSIX library header files C POSIX library C POSIX library header files Official List of headers in the POSIX library on opengroup.org The Single UNIX Specification The Single UNIX Specification, a superset of the POSIX.1 standard, specifies additional interfaces that extend the functionality provided by the POSIX.1 specification. POSIX.1 is equivalent to the Base Specifications portion of the Single UNIX Specification. NOTE: wikipedia The Open Group wikipedia Single UNIX Specification The X/Open System Interfaces (XSI) option in POSIX.1 describes optional interfaces and defines which optional portions of POSIX.1 must be supported for an implementation to be deemed XSI conforming . These include file synchronization, thread stack address and size attributes, thread process-shared synchronization, and the _XOPEN_UNIX symbolic constant (marked \u2018\u2018SUS mandatory\u2019\u2019 in Figure 2.5). Only XSI-conforming implementations can be called UNIX systems . NOTE: X/Open The Single UNIX Specification is a publication of The Open Group, which was formed in 1996 as a merger of X/Open and the Open Software Foundation (OSF), both industry consortia. X/Open used to publish the X/Open Portability Guide, which adopted specific standards and filled in the gaps where functionality was missing. The goal of these guides was to improve application portability beyond what was possible by merely conforming to published standards. NOTE: \u4e0b\u9762\u89e3\u91ca\u4e00\u4e9b\u7b80\u79f0\u7684\u542b\u4e49 SUSv3\uff1a the third version of the Single UNIX Specification SUSv4\uff1a the forth version of the Single UNIX Specification UNIX System Implementations The previous section described ISO C, IEEE POSIX, and the Single UNIX Specification \u2014 three standards originally created by independent organizations. Standards, however, are interface specifications. How do these standards relate to the real world? These standards are taken by vendors and turned into actual implementations. In this book, we are interested in both these standards and their implementation. UNIX System V Release 4 UNIX System V Release 4 (SVR4) was a product of AT&T\u2019s UNIX System Laboratories (USL, formerly AT&T\u2019s UNIX Software Operation). SVR4 merged functionality from AT&T UNIX System V Release 3.2 (SVR3.2), the SunOS operating system from Sun Microsystems, the 4.3BSD release from the University of California, and the Xenix system from Microsoft into one coherent operating system. (Xenix was originally developed from Version 7, with many features later taken from System V.) The SVR4 source code was released in late 1989, with the first end-user copies becoming available during 1990. SVR4 conformed to both the POSIX 1003.1 standard and the X/Open Portability Guide, Issue 3 (XPG3). 4.4BSD FreeBSD Linux Mac OS X Solaris Relationship of Standards and Implementations The standards that we\u2019ve mentioned define a subset of any actual system. The focus of this book is on four real systems: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris Although only Mac OS X and Solaris can call themselves UNIX systems, all four provide a similar programming environment. Because all four are POSIX compliant to varying degrees, we will also concentrate on the features required by the POSIX.1 standard, noting any differences between POSIX and the actual implementations of these four systems. Those features and routines that are specific to only a particular implementation are clearly marked. We\u2019ll also note any features that are required on UNIX systems but are optional on other POSIX-conforming systems. Be aware that the implementations provide backward compatibility for features in earlier releases, such as SVR3.2 and 4.3BSD. For example, Solaris supports both the POSIX.1 specification for nonblocking I/O (O_NONBLOCK) and the traditional System V method ( O_NDELAY ). In this text, we\u2019ll use only the POSIX.1 feature, although we\u2019ll mention the nonstandard feature that it replaces. Similarly, both SVR3.2 and 4.3BSD provided reliable signals in a way that differs from the POSIX.1 standard. In Chapter 10 we describe only the POSIX.1 signal mechanism. man STANDARDS(7) NOTE: \u8fd9\u662flinux\u6587\u6863\u4e2d\u5bf9standard\u7684\u4ecb\u7ecd\u3002","title":"Unix-standardization-and-implementation"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#unix#standardization#and#implementations","text":"\u672c\u8282\u68b3\u7406 Unix operating system \u548c Unix-like operating system \u4e4b\u95f4\u7684\u6807\u51c6\u3001\u6f14\u8fdb\u3001\u5173\u7cfb\u7b49\u3002\u5bf9\u4e8e\u8fd9\u4e9b\u6807\u51c6\u6709\u5fc5\u8981\u4e86\u89e3\u4e00\u4e0b\uff0c\u56e0\u4e3a\u5728\u5f88\u591a\u4e66\u7c4d\uff0c\u6587\u7ae0\u4e2d\u90fd\u4f1a\u89c1\u5230\u8fd9\u4e9b\u6807\u51c6\u3002\u672c\u8282\u7684\u5185\u5bb9\u4e3b\u8981\u6e90\u81ea\u4e8e Advanced Programming in the UNIX\u00ae Environment, Third Edition \u7684chapter 2 UNIX Standardization and Implementations","title":"UNIX standardization and implementations"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#introduction","text":"Much work has gone into standardizing the UNIX programming environment and the C programming language. In this chapter we first look at the various standardization efforts that have been under way over the past two and a half decades. We then discuss the effects of these UNIX programming standards on the operating system implementations that are described in this book. An important part of all the standardization efforts is the specification of various limits that each implementation must define, so we look at these limits and the various ways to determine their values.","title":"Introduction"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#unix#standardization","text":"","title":"UNIX Standardization"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#iso#c","text":"NOTE: \u672c\u8282\u4ecb\u7ecd\u4e86ISO C standard\u7684\u6f14\u8fdb\u8fc7\u7a0b\uff0c\u8fd9\u4e9b\u5386\u53f2\u53ef\u4ee5pass\u6389\u3002\u4e0b\u9762\u5173\u4e8eISO C standard\u7684\u4e00\u4e9b\u7f51\u7ad9\u94fe\u63a5\uff1a wikipedia C (programming language) The Standard wikipedia ANSI C This standard defines not only the syntax and semantics of the programming language but also a standard library . The ISO C library can be divided into 24 areas, based on the headers defined by the standard (see Figure 2.1). The POSIX.1 standard includes these headers, as well as others. As Figure 2.1 shows, all of these headers are supported by the four implementations (FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10) that are described later in this chapter. NOTE: **POSIX.1 standard**\u662fISO C standard\u7684\u8d85\u96c6\u3002 The ISO C headers depend on which version of the C compiler is used with the operating system. FreeBSD 8.0 ships with version 4.2.1 of gcc, Solaris 10 ships with version 3.4.3 of gcc (in addition to its own C compiler in Sun Studio), Ubuntu 12.04 (Linux 3.2.0) ships with version 4.6.3 of gcc, and Mac OS X 10.6.8 ships with both versions 4.0.1 and 4.2.1 of gcc.","title":"ISO C"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#headers#defined#by#the#iso#c#standard","text":"C standard library","title":"Headers defined by the ISO C standard"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#ieee#posix","text":"NOTE: \u672c\u8282\u4ecb\u7ecd\u4e86IEEE POSIX standard\u7684\u6f14\u8fdb\u8fc7\u7a0b\uff0c\u8fd9\u4e9b\u5386\u53f2\u53ef\u4ee5pass\u6389\u3002\u4e0b\u9762\u5173\u4e8eIEEE POSIX\u7684\u4e00\u4e9b\u7f51\u7ad9\u94fe\u63a5\uff1a wikipedia POSIX POSIX official site POSIX is a family of standards initially developed by the IEEE (Institute of Electrical and Electronics Engineers). POSIX stands for Portable Operating System Interface. It originally referred only to the IEEE Standard 1003.1-1988 \u2014 the operating system interface \u2014 but was later extended to include many of the standards and draft standards with the 1003 designation, including the shell and utilities (1003.2). Because the 1003.1 standard specifies an interface and not an implementation , no distinction is made between system calls and library functions . All the routines in the standard are called functions .","title":"IEEE POSIX"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#posix#threads","text":"POSIX Threads The Open Group Base Specifications Issue 7, IEEE Std 1003.1","title":"POSIX Threads"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#c#posix#library#header#files","text":"C POSIX library C POSIX library header files Official List of headers in the POSIX library on opengroup.org","title":"C POSIX library header files"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#the#single#unix#specification","text":"The Single UNIX Specification, a superset of the POSIX.1 standard, specifies additional interfaces that extend the functionality provided by the POSIX.1 specification. POSIX.1 is equivalent to the Base Specifications portion of the Single UNIX Specification. NOTE: wikipedia The Open Group wikipedia Single UNIX Specification The X/Open System Interfaces (XSI) option in POSIX.1 describes optional interfaces and defines which optional portions of POSIX.1 must be supported for an implementation to be deemed XSI conforming . These include file synchronization, thread stack address and size attributes, thread process-shared synchronization, and the _XOPEN_UNIX symbolic constant (marked \u2018\u2018SUS mandatory\u2019\u2019 in Figure 2.5). Only XSI-conforming implementations can be called UNIX systems . NOTE: X/Open The Single UNIX Specification is a publication of The Open Group, which was formed in 1996 as a merger of X/Open and the Open Software Foundation (OSF), both industry consortia. X/Open used to publish the X/Open Portability Guide, which adopted specific standards and filled in the gaps where functionality was missing. The goal of these guides was to improve application portability beyond what was possible by merely conforming to published standards. NOTE: \u4e0b\u9762\u89e3\u91ca\u4e00\u4e9b\u7b80\u79f0\u7684\u542b\u4e49 SUSv3\uff1a the third version of the Single UNIX Specification SUSv4\uff1a the forth version of the Single UNIX Specification","title":"The Single UNIX Specification"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#unix#system#implementations","text":"The previous section described ISO C, IEEE POSIX, and the Single UNIX Specification \u2014 three standards originally created by independent organizations. Standards, however, are interface specifications. How do these standards relate to the real world? These standards are taken by vendors and turned into actual implementations. In this book, we are interested in both these standards and their implementation.","title":"UNIX System Implementations"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#unix#system#v#release#4","text":"UNIX System V Release 4 (SVR4) was a product of AT&T\u2019s UNIX System Laboratories (USL, formerly AT&T\u2019s UNIX Software Operation). SVR4 merged functionality from AT&T UNIX System V Release 3.2 (SVR3.2), the SunOS operating system from Sun Microsystems, the 4.3BSD release from the University of California, and the Xenix system from Microsoft into one coherent operating system. (Xenix was originally developed from Version 7, with many features later taken from System V.) The SVR4 source code was released in late 1989, with the first end-user copies becoming available during 1990. SVR4 conformed to both the POSIX 1003.1 standard and the X/Open Portability Guide, Issue 3 (XPG3).","title":"UNIX System V Release 4"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#44bsd","text":"","title":"4.4BSD"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#freebsd","text":"","title":"FreeBSD"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#linux","text":"","title":"Linux"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#mac#os#x","text":"","title":"Mac OS X"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#solaris","text":"","title":"Solaris"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#relationship#of#standards#and#implementations","text":"The standards that we\u2019ve mentioned define a subset of any actual system. The focus of this book is on four real systems: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris Although only Mac OS X and Solaris can call themselves UNIX systems, all four provide a similar programming environment. Because all four are POSIX compliant to varying degrees, we will also concentrate on the features required by the POSIX.1 standard, noting any differences between POSIX and the actual implementations of these four systems. Those features and routines that are specific to only a particular implementation are clearly marked. We\u2019ll also note any features that are required on UNIX systems but are optional on other POSIX-conforming systems. Be aware that the implementations provide backward compatibility for features in earlier releases, such as SVR3.2 and 4.3BSD. For example, Solaris supports both the POSIX.1 specification for nonblocking I/O (O_NONBLOCK) and the traditional System V method ( O_NDELAY ). In this text, we\u2019ll use only the POSIX.1 feature, although we\u2019ll mention the nonstandard feature that it replaces. Similarly, both SVR3.2 and 4.3BSD provided reliable signals in a way that differs from the POSIX.1 standard. In Chapter 10 we describe only the POSIX.1 signal mechanism.","title":"Relationship of Standards and Implementations"},{"location":"Unix-standardization-and-implementation/Unix-standardization-and-implementation/#man#standards7","text":"NOTE: \u8fd9\u662flinux\u6587\u6863\u4e2d\u5bf9standard\u7684\u4ecb\u7ecd\u3002","title":"man STANDARDS(7)"}]}